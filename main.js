(function(global_object) {
  "use strict";

  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var console;

  // Detect the global object
  if (typeof(globalThis) !== 'undefined') { global_object = globalThis; }
  else if (typeof(global) !== 'undefined') { global_object = global; }
  else if (typeof(window) !== 'undefined') { global_object = window; }

  // Setup a dummy console object if missing
  if (typeof(global_object.console) === 'object') {
    console = global_object.console;
  } else if (global_object.console == null) {
    console = global_object.console = {};
  } else {
    console = {};
  }

  if (!('log' in console)) { console.log = function () {}; }
  if (!('warn' in console)) { console.warn = console.log; }

  if (typeof(global_object.Opal) !== 'undefined') {
    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
    return global_object.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // The Opal object that is exposed globally
  var Opal = global_object.Opal = {};

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;
  global_object.Opal = Opal;

  // Configure runtime behavior with regards to require and unsupported features
  Opal.config = {
    missing_require_severity: 'error',        // error, warning, ignore
    unsupported_features_severity: 'warning', // error, warning, ignore
    enable_stack_trace: true                  // true, false
  };

  // Minify common function calls
  var $has_own   = Object.hasOwnProperty;
  var $bind      = Function.prototype.bind;
  var $set_proto = Object.setPrototypeOf;
  var $slice     = Array.prototype.slice;
  var $splice    = Array.prototype.splice;

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  Opal.uid = function() {
    unique_id += 2;
    return unique_id;
  };

  // Retrieve or assign the id of an object
  Opal.id = function(obj) {
    if (obj.$$is_number) return (obj * 2)+1;
    if (obj.$$id != null) {
      return obj.$$id;
    }
    $defineProperty(obj, '$$id', Opal.uid());
    return obj.$$id;
  };

  // Globals table
  Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log('Exited with status '+status); };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function() {
    Opal.gvars["!"] = Opal.exceptions.pop() || nil;
  };

  // Inspect any kind of object, including non Ruby ones
  Opal.inspect = function(obj) {
    if (obj === undefined) {
      return "undefined";
    }
    else if (obj === null) {
      return "null";
    }
    else if (!obj.$$class) {
      return obj.toString();
    }
    else {
      return obj.$inspect();
    }
  };

  function $defineProperty(object, name, initialValue) {
    if (typeof(object) === "string") {
      // Special case for:
      //   s = "string"
      //   def s.m; end
      // String class is the only class that:
      // + compiles to JS primitive
      // + allows method definition directly on instances
      // numbers, true, false and null do not support it.
      object[name] = initialValue;
    } else {
      Object.defineProperty(object, name, {
        value: initialValue,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
  }

  Opal.defineProperty = $defineProperty;

  Opal.slice = $slice;


  // Helpers
  // -----

  Opal.truthy = function(val) {
    return (val !== nil && val != null && (!val.$$is_boolean || val == true));
  };

  Opal.falsy = function(val) {
    return (val === nil || val == null || (val.$$is_boolean && val == false))
  };

  Opal.type_error = function(object, type, method, coerced) {
    object = object.$$class;

    if (coerced && method) {
      coerced = coerced.$$class;
      return Opal.TypeError.$new(
        "can't convert " + object + " into " + type +
        " (" + object + "#" + method + " gives " + coerced + ")"
      )
    } else {
      return Opal.TypeError.$new(
        "no implicit conversion of " + object + " into " + type
      )
    }
  };

  Opal.coerce_to = function(object, type, method, args) {
    if (type['$==='](object)) return object;

    if (!object['$respond_to?'](method)) {
      throw Opal.type_error(object, type);
    }

    if (args == null) args = [];
    return Opal.send(object, method, args);
  }

  Opal.respond_to = function(obj, jsid, include_all) {
    if (obj == null || !obj.$$class) return false;
    include_all = !!include_all;
    var body = obj[jsid];

    if (obj['$respond_to?'].$$pristine) {
      if (obj['$respond_to_missing?'].$$pristine) {
        return typeof(body) === "function" && !body.$$stub;
      } else {
        return Opal.send(obj, obj['$respond_to_missing?'], [jsid.substr(1), include_all]);
      }
    } else {
      return Opal.send(obj, obj['$respond_to?'], [jsid.substr(1), include_all]);
    }
  }


  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) return cref.$$const[name];
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) return constant;
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, ancestors;

    if (cref == null) return;

    ancestors = Opal.ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $has_own.call(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name, skip_missing) {
    if (!skip_missing) {
      return (cref || _Object).$const_missing(name);
    }
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function(cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);              if (result != null) return result;
    result = const_missing(cref, name, skip_missing); if (result != null) return result;
  };

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function(cref, name, skip_missing) {
    var result, cache, cached, current_version = Opal.const_cache_version;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      $defineProperty(cref, '$$const_cache', Object.create(null));
      cache = cref.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null);
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function(nesting, name, skip_missing) {
    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

    if ((cache = nesting.$$const_cache) == null) {
      $defineProperty(nesting, '$$const_cache', Object.create(null));
      cache = nesting.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_nesting(nesting, name))     != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null) ||
      ((result = const_lookup_Object(cref, name))         != null);

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  Opal.const_set = function(cref, name, value) {
    if (cref == null || cref === '::') cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = (cref.$$const || Object.create(null));
    cref.$$const[name] = value;

    // Add a short helper to navigate constants manually.
    // @example
    //   Opal.$$.Regexp.$$.IGNORECASE
    cref.$$ = cref.$$const;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    $defineProperty(cref, name, value);

    return value;
  };

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function(cref, inherit) {
    if (inherit == null) inherit = true;

    var module, modules = [cref], i, ii, constants = {}, constant;

    if (inherit) modules = modules.concat(Opal.ancestors(cref));
    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Do not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function(cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload != null && cref.$$autoload[name] != null) {
      delete cref.$$autoload[name];
      return nil;
    }

    throw Opal.NameError.$new("constant "+cref+"::"+cref.$name()+" not defined");
  };

  // Setup some shortcuts to reduce compiled size
  Opal.$$ = Opal.const_get_relative;
  Opal.$$$ = Opal.const_get_qualified;


  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `scope` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `scope` is an object (not a class/module), we simple get its class and
  // use that as the scope instead.
  //
  // @param scope        [Object] where the class is being created
  // @param superclass  [Class,null] superclass of the new class (may be null)
  // @param id          [String] the name of the class to be created
  // @param constructor [JS.Function] function to use as constructor
  //
  // @return new [Class]  or existing ruby class
  //
  Opal.allocate_class = function(name, superclass) {
    var klass, constructor;

    if (superclass != null && superclass.$$bridge) {
      // Inheritance from bridged classes requires
      // calling original JS constructors
      constructor = function() {
        var args = $slice.call(arguments),
            self = new ($bind.apply(superclass.$$constructor, [null].concat(args)))();

        // and replacing a __proto__ manually
        $set_proto(self, klass.$$prototype);
        return self;
      }
    } else {
      constructor = function(){};
    }

    if (name) {
      $defineProperty(constructor, 'displayName', '::'+name);
    }

    klass = constructor;

    $defineProperty(klass, '$$name', name);
    $defineProperty(klass, '$$constructor', constructor);
    $defineProperty(klass, '$$prototype', constructor.prototype);
    $defineProperty(klass, '$$const', {});
    $defineProperty(klass, '$$is_class', true);
    $defineProperty(klass, '$$is_a_module', true);
    $defineProperty(klass, '$$super', superclass);
    $defineProperty(klass, '$$cvars', {});
    $defineProperty(klass, '$$own_included_modules', []);
    $defineProperty(klass, '$$own_prepended_modules', []);
    $defineProperty(klass, '$$ancestors', []);
    $defineProperty(klass, '$$ancestors_cache_version', null);

    $defineProperty(klass.$$prototype, '$$class', klass);

    // By default if there are no singleton class methods
    // __proto__ is Class.prototype
    // Later singleton methods generate a singleton_class
    // and inject it into ancestors chain
    if (Opal.Class) {
      $set_proto(klass, Opal.Class.prototype);
    }

    if (superclass != null) {
      $set_proto(klass.$$prototype, superclass.$$prototype);

      if (superclass.$$meta) {
        // If superclass has metaclass then we have explicitely inherit it.
        Opal.build_class_singleton_class(klass);
      }
    }

    return klass;
  };


  function find_existing_class(scope, name) {
    // Try to find the class in the current scope
    var klass = const_get_name(scope, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        throw Opal.TypeError.$new(name + " is not a class");
      }

      return klass;
    }
  }

  function ensureSuperclassMatch(klass, superclass) {
    if (klass.$$super !== superclass) {
      throw Opal.TypeError.$new("superclass mismatch for class " + klass.$$name);
    }
  }

  Opal.klass = function(scope, superclass, name) {
    var bridged;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    // If the superclass is not an Opal-generated class then we're bridging a native JS class
    if (
      superclass != null && (!superclass.hasOwnProperty || (
        superclass.hasOwnProperty && !superclass.hasOwnProperty('$$is_class')
      ))
    ) {
      if (superclass.constructor && superclass.constructor.name == "Function") {
        bridged = superclass;
        superclass = _Object;
      } else {
        throw Opal.TypeError.$new("superclass must be a Class (" + (
          (superclass.constructor && (superclass.constructor.name || superclass.constructor.$$name)) ||
          typeof(superclass)
        ) + " given)");
      }
    }

    var klass = find_existing_class(scope, name);

    if (klass) {
      if (superclass) {
        // Make sure existing class has same superclass
        ensureSuperclassMatch(klass, superclass);
      }
      return klass;
    }

    // Class doesn't exist, create a new one with given superclass...

    // Not specifying a superclass means we can assume it to be Object
    if (superclass == null) {
      superclass = _Object;
    }

    // Create the class object (instance of Class)
    klass = Opal.allocate_class(name, superclass);
    Opal.const_set(scope, name, klass);

    // Call .inherited() hook with new class on the superclass
    if (superclass.$inherited) {
      superclass.$inherited(klass);
    }

    if (bridged) {
      Opal.bridge(bridged, klass);
    }

    return klass;
  };

  // Define new module (or return existing module). The given `scope` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the scope is a ruby
  // object then that objects real ruby class is used (e.g. if the scope is the
  // main object, then the top level `Object` class is used as the scope).
  //
  // If a module of the given name is already defined in the scope, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the scope, then an error is
  // generated instead (cannot have a class and module of same name in same scope).
  //
  // Otherwise, a new module is created in the scope with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  scope [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  Opal.allocate_module = function(name) {
    var constructor = function(){};
    if (name) {
      $defineProperty(constructor, 'displayName', name+'.$$constructor');
    }

    var module = constructor;

    if (name)
      $defineProperty(constructor, 'displayName', name+'.constructor');

    $defineProperty(module, '$$name', name);
    $defineProperty(module, '$$prototype', constructor.prototype);
    $defineProperty(module, '$$const', {});
    $defineProperty(module, '$$is_module', true);
    $defineProperty(module, '$$is_a_module', true);
    $defineProperty(module, '$$cvars', {});
    $defineProperty(module, '$$iclasses', []);
    $defineProperty(module, '$$own_included_modules', []);
    $defineProperty(module, '$$own_prepended_modules', []);
    $defineProperty(module, '$$ancestors', [module]);
    $defineProperty(module, '$$ancestors_cache_version', null);

    $set_proto(module, Opal.Module.prototype);

    return module;
  };

  function find_existing_module(scope, name) {
    var module = const_get_name(scope, name);
    if (module == null && scope === _Object) module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        throw Opal.TypeError.$new(name + " is not a module");
      }
    }

    return module;
  }

  Opal.module = function(scope, name) {
    var module;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    module = find_existing_module(scope, name);

    if (module) {
      return module;
    }

    // Module doesnt exist, create a new one...
    module = Opal.allocate_module(name);
    Opal.const_set(scope, name, module);

    return module;
  };

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function(object) {
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.hasOwnProperty('$$is_class')) {
      return Opal.build_class_singleton_class(object);
    } else if (object.hasOwnProperty('$$is_module')) {
      return Opal.build_module_singleton_class(object);
    } else {
      return Opal.build_object_singleton_class(object);
    }
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function(klass) {
    var superclass, meta;

    if (klass.$$meta) {
      return klass.$$meta;
    }

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

    meta = Opal.allocate_class(null, superclass, function(){});

    $defineProperty(meta, '$$is_singleton', true);
    $defineProperty(meta, '$$singleton_of', klass);
    $defineProperty(klass, '$$meta', meta);
    $set_proto(klass, meta.$$prototype);
    // Restoring ClassName.class
    $defineProperty(klass, '$$class', Opal.Class);

    return meta;
  };

  Opal.build_module_singleton_class = function(mod) {
    if (mod.$$meta) {
      return mod.$$meta;
    }

    var meta = Opal.allocate_class(null, Opal.Module, function(){});

    $defineProperty(meta, '$$is_singleton', true);
    $defineProperty(meta, '$$singleton_of', mod);
    $defineProperty(mod, '$$meta', meta);
    $set_proto(mod, meta.$$prototype);
    // Restoring ModuleName.class
    $defineProperty(mod, '$$class', Opal.Module);

    return meta;
  };

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function(object) {
    var superclass = object.$$class,
        klass = Opal.allocate_class(nil, superclass, function(){});

    $defineProperty(klass, '$$is_singleton', true);
    $defineProperty(klass, '$$singleton_of', object);

    delete klass.$$prototype.$$class;

    $defineProperty(object, '$$meta', klass);

    $set_proto(object, object.$$meta.$$prototype);

    return klass;
  };

  Opal.is_method = function(prop) {
    return (prop[0] === '$' && prop[1] !== '$');
  };

  Opal.instance_methods = function(mod) {
    var exclude = [], results = [], ancestors = Opal.ancestors(mod);

    for (var i = 0, l = ancestors.length; i < l; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      var props = Object.getOwnPropertyNames(proto);

      for (var j = 0, ll = props.length; j < ll; j++) {
        var prop = props[j];

        if (Opal.is_method(prop)) {
          var method_name = prop.slice(1),
              method = proto[prop];

          if (method.$$stub && exclude.indexOf(method_name) === -1) {
            exclude.push(method_name);
          }

          if (!method.$$stub && results.indexOf(method_name) === -1 && exclude.indexOf(method_name) === -1) {
            results.push(method_name);
          }
        }
      }
    }

    return results;
  };

  Opal.own_instance_methods = function(mod) {
    var results = [],
        proto = mod.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto);

    for (var i = 0, length = props.length; i < length; i++) {
      var prop = props[i];

      if (Opal.is_method(prop)) {
        var method = proto[prop];

        if (!method.$$stub) {
          var method_name = prop.slice(1);
          results.push(method_name);
        }
      }
    }

    return results;
  };

  Opal.methods = function(obj) {
    return Opal.instance_methods(Opal.get_singleton_class(obj));
  };

  Opal.own_methods = function(obj) {
    return Opal.own_instance_methods(Opal.get_singleton_class(obj));
  };

  Opal.receiver_methods = function(obj) {
    var mod = Opal.get_singleton_class(obj);
    var singleton_methods = Opal.own_instance_methods(mod);
    var instance_methods = Opal.own_instance_methods(mod.$$super);
    return singleton_methods.concat(instance_methods);
  };

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function(module) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length,
        result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  };

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function(module, name, value) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  };

  // Gets class variable with specified +name+ from provided +module+
  //
  // @param module [Module]
  // @param name [String]
  Opal.class_variable_get = function(module, name, tolerant) {
    if ($has_own.call(module.$$cvars, name))
      return module.$$cvars[name];

    var ancestors = Opal.ancestors(module),
      i, length = ancestors.length;

    for (i = 0; i < length; i++) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        return ancestor.$$cvars[name];
      }
    }

    if (!tolerant)
      throw Opal.NameError.$new('uninitialized class variable '+name+' in '+module.$name());

    return nil;
  }

  function isRoot(proto) {
    return proto.hasOwnProperty('$$iclass') && proto.hasOwnProperty('$$root');
  }

  function own_included_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    while (proto) {
      if (proto.hasOwnProperty('$$class')) {
        // superclass
        break;
      }
      mod = protoToModule(proto);
      if (mod) {
        result.push(mod);
      }
      proto = Object.getPrototypeOf(proto);
    }

    return result;
  }

  function own_prepended_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    if (module.$$prototype.hasOwnProperty('$$dummy')) {
      while (proto) {
        if (proto === module.$$prototype.$$define_methods_on) {
          break;
        }

        mod = protoToModule(proto);
        if (mod) {
          result.push(mod);
        }

        proto = Object.getPrototypeOf(proto);
      }
    }

    return result;
  }


  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function(module, includer) {
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(includer) !== -1) {
      throw Opal.ArgumentError.$new('cyclic include detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $defineProperty(iclass, '$$included', true);
      iclasses.push(iclass);
    }
    var includer_ancestors = Opal.ancestors(includer),
        chain = chain_iclasses(iclasses),
        start_chain_after,
        end_chain_on;

    if (includer_ancestors.indexOf(module) === -1) {
      // first time include

      // includer -> chain.first -> ...chain... -> chain.last -> includer.parent
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    } else {
      // The module has been already included,
      // we don't need to put it into the ancestors chain again,
      // but this module may have new included modules.
      // If it's true we need to copy them.
      //
      // The simplest way is to replace ancestors chain from
      //          parent
      //            |
      //   `module` iclass (has a $$root flag)
      //            |
      //   ...previos chain of module.included_modules ...
      //            |
      //  "next ancestor" (has a $$root flag or is a real class)
      //
      // to
      //          parent
      //            |
      //    `module` iclass (has a $$root flag)
      //            |
      //   ...regenerated chain of module.included_modules
      //            |
      //   "next ancestor" (has a $$root flag or is a real class)
      //
      // because there are no intermediate classes between `parent` and `next ancestor`.
      // It doesn't break any prototypes of other objects as we don't change class references.

      var parent = includer.$$prototype, module_iclass = Object.getPrototypeOf(parent);

      while (module_iclass != null) {
        if (module_iclass.$$module === module && isRoot(module_iclass)) {
          break;
        }

        parent = module_iclass;
        module_iclass = Object.getPrototypeOf(module_iclass);
      }

      if (module_iclass) {
        // module has been directly included
        var next_ancestor = Object.getPrototypeOf(module_iclass);

        // skip non-root iclasses (that were recursively included)
        while (next_ancestor.hasOwnProperty('$$iclass') && !isRoot(next_ancestor)) {
          next_ancestor = Object.getPrototypeOf(next_ancestor);
        }

        start_chain_after = parent;
        end_chain_on = next_ancestor;
      } else {
        // module has not been directly included but was in ancestor chain because it was included by another module
        // include it directly
        start_chain_after = includer.$$prototype;
        end_chain_on = Object.getPrototypeOf(includer.$$prototype);
      }
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_included_modules cache
    includer.$$own_included_modules = own_included_modules(includer);

    Opal.const_cache_version++;
  };

  Opal.prepend_features = function(module, prepender) {
    // Here we change the ancestors chain from
    //
    //   prepender
    //      |
    //    parent
    //
    // to:
    //
    // dummy(prepender)
    //      |
    //  iclass(module)
    //      |
    // iclass(prepender)
    //      |
    //    parent
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(prepender) !== -1) {
      throw Opal.ArgumentError.$new('cyclic prepend detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $defineProperty(iclass, '$$prepended', true);
      iclasses.push(iclass);
    }

    var chain = chain_iclasses(iclasses),
        dummy_prepender = prepender.$$prototype,
        previous_parent = Object.getPrototypeOf(dummy_prepender),
        prepender_iclass,
        start_chain_after,
        end_chain_on;

    if (dummy_prepender.hasOwnProperty('$$dummy')) {
      // The module already has some prepended modules
      // which means that we don't need to make it "dummy"
      prepender_iclass = dummy_prepender.$$define_methods_on;
    } else {
      // Making the module "dummy"
      prepender_iclass = create_dummy_iclass(prepender);
      flush_methods_in(prepender);
      $defineProperty(dummy_prepender, '$$dummy', true);
      $defineProperty(dummy_prepender, '$$define_methods_on', prepender_iclass);

      // Converting
      //   dummy(prepender) -> previous_parent
      // to
      //   dummy(prepender) -> iclass(prepender) -> previous_parent
      $set_proto(dummy_prepender, prepender_iclass);
      $set_proto(prepender_iclass, previous_parent);
    }

    var prepender_ancestors = Opal.ancestors(prepender);

    if (prepender_ancestors.indexOf(module) === -1) {
      // first time prepend

      start_chain_after = dummy_prepender;

      // next $$root or prepender_iclass or non-$$iclass
      end_chain_on = Object.getPrototypeOf(dummy_prepender);
      while (end_chain_on != null) {
        if (
          end_chain_on.hasOwnProperty('$$root') ||
          end_chain_on === prepender_iclass ||
          !end_chain_on.hasOwnProperty('$$iclass')
        ) {
          break;
        }

        end_chain_on = Object.getPrototypeOf(end_chain_on);
      }
    } else {
      throw Opal.RuntimeError.$new("Prepending a module multiple times is not supported");
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_prepended_modules cache
    prepender.$$own_prepended_modules = own_prepended_modules(prepender);

    Opal.const_cache_version++;
  };

  function flush_methods_in(module) {
    var proto = module.$$prototype,
        props = Object.getOwnPropertyNames(proto);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (Opal.is_method(prop)) {
        delete proto[prop];
      }
    }
  }

  function create_iclass(module) {
    var iclass = create_dummy_iclass(module);

    if (module.$$is_module) {
      module.$$iclasses.push(iclass);
    }

    return iclass;
  }

  // Dummy iclass doesn't receive updates when the module gets a new method.
  function create_dummy_iclass(module) {
    var iclass = {},
        proto = module.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto),
        length = props.length, i;

    for (i = 0; i < length; i++) {
      var prop = props[i];
      $defineProperty(iclass, prop, proto[prop]);
    }

    $defineProperty(iclass, '$$iclass', true);
    $defineProperty(iclass, '$$module', module);

    return iclass;
  }

  function chain_iclasses(iclasses) {
    var length = iclasses.length, first = iclasses[0];

    $defineProperty(first, '$$root', true);

    if (length === 1) {
      return { first: first, last: first };
    }

    var previous = first;

    for (var i = 1; i < length; i++) {
      var current = iclasses[i];
      $set_proto(previous, current);
      previous = current;
    }


    return { first: iclasses[0], last: iclasses[length - 1] };
  }

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for the new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function(native_klass, klass) {
    if (native_klass.hasOwnProperty('$$bridge')) {
      throw Opal.ArgumentError.$new("already bridged");
    }

    // constructor is a JS function with a prototype chain like:
    // - constructor
    //   - super
    //
    // What we need to do is to inject our class (with its prototype chain)
    // between constructor and super. For example, after injecting ::Object
    // into JS String we get:
    //
    // - constructor (window.String)
    //   - Opal.Object
    //     - Opal.Kernel
    //       - Opal.BasicObject
    //         - super (window.Object)
    //           - null
    //
    $defineProperty(native_klass, '$$bridge', klass);
    $set_proto(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
    $defineProperty(klass, '$$prototype', native_klass.prototype);

    $defineProperty(klass.$$prototype, '$$class', klass);
    $defineProperty(klass, '$$constructor', native_klass);
    $defineProperty(klass, '$$bridge', true);
  };

  function protoToModule(proto) {
    if (proto.hasOwnProperty('$$dummy')) {
      return;
    } else if (proto.hasOwnProperty('$$iclass')) {
      return proto.$$module;
    } else if (proto.hasOwnProperty('$$class')) {
      return proto.$$class;
    }
  }

  function own_ancestors(module) {
    return module.$$own_prepended_modules.concat([module]).concat(module.$$own_included_modules);
  }

  // The Array of ancestors for a given module/class
  Opal.ancestors = function(module) {
    if (!module) { return []; }

    if (module.$$ancestors_cache_version === Opal.const_cache_version) {
      return module.$$ancestors;
    }

    var result = [], i, mods, length;

    for (i = 0, mods = own_ancestors(module), length = mods.length; i < length; i++) {
      result.push(mods[i]);
    }

    if (module.$$super) {
      for (i = 0, mods = Opal.ancestors(module.$$super), length = mods.length; i < length; i++) {
        result.push(mods[i]);
      }
    }

    module.$$ancestors_cache_version = Opal.const_cache_version;
    module.$$ancestors = result;

    return result;
  };

  Opal.included_modules = function(module) {
    var result = [], mod = null, proto = Object.getPrototypeOf(module.$$prototype);

    for (; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)) {
      mod = protoToModule(proto);
      if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
        result.push(mod);
      }
    }

    return result;
  };


  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs(["$foo", "$bar", "$baz="]);
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function(stubs) {
    var proto = Opal.BasicObject.$$prototype;

    for (var i = 0, length = stubs.length; i < length; i++) {
      var stub = stubs[i], existing_method = proto[stub];

      if (existing_method == null || existing_method.$$stub) {
        Opal.add_stub_for(proto, stub);
      }
    }
  };

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function(prototype, stub) {
    var method_missing_stub = Opal.stub_for(stub);
    $defineProperty(prototype, stub, method_missing_stub);
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function(method_name) {

    function method_missing_stub() {
      /* jshint validthis: true */

      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      method_missing_stub.$$p = null;

      // call method missing with correct args (remove '$' prefix on method name)
      var args_ary = new Array(arguments.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = arguments[i]; }

      return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));
    }

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };


  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function(actual, expected, object, meth) {
    var inspect = '';
    if (object.$$is_a_module) {
      inspect += object.$$name + '.';
    }
    else {
      inspect += object.$$class.$$name + '#';
    }
    inspect += meth;

    throw Opal.ArgumentError.$new('[' + inspect + '] wrong number of arguments(' + actual + ' for ' + expected + ')');
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function(actual, expected, context) {
    var inspect = "`block in " + context + "'";

    throw Opal.ArgumentError.$new(inspect + ': wrong number of arguments (' + actual + ' for ' + expected + ')');
  };

  // Super dispatcher
  Opal.find_super_dispatcher = function(obj, mid, current_func, defcheck, allow_stubs) {
    var jsid = '$' + mid, ancestors, super_method;

    if (obj.hasOwnProperty('$$meta')) {
      ancestors = Opal.ancestors(obj.$$meta);
    } else {
      ancestors = Opal.ancestors(obj.$$class);
    }

    var current_index = ancestors.indexOf(current_func.$$owner);

    for (var i = current_index + 1; i < ancestors.length; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      if (proto.hasOwnProperty(jsid)) {
        super_method = proto[jsid];
        break;
      }
    }

    if (!defcheck && super_method && super_method.$$stub && obj.$method_missing.$$pristine) {
      // method_missing hasn't been explicitly defined
      throw Opal.NoMethodError.$new('super: no superclass method `'+mid+"' for "+obj, mid);
    }

    return (super_method.$$stub && !allow_stubs) ? null : super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, defcheck, implicit) {
    var call_jsid = jsid;

    if (!current_func) {
      throw Opal.RuntimeError.$new("super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      throw Opal.RuntimeError.$new("implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly");
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super_dispatcher(obj, call_jsid, current_func, defcheck);
  };

  // Used to return as an expression. Sometimes, we can't simply return from
  // a javascript function as if we were a method, as the return is used as
  // an expression, or even inside a block which must "return" to the outer
  // method. This helper simply throws an error which is then caught by the
  // method. This approach is expensive, so it is only used when absolutely
  // needed.
  //
  Opal.ret = function(val) {
    Opal.returner.$v = val;
    throw Opal.returner;
  };

  // Used to break out of a block.
  Opal.brk = function(val, breaker) {
    breaker.$v = val;
    throw breaker;
  };

  // Builds a new unique breaker, this is to avoid multiple nested breaks to get
  // in the way of each other.
  Opal.new_brk = function() {
    return new Error('unexpected break');
  };

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function(block, arg) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
        has_trailing_comma = block.$$has_trailing_comma_in_args;

    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {
      arg = Opal.to_ary(arg);
    }

    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {
      return block.apply(null, arg);
    }
    else {
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function(block, args) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        return block.apply(null, args[0]);
      }
    }

    if (!args.$$is_array) {
      var args_ary = new Array(args.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

      return block.apply(null, args_ary);
    }

    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function(exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      }
      else if (candidate === Opal.JS.Error) {
        return candidate;
      }
      else if (candidate['$==='](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function(object, klass) {
    if (klass != null && object.$$meta === klass || object.$$class === klass) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return (klass.$$is_integer_class) ? (object % 1) === 0 : true;
    }

    var i, length, ancestors = Opal.ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));

    for (i = 0, length = ancestors.length; i < length; i++) {
      if (ancestors[i] === klass) {
        return true;
      }
    }

    return false;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function(value) {
    if (value.$$is_hash) {
      return value;
    }
    else if (value['$respond_to?']('to_hash', true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
      }
    }
    else {
      throw Opal.TypeError.$new("no implicit conversion of " + value.$$class + " into Hash");
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function(value) {
    if (value.$$is_array) {
      return value;
    }
    else if (value['$respond_to?']('to_ary', true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function(value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    }
    else if (value['$respond_to?']('to_a', true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function. If provided +arguments+ list doesn't have a Hash
  // as a last item, returns a blank Hash.
  //
  // @param parameters [Array]
  // @return [Hash]
  //
  Opal.extract_kwargs = function(parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && Opal.respond_to(kwargs, '$to_hash', true)) {
      $splice.call(parameters, parameters.length - 1, 1);
      return kwargs.$to_hash();
    }
    else {
      return Opal.hash2([], {});
    }
  };

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguemnts passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function(given_args, used_args) {
    var keys      = [],
        map       = {},
        key           ,
        given_map = given_args.$$smap;

    for (key in given_map) {
      if (!used_args[key]) {
        keys.push(key);
        map[key] = given_map[key];
      }
    }

    return Opal.hash2(keys, map);
  };

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @return [Object] returning value of the method call
  Opal.send = function(recv, method, args, block) {
    var body;

    if (typeof(method) === 'function') {
      body = method;
      method = null;
    } else if (typeof(method) === 'string') {
      body = recv['$'+method];
    } else {
      throw Opal.NameError.$new("Passed method should be a string or a function");
    }

    return Opal.send2(recv, body, method, args, block);
  };

  Opal.send2 = function(recv, body, method, args, block) {
    if (body == null && method != null && recv.$method_missing) {
      body = recv.$method_missing;
      args = [method].concat(args);
    }

    if (typeof block === 'function') body.$$p = block;
    return body.apply(recv, args);
  };

  Opal.lambda = function(block) {
    block.$$is_lambda = true;
    return block;
  };

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @return [null]
  //
  Opal.def = function(obj, jsid, body) {
    // Special case for a method definition in the
    // top-level namespace
    if (obj === Opal.top) {
      Opal.defn(Opal.Object, jsid, body)
    }
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    else if (!obj.$$eval && obj.$$is_a_module) {
      Opal.defn(obj, jsid, body);
    }
    else {
      Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function(module, jsid, body) {
    body.displayName = jsid;
    body.$$owner = module;

    var proto = module.$$prototype;
    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }
    $defineProperty(proto, jsid, body);

    if (module.$$is_module) {
      if (module.$$module_function) {
        Opal.defs(module, jsid, body)
      }

      for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        $defineProperty(iclass, jsid, body);
      }
    }

    var singleton_of = module.$$singleton_of;
    if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
      module.$method_added(jsid.substr(1));
    }
    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
      singleton_of.$singleton_method_added(jsid.substr(1));
    }
  };

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function(obj, jsid, body) {
    if (obj.$$is_string || obj.$$is_number) {
      throw Opal.TypeError.$new("can't define singleton");
    }
    Opal.defn(Opal.get_singleton_class(obj), jsid, body)
  };

  // Called from #remove_method.
  Opal.rdef = function(obj, jsid) {
    if (!$has_own.call(obj.$$prototype, jsid)) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    delete obj.$$prototype[jsid];

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
        obj.$$prototype.$singleton_method_removed(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function(obj, jsid) {
    if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    Opal.add_stub_for(obj.$$prototype, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
        obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  function is_method_body(body) {
    return (typeof(body) === "function" && !body.$$stub);
  }

  Opal.alias = function(obj, name, old) {
    var id     = '$' + name,
        old_id = '$' + old,
        body   = obj.$$prototype['$' + old],
        alias;

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (!is_method_body(body)) {
      var ancestor = obj.$$super;

      while (typeof(body) !== "function" && ancestor) {
        body     = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (!is_method_body(body) && obj.$$is_module) {
        // try to look into Object
        body = Opal.Object.$$prototype[old_id]
      }

      if (!is_method_body(body)) {
        throw Opal.NameError.$new("undefined method `" + old + "' for class `" + obj.$name() + "'")
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise properties
    // would be overwritten on the original body.
    alias = function() {
      var block = alias.$$p, args, i, ii;

      args = new Array(arguments.length);
      for(i = 0, ii = arguments.length; i < ii; i++) {
        args[i] = arguments[i];
      }

      if (block != null) { alias.$$p = null }

      return Opal.send(this, body, args, block);
    };

    // Assign the 'length' value with defineProperty because
    // in strict mode the property is not writable.
    // It doesn't work in older browsers (like Chrome 38), where
    // an exception is thrown breaking Opal altogether.
    try {
      Object.defineProperty(alias, 'length', { value: body.length });
    } catch (e) {}

    // Try to make the browser pick the right name
    alias.displayName       = name;

    alias.$$arity           = body.$$arity;
    alias.$$parameters      = body.$$parameters;
    alias.$$source_location = body.$$source_location;
    alias.$$alias_of        = body;
    alias.$$alias_name      = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.alias_native = function(obj, name, native_name) {
    var id   = '$' + name,
        body = obj.$$prototype[native_name];

    if (typeof(body) !== "function" || body.$$stub) {
      throw Opal.NameError.$new("undefined native method `" + native_name + "' for class `" + obj.$name() + "'")
    }

    Opal.defn(obj, id, body);

    return obj;
  };


  // Hashes
  // ------

  Opal.hash_init = function(hash) {
    hash.$$smap = Object.create(null);
    hash.$$map  = Object.create(null);
    hash.$$keys = [];
  };

  Opal.hash_clone = function(from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {
      key = keys[i];

      if (key.$$is_string) {
        value = smap[key];
      } else {
        value = key.value;
        key = key.key;
      }

      Opal.hash_put(to_hash, key, value);
    }
  };

  Opal.hash_put = function(hash, key, value) {
    if (key.$$is_string) {
      if (!$has_own.call(hash.$$smap, key)) {
        hash.$$keys.push(key);
      }
      hash.$$smap[key] = value;
      return;
    }

    var key_hash, bucket, last_bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      hash.$$map[key_hash] = bucket;
      return;
    }

    bucket = hash.$$map[key_hash];

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        last_bucket = undefined;
        bucket.value = value;
        break;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }

    if (last_bucket) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      last_bucket.next = bucket;
    }
  };

  Opal.hash_get = function(hash, key) {
    if (key.$$is_string) {
      if ($has_own.call(hash.$$smap, key)) {
        return hash.$$smap[key];
      }
      return;
    }

    var key_hash, bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if ($has_own.call(hash.$$map, key_hash)) {
      bucket = hash.$$map[key_hash];

      while (bucket) {
        if (key === bucket.key || key['$eql?'](bucket.key)) {
          return bucket.value;
        }
        bucket = bucket.next;
      }
    }
  };

  Opal.hash_delete = function(hash, key) {
    var i, keys = hash.$$keys, length = keys.length, value;

    if (key.$$is_string) {
      if (typeof key !== "string") key = key.valueOf();

      if (!$has_own.call(hash.$$smap, key)) {
        return;
      }

      for (i = 0; i < length; i++) {
        if (keys[i] === key) {
          keys.splice(i, 1);
          break;
        }
      }

      value = hash.$$smap[key];
      delete hash.$$smap[key];
      return value;
    }

    var key_hash = key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      return;
    }

    var bucket = hash.$$map[key_hash], last_bucket;

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        value = bucket.value;

        for (i = 0; i < length; i++) {
          if (keys[i] === bucket) {
            keys.splice(i, 1);
            break;
          }
        }

        if (last_bucket && bucket.next) {
          last_bucket.next = bucket.next;
        }
        else if (last_bucket) {
          delete last_bucket.next;
        }
        else if (bucket.next) {
          hash.$$map[key_hash] = bucket.next;
        }
        else {
          delete hash.$$map[key_hash];
        }

        return value;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }
  };

  Opal.hash_rehash = function(hash) {
    for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {

      if (hash.$$keys[i].$$is_string) {
        continue;
      }

      key_hash = hash.$$keys[i].key.$hash();

      if (key_hash === hash.$$keys[i].key_hash) {
        continue;
      }

      bucket = hash.$$map[hash.$$keys[i].key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          if (last_bucket && bucket.next) {
            last_bucket.next = bucket.next;
          }
          else if (last_bucket) {
            delete last_bucket.next;
          }
          else if (bucket.next) {
            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;
          }
          else {
            delete hash.$$map[hash.$$keys[i].key_hash];
          }
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      hash.$$keys[i].key_hash = key_hash;

      if (!$has_own.call(hash.$$map, key_hash)) {
        hash.$$map[key_hash] = hash.$$keys[i];
        continue;
      }

      bucket = hash.$$map[key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          last_bucket = undefined;
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      if (last_bucket) {
        last_bucket.next = hash.$$keys[i];
      }
    }
  };

  Opal.hash = function() {
    var arguments_length = arguments.length, args, hash, i, length, key, value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Opal.Hash();
    Opal.hash_init(hash);

    if (arguments_length === 1 && arguments[0].$$is_array) {
      args = arguments[0];
      length = args.length;

      for (i = 0; i < length; i++) {
        if (args[i].length !== 2) {
          throw Opal.ArgumentError.$new("value not of length 2: " + args[i].$inspect());
        }

        key = args[i][0];
        value = args[i][1];

        Opal.hash_put(hash, key, value);
      }

      return hash;
    }

    if (arguments_length === 1) {
      args = arguments[0];
      for (key in args) {
        if ($has_own.call(args, key)) {
          value = args[key];

          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    }

    if (arguments_length % 2 !== 0) {
      throw Opal.ArgumentError.$new("odd number of arguments for Hash");
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function(keys, smap) {
    var hash = new Opal.Hash();

    hash.$$smap = smap;
    hash.$$map  = Object.create(null);
    hash.$$keys = keys;

    return hash;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function(first, last, exc) {
    var range         = new Opal.Range();
        range.begin   = first;
        range.end     = last;
        range.excl    = exc;

    return range;
  };

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function(name) {
    if (
        // properties
        name === "constructor" ||
        name === "displayName" ||
        name === "__count__" ||
        name === "__noSuchMethod__" ||
        name === "__parent__" ||
        name === "__proto__" ||

        // methods
        name === "hasOwnProperty" ||
        name === "valueOf"
       )
    {
      return name + "$";
    }

    return name;
  };


  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function(str) {
    return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1')
              .replace(/[\n]/g, '\\n')
              .replace(/[\r]/g, '\\r')
              .replace(/[\f]/g, '\\f')
              .replace(/[\t]/g, '\\t');
  };

  // Create a global Regexp from a RegExp object and cache the result
  // on the object itself ($$g attribute).
  //
  Opal.global_regexp = function(pattern) {
    if (pattern.global) {
      return pattern; // RegExp already has the global flag
    }
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? 'gm' : 'g') + (pattern.ignoreCase ? 'i' : ''));
    } else {
      pattern.$$g.lastIndex = null; // reset lastIndex property
    }
    return pattern.$$g;
  };

  // Create a global multiline Regexp from a RegExp object and cache the result
  // on the object itself ($$gm or $$g attribute).
  //
  Opal.global_multiline_regexp = function(pattern) {
    var result;
    if (pattern.multiline) {
      if (pattern.global) {
        return pattern; // RegExp already has the global and multiline flag
      }
      // we are using the $$g attribute because the Regexp is already multiline
      if (pattern.$$g != null) {
        result = pattern.$$g;
      } else {
        result = pattern.$$g = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
      }
    } else if (pattern.$$gm != null) {
      result = pattern.$$gm;
    } else {
      result = pattern.$$gm = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
    }
    result.lastIndex = null; // reset lastIndex property
    return result;
  };

  // Combine multiple regexp parts together
  Opal.regexp = function(parts, flags) {
    var part;
    var ignoreCase = typeof flags !== 'undefined' && flags && flags.indexOf('i') >= 0;

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part instanceof RegExp) {
        if (part.ignoreCase !== ignoreCase)
          Opal.Kernel.$warn(
            "ignore case doesn't match for " + part.source.$inspect(),
            Opal.hash({uplevel: 1})
          )

        part = part.source;
      }
      if (part === '') part = '(?:' + part + ')';
      parts[i] = part;
    }

    if (flags) {
      return new RegExp(parts.join(''), flags);
    } else {
      return new RegExp(parts.join(''));
    }
  };

  // Require system
  // --------------

  Opal.modules         = {};
  Opal.loaded_features = ['corelib/runtime'];
  Opal.current_dir     = '.';
  Opal.require_table   = {'corelib/runtime': true};

  Opal.normalize = function(path) {
    var parts, part, new_parts = [], SEPARATOR = '/';

    if (Opal.current_dir !== '.') {
      path = Opal.current_dir.replace(/\/*$/, '/') + path;
    }

    path = path.replace(/^\.\//, '');
    path = path.replace(/\.(rb|opal|js)$/, '');
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === '') continue;
      (part === '..') ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function(paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        continue;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load = function(path) {
    path = Opal.normalize(path);

    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      module(Opal);
    }
    else {
      var severity = Opal.config.missing_require_severity;
      var message  = 'cannot load such file -- ' + path;

      if (severity === "error") {
        if (Opal.LoadError) {
          throw Opal.LoadError.$new(message)
        } else {
          throw message
        }
      }
      else if (severity === "warning") {
        console.warn('WARNING: LoadError: ' + message);
      }
    }

    return true;
  };

  Opal.require = function(path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load(path);
  };


  // Strings
  // -------

  Opal.encodings = Object.create(null);

  // Sets the encoding on a string, will treat string literals as frozen strings
  // raising a FrozenError.
  //
  // @param str [String] the string on which the encoding should be set
  // @param name [String] the canonical name of the encoding
  // @param type [String] possible values are either `"encoding"`, `"internal_encoding"`, or `undefined
  Opal.set_encoding = function(str, name, type) {
    if (typeof type === "undefined") type = "encoding";
    if (typeof str === 'string' || str.$$frozen === true)
      throw Opal.FrozenError.$new("can't modify frozen String");

    var encoding = Opal.find_encoding(name);

    if (encoding === str[type]) { return str; }

    str[type] = encoding;

    return str;
  };

  // Fetches the encoding for the given name or raises ArgumentError.
  Opal.find_encoding = function(name) {
    var register = Opal.encodings;
    var encoding = register[name] || register[name.toUpperCase()];
    if (!encoding) throw Opal.ArgumentError.$new("unknown encoding name - " + name);
    return encoding;
  }

  // @returns a String object with the encoding set from a string literal
  Opal.enc = function(str, name) {
    var dup = new String(str);
    dup = Opal.set_encoding(dup, name);
    dup.internal_encoding = dup.encoding;
    return dup
  }

  // @returns a String object with the internal encoding set to Binary
  Opal.binary = function(str) {
    var dup = new String(str);
    return Opal.set_encoding(dup, "binary", "internal_encoding");
  }


  // Initialization
  // --------------
  function $BasicObject() {}
  function $Object() {}
  function $Module() {}
  function $Class() {}

  Opal.BasicObject = BasicObject = Opal.allocate_class('BasicObject', null, $BasicObject);
  Opal.Object      = _Object     = Opal.allocate_class('Object', Opal.BasicObject, $Object);
  Opal.Module      = Module      = Opal.allocate_class('Module', Opal.Object, $Module);
  Opal.Class       = Class       = Opal.allocate_class('Class', Opal.Module, $Class);

  $set_proto(Opal.BasicObject, Opal.Class.$$prototype);
  $set_proto(Opal.Object, Opal.Class.$$prototype);
  $set_proto(Opal.Module, Opal.Class.$$prototype);
  $set_proto(Opal.Class, Opal.Class.$$prototype);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const["BasicObject"] = BasicObject;

  // Assign basic constants
  Opal.const_set(_Object, "BasicObject",  BasicObject);
  Opal.const_set(_Object, "Object",       _Object);
  Opal.const_set(_Object, "Module",       Module);
  Opal.const_set(_Object, "Class",        Class);

  // Fix booted classes to have correct .class value
  BasicObject.$$class = Class;
  _Object.$$class     = Class;
  Module.$$class      = Class;
  Class.$$class       = Class;

  // Forward .toString() to #to_s
  $defineProperty(_Object.$$prototype, 'toString', function() {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof(to_s) === 'object') {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  });

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  $defineProperty(_Object.$$prototype, '$require', Opal.require);

  // Instantiate the main object
  Opal.top = new _Object();
  Opal.top.$to_s = Opal.top.$inspect = function() { return 'main' };
  Opal.top.$define_method = top_define_method;

  // Foward calls to define_method on the top object to Object
  function top_define_method() {
    var args = Opal.slice.call(arguments, 0, arguments.length);
    var block = top_define_method.$$p;
    top_define_method.$$p = null;
    return Opal.send(_Object, 'define_method', args, block)
  };


  // Nil
  function $NilClass() {}
  Opal.NilClass = Opal.allocate_class('NilClass', Opal.Object, $NilClass);
  Opal.const_set(_Object, 'NilClass', Opal.NilClass);
  nil = Opal.nil = new Opal.NilClass();
  nil.$$id = nil_id;
  nil.call = nil.apply = function() { throw Opal.LocalJumpError.$new('no block given'); };

  // Errors
  Opal.breaker  = new Error('unexpected break (old)');
  Opal.returner = new Error('unexpected return');
  TypeError.$$super = Error;
}).call(this);
Opal.loaded(["corelib/runtime.js"]);
/* Generated by Opal 1.2.0 */
Opal.modules["corelib/helpers"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $type_error = Opal.type_error, $coerce_to = Opal.coerce_to, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$===', '$raise', '$respond_to?', '$nil?', '$__send__', '$<=>', '$class', '$coerce_to!', '$new', '$!=', '$[]', '$upcase']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $Opal_bridge$1, $Opal_coerce_to$excl$2, $Opal_coerce_to$ques$3, $Opal_try_convert$4, $Opal_compare$5, $Opal_destructure$6, $Opal_respond_to$ques$7, $Opal_instance_variable_name$excl$8, $Opal_class_variable_name$excl$9, $Opal_const_name$excl$10, $Opal_pristine$11;

    
    Opal.defs(self, '$bridge', $Opal_bridge$1 = function $$bridge(constructor, klass) {
      var self = this;

      return Opal.bridge(constructor, klass);
    }, $Opal_bridge$1.$$arity = 2);
    Opal.defs(self, '$coerce_to!', $Opal_coerce_to$excl$2 = function(object, type, method, $a) {
      var $post_args, args, self = this, coerced = nil;

      
      
      $post_args = Opal.slice.call(arguments, 3, arguments.length);
      
      args = $post_args;;
      coerced = $coerce_to(object, type, method, args);
      if ($truthy(type['$==='](coerced))) {
      } else {
        self.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, $Opal_coerce_to$excl$2.$$arity = -4);
    Opal.defs(self, '$coerce_to?', $Opal_coerce_to$ques$3 = function(object, type, method, $a) {
      var $post_args, args, self = this, coerced = nil;

      
      
      $post_args = Opal.slice.call(arguments, 3, arguments.length);
      
      args = $post_args;;
      if ($truthy(object['$respond_to?'](method))) {
      } else {
        return nil
      };
      coerced = $coerce_to(object, type, method, args);
      if ($truthy(coerced['$nil?']())) {
        return nil};
      if ($truthy(type['$==='](coerced))) {
      } else {
        self.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, $Opal_coerce_to$ques$3.$$arity = -4);
    Opal.defs(self, '$try_convert', $Opal_try_convert$4 = function $$try_convert(object, type, method) {
      var self = this;

      
      if ($truthy(type['$==='](object))) {
        return object};
      if ($truthy(object['$respond_to?'](method))) {
        return object.$__send__(method)
      } else {
        return nil
      };
    }, $Opal_try_convert$4.$$arity = 3);
    Opal.defs(self, '$compare', $Opal_compare$5 = function $$compare(a, b) {
      var self = this, compare = nil;

      
      compare = a['$<=>'](b);
      if ($truthy(compare === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (a.$class()) + " with " + (b.$class()) + " failed")};
      return compare;
    }, $Opal_compare$5.$$arity = 2);
    Opal.defs(self, '$destructure', $Opal_destructure$6 = function $$destructure(args) {
      var self = this;

      
      if (args.length == 1) {
        return args[0];
      }
      else if (args.$$is_array) {
        return args;
      }
      else {
        var args_ary = new Array(args.length);
        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

        return args_ary;
      }
    
    }, $Opal_destructure$6.$$arity = 1);
    Opal.defs(self, '$respond_to?', $Opal_respond_to$ques$7 = function(obj, method, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      
      if (obj == null || !obj.$$class) {
        return false;
      }
    ;
      return obj['$respond_to?'](method, include_all);
    }, $Opal_respond_to$ques$7.$$arity = -3);
    Opal.defs(self, '$instance_variable_name!', $Opal_instance_variable_name$excl$8 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      if ($truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "'" + (name) + "' is not allowed as an instance variable name", name))
      };
      return name;
    }, $Opal_instance_variable_name$excl$8.$$arity = 1);
    Opal.defs(self, '$class_variable_name!', $Opal_class_variable_name$excl$9 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {
        self.$raise($$($nesting, 'NameError').$new("" + "`" + (name) + "' is not allowed as a class variable name", name))};
      return name;
    }, $Opal_class_variable_name$excl$9.$$arity = 1);
    Opal.defs(self, '$const_name!', $Opal_const_name$excl$10 = function(const_name) {
      var self = this;

      
      const_name = $$($nesting, 'Opal')['$coerce_to!'](const_name, $$($nesting, 'String'), "to_str");
      if ($truthy(const_name['$[]'](0)['$!='](const_name['$[]'](0).$upcase()))) {
        self.$raise($$($nesting, 'NameError'), "" + "wrong constant name " + (const_name))};
      return const_name;
    }, $Opal_const_name$excl$10.$$arity = 1);
    return (Opal.defs(self, '$pristine', $Opal_pristine$11 = function $$pristine(owner_class, $a) {
      var $post_args, method_names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      method_names = $post_args;;
      
      var method_name, method;
      for (var i = method_names.length - 1; i >= 0; i--) {
        method_name = method_names[i];
        method = owner_class.$$prototype['$'+method_name];

        if (method && !method.$$stub) {
          method.$$pristine = true;
        }
      }
    ;
      return nil;
    }, $Opal_pristine$11.$$arity = -2), nil) && 'pristine';
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/module"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $lambda = Opal.lambda, $range = Opal.range, $send2 = Opal.send2;

  Opal.add_stubs(['$module_eval', '$to_proc', '$===', '$raise', '$equal?', '$<', '$>', '$nil?', '$attr_reader', '$attr_writer', '$warn', '$attr_accessor', '$class_variable_name!', '$const_name!', '$=~', '$new', '$inject', '$split', '$const_get', '$==', '$!~', '$start_with?', '$bind', '$call', '$class', '$append_features', '$included', '$name', '$cover?', '$size', '$merge', '$compile', '$proc', '$any?', '$prepend_features', '$prepended', '$to_s', '$__id__', '$constants', '$include?', '$copy_class_variables', '$copy_constants']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_allocate$1, $Module_initialize$2, $Module_$eq_eq_eq$3, $Module_$lt$4, $Module_$lt_eq$5, $Module_$gt$6, $Module_$gt_eq$7, $Module_$lt_eq_gt$8, $Module_alias_method$9, $Module_alias_native$10, $Module_ancestors$11, $Module_append_features$12, $Module_attr_accessor$13, $Module_attr$14, $Module_attr_reader$15, $Module_attr_writer$16, $Module_autoload$17, $Module_class_variables$18, $Module_class_variable_get$19, $Module_class_variable_set$20, $Module_class_variable_defined$ques$21, $Module_remove_class_variable$22, $Module_constants$23, $Module_constants$24, $Module_nesting$25, $Module_const_defined$ques$26, $Module_const_get$27, $Module_const_missing$29, $Module_const_set$30, $Module_public_constant$31, $Module_define_method$32, $Module_remove_method$34, $Module_singleton_class$ques$35, $Module_include$36, $Module_included_modules$37, $Module_include$ques$38, $Module_instance_method$39, $Module_instance_methods$40, $Module_included$41, $Module_extended$42, $Module_extend_object$43, $Module_method_added$44, $Module_method_removed$45, $Module_method_undefined$46, $Module_module_eval$47, $Module_module_exec$49, $Module_method_defined$ques$50, $Module_module_function$51, $Module_name$52, $Module_prepend$53, $Module_prepend_features$54, $Module_prepended$55, $Module_remove_const$56, $Module_to_s$57, $Module_undef_method$58, $Module_instance_variables$59, $Module_dup$60, $Module_copy_class_variables$61, $Module_copy_constants$62;

    
    Opal.defs(self, '$allocate', $Module_allocate$1 = function $$allocate() {
      var self = this;

      
      var module = Opal.allocate_module(nil, function(){});
      // Link the prototype of Module subclasses
      if (self !== Opal.Module) Object.setPrototypeOf(module, self.$$prototype);
      return module;
    
    }, $Module_allocate$1.$$arity = 0);
    
    Opal.def(self, '$initialize', $Module_initialize$2 = function $$initialize() {
      var $iter = $Module_initialize$2.$$p, block = $iter || nil, self = this;

      if ($iter) $Module_initialize$2.$$p = null;
      
      
      if ($iter) $Module_initialize$2.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'module_eval', [], block.$to_proc())
      } else {
        return nil
      };
    }, $Module_initialize$2.$$arity = 0);
    
    Opal.def(self, '$===', $Module_$eq_eq_eq$3 = function(object) {
      var self = this;

      
      if ($truthy(object == null)) {
        return false};
      return Opal.is_a(object, self);;
    }, $Module_$eq_eq_eq$3.$$arity = 1);
    
    Opal.def(self, '$<', $Module_$lt$4 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "compared with non class/module")
      };
      
      var working = self,
          ancestors,
          i, length;

      if (working === other) {
        return false;
      }

      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === other) {
          return true;
        }
      }

      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === self) {
          return false;
        }
      }

      return nil;
    ;
    }, $Module_$lt$4.$$arity = 1);
    
    Opal.def(self, '$<=', $Module_$lt_eq$5 = function(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_lt(self, other)
      }
    }, $Module_$lt_eq$5.$$arity = 1);
    
    Opal.def(self, '$>', $Module_$gt$6 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "compared with non class/module")
      };
      return $rb_lt(other, self);
    }, $Module_$gt$6.$$arity = 1);
    
    Opal.def(self, '$>=', $Module_$gt_eq$7 = function(other) {
      var self = this, $ret_or_2 = nil;

      if ($truthy(($ret_or_2 = self['$equal?'](other)))) {
        return $ret_or_2
      } else {
        return $rb_gt(self, other)
      }
    }, $Module_$gt_eq$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Module_$lt_eq_gt$8 = function(other) {
      var self = this, lt = nil;

      
      
      if (self === other) {
        return 0;
      }
    ;
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        return nil
      };
      lt = $rb_lt(self, other);
      if ($truthy(lt['$nil?']())) {
        return nil};
      if ($truthy(lt)) {
        return -1
      } else {
        return 1
      };
    }, $Module_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$alias_method', $Module_alias_method$9 = function $$alias_method(newname, oldname) {
      var self = this;

      
      newname = $coerce_to(newname, $$($nesting, 'String'), 'to_str');
      oldname = $coerce_to(oldname, $$($nesting, 'String'), 'to_str');
      Opal.alias(self, newname, oldname);
      return self;
    }, $Module_alias_method$9.$$arity = 2);
    
    Opal.def(self, '$alias_native', $Module_alias_native$10 = function $$alias_native(mid, jsid) {
      var self = this;

      
      
      if (jsid == null) {
        jsid = mid;
      };
      Opal.alias_native(self, mid, jsid);
      return self;
    }, $Module_alias_native$10.$$arity = -2);
    
    Opal.def(self, '$ancestors', $Module_ancestors$11 = function $$ancestors() {
      var self = this;

      return Opal.ancestors(self);
    }, $Module_ancestors$11.$$arity = 0);
    
    Opal.def(self, '$append_features', $Module_append_features$12 = function $$append_features(includer) {
      var self = this;

      
      Opal.append_features(self, includer);
      return self;
    }, $Module_append_features$12.$$arity = 1);
    
    Opal.def(self, '$attr_accessor', $Module_attr_accessor$13 = function $$attr_accessor($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      $send(self, 'attr_reader', Opal.to_a(names));
      return $send(self, 'attr_writer', Opal.to_a(names));
    }, $Module_attr_accessor$13.$$arity = -1);
    
    Opal.def(self, '$attr', $Module_attr$14 = function $$attr($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (args.length == 2 && (args[1] === true || args[1] === false)) {
        self.$warn("optional boolean argument is obsoleted", $hash2(["uplevel"], {"uplevel": 1}))

        args[1] ? self.$attr_accessor(args[0]) : self.$attr_reader(args[0]);
        return nil;
      }
    ;
      return $send(self, 'attr_reader', Opal.to_a(args));
    }, $Module_attr$14.$$arity = -1);
    
    Opal.def(self, '$attr_reader', $Module_attr_reader$15 = function $$attr_reader($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name,
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar) {
          return function() {
            if (this[ivar] == null) {
              return nil;
            }
            else {
              return this[ivar];
            }
          };
        })(ivar);

        // initialize the instance variable as nil
        Opal.defineProperty(proto, ivar, nil);

        body.$$parameters = [];
        body.$$arity = 0;

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, $Module_attr_reader$15.$$arity = -1);
    
    Opal.def(self, '$attr_writer', $Module_attr_writer$16 = function $$attr_writer($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name + '=',
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar){
          return function(value) {
            return this[ivar] = value;
          }
        })(ivar);

        body.$$parameters = [['req']];
        body.$$arity = 1;

        // initialize the instance variable as nil
        Opal.defineProperty(proto, ivar, nil);

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, $Module_attr_writer$16.$$arity = -1);
    
    Opal.def(self, '$autoload', $Module_autoload$17 = function $$autoload(const$, path) {
      var self = this;

      
      if (self.$$autoload == null) self.$$autoload = {};
      Opal.const_cache_version++;
      self.$$autoload[const$] = path;
      return nil;
    
    }, $Module_autoload$17.$$arity = 2);
    
    Opal.def(self, '$class_variables', $Module_class_variables$18 = function $$class_variables() {
      var self = this;

      return Object.keys(Opal.class_variables(self));
    }, $Module_class_variables$18.$$arity = 0);
    
    Opal.def(self, '$class_variable_get', $Module_class_variable_get$19 = function $$class_variable_get(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variable_get(self, name, false);;
    }, $Module_class_variable_get$19.$$arity = 1);
    
    Opal.def(self, '$class_variable_set', $Module_class_variable_set$20 = function $$class_variable_set(name, value) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variable_set(self, name, value);;
    }, $Module_class_variable_set$20.$$arity = 2);
    
    Opal.def(self, '$class_variable_defined?', $Module_class_variable_defined$ques$21 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variables(self).hasOwnProperty(name);;
    }, $Module_class_variable_defined$ques$21.$$arity = 1);
    
    Opal.def(self, '$remove_class_variable', $Module_remove_class_variable$22 = function $$remove_class_variable(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      
      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
        var value = self.$$cvars[name];
        delete self.$$cvars[name];
        return value;
      } else {
        self.$raise($$($nesting, 'NameError'), "" + "cannot remove " + (name) + " for " + (self))
      }
    ;
    }, $Module_remove_class_variable$22.$$arity = 1);
    
    Opal.def(self, '$constants', $Module_constants$23 = function $$constants(inherit) {
      var self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      return Opal.constants(self, inherit);;
    }, $Module_constants$23.$$arity = -1);
    Opal.defs(self, '$constants', $Module_constants$24 = function $$constants(inherit) {
      var self = this;

      
      ;
      
      if (inherit == null) {
        var nesting = (self.$$nesting || []).concat(Opal.Object),
            constant, constants = {},
            i, ii;

        for(i = 0, ii = nesting.length; i < ii; i++) {
          for (constant in nesting[i].$$const) {
            constants[constant] = true;
          }
        }
        return Object.keys(constants);
      } else {
        return Opal.constants(self, inherit)
      }
    ;
    }, $Module_constants$24.$$arity = -1);
    Opal.defs(self, '$nesting', $Module_nesting$25 = function $$nesting() {
      var self = this;

      return self.$$nesting || [];
    }, $Module_nesting$25.$$arity = 0);
    
    Opal.def(self, '$const_defined?', $Module_const_defined$ques$26 = function(name, inherit) {
      var self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      name = $$($nesting, 'Opal')['$const_name!'](name);
      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      var module, modules = [self], module_constants, i, ii;

      // Add up ancestors if inherit is true
      if (inherit) {
        modules = modules.concat(Opal.ancestors(self));

        // Add Object's ancestors if it's a module – modules have no ancestors otherwise
        if (self.$$is_module) {
          modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));
        }
      }

      for (i = 0, ii = modules.length; i < ii; i++) {
        module = modules[i];
        if (module.$$const[name] != null) {
          return true;
        }
      }

      return false;
    ;
    }, $Module_const_defined$ques$26.$$arity = -2);
    
    Opal.def(self, '$const_get', $Module_const_get$27 = function $$const_get(name, inherit) {
      var $$28, self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      name = $$($nesting, 'Opal')['$const_name!'](name);
      
      if (name.indexOf('::') === 0 && name !== '::'){
        name = name.slice(2);
      }
    ;
      if ($truthy(name.indexOf('::') != -1 && name != '::')) {
        return $send(name.$split("::"), 'inject', [self], ($$28 = function(o, c){var self = $$28.$$s == null ? this : $$28.$$s;

        
          
          if (o == null) {
            o = nil;
          };
          
          if (c == null) {
            c = nil;
          };
          return o.$const_get(c);}, $$28.$$s = self, $$28.$$arity = 2, $$28))};
      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      if (inherit) {
        return $$([self], name);
      } else {
        return Opal.const_get_local(self, name);
      }
    ;
    }, $Module_const_get$27.$$arity = -2);
    
    Opal.def(self, '$const_missing', $Module_const_missing$29 = function $$const_missing(name) {
      var self = this, full_const_name = nil;

      
      
      if (self.$$autoload) {
        var file = self.$$autoload[name];

        if (file) {
          self.$require(file);

          return self.$const_get(name);
        }
      }
    ;
      full_const_name = (function() {if (self['$==']($$($nesting, 'Object'))) {
        return name
      } else {
        return "" + (self) + "::" + (name)
      }; return nil; })();
      return self.$raise($$($nesting, 'NameError').$new("" + "uninitialized constant " + (full_const_name), name));
    }, $Module_const_missing$29.$$arity = 1);
    
    Opal.def(self, '$const_set', $Module_const_set$30 = function $$const_set(name, value) {
      var self = this, $ret_or_3 = nil;

      
      name = $$($nesting, 'Opal')['$const_name!'](name);
      if ($truthy((function() {if ($truthy(($ret_or_3 = name['$!~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP'))))) {
        return $ret_or_3
      } else {
        return name['$start_with?']("::")
      }; return nil; })())) {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))};
      Opal.const_set(self, name, value);
      return value;
    }, $Module_const_set$30.$$arity = 2);
    
    Opal.def(self, '$public_constant', $Module_public_constant$31 = function $$public_constant(const_name) {
      var self = this;

      return nil
    }, $Module_public_constant$31.$$arity = 1);
    
    Opal.def(self, '$define_method', $Module_define_method$32 = function $$define_method(name, method) {
      var $iter = $Module_define_method$32.$$p, block = $iter || nil, $$33, self = this, $ret_or_4 = nil, $case = nil;

      if ($iter) $Module_define_method$32.$$p = null;
      
      
      if ($iter) $Module_define_method$32.$$p = null;;
      ;
      if ($truthy(method === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block")};
      block = (function() {if ($truthy(($ret_or_4 = block))) {
        return $ret_or_4
      } else {
        return (function() {$case = method;
        if ($$($nesting, 'Proc')['$===']($case)) {return method}
        else if ($$($nesting, 'Method')['$===']($case)) {return method.$to_proc().$$unbound}
        else if ($$($nesting, 'UnboundMethod')['$===']($case)) {return $lambda(($$33 = function($a){var self = $$33.$$s == null ? this : $$33.$$s, $post_args, args, bound = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          bound = method.$bind(self);
          return $send(bound, 'call', Opal.to_a(args));}, $$33.$$s = self, $$33.$$arity = -1, $$33))}
        else {return self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (block.$class()) + " (expected Proc/Method)")}})()
      }; return nil; })();
      
      var id = '$' + name;

      block.$$jsid        = name;
      block.$$s           = null;
      block.$$def         = block;
      block.$$define_meth = true;

      Opal.defn(self, id, block);

      return name;
    ;
    }, $Module_define_method$32.$$arity = -2);
    
    Opal.def(self, '$remove_method', $Module_remove_method$34 = function $$remove_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.rdef(self, "$" + names[i]);
      }
    ;
      return self;
    }, $Module_remove_method$34.$$arity = -1);
    
    Opal.def(self, '$singleton_class?', $Module_singleton_class$ques$35 = function() {
      var self = this;

      return !!self.$$is_singleton;
    }, $Module_singleton_class$ques$35.$$arity = 0);
    
    Opal.def(self, '$include', $Module_include$36 = function $$include($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(self);
        (mod).$included(self);
      }
    ;
      return self;
    }, $Module_include$36.$$arity = -1);
    
    Opal.def(self, '$included_modules', $Module_included_modules$37 = function $$included_modules() {
      var self = this;

      return Opal.included_modules(self);
    }, $Module_included_modules$37.$$arity = 0);
    
    Opal.def(self, '$include?', $Module_include$ques$38 = function(mod) {
      var self = this;

      
      if (!mod.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
      }

      var i, ii, mod2, ancestors = Opal.ancestors(self);

      for (i = 0, ii = ancestors.length; i < ii; i++) {
        mod2 = ancestors[i];
        if (mod2 === mod && mod2 !== self) {
          return true;
        }
      }

      return false;
    
    }, $Module_include$ques$38.$$arity = 1);
    
    Opal.def(self, '$instance_method', $Module_instance_method$39 = function $$instance_method(name) {
      var self = this;

      
      var meth = self.$$prototype['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$name()) + "'", name));
      }

      return $$($nesting, 'UnboundMethod').$new(self, meth.$$owner || self, meth, name);
    
    }, $Module_instance_method$39.$$arity = 1);
    
    Opal.def(self, '$instance_methods', $Module_instance_methods$40 = function $$instance_methods(include_super) {
      var self = this;

      
      
      if (include_super == null) {
        include_super = true;
      };
      
      if ($truthy(include_super)) {
        return Opal.instance_methods(self);
      } else {
        return Opal.own_instance_methods(self);
      }
    ;
    }, $Module_instance_methods$40.$$arity = -1);
    
    Opal.def(self, '$included', $Module_included$41 = function $$included(mod) {
      var self = this;

      return nil
    }, $Module_included$41.$$arity = 1);
    
    Opal.def(self, '$extended', $Module_extended$42 = function $$extended(mod) {
      var self = this;

      return nil
    }, $Module_extended$42.$$arity = 1);
    
    Opal.def(self, '$extend_object', $Module_extend_object$43 = function $$extend_object(object) {
      var self = this;

      return nil
    }, $Module_extend_object$43.$$arity = 1);
    
    Opal.def(self, '$method_added', $Module_method_added$44 = function $$method_added($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_added$44.$$arity = -1);
    
    Opal.def(self, '$method_removed', $Module_method_removed$45 = function $$method_removed($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_removed$45.$$arity = -1);
    
    Opal.def(self, '$method_undefined', $Module_method_undefined$46 = function $$method_undefined($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_undefined$46.$$arity = -1);
    
    Opal.def(self, '$module_eval', $Module_module_eval$47 = function $$module_eval($a) {
      var $iter = $Module_module_eval$47.$$p, block = $iter || nil, $post_args, args, $b, $$48, self = this, $ret_or_5 = nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_6 = nil, compiling_options = nil, compiled = nil;

      if ($iter) $Module_module_eval$47.$$p = null;
      
      
      if ($iter) $Module_module_eval$47.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_5 = block['$nil?']()))) {
        return !!Opal.compile;
      } else {
        return $ret_or_5
      }; return nil; })())) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
        } else {
          $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": (function() {if ($truthy(($ret_or_6 = file))) {
          return $ret_or_6
        } else {
          return "(eval)"
        }; return nil; })(), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $$($nesting, 'Opal').$compile(string, compiling_options);
        block = $send($$($nesting, 'Kernel'), 'proc', [], ($$48 = function(){var self = $$48.$$s == null ? this : $$48.$$s;

        
          return (function(self) {
            return eval(compiled);
          })(self)
        }, $$48.$$s = self, $$48.$$arity = 0, $$48));
      } else if ($truthy(args['$any?']())) {
        $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "" + ("" + "wrong number of arguments (" + (args.$size()) + " for 0)") + "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n")};
      
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.apply(self, [self]);
      block.$$s = old;

      return result;
    ;
    }, $Module_module_eval$47.$$arity = -1);
    Opal.alias(self, "class_eval", "module_eval");
    
    Opal.def(self, '$module_exec', $Module_module_exec$49 = function $$module_exec($a) {
      var $iter = $Module_module_exec$49.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Module_module_exec$49.$$p = null;
      
      
      if ($iter) $Module_module_exec$49.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (block === nil) {
        self.$raise($$($nesting, 'LocalJumpError'), "no block given")
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, args);
      block.$$s = block_self;

      return result;
    ;
    }, $Module_module_exec$49.$$arity = -1);
    Opal.alias(self, "class_exec", "module_exec");
    
    Opal.def(self, '$method_defined?', $Module_method_defined$ques$50 = function(method) {
      var self = this;

      
      var body = self.$$prototype['$' + method];
      return (!!body) && !body.$$stub;
    
    }, $Module_method_defined$ques$50.$$arity = 1);
    
    Opal.def(self, '$module_function', $Module_module_function$51 = function $$module_function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = true;
      }
      else {
        for (var i = 0, length = methods.length; i < length; i++) {
          var meth = methods[i],
              id   = '$' + meth,
              func = self.$$prototype[id];

          Opal.defs(self, id, func);
        }
      }

      return self;
    ;
    }, $Module_module_function$51.$$arity = -1);
    
    Opal.def(self, '$name', $Module_name$52 = function $$name() {
      var self = this;

      
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        // Give up if any of the ancestors is unnamed
        if (base.$$name === nil || base.$$name == null) return nil;

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === Opal.Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join('::');
    
    }, $Module_name$52.$$arity = 0);
    
    Opal.def(self, '$prepend', $Module_prepend$53 = function $$prepend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      if (mods.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$prepend_features(self);
        (mod).$prepended(self);
      }
    ;
      return self;
    }, $Module_prepend$53.$$arity = -1);
    
    Opal.def(self, '$prepend_features', $Module_prepend_features$54 = function $$prepend_features(prepender) {
      var self = this;

      
      
      if (!self.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (self.$class()) + " (expected Module)");
      }

      Opal.prepend_features(self, prepender)
    ;
      return self;
    }, $Module_prepend_features$54.$$arity = 1);
    
    Opal.def(self, '$prepended', $Module_prepended$55 = function $$prepended(mod) {
      var self = this;

      return nil
    }, $Module_prepended$55.$$arity = 1);
    
    Opal.def(self, '$remove_const', $Module_remove_const$56 = function $$remove_const(name) {
      var self = this;

      return Opal.const_remove(self, name);
    }, $Module_remove_const$56.$$arity = 1);
    
    Opal.def(self, '$to_s', $Module_to_s$57 = function $$to_s() {
      var self = this, $ret_or_7 = nil;

      if ($truthy(($ret_or_7 = Opal.Module.$name.call(self)))) {
        return $ret_or_7
      } else {
        return "" + "#<" + (self.$$is_module ? 'Module' : 'Class') + ":0x" + (self.$__id__().$to_s(16)) + ">"
      }
    }, $Module_to_s$57.$$arity = 0);
    
    Opal.def(self, '$undef_method', $Module_undef_method$58 = function $$undef_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.udef(self, "$" + names[i]);
      }
    ;
      return self;
    }, $Module_undef_method$58.$$arity = -1);
    
    Opal.def(self, '$instance_variables', $Module_instance_variables$59 = function $$instance_variables() {
      var self = this, consts = nil;

      
      consts = (Opal.Module.$$nesting = $nesting, self.$constants());
      
      var result = [];

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$' && name !== 'constructor' && !consts['$include?'](name)) {
          result.push('@' + name);
        }
      }

      return result;
    ;
    }, $Module_instance_variables$59.$$arity = 0);
    
    Opal.def(self, '$dup', $Module_dup$60 = function $$dup() {
      var $iter = $Module_dup$60.$$p, $yield = $iter || nil, self = this, copy = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Module_dup$60.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      copy = $send2(self, Opal.find_super_dispatcher(self, 'dup', $Module_dup$60, false, true), 'dup', $zuper, $iter);
      copy.$copy_class_variables(self);
      copy.$copy_constants(self);
      return copy;
    }, $Module_dup$60.$$arity = 0);
    
    Opal.def(self, '$copy_class_variables', $Module_copy_class_variables$61 = function $$copy_class_variables(other) {
      var self = this;

      
      for (var name in other.$$cvars) {
        self.$$cvars[name] = other.$$cvars[name];
      }
    
    }, $Module_copy_class_variables$61.$$arity = 1);
    return (Opal.def(self, '$copy_constants', $Module_copy_constants$62 = function $$copy_constants(other) {
      var self = this;

      
      var name, other_constants = other.$$const;

      for (name in other_constants) {
        Opal.const_set(self, name, other_constants[name]);
      }
    
    }, $Module_copy_constants$62.$$arity = 1), nil) && 'copy_constants';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/class"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $send2 = Opal.send2;

  Opal.add_stubs(['$require', '$class_eval', '$to_proc', '$initialize_copy', '$allocate', '$name', '$to_s']);
  
  self.$require("corelib/module");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $Class_new$1, $Class_allocate$2, $Class_inherited$3, $Class_initialize_dup$4, $Class_new$5, $Class_superclass$6, $Class_to_s$7;

    
    Opal.defs(self, '$new', $Class_new$1 = function(superclass) {
      var $iter = $Class_new$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Class_new$1.$$p = null;
      
      
      if ($iter) $Class_new$1.$$p = null;;
      
      if (superclass == null) {
        superclass = $$($nesting, 'Object');
      };
      
      if (!superclass.$$is_class) {
        throw Opal.TypeError.$new("superclass must be a Class");
      }

      var klass = Opal.allocate_class(nil, superclass);
      superclass.$inherited(klass);
      (function() {if ((block !== nil)) {
        return $send((klass), 'class_eval', [], block.$to_proc())
      } else {
        return nil
      }; return nil; })()
      return klass;
    ;
    }, $Class_new$1.$$arity = -1);
    
    Opal.def(self, '$allocate', $Class_allocate$2 = function $$allocate() {
      var self = this;

      
      var obj = new self.$$constructor();
      obj.$$id = Opal.uid();
      return obj;
    
    }, $Class_allocate$2.$$arity = 0);
    
    Opal.def(self, '$inherited', $Class_inherited$3 = function $$inherited(cls) {
      var self = this;

      return nil
    }, $Class_inherited$3.$$arity = 1);
    
    Opal.def(self, '$initialize_dup', $Class_initialize_dup$4 = function $$initialize_dup(original) {
      var self = this;

      
      self.$initialize_copy(original);
      
      self.$$name = null;
      self.$$full_name = null;
    ;
    }, $Class_initialize_dup$4.$$arity = 1);
    
    Opal.def(self, '$new', $Class_new$5 = function($a) {
      var $iter = $Class_new$5.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Class_new$5.$$p = null;
      
      
      if ($iter) $Class_new$5.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var object = self.$allocate();
      Opal.send(object, object.$initialize, args, block);
      return object;
    ;
    }, $Class_new$5.$$arity = -1);
    
    Opal.def(self, '$superclass', $Class_superclass$6 = function $$superclass() {
      var self = this;

      return self.$$super || nil;
    }, $Class_superclass$6.$$arity = 0);
    return (Opal.def(self, '$to_s', $Class_to_s$7 = function $$to_s() {
      var $iter = $Class_to_s$7.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Class_to_s$7.$$p = null;
      
      var singleton_of = self.$$singleton_of;

      if (singleton_of && singleton_of.$$is_a_module) {
        return "" + "#<Class:" + ((singleton_of).$name()) + ">";
      }
      else if (singleton_of) {
        // a singleton class created from an object
        return "" + "#<Class:#<" + ((singleton_of.$$class).$name()) + ":0x" + ((Opal.id(singleton_of)).$to_s(16)) + ">>";
      }

      return $send2(self, Opal.find_super_dispatcher(self, 'to_s', $Class_to_s$7, false, true), 'to_s', [], null);
    
    }, $Class_to_s$7.$$arity = 0), nil) && 'to_s';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/basic_object"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$==', '$!', '$nil?', '$cover?', '$size', '$raise', '$merge', '$compile', '$proc', '$any?', '$inspect', '$new']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'BasicObject');

    var $nesting = [self].concat($parent_nesting), $BasicObject_initialize$1, $BasicObject_$eq_eq$2, $BasicObject_eql$ques$3, $BasicObject___id__$4, $BasicObject___send__$5, $BasicObject_$excl$6, $BasicObject_$not_eq$7, $BasicObject_instance_eval$8, $BasicObject_instance_exec$10, $BasicObject_singleton_method_added$11, $BasicObject_singleton_method_removed$12, $BasicObject_singleton_method_undefined$13, $BasicObject_method_missing$14, $BasicObject_respond_to_missing$ques$15;

    
    
    Opal.def(self, '$initialize', $BasicObject_initialize$1 = function $$initialize($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_initialize$1.$$arity = -1);
    
    Opal.def(self, '$==', $BasicObject_$eq_eq$2 = function(other) {
      var self = this;

      return self === other;
    }, $BasicObject_$eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$eql?', $BasicObject_eql$ques$3 = function(other) {
      var self = this;

      return self['$=='](other)
    }, $BasicObject_eql$ques$3.$$arity = 1);
    Opal.alias(self, "equal?", "==");
    
    Opal.def(self, '$__id__', $BasicObject___id__$4 = function $$__id__() {
      var self = this;

      
      if (self.$$id != null) {
        return self.$$id;
      }
      Opal.defineProperty(self, '$$id', Opal.uid());
      return self.$$id;
    
    }, $BasicObject___id__$4.$$arity = 0);
    
    Opal.def(self, '$__send__', $BasicObject___send__$5 = function $$__send__(symbol, $a) {
      var $iter = $BasicObject___send__$5.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $BasicObject___send__$5.$$p = null;
      
      
      if ($iter) $BasicObject___send__$5.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      var func = self['$' + symbol]

      if (func) {
        if (block !== nil) {
          func.$$p = block;
        }

        return func.apply(self, args);
      }

      if (block !== nil) {
        self.$method_missing.$$p = block;
      }

      return self.$method_missing.apply(self, [symbol].concat(args));
    ;
    }, $BasicObject___send__$5.$$arity = -2);
    
    Opal.def(self, '$!', $BasicObject_$excl$6 = function() {
      var self = this;

      return false
    }, $BasicObject_$excl$6.$$arity = 0);
    
    Opal.def(self, '$!=', $BasicObject_$not_eq$7 = function(other) {
      var self = this;

      return self['$=='](other)['$!']()
    }, $BasicObject_$not_eq$7.$$arity = 1);
    
    Opal.def(self, '$instance_eval', $BasicObject_instance_eval$8 = function $$instance_eval($a) {
      var $iter = $BasicObject_instance_eval$8.$$p, block = $iter || nil, $post_args, args, $b, $$9, self = this, $ret_or_1 = nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_2 = nil, compiling_options = nil, compiled = nil;

      if ($iter) $BasicObject_instance_eval$8.$$p = null;
      
      
      if ($iter) $BasicObject_instance_eval$8.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_1 = block['$nil?']()))) {
        return !!Opal.compile;
      } else {
        return $ret_or_1
      }; return nil; })())) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
        } else {
          $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": (function() {if ($truthy(($ret_or_2 = file))) {
          return $ret_or_2
        } else {
          return "(eval)"
        }; return nil; })(), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $$$('::', 'Opal').$compile(string, compiling_options);
        block = $send($$$('::', 'Kernel'), 'proc', [], ($$9 = function(){var self = $$9.$$s == null ? this : $$9.$$s;

        
          return (function(self) {
            return eval(compiled);
          })(self)
        }, $$9.$$s = self, $$9.$$arity = 0, $$9));
      } else if ($truthy(args['$any?']())) {
        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "" + "wrong number of arguments (" + (args.$size()) + " for 0)")};
      
      var old = block.$$s,
          result;

      block.$$s = null;

      // Need to pass $$eval so that method definitions know if this is
      // being done on a class/module. Cannot be compiler driven since
      // send(:instance_eval) needs to work.
      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.call(self, self);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.call(self, self);
      }

      block.$$s = old;

      return result;
    ;
    }, $BasicObject_instance_eval$8.$$arity = -1);
    
    Opal.def(self, '$instance_exec', $BasicObject_instance_exec$10 = function $$instance_exec($a) {
      var $iter = $BasicObject_instance_exec$10.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $BasicObject_instance_exec$10.$$p = null;
      
      
      if ($iter) $BasicObject_instance_exec$10.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(block)) {
      } else {
        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "no block given")
      };
      
      var block_self = block.$$s,
          result;

      block.$$s = null;

      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.apply(self, args);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.apply(self, args);
      }

      block.$$s = block_self;

      return result;
    ;
    }, $BasicObject_instance_exec$10.$$arity = -1);
    
    Opal.def(self, '$singleton_method_added', $BasicObject_singleton_method_added$11 = function $$singleton_method_added($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_added$11.$$arity = -1);
    
    Opal.def(self, '$singleton_method_removed', $BasicObject_singleton_method_removed$12 = function $$singleton_method_removed($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_removed$12.$$arity = -1);
    
    Opal.def(self, '$singleton_method_undefined', $BasicObject_singleton_method_undefined$13 = function $$singleton_method_undefined($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_undefined$13.$$arity = -1);
    
    Opal.def(self, '$method_missing', $BasicObject_method_missing$14 = function $$method_missing(symbol, $a) {
      var $iter = $BasicObject_method_missing$14.$$p, block = $iter || nil, $post_args, args, self = this, message = nil;

      if ($iter) $BasicObject_method_missing$14.$$p = null;
      
      
      if ($iter) $BasicObject_method_missing$14.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      message = (function() {if ($truthy(self.$inspect && !self.$inspect.$$stub)) {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$inspect()) + ":" + (self.$$class)
      } else {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$$class)
      }; return nil; })();
      return $$$('::', 'Kernel').$raise($$$('::', 'NoMethodError').$new(message, symbol));
    }, $BasicObject_method_missing$14.$$arity = -2);
    return (Opal.def(self, '$respond_to_missing?', $BasicObject_respond_to_missing$ques$15 = function(method_name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return false;
    }, $BasicObject_respond_to_missing$ques$15.$$arity = -2), nil) && 'respond_to_missing?';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/kernel"] = function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $module = Opal.module, $gvars = Opal.gvars, $hash2 = Opal.hash2, $send = Opal.send, $klass = Opal.klass;

  Opal.add_stubs(['$raise', '$new', '$inspect', '$!', '$=~', '$==', '$object_id', '$class', '$coerce_to?', '$<<', '$allocate', '$copy_instance_variables', '$copy_singleton_methods', '$initialize_clone', '$initialize_copy', '$define_method', '$singleton_class', '$to_proc', '$initialize_dup', '$for', '$empty?', '$pop', '$call', '$append_features', '$extend_object', '$extended', '$__id__', '$to_s', '$instance_variable_name!', '$respond_to?', '$to_int', '$coerce_to!', '$Integer', '$nil?', '$===', '$enum_for', '$result', '$any?', '$print', '$format', '$puts', '$each', '$<=', '$length', '$[]', '$<', '$first', '$caller', '$+', '$map', '$exception', '$is_a?', '$rand', '$respond_to_missing?', '$pristine', '$try_convert!', '$expand_path', '$join', '$start_with?', '$new_seed', '$srand', '$sym', '$arg', '$open', '$include']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_method_missing$1, $Kernel_$eq_tilde$2, $Kernel_$excl_tilde$3, $Kernel_$eq_eq_eq$4, $Kernel_$lt_eq_gt$5, $Kernel_method$6, $Kernel_methods$7, $Kernel_public_methods$8, $Kernel_Array$9, $Kernel_at_exit$10, $Kernel_caller$11, $Kernel_class$12, $Kernel_copy_instance_variables$13, $Kernel_copy_singleton_methods$14, $Kernel_clone$15, $Kernel_initialize_clone$16, $Kernel_define_singleton_method$17, $Kernel_dup$18, $Kernel_initialize_dup$19, $Kernel_enum_for$20, $Kernel_equal$ques$21, $Kernel_exit$22, $Kernel_extend$23, $Kernel_hash$24, $Kernel_initialize_copy$25, $Kernel_inspect$26, $Kernel_instance_of$ques$27, $Kernel_instance_variable_defined$ques$28, $Kernel_instance_variable_get$29, $Kernel_instance_variable_set$30, $Kernel_remove_instance_variable$31, $Kernel_instance_variables$32, $Kernel_Integer$33, $Kernel_Float$34, $Kernel_Hash$35, $Kernel_is_a$ques$36, $Kernel_itself$37, $Kernel_lambda$38, $Kernel_load$39, $Kernel_loop$40, $Kernel_nil$ques$42, $Kernel_printf$43, $Kernel_proc$44, $Kernel_puts$45, $Kernel_p$46, $Kernel_print$48, $Kernel_warn$49, $Kernel_raise$51, $Kernel_rand$52, $Kernel_respond_to$ques$53, $Kernel_respond_to_missing$ques$54, $Kernel_require$55, $Kernel_require_relative$56, $Kernel_require_tree$57, $Kernel_singleton_class$58, $Kernel_sleep$59, $Kernel_srand$60, $Kernel_String$61, $Kernel_tap$62, $Kernel_to_proc$63, $Kernel_to_s$64, $Kernel_catch$65, $Kernel_throw$66, $Kernel_open$67, $Kernel_yield_self$68;

    
    
    Opal.def(self, '$method_missing', $Kernel_method_missing$1 = function $$method_missing(symbol, $a) {
      var $iter = $Kernel_method_missing$1.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_method_missing$1.$$p = null;
      
      
      if ($iter) $Kernel_method_missing$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      return self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `" + (symbol) + "' for " + (self.$inspect()), symbol, args));
    }, $Kernel_method_missing$1.$$arity = -2);
    
    Opal.def(self, '$=~', $Kernel_$eq_tilde$2 = function(obj) {
      var self = this;

      return false
    }, $Kernel_$eq_tilde$2.$$arity = 1);
    
    Opal.def(self, '$!~', $Kernel_$excl_tilde$3 = function(obj) {
      var self = this;

      return self['$=~'](obj)['$!']()
    }, $Kernel_$excl_tilde$3.$$arity = 1);
    
    Opal.def(self, '$===', $Kernel_$eq_eq_eq$4 = function(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$object_id()['$=='](other.$object_id())))) {
        return $ret_or_1
      } else {
        return self['$=='](other)
      }
    }, $Kernel_$eq_eq_eq$4.$$arity = 1);
    
    Opal.def(self, '$<=>', $Kernel_$lt_eq_gt$5 = function(other) {
      var self = this;

      
      // set guard for infinite recursion
      self.$$comparable = true;

      var x = self['$=='](other);

      if (x && x !== nil) {
        return 0;
      }

      return nil;
    
    }, $Kernel_$lt_eq_gt$5.$$arity = 1);
    
    Opal.def(self, '$method', $Kernel_method$6 = function $$method(name) {
      var self = this;

      
      var meth = self['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$class()) + "'", name));
      }

      return $$($nesting, 'Method').$new(self, meth.$$owner || self.$class(), meth, name);
    
    }, $Kernel_method$6.$$arity = 1);
    
    Opal.def(self, '$methods', $Kernel_methods$7 = function $$methods(all) {
      var self = this;

      
      
      if (all == null) {
        all = true;
      };
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.own_methods(self);
      }
    ;
    }, $Kernel_methods$7.$$arity = -1);
    
    Opal.def(self, '$public_methods', $Kernel_public_methods$8 = function $$public_methods(all) {
      var self = this;

      
      
      if (all == null) {
        all = true;
      };
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.receiver_methods(self);
      }
    ;
    }, $Kernel_public_methods$8.$$arity = -1);
    
    Opal.def(self, '$Array', $Kernel_Array$9 = function $$Array(object) {
      var self = this;

      
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_ary");
      if (coerced !== nil) { return coerced; }

      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_a");
      if (coerced !== nil) { return coerced; }

      return [object];
    
    }, $Kernel_Array$9.$$arity = 1);
    
    Opal.def(self, '$at_exit', $Kernel_at_exit$10 = function $$at_exit() {
      var $iter = $Kernel_at_exit$10.$$p, block = $iter || nil, self = this, $ret_or_2 = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      if ($iter) $Kernel_at_exit$10.$$p = null;
      
      
      if ($iter) $Kernel_at_exit$10.$$p = null;;
      $gvars.__at_exit__ = (function() {if ($truthy(($ret_or_2 = $gvars.__at_exit__))) {
        return $ret_or_2
      } else {
        return []
      }; return nil; })();
      $gvars.__at_exit__['$<<'](block);
      return block;
    }, $Kernel_at_exit$10.$$arity = 0);
    
    Opal.def(self, '$caller', $Kernel_caller$11 = function $$caller(start, length) {
      var self = this;

      
      
      if (start == null) {
        start = 1;
      };
      
      if (length == null) {
        length = nil;
      };
      
      var stack, result

      stack = (new Error().stack || "").split("\n")
      result = []

      // Skip the initial line ("Error:") and Kernel#caller with i=3
      for (var i = 3, ii = stack.length; i < ii; i++) {
        if (!stack[i].match("runtime.js")) {
          result.push(stack[i].replace(/^ *\w+ +/, ''))
          if (length && result.length == length) break
        }
      }
      return result
    ;
    }, $Kernel_caller$11.$$arity = -1);
    
    Opal.def(self, '$class', $Kernel_class$12 = function() {
      var self = this;

      return self.$$class;
    }, $Kernel_class$12.$$arity = 0);
    
    Opal.def(self, '$copy_instance_variables', $Kernel_copy_instance_variables$13 = function $$copy_instance_variables(other) {
      var self = this;

      
      var keys = Object.keys(other), i, ii, name;
      for (i = 0, ii = keys.length; i < ii; i++) {
        name = keys[i];
        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, $Kernel_copy_instance_variables$13.$$arity = 1);
    
    Opal.def(self, '$copy_singleton_methods', $Kernel_copy_singleton_methods$14 = function $$copy_singleton_methods(other) {
      var self = this;

      
      var i, name, names, length;

      if (other.hasOwnProperty('$$meta')) {
        var other_singleton_class = Opal.get_singleton_class(other);
        var self_singleton_class = Opal.get_singleton_class(self);
        names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);

        for (i = 0, length = names.length; i < length; i++) {
          name = names[i];
          if (Opal.is_method(name)) {
            self_singleton_class.$$prototype[name] = other_singleton_class.$$prototype[name];
          }
        }

        self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
        Object.setPrototypeOf(
          self_singleton_class.$$prototype,
          Object.getPrototypeOf(other_singleton_class.$$prototype)
        );
      }

      for (i = 0, names = Object.getOwnPropertyNames(other), length = names.length; i < length; i++) {
        name = names[i];
        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, $Kernel_copy_singleton_methods$14.$$arity = 1);
    
    Opal.def(self, '$clone', $Kernel_clone$15 = function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, $Kernel_clone$15.$$arity = -1);
    
    Opal.def(self, '$initialize_clone', $Kernel_initialize_clone$16 = function $$initialize_clone(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, $Kernel_initialize_clone$16.$$arity = 1);
    
    Opal.def(self, '$define_singleton_method', $Kernel_define_singleton_method$17 = function $$define_singleton_method(name, method) {
      var $iter = $Kernel_define_singleton_method$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_define_singleton_method$17.$$p = null;
      
      
      if ($iter) $Kernel_define_singleton_method$17.$$p = null;;
      ;
      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc());
    }, $Kernel_define_singleton_method$17.$$arity = -2);
    
    Opal.def(self, '$dup', $Kernel_dup$18 = function $$dup() {
      var self = this, copy = nil;

      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, $Kernel_dup$18.$$arity = 0);
    
    Opal.def(self, '$initialize_dup', $Kernel_initialize_dup$19 = function $$initialize_dup(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, $Kernel_initialize_dup$19.$$arity = 1);
    
    Opal.def(self, '$enum_for', $Kernel_enum_for$20 = function $$enum_for($a, $b) {
      var $iter = $Kernel_enum_for$20.$$p, block = $iter || nil, $post_args, method, args, self = this;

      if ($iter) $Kernel_enum_for$20.$$p = null;
      
      
      if ($iter) $Kernel_enum_for$20.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      if ($post_args.length > 0) {
        method = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (method == null) {
        method = "each";
      };
      
      args = $post_args;;
      return $send($$($nesting, 'Enumerator'), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc());
    }, $Kernel_enum_for$20.$$arity = -1);
    Opal.alias(self, "to_enum", "enum_for");
    
    Opal.def(self, '$equal?', $Kernel_equal$ques$21 = function(other) {
      var self = this;

      return self === other;
    }, $Kernel_equal$ques$21.$$arity = 1);
    
    Opal.def(self, '$exit', $Kernel_exit$22 = function $$exit(status) {
      var $a, self = this, $ret_or_3 = nil, block = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      
      
      if (status == null) {
        status = true;
      };
      $gvars.__at_exit__ = (function() {if ($truthy(($ret_or_3 = $gvars.__at_exit__))) {
        return $ret_or_3
      } else {
        return []
      }; return nil; })();
      while (!($truthy($gvars.__at_exit__['$empty?']()))) {
        
        block = $gvars.__at_exit__.$pop();
        block.$call();
      };
      
      if (status.$$is_boolean) {
        status = status ? 0 : 1;
      } else {
        status = $coerce_to(status, $$($nesting, 'Integer'), 'to_int')
      }

      Opal.exit(status);
    ;
      return nil;
    }, $Kernel_exit$22.$$arity = -1);
    
    Opal.def(self, '$extend', $Kernel_extend$23 = function $$extend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      var singleton = self.$singleton_class();

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(singleton);
        (mod).$extend_object(self);
        (mod).$extended(self);
      }
    ;
      return self;
    }, $Kernel_extend$23.$$arity = -1);
    
    Opal.def(self, '$hash', $Kernel_hash$24 = function $$hash() {
      var self = this;

      return self.$__id__()
    }, $Kernel_hash$24.$$arity = 0);
    
    Opal.def(self, '$initialize_copy', $Kernel_initialize_copy$25 = function $$initialize_copy(other) {
      var self = this;

      return nil
    }, $Kernel_initialize_copy$25.$$arity = 1);
    
    Opal.def(self, '$inspect', $Kernel_inspect$26 = function $$inspect() {
      var self = this;

      return self.$to_s()
    }, $Kernel_inspect$26.$$arity = 0);
    
    Opal.def(self, '$instance_of?', $Kernel_instance_of$ques$27 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "class or module required");
      }

      return self.$$class === klass;
    
    }, $Kernel_instance_of$ques$27.$$arity = 1);
    
    Opal.def(self, '$instance_variable_defined?', $Kernel_instance_variable_defined$ques$28 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      return Opal.hasOwnProperty.call(self, name.substr(1));;
    }, $Kernel_instance_variable_defined$ques$28.$$arity = 1);
    
    Opal.def(self, '$instance_variable_get', $Kernel_instance_variable_get$29 = function $$instance_variable_get(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var ivar = self[Opal.ivar(name.substr(1))];

      return ivar == null ? nil : ivar;
    ;
    }, $Kernel_instance_variable_get$29.$$arity = 1);
    
    Opal.def(self, '$instance_variable_set', $Kernel_instance_variable_set$30 = function $$instance_variable_set(name, value) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      return self[Opal.ivar(name.substr(1))] = value;;
    }, $Kernel_instance_variable_set$30.$$arity = 2);
    
    Opal.def(self, '$remove_instance_variable', $Kernel_remove_instance_variable$31 = function $$remove_instance_variable(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var key = Opal.ivar(name.substr(1)),
          val;
      if (self.hasOwnProperty(key)) {
        val = self[key];
        delete self[key];
        return val;
      }
    ;
      return self.$raise($$($nesting, 'NameError'), "" + "instance variable " + (name) + " not defined");
    }, $Kernel_remove_instance_variable$31.$$arity = 1);
    
    Opal.def(self, '$instance_variables', $Kernel_instance_variables$32 = function $$instance_variables() {
      var self = this;

      
      var result = [], ivar;

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$') {
          if (name.substr(-1) === '$') {
            ivar = name.slice(0, name.length - 1);
          } else {
            ivar = name;
          }
          result.push('@' + ivar);
        }
      }

      return result;
    
    }, $Kernel_instance_variables$32.$$arity = 0);
    
    Opal.def(self, '$Integer', $Kernel_Integer$33 = function $$Integer(value, base) {
      var self = this;

      
      ;
      
      var i, str, base_digits;

      if (!value.$$is_string) {
        if (base !== undefined) {
          self.$raise($$($nesting, 'ArgumentError'), "base specified for non string value")
        }
        if (value === nil) {
          self.$raise($$($nesting, 'TypeError'), "can't convert nil into Integer")
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            self.$raise($$($nesting, 'FloatDomainError'), value)
          }
          return Math.floor(value);
        }
        if (value['$respond_to?']("to_int")) {
          i = value.$to_int();
          if (i !== nil) {
            return i;
          }
        }
        return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Integer'), "to_i");
      }

      if (value === "0") {
        return 0;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = $coerce_to(base, $$($nesting, 'Integer'), 'to_int');
        if (base === 1 || base < 0 || base > 36) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, '$1');

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case '0b':
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
        case '0':
        case '0o':
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
        case '0d':
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
        case '0x':
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
        }
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      });

      base = (base === 0 ? 10 : base);

      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$')).test(str)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      return i;
    ;
    }, $Kernel_Integer$33.$$arity = -2);
    
    Opal.def(self, '$Float', $Kernel_Float$34 = function $$Float(value) {
      var self = this;

      
      var str;

      if (value === nil) {
        self.$raise($$($nesting, 'TypeError'), "can't convert nil into Float")
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, '$1');

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return self.$Integer(str);
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Float(): \"" + (value) + "\"")
        }

        return parseFloat(str);
      }

      return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Float'), "to_f");
    
    }, $Kernel_Float$34.$$arity = 1);
    
    Opal.def(self, '$Hash', $Kernel_Hash$35 = function $$Hash(arg) {
      var self = this, $ret_or_4 = nil;

      
      if ($truthy((function() {if ($truthy(($ret_or_4 = arg['$nil?']()))) {
        return $ret_or_4
      } else {
        return arg['$==']([])
      }; return nil; })())) {
        return $hash2([], {})};
      if ($truthy($$($nesting, 'Hash')['$==='](arg))) {
        return arg};
      return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'Hash'), "to_hash");
    }, $Kernel_Hash$35.$$arity = 1);
    
    Opal.def(self, '$is_a?', $Kernel_is_a$ques$36 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "class or module required");
      }

      return Opal.is_a(self, klass);
    
    }, $Kernel_is_a$ques$36.$$arity = 1);
    
    Opal.def(self, '$itself', $Kernel_itself$37 = function $$itself() {
      var self = this;

      return self
    }, $Kernel_itself$37.$$arity = 0);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$lambda', $Kernel_lambda$38 = function $$lambda() {
      var $iter = $Kernel_lambda$38.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_lambda$38.$$p = null;
      
      
      if ($iter) $Kernel_lambda$38.$$p = null;;
      return Opal.lambda(block);;
    }, $Kernel_lambda$38.$$arity = 0);
    
    Opal.def(self, '$load', $Kernel_load$39 = function $$load(file) {
      var self = this;

      
      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
      return Opal.load(file);
    }, $Kernel_load$39.$$arity = 1);
    
    Opal.def(self, '$loop', $Kernel_loop$40 = function $$loop() {
      var $$41, $a, $iter = $Kernel_loop$40.$$p, $yield = $iter || nil, self = this, e = nil;

      if ($iter) $Kernel_loop$40.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["loop"], ($$41 = function(){var self = $$41.$$s == null ? this : $$41.$$s;

        return $$$($$($nesting, 'Float'), 'INFINITY')}, $$41.$$s = self, $$41.$$arity = 0, $$41))
      };
      while ($truthy(true)) {
        
        try {
          Opal.yieldX($yield, [])
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'StopIteration')])) {(e = $err)
            try {
              return e.$result()
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };
      };
      return self;
    }, $Kernel_loop$40.$$arity = 0);
    
    Opal.def(self, '$nil?', $Kernel_nil$ques$42 = function() {
      var self = this;

      return false
    }, $Kernel_nil$ques$42.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$printf', $Kernel_printf$43 = function $$printf($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(args['$any?']())) {
        self.$print($send(self, 'format', Opal.to_a(args)))};
      return nil;
    }, $Kernel_printf$43.$$arity = -1);
    
    Opal.def(self, '$proc', $Kernel_proc$44 = function $$proc() {
      var $iter = $Kernel_proc$44.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_proc$44.$$p = null;
      
      
      if ($iter) $Kernel_proc$44.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create Proc object without a block")
      };
      block.$$is_lambda = false;
      return block;
    }, $Kernel_proc$44.$$arity = 0);
    
    Opal.def(self, '$puts', $Kernel_puts$45 = function $$puts($a) {
      var $post_args, strs, self = this;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'puts', Opal.to_a(strs));
    }, $Kernel_puts$45.$$arity = -1);
    
    Opal.def(self, '$p', $Kernel_p$46 = function $$p($a) {
      var $post_args, args, $$47, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      $send(args, 'each', [], ($$47 = function(obj){var self = $$47.$$s == null ? this : $$47.$$s;
        if ($gvars.stdout == null) $gvars.stdout = nil;

      
        
        if (obj == null) {
          obj = nil;
        };
        return $gvars.stdout.$puts(obj.$inspect());}, $$47.$$s = self, $$47.$$arity = 1, $$47));
      if ($truthy($rb_le(args.$length(), 1))) {
        return args['$[]'](0)
      } else {
        return args
      };
    }, $Kernel_p$46.$$arity = -1);
    
    Opal.def(self, '$print', $Kernel_print$48 = function $$print($a) {
      var $post_args, strs, self = this;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'print', Opal.to_a(strs));
    }, $Kernel_print$48.$$arity = -1);
    
    Opal.def(self, '$warn', $Kernel_warn$49 = function $$warn($a, $b) {
      var $post_args, $kwargs, strs, uplevel, $$50, self = this, location = nil, $ret_or_5 = nil;
      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      strs = $post_args;;
      
      uplevel = $kwargs.$$smap["uplevel"];
      if (uplevel == null) {
        uplevel = nil
      };
      if ($truthy(uplevel)) {
        
        uplevel = $$($nesting, 'Opal')['$coerce_to!'](uplevel, $$($nesting, 'Integer'), "to_str");
        if ($truthy($rb_lt(uplevel, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "negative level (" + (uplevel) + ")")};
        location = self.$caller($rb_plus(uplevel, 2), 1).$first();
        if ($truthy(location)) {
          location = "" + (location) + ": "};
        strs = $send(strs, 'map', [], ($$50 = function(s){var self = $$50.$$s == null ? this : $$50.$$s;

        
          
          if (s == null) {
            s = nil;
          };
          return "" + (location) + "warning: " + (s);}, $$50.$$s = self, $$50.$$arity = 1, $$50));};
      if ($truthy((function() {if ($truthy(($ret_or_5 = $gvars.VERBOSE['$nil?']()))) {
        return $ret_or_5
      } else {
        return strs['$empty?']()
      }; return nil; })())) {
        return nil
      } else {
        return $send($gvars.stderr, 'puts', Opal.to_a(strs))
      };
    }, $Kernel_warn$49.$$arity = -1);
    
    Opal.def(self, '$raise', $Kernel_raise$51 = function $$raise(exception, string, _backtrace) {
      var self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      
      ;
      
      if (string == null) {
        string = nil;
      };
      
      if (_backtrace == null) {
        _backtrace = nil;
      };
      
      if (exception == null && $gvars["!"] !== nil) {
        throw $gvars["!"];
      }
      if (exception == null) {
        exception = $$($nesting, 'RuntimeError').$new();
      }
      else if (exception.$$is_string) {
        exception = $$($nesting, 'RuntimeError').$new(exception);
      }
      // using respond_to? and not an undefined check to avoid method_missing matching as true
      else if (exception.$$is_class && exception['$respond_to?']("exception")) {
        exception = exception.$exception(string);
      }
      else if (exception['$is_a?']($$($nesting, 'Exception'))) {
        // exception is fine
      }
      else {
        exception = $$($nesting, 'TypeError').$new("exception class/object expected");
      }

      if ($gvars["!"] !== nil) {
        Opal.exceptions.push($gvars["!"]);
      }

      $gvars["!"] = exception;

      throw exception;
    ;
    }, $Kernel_raise$51.$$arity = -1);
    Opal.alias(self, "fail", "raise");
    
    Opal.def(self, '$rand', $Kernel_rand$52 = function $$rand(max) {
      var self = this;

      
      ;
      
      if (max === undefined) {
        return $$$($$($nesting, 'Random'), 'DEFAULT').$rand();
      }

      if (max.$$is_number) {
        if (max < 0) {
          max = Math.abs(max);
        }

        if (max % 1 !== 0) {
          max = max.$to_i();
        }

        if (max === 0) {
          max = undefined;
        }
      }
    ;
      return $$$($$($nesting, 'Random'), 'DEFAULT').$rand(max);
    }, $Kernel_rand$52.$$arity = -1);
    
    Opal.def(self, '$respond_to?', $Kernel_respond_to$ques$53 = function(name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      
      var body = self['$' + name];

      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }

      if (self['$respond_to_missing?'].$$pristine === true) {
        return false;
      } else {
        return self['$respond_to_missing?'](name, include_all);
      }
    ;
    }, $Kernel_respond_to$ques$53.$$arity = -2);
    
    Opal.def(self, '$respond_to_missing?', $Kernel_respond_to_missing$ques$54 = function(method_name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return false;
    }, $Kernel_respond_to_missing$ques$54.$$arity = -2);
    $$($nesting, 'Opal').$pristine(self, "respond_to?", "respond_to_missing?");
    
    Opal.def(self, '$require', $Kernel_require$55 = function $$require(file) {
      var self = this;

      
      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
      return Opal.require(file);
    }, $Kernel_require$55.$$arity = 1);
    
    Opal.def(self, '$require_relative', $Kernel_require_relative$56 = function $$require_relative(file) {
      var self = this;

      
      $$($nesting, 'Opal')['$try_convert!'](file, $$($nesting, 'String'), "to_str");
      file = $$($nesting, 'File').$expand_path($$($nesting, 'File').$join(Opal.current_file, "..", file));
      return Opal.require(file);
    }, $Kernel_require_relative$56.$$arity = 1);
    
    Opal.def(self, '$require_tree', $Kernel_require_tree$57 = function $$require_tree(path) {
      var self = this;

      
      var result = [];

      path = $$($nesting, 'File').$expand_path(path)
      path = Opal.normalize(path);
      if (path === '.') path = '';
      for (var name in Opal.modules) {
        if ((name)['$start_with?'](path)) {
          result.push([name, Opal.require(name)]);
        }
      }

      return result;
    
    }, $Kernel_require_tree$57.$$arity = 1);
    Opal.alias(self, "send", "__send__");
    Opal.alias(self, "public_send", "__send__");
    
    Opal.def(self, '$singleton_class', $Kernel_singleton_class$58 = function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    }, $Kernel_singleton_class$58.$$arity = 0);
    
    Opal.def(self, '$sleep', $Kernel_sleep$59 = function $$sleep(seconds) {
      var self = this;

      
      
      if (seconds == null) {
        seconds = nil;
      };
      
      if (seconds === nil) {
        self.$raise($$($nesting, 'TypeError'), "can't convert NilClass into time interval")
      }
      if (!seconds.$$is_number) {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (seconds.$class()) + " into time interval")
      }
      if (seconds < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "time interval must be positive")
      }
      var get_time = Opal.global.performance ?
        function() {return performance.now()} :
        function() {return new Date()}

      var t = get_time();
      while (get_time() - t <= seconds * 1000);
      return Math.round(seconds);
    ;
    }, $Kernel_sleep$59.$$arity = -1);
    
    Opal.def(self, '$srand', $Kernel_srand$60 = function $$srand(seed) {
      var self = this;

      
      
      if (seed == null) {
        seed = $$($nesting, 'Random').$new_seed();
      };
      return $$($nesting, 'Random').$srand(seed);
    }, $Kernel_srand$60.$$arity = -1);
    
    Opal.def(self, '$String', $Kernel_String$61 = function $$String(str) {
      var self = this, $ret_or_6 = nil;

      if ($truthy(($ret_or_6 = $$($nesting, 'Opal')['$coerce_to?'](str, $$($nesting, 'String'), "to_str")))) {
        return $ret_or_6
      } else {
        return $$($nesting, 'Opal')['$coerce_to!'](str, $$($nesting, 'String'), "to_s")
      }
    }, $Kernel_String$61.$$arity = 1);
    
    Opal.def(self, '$tap', $Kernel_tap$62 = function $$tap() {
      var $iter = $Kernel_tap$62.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_tap$62.$$p = null;
      
      
      if ($iter) $Kernel_tap$62.$$p = null;;
      Opal.yield1(block, self);
      return self;
    }, $Kernel_tap$62.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Kernel_to_proc$63 = function $$to_proc() {
      var self = this;

      return self
    }, $Kernel_to_proc$63.$$arity = 0);
    
    Opal.def(self, '$to_s', $Kernel_to_s$64 = function $$to_s() {
      var self = this;

      return "" + "#<" + (self.$class()) + ":0x" + (self.$__id__().$to_s(16)) + ">"
    }, $Kernel_to_s$64.$$arity = 0);
    
    Opal.def(self, '$catch', $Kernel_catch$65 = function(sym) {
      var $iter = $Kernel_catch$65.$$p, $yield = $iter || nil, self = this, e = nil;

      if ($iter) $Kernel_catch$65.$$p = null;
      try {
        return Opal.yieldX($yield, []);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'UncaughtThrowError')])) {(e = $err)
          try {
            
            if (e.$sym()['$=='](sym)) {
              return e.$arg()};
            return self.$raise();
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Kernel_catch$65.$$arity = 1);
    
    Opal.def(self, '$throw', $Kernel_throw$66 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.$raise($$($nesting, 'UncaughtThrowError'), args);
    }, $Kernel_throw$66.$$arity = -1);
    
    Opal.def(self, '$open', $Kernel_open$67 = function $$open($a) {
      var $iter = $Kernel_open$67.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_open$67.$$p = null;
      
      
      if ($iter) $Kernel_open$67.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send($$($nesting, 'File'), 'open', Opal.to_a(args), block.$to_proc());
    }, $Kernel_open$67.$$arity = -1);
    
    Opal.def(self, '$yield_self', $Kernel_yield_self$68 = function $$yield_self() {
      var $$69, $iter = $Kernel_yield_self$68.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Kernel_yield_self$68.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["yield_self"], ($$69 = function(){var self = $$69.$$s == null ? this : $$69.$$s;

        return 1}, $$69.$$s = self, $$69.$$arity = 0, $$69))
      };
      return Opal.yield1($yield, self);;
    }, $Kernel_yield_self$68.$$arity = 0);
    Opal.alias(self, "then", "yield_self");
    return $$($nesting, 'Opal').$pristine(self, "method_missing");
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting);

    return self.$include($$($nesting, 'Kernel'))
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/error"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $module = Opal.module, $send2 = Opal.send2, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new', '$clone', '$to_s', '$empty?', '$class', '$raise', '$+', '$attr_reader', '$[]', '$>', '$length', '$inspect']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Exception');

    var $nesting = [self].concat($parent_nesting), $Exception_new$1, $Exception_exception$2, $Exception_initialize$3, $Exception_backtrace$4, $Exception_exception$5, $Exception_message$6, $Exception_inspect$7, $Exception_set_backtrace$8, $Exception_to_s$9;

    self.$$prototype.message = nil;
    
    var stack_trace_limit;
    Opal.defs(self, '$new', $Exception_new$1 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var message   = (args.length > 0) ? args[0] : nil;
      var error     = new self.$$constructor(message);
      error.name    = self.$$name;
      error.message = message;
      Opal.send(error, error.$initialize, args);

      // Error.captureStackTrace() will use .name and .toString to build the
      // first line of the stack trace so it must be called after the error
      // has been initialized.
      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
        // Passing Kernel.raise will cut the stack trace from that point above
        Error.captureStackTrace(error, stack_trace_limit);
      }

      return error;
    ;
    }, $Exception_new$1.$$arity = -1);
    stack_trace_limit = self.$new;
    Opal.defs(self, '$exception', $Exception_exception$2 = function $$exception($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self, 'new', Opal.to_a(args));
    }, $Exception_exception$2.$$arity = -1);
    
    Opal.def(self, '$initialize', $Exception_initialize$3 = function $$initialize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.message = (args.length > 0) ? args[0] : nil;;
    }, $Exception_initialize$3.$$arity = -1);
    
    Opal.def(self, '$backtrace', $Exception_backtrace$4 = function $$backtrace() {
      var self = this;

      
      if (self.backtrace) {
        // nil is a valid backtrace
        return self.backtrace;
      }

      var backtrace = self.stack;

      if (typeof(backtrace) === 'string') {
        return backtrace.split("\n").slice(0, 15);
      }
      else if (backtrace) {
        return backtrace.slice(0, 15);
      }

      return [];
    
    }, $Exception_backtrace$4.$$arity = 0);
    
    Opal.def(self, '$exception', $Exception_exception$5 = function $$exception(str) {
      var self = this;

      
      
      if (str == null) {
        str = nil;
      };
      
      if (str === nil || self === str) {
        return self;
      }

      var cloned = self.$clone();
      cloned.message = str;
      cloned.stack = self.stack;
      return cloned;
    ;
    }, $Exception_exception$5.$$arity = -1);
    
    Opal.def(self, '$message', $Exception_message$6 = function $$message() {
      var self = this;

      return self.$to_s()
    }, $Exception_message$6.$$arity = 0);
    
    Opal.def(self, '$inspect', $Exception_inspect$7 = function $$inspect() {
      var self = this, as_str = nil;

      
      as_str = self.$to_s();
      if ($truthy(as_str['$empty?']())) {
        return self.$class().$to_s()
      } else {
        return "" + "#<" + (self.$class().$to_s()) + ": " + (self.$to_s()) + ">"
      };
    }, $Exception_inspect$7.$$arity = 0);
    
    Opal.def(self, '$set_backtrace', $Exception_set_backtrace$8 = function $$set_backtrace(backtrace) {
      var self = this;

      
      var valid = true, i, ii;

      if (backtrace === nil) {
        self.backtrace = nil;
        self.stack = '';
      } else if (backtrace.$$is_string) {
        self.backtrace = [backtrace];
        self.stack = backtrace;
      } else {
        if (backtrace.$$is_array) {
          for (i = 0, ii = backtrace.length; i < ii; i++) {
            if (!backtrace[i].$$is_string) {
              valid = false;
              break;
            }
          }
        } else {
          valid = false;
        }

        if (valid === false) {
          self.$raise($$($nesting, 'TypeError'), "backtrace must be Array of String")
        }

        self.backtrace = backtrace;
        self.stack = backtrace.join('\n');
      }

      return backtrace;
    
    }, $Exception_set_backtrace$8.$$arity = 1);
    return (Opal.def(self, '$to_s', $Exception_to_s$9 = function $$to_s() {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = (function() {if ($truthy(($ret_or_2 = self.message))) {
        return self.message.$to_s()
      } else {
        return $ret_or_2
      }; return nil; })()))) {
        return $ret_or_1
      } else {
        return self.$class().$to_s()
      }
    }, $Exception_to_s$9.$$arity = 0), nil) && 'to_s';
  })($nesting[0], Error, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ScriptError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SyntaxError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'LoadError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NotImplementedError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemExit');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMemoryError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SignalException');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Interrupt');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SecurityError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StandardError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'EncodingError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ZeroDivisionError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NameError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMethodError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'NameError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RuntimeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FrozenError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'RuntimeError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'LocalJumpError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'TypeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ArgumentError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IndexError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StopIteration');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'KeyError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RangeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FloatDomainError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'RangeError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IOError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemCallError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Errno');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EINVAL');

      var $nesting = [self].concat($parent_nesting), $EINVAL_new$10;

      return (Opal.defs(self, '$new', $EINVAL_new$10 = function(name) {
        var $iter = $EINVAL_new$10.$$p, $yield = $iter || nil, self = this, message = nil;

        if ($iter) $EINVAL_new$10.$$p = null;
        
        
        if (name == null) {
          name = nil;
        };
        message = "Invalid argument";
        if ($truthy(name)) {
          message = $rb_plus(message, "" + " - " + (name))};
        return $send2(self, Opal.find_super_dispatcher(self, 'new', $EINVAL_new$10, false, true), 'new', [message], null);
      }, $EINVAL_new$10.$$arity = -1), nil) && 'new'
    })($nesting[0], $$($nesting, 'SystemCallError'), $nesting)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'UncaughtThrowError');

    var $nesting = [self].concat($parent_nesting), $UncaughtThrowError_initialize$11;

    self.$$prototype.sym = nil;
    
    self.$attr_reader("sym", "arg");
    return (Opal.def(self, '$initialize', $UncaughtThrowError_initialize$11 = function $$initialize(args) {
      var $iter = $UncaughtThrowError_initialize$11.$$p, $yield = $iter || nil, self = this;

      if ($iter) $UncaughtThrowError_initialize$11.$$p = null;
      
      self.sym = args['$[]'](0);
      if ($truthy($rb_gt(args.$length(), 1))) {
        self.arg = args['$[]'](1)};
      return $send2(self, Opal.find_super_dispatcher(self, 'initialize', $UncaughtThrowError_initialize$11, false, true), 'initialize', ["" + "uncaught throw " + (self.sym.$inspect())], null);
    }, $UncaughtThrowError_initialize$11.$$arity = 1), nil) && 'initialize';
  })($nesting[0], $$($nesting, 'ArgumentError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NameError');

    var $nesting = [self].concat($parent_nesting), $NameError_initialize$12;

    
    self.$attr_reader("name");
    return (Opal.def(self, '$initialize', $NameError_initialize$12 = function $$initialize(message, name) {
      var $iter = $NameError_initialize$12.$$p, $yield = $iter || nil, self = this;

      if ($iter) $NameError_initialize$12.$$p = null;
      
      
      if (name == null) {
        name = nil;
      };
      $send2(self, Opal.find_super_dispatcher(self, 'initialize', $NameError_initialize$12, false, true), 'initialize', [message], null);
      return (self.name = name);
    }, $NameError_initialize$12.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMethodError');

    var $nesting = [self].concat($parent_nesting), $NoMethodError_initialize$13;

    
    self.$attr_reader("args");
    return (Opal.def(self, '$initialize', $NoMethodError_initialize$13 = function $$initialize(message, name, args) {
      var $iter = $NoMethodError_initialize$13.$$p, $yield = $iter || nil, self = this;

      if ($iter) $NoMethodError_initialize$13.$$p = null;
      
      
      if (name == null) {
        name = nil;
      };
      
      if (args == null) {
        args = [];
      };
      $send2(self, Opal.find_super_dispatcher(self, 'initialize', $NoMethodError_initialize$13, false, true), 'initialize', [message, name], null);
      return (self.args = args);
    }, $NoMethodError_initialize$13.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StopIteration');

    var $nesting = [self].concat($parent_nesting);

    return self.$attr_reader("result")
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'KeyError');

    var $nesting = [self].concat($parent_nesting), $KeyError_initialize$14, $KeyError_receiver$15, $KeyError_key$16;

    self.$$prototype.receiver = self.$$prototype.key = nil;
    
    
    Opal.def(self, '$initialize', $KeyError_initialize$14 = function $$initialize(message, $kwargs) {
      var receiver, key, $iter = $KeyError_initialize$14.$$p, $yield = $iter || nil, self = this;

      if ($iter) $KeyError_initialize$14.$$p = null;
      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      receiver = $kwargs.$$smap["receiver"];
      if (receiver == null) {
        receiver = nil
      };
      
      key = $kwargs.$$smap["key"];
      if (key == null) {
        key = nil
      };
      $send2(self, Opal.find_super_dispatcher(self, 'initialize', $KeyError_initialize$14, false, true), 'initialize', [message], null);
      self.receiver = receiver;
      return (self.key = key);
    }, $KeyError_initialize$14.$$arity = -2);
    
    Opal.def(self, '$receiver', $KeyError_receiver$15 = function $$receiver() {
      var self = this, $ret_or_3 = nil;

      if ($truthy(($ret_or_3 = self.receiver))) {
        return $ret_or_3
      } else {
        return self.$raise($$($nesting, 'ArgumentError'), "no receiver is available")
      }
    }, $KeyError_receiver$15.$$arity = 0);
    return (Opal.def(self, '$key', $KeyError_key$16 = function $$key() {
      var self = this, $ret_or_4 = nil;

      if ($truthy(($ret_or_4 = self.key))) {
        return $ret_or_4
      } else {
        return self.$raise($$($nesting, 'ArgumentError'), "no key is available")
      }
    }, $KeyError_key$16.$$arity = 0), nil) && 'key';
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'JS');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Error');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/constants"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  
  Opal.const_set($nesting[0], 'RUBY_PLATFORM', "opal");
  Opal.const_set($nesting[0], 'RUBY_ENGINE', "opal");
  Opal.const_set($nesting[0], 'RUBY_VERSION', "3.0.2");
  Opal.const_set($nesting[0], 'RUBY_ENGINE_VERSION', "1.2.0");
  Opal.const_set($nesting[0], 'RUBY_RELEASE_DATE', "2021-07-28");
  Opal.const_set($nesting[0], 'RUBY_PATCHLEVEL', 0);
  Opal.const_set($nesting[0], 'RUBY_REVISION', "0");
  Opal.const_set($nesting[0], 'RUBY_COPYRIGHT', "opal - Copyright (C) 2013-2021 Adam Beynon and the Opal contributors");
  return Opal.const_set($nesting[0], 'RUBY_DESCRIPTION', "" + "opal " + ($$($nesting, 'RUBY_ENGINE_VERSION')) + " (" + ($$($nesting, 'RUBY_RELEASE_DATE')) + " revision " + ($$($nesting, 'RUBY_REVISION')) + ")");
};

/* Generated by Opal 1.2.0 */
Opal.modules["opal/base"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$require']);
  
  self.$require("corelib/runtime");
  self.$require("corelib/helpers");
  self.$require("corelib/module");
  self.$require("corelib/class");
  self.$require("corelib/basic_object");
  self.$require("corelib/kernel");
  self.$require("corelib/error");
  return self.$require("corelib/constants");
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/nil"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$name', '$new', '$>', '$length', '$Rational']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting), $NilClass_$excl$2, $NilClass_$$3, $NilClass_$$4, $NilClass_$$5, $NilClass_$eq_eq$6, $NilClass_dup$7, $NilClass_clone$8, $NilClass_inspect$9, $NilClass_nil$ques$10, $NilClass_singleton_class$11, $NilClass_to_a$12, $NilClass_to_h$13, $NilClass_to_i$14, $NilClass_to_s$15, $NilClass_to_c$16, $NilClass_rationalize$17, $NilClass_to_r$18, $NilClass_instance_variables$19;

    
    self.$$prototype.$$meta = self;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$!', $NilClass_$excl$2 = function() {
      var self = this;

      return true
    }, $NilClass_$excl$2.$$arity = 0);
    
    Opal.def(self, '$&', $NilClass_$$3 = function(other) {
      var self = this;

      return false
    }, $NilClass_$$3.$$arity = 1);
    
    Opal.def(self, '$|', $NilClass_$$4 = function(other) {
      var self = this;

      return other !== false && other !== nil;
    }, $NilClass_$$4.$$arity = 1);
    
    Opal.def(self, '$^', $NilClass_$$5 = function(other) {
      var self = this;

      return other !== false && other !== nil;
    }, $NilClass_$$5.$$arity = 1);
    
    Opal.def(self, '$==', $NilClass_$eq_eq$6 = function(other) {
      var self = this;

      return other === nil;
    }, $NilClass_$eq_eq$6.$$arity = 1);
    
    Opal.def(self, '$dup', $NilClass_dup$7 = function $$dup() {
      var self = this;

      return nil
    }, $NilClass_dup$7.$$arity = 0);
    
    Opal.def(self, '$clone', $NilClass_clone$8 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return nil;
    }, $NilClass_clone$8.$$arity = -1);
    
    Opal.def(self, '$inspect', $NilClass_inspect$9 = function $$inspect() {
      var self = this;

      return "nil"
    }, $NilClass_inspect$9.$$arity = 0);
    
    Opal.def(self, '$nil?', $NilClass_nil$ques$10 = function() {
      var self = this;

      return true
    }, $NilClass_nil$ques$10.$$arity = 0);
    
    Opal.def(self, '$singleton_class', $NilClass_singleton_class$11 = function $$singleton_class() {
      var self = this;

      return $$($nesting, 'NilClass')
    }, $NilClass_singleton_class$11.$$arity = 0);
    
    Opal.def(self, '$to_a', $NilClass_to_a$12 = function $$to_a() {
      var self = this;

      return []
    }, $NilClass_to_a$12.$$arity = 0);
    
    Opal.def(self, '$to_h', $NilClass_to_h$13 = function $$to_h() {
      var self = this;

      return Opal.hash();
    }, $NilClass_to_h$13.$$arity = 0);
    
    Opal.def(self, '$to_i', $NilClass_to_i$14 = function $$to_i() {
      var self = this;

      return 0
    }, $NilClass_to_i$14.$$arity = 0);
    Opal.alias(self, "to_f", "to_i");
    
    Opal.def(self, '$to_s', $NilClass_to_s$15 = function $$to_s() {
      var self = this;

      return ""
    }, $NilClass_to_s$15.$$arity = 0);
    
    Opal.def(self, '$to_c', $NilClass_to_c$16 = function $$to_c() {
      var self = this;

      return $$($nesting, 'Complex').$new(0, 0)
    }, $NilClass_to_c$16.$$arity = 0);
    
    Opal.def(self, '$rationalize', $NilClass_rationalize$17 = function $$rationalize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy($rb_gt(args.$length(), 1))) {
        self.$raise($$($nesting, 'ArgumentError'))};
      return self.$Rational(0, 1);
    }, $NilClass_rationalize$17.$$arity = -1);
    
    Opal.def(self, '$to_r', $NilClass_to_r$18 = function $$to_r() {
      var self = this;

      return self.$Rational(0, 1)
    }, $NilClass_to_r$18.$$arity = 0);
    return (Opal.def(self, '$instance_variables', $NilClass_instance_variables$19 = function $$instance_variables() {
      var self = this;

      return []
    }, $NilClass_instance_variables$19.$$arity = 0), nil) && 'instance_variables';
  })($nesting[0], null, $nesting);
  return Opal.const_set($nesting[0], 'NIL', nil);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/boolean"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2;

  Opal.add_stubs(['$raise', '$name']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting), $Boolean___id__$2, $Boolean_$excl$3, $Boolean_$$4, $Boolean_$$5, $Boolean_$$6, $Boolean_$eq_eq$7, $Boolean_singleton_class$8, $Boolean_to_s$9, $Boolean_dup$10, $Boolean_clone$11;

    
    Opal.defineProperty(self.$$prototype, '$$is_boolean', true);
    Opal.defineProperty(self.$$prototype, '$$meta', self);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$__id__', $Boolean___id__$2 = function $$__id__() {
      var self = this;

      return self.valueOf() ? 2 : 0;
    }, $Boolean___id__$2.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$!', $Boolean_$excl$3 = function() {
      var self = this;

      return self != true;
    }, $Boolean_$excl$3.$$arity = 0);
    
    Opal.def(self, '$&', $Boolean_$$4 = function(other) {
      var self = this;

      return (self == true) ? (other !== false && other !== nil) : false;
    }, $Boolean_$$4.$$arity = 1);
    
    Opal.def(self, '$|', $Boolean_$$5 = function(other) {
      var self = this;

      return (self == true) ? true : (other !== false && other !== nil);
    }, $Boolean_$$5.$$arity = 1);
    
    Opal.def(self, '$^', $Boolean_$$6 = function(other) {
      var self = this;

      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil);
    }, $Boolean_$$6.$$arity = 1);
    
    Opal.def(self, '$==', $Boolean_$eq_eq$7 = function(other) {
      var self = this;

      return (self == true) === other.valueOf();
    }, $Boolean_$eq_eq$7.$$arity = 1);
    Opal.alias(self, "equal?", "==");
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$singleton_class', $Boolean_singleton_class$8 = function $$singleton_class() {
      var self = this;

      return $$($nesting, 'Boolean')
    }, $Boolean_singleton_class$8.$$arity = 0);
    
    Opal.def(self, '$to_s', $Boolean_to_s$9 = function $$to_s() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, $Boolean_to_s$9.$$arity = 0);
    
    Opal.def(self, '$dup', $Boolean_dup$10 = function $$dup() {
      var self = this;

      return self
    }, $Boolean_dup$10.$$arity = 0);
    return (Opal.def(self, '$clone', $Boolean_clone$11 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return self;
    }, $Boolean_clone$11.$$arity = -1), nil) && 'clone';
  })($nesting[0], Boolean, $nesting);
  Opal.const_set($nesting[0], 'TrueClass', $$($nesting, 'Boolean'));
  Opal.const_set($nesting[0], 'FalseClass', $$($nesting, 'Boolean'));
  Opal.const_set($nesting[0], 'TRUE', true);
  return Opal.const_set($nesting[0], 'FALSE', false);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/comparable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $falsy = Opal.falsy, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$>', '$<', '$===', '$raise', '$class', '$<=>', '$equal?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Comparable');

    var $nesting = [self].concat($parent_nesting), $Comparable_$eq_eq$1, $Comparable_$gt$2, $Comparable_$gt_eq$3, $Comparable_$lt$4, $Comparable_$lt_eq$5, $Comparable_between$ques$6, $Comparable_clamp$7, $case = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (function() {$case = rhs;
    if (nil['$===']($case) || true['$===']($case) || false['$===']($case) || $$($nesting, 'Integer')['$===']($case) || $$($nesting, 'Float')['$===']($case)) {return class_name = rhs.$inspect();}
    else {return class_name = rhs.$$class;}})()
      self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = (lhs)['$<=>'](rhs);
      if ($falsy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
  ;
    
    Opal.def(self, '$==', $Comparable_$eq_eq$1 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true};
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        return false
      };
      return normalize(cmp) == 0;;
    }, $Comparable_$eq_eq$1.$$arity = 1);
    
    Opal.def(self, '$>', $Comparable_$gt$2 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) > 0;
    }, $Comparable_$gt$2.$$arity = 1);
    
    Opal.def(self, '$>=', $Comparable_$gt_eq$3 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) >= 0;
    }, $Comparable_$gt_eq$3.$$arity = 1);
    
    Opal.def(self, '$<', $Comparable_$lt$4 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) < 0;
    }, $Comparable_$lt$4.$$arity = 1);
    
    Opal.def(self, '$<=', $Comparable_$lt_eq$5 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) <= 0;
    }, $Comparable_$lt_eq$5.$$arity = 1);
    
    Opal.def(self, '$between?', $Comparable_between$ques$6 = function(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false};
      if ($rb_gt(self, max)) {
        return false};
      return true;
    }, $Comparable_between$ques$6.$$arity = 2);
    return (Opal.def(self, '$clamp', $Comparable_clamp$7 = function $$clamp(min, max) {
      var self = this;

      
      
      if (max == null) {
        max = nil;
      };
      
      var c, excl;

      if (max === nil) {
        // We are dealing with a new Ruby 2.7 behaviour that we are able to
        // provide a single Range argument instead of 2 Comparables.

        if (!Opal.is_a(min, Opal.Range)) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (min.$class()) + " (expected Range)")
        }

        excl = min.excl;
        max = min.end;
        min = min.begin;

        if (max !== nil && excl) {
          self.$raise($$($nesting, 'ArgumentError'), "cannot clamp with an exclusive range")
        }
      }

      if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
        self.$raise($$($nesting, 'ArgumentError'), "min argument must be smaller than max argument")
      }

      if (min !== nil) {
        c = cmp_or_fail(self, min);

        if (c == 0) return self;
        if (c < 0) return min;
      }

      if (max !== nil) {
        c = cmp_or_fail(self, max);

        if (c > 0) return max;
      }

      return self;
    ;
    }, $Comparable_clamp$7.$$arity = -2), nil) && 'clamp';
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/regexp"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send2 = Opal.send2, $truthy = Opal.truthy, $gvars = Opal.gvars, $send = Opal.send;

  Opal.add_stubs(['$nil?', '$[]', '$raise', '$escape', '$options', '$to_str', '$new', '$join', '$coerce_to!', '$!', '$match', '$coerce_to?', '$begin', '$=~', '$attr_reader', '$===', '$inspect', '$to_a']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RegexpError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $Regexp_$eq_eq$6, $Regexp_$eq_eq_eq$7, $Regexp_$eq_tilde$8, $Regexp_inspect$9, $Regexp_match$10, $Regexp_match$ques$11, $Regexp_$$12, $Regexp_source$13, $Regexp_options$14, $Regexp_casefold$ques$15;

    
    Opal.const_set($nesting[0], 'IGNORECASE', 1);
    Opal.const_set($nesting[0], 'EXTENDED', 2);
    Opal.const_set($nesting[0], 'MULTILINE', 4);
    Opal.defineProperty(self.$$prototype, '$$is_regexp', true);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1, $escape$2, $last_match$3, $union$4, $new$5;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var $iter = $allocate$1.$$p, $yield = $iter || nil, self = this, allocated = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $allocate$1.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        allocated = $send2(self, Opal.find_super_dispatcher(self, 'allocate', $allocate$1, false, true), 'allocate', $zuper, $iter);
        allocated.uninitialized = true;
        return allocated;
      }, $allocate$1.$$arity = 0);
      
      Opal.def(self, '$escape', $escape$2 = function $$escape(string) {
        var self = this;

        return Opal.escape_regexp(string);
      }, $escape$2.$$arity = 1);
      
      Opal.def(self, '$last_match', $last_match$3 = function $$last_match(n) {
        var self = this;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        
        
        if (n == null) {
          n = nil;
        };
        if ($truthy(n['$nil?']())) {
          return $gvars["~"]
        } else {
          return $gvars["~"]['$[]'](n)
        };
      }, $last_match$3.$$arity = -1);
      Opal.alias(self, "quote", "escape");
      
      Opal.def(self, '$union', $union$4 = function $$union($a) {
        var $post_args, parts, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        parts = $post_args;;
        
        var is_first_part_array, quoted_validated, part, options, each_part_options;
        if (parts.length == 0) {
          return /(?!)/;
        }
        // return fast if there's only one element
        if (parts.length == 1 && parts[0].$$is_regexp) {
          return parts[0];
        }
        // cover the 2 arrays passed as arguments case
        is_first_part_array = parts[0].$$is_array;
        if (parts.length > 1 && is_first_part_array) {
          self.$raise($$($nesting, 'TypeError'), "no implicit conversion of Array into String")
        }
        // deal with splat issues (related to https://github.com/opal/opal/issues/858)
        if (is_first_part_array) {
          parts = parts[0];
        }
        options = undefined;
        quoted_validated = [];
        for (var i=0; i < parts.length; i++) {
          part = parts[i];
          if (part.$$is_string) {
            quoted_validated.push(self.$escape(part));
          }
          else if (part.$$is_regexp) {
            each_part_options = (part).$options();
            if (options != undefined && options != each_part_options) {
              self.$raise($$($nesting, 'TypeError'), "All expressions must use the same options")
            }
            options = each_part_options;
            quoted_validated.push('('+part.source+')');
          }
          else {
            quoted_validated.push(self.$escape((part).$to_str()));
          }
        }
      ;
        return self.$new((quoted_validated).$join("|"), options);
      }, $union$4.$$arity = -1);
      
      Opal.def(self, '$new', $new$5 = function(regexp, options) {
        var self = this;

        
        ;
        
        if (regexp.$$is_regexp) {
          return new RegExp(regexp);
        }

        regexp = $$($nesting, 'Opal')['$coerce_to!'](regexp, $$($nesting, 'String'), "to_str");

        if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
          self.$raise($$($nesting, 'RegexpError'), "" + "too short escape sequence: /" + (regexp) + "/")
        }

        if (options === undefined || options['$!']()) {
          return new RegExp(regexp);
        }

        if (options.$$is_number) {
          var temp = '';
          if ($$($nesting, 'IGNORECASE') & options) { temp += 'i'; }
          if ($$($nesting, 'MULTILINE')  & options) { temp += 'm'; }
          options = temp;
        }
        else {
          options = 'i';
        }

        return new RegExp(regexp, options);
      ;
      }, $new$5.$$arity = -2);
      return Opal.alias(self, "compile", "new");
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$==', $Regexp_$eq_eq$6 = function(other) {
      var self = this;

      return other instanceof RegExp && self.toString() === other.toString();
    }, $Regexp_$eq_eq$6.$$arity = 1);
    
    Opal.def(self, '$===', $Regexp_$eq_eq_eq$7 = function(string) {
      var self = this;

      return self.$match($$($nesting, 'Opal')['$coerce_to?'](string, $$($nesting, 'String'), "to_str")) !== nil
    }, $Regexp_$eq_eq_eq$7.$$arity = 1);
    
    Opal.def(self, '$=~', $Regexp_$eq_tilde$8 = function(string) {
      var self = this, $ret_or_1 = nil;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($truthy(($ret_or_1 = self.$match(string)))) {
        return $gvars["~"].$begin(0)
      } else {
        return $ret_or_1
      }
    }, $Regexp_$eq_tilde$8.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$inspect', $Regexp_inspect$9 = function $$inspect() {
      var self = this;

      
      var regexp_format = /^\/(.*)\/([^\/]*)$/;
      var value = self.toString();
      var matches = regexp_format.exec(value);
      if (matches) {
        var regexp_pattern = matches[1];
        var regexp_flags = matches[2];
        var chars = regexp_pattern.split('');
        var chars_length = chars.length;
        var char_escaped = false;
        var regexp_pattern_escaped = '';
        for (var i = 0; i < chars_length; i++) {
          var current_char = chars[i];
          if (!char_escaped && current_char == '/') {
            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\');
          }
          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
          if (current_char == '\\') {
            if (char_escaped) {
              // does not over escape
              char_escaped = false;
            } else {
              char_escaped = true;
            }
          } else {
            char_escaped = false;
          }
        }
        return '/' + regexp_pattern_escaped + '/' + regexp_flags;
      } else {
        return value;
      }
    
    }, $Regexp_inspect$9.$$arity = 0);
    
    Opal.def(self, '$match', $Regexp_match$10 = function $$match(string, pos) {
      var $iter = $Regexp_match$10.$$p, block = $iter || nil, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($iter) $Regexp_match$10.$$p = null;
      
      
      if ($iter) $Regexp_match$10.$$p = null;;
      ;
      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        if (string === nil) return ($gvars["~"] = nil);
        var m = self.exec($coerce_to(string, $$($nesting, 'String'), 'to_str'));
        if (m) {
          ($gvars["~"] = $$($nesting, 'MatchData').$new(self, m));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        } else {
          return ($gvars["~"] = nil);
        }
      }

      pos = $coerce_to(pos, $$($nesting, 'Integer'), 'to_int');

      if (string === nil) {
        return ($gvars["~"] = nil);
      }

      string = $coerce_to(string, $$($nesting, 'String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return ($gvars["~"] = nil);
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      while (true) {
        md = re.exec(string);
        if (md === null) {
          return ($gvars["~"] = nil);
        }
        if (md.index >= pos) {
          ($gvars["~"] = $$($nesting, 'MatchData').$new(re, md));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        }
        re.lastIndex = md.index + 1;
      }
    ;
    }, $Regexp_match$10.$$arity = -2);
    
    Opal.def(self, '$match?', $Regexp_match$ques$11 = function(string, pos) {
      var self = this;

      
      ;
      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        return string === nil ? false : self.test($coerce_to(string, $$($nesting, 'String'), 'to_str'));
      }

      pos = $coerce_to(pos, $$($nesting, 'Integer'), 'to_int');

      if (string === nil) {
        return false;
      }

      string = $coerce_to(string, $$($nesting, 'String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return false;
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      md = re.exec(string);
      if (md === null || md.index < pos) {
        return false;
      } else {
        return true;
      }
    ;
    }, $Regexp_match$ques$11.$$arity = -2);
    
    Opal.def(self, '$~', $Regexp_$$12 = function() {
      var self = this;
      if ($gvars._ == null) $gvars._ = nil;

      return self['$=~']($gvars._)
    }, $Regexp_$$12.$$arity = 0);
    
    Opal.def(self, '$source', $Regexp_source$13 = function $$source() {
      var self = this;

      return self.source;
    }, $Regexp_source$13.$$arity = 0);
    
    Opal.def(self, '$options', $Regexp_options$14 = function $$options() {
      var self = this;

      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }
      var result = 0;
      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
      if (self.multiline) {
        result |= $$($nesting, 'MULTILINE');
      }
      if (self.ignoreCase) {
        result |= $$($nesting, 'IGNORECASE');
      }
      return result;
    
    }, $Regexp_options$14.$$arity = 0);
    
    Opal.def(self, '$casefold?', $Regexp_casefold$ques$15 = function() {
      var self = this;

      return self.ignoreCase;
    }, $Regexp_casefold$ques$15.$$arity = 0);
    return Opal.alias(self, "to_s", "source");
  })($nesting[0], RegExp, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $MatchData_initialize$16, $MatchData_$$$17, $MatchData_offset$18, $MatchData_$eq_eq$19, $MatchData_begin$20, $MatchData_end$21, $MatchData_captures$22, $MatchData_inspect$23, $MatchData_length$24, $MatchData_to_a$25, $MatchData_to_s$26, $MatchData_values_at$27;

    self.$$prototype.matches = nil;
    
    self.$attr_reader("post_match", "pre_match", "regexp", "string");
    
    Opal.def(self, '$initialize', $MatchData_initialize$16 = function $$initialize(regexp, match_groups) {
      var self = this;

      
      $gvars["~"] = self;
      self.regexp = regexp;
      self.begin = match_groups.index;
      self.string = match_groups.input;
      self.pre_match = match_groups.input.slice(0, match_groups.index);
      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
      self.matches = [];
      
      for (var i = 0, length = match_groups.length; i < length; i++) {
        var group = match_groups[i];

        if (group == null) {
          self.matches.push(nil);
        }
        else {
          self.matches.push(group);
        }
      }
    ;
    }, $MatchData_initialize$16.$$arity = 2);
    
    Opal.def(self, '$[]', $MatchData_$$$17 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self.matches, '[]', Opal.to_a(args));
    }, $MatchData_$$$17.$$arity = -1);
    
    Opal.def(self, '$offset', $MatchData_offset$18 = function $$offset(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#offset only supports 0th element")
      }
      return [self.begin, self.begin + self.matches[n].length];
    
    }, $MatchData_offset$18.$$arity = 1);
    
    Opal.def(self, '$==', $MatchData_$eq_eq$19 = function(other) {
      var self = this, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil, $ret_or_5 = nil;

      
      if ($truthy($$($nesting, 'MatchData')['$==='](other))) {
      } else {
        return false
      };
      if ($truthy(($ret_or_2 = (function() {if ($truthy(($ret_or_3 = (function() {if ($truthy(($ret_or_4 = (function() {if ($truthy(($ret_or_5 = self.string == other.string))) {
        return self.regexp.toString() == other.regexp.toString();
      } else {
        return $ret_or_5
      }; return nil; })()))) {
        return self.pre_match == other.pre_match;
      } else {
        return $ret_or_4
      }; return nil; })()))) {
        return self.post_match == other.post_match;
      } else {
        return $ret_or_3
      }; return nil; })()))) {
        return self.begin == other.begin;
      } else {
        return $ret_or_2
      };
    }, $MatchData_$eq_eq$19.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$begin', $MatchData_begin$20 = function $$begin(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#begin only supports 0th element")
      }
      return self.begin;
    
    }, $MatchData_begin$20.$$arity = 1);
    
    Opal.def(self, '$end', $MatchData_end$21 = function $$end(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#end only supports 0th element")
      }
      return self.begin + self.matches[n].length;
    
    }, $MatchData_end$21.$$arity = 1);
    
    Opal.def(self, '$captures', $MatchData_captures$22 = function $$captures() {
      var self = this;

      return self.matches.slice(1)
    }, $MatchData_captures$22.$$arity = 0);
    
    Opal.def(self, '$inspect', $MatchData_inspect$23 = function $$inspect() {
      var self = this;

      
      var str = "#<MatchData " + (self.matches[0]).$inspect();

      for (var i = 1, length = self.matches.length; i < length; i++) {
        str += " " + i + ":" + (self.matches[i]).$inspect();
      }

      return str + ">";
    
    }, $MatchData_inspect$23.$$arity = 0);
    
    Opal.def(self, '$length', $MatchData_length$24 = function $$length() {
      var self = this;

      return self.matches.length
    }, $MatchData_length$24.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$to_a', $MatchData_to_a$25 = function $$to_a() {
      var self = this;

      return self.matches
    }, $MatchData_to_a$25.$$arity = 0);
    
    Opal.def(self, '$to_s', $MatchData_to_s$26 = function $$to_s() {
      var self = this;

      return self.matches[0]
    }, $MatchData_to_s$26.$$arity = 0);
    return (Opal.def(self, '$values_at', $MatchData_values_at$27 = function $$values_at($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var i, a, index, values = [];

      for (i = 0; i < args.length; i++) {

        if (args[i].$$is_range) {
          a = (args[i]).$to_a();
          a.unshift(i, 1);
          Array.prototype.splice.apply(args, a);
        }

        index = $$($nesting, 'Opal')['$coerce_to!'](args[i], $$($nesting, 'Integer'), "to_int");

        if (index < 0) {
          index += self.matches.length;
          if (index < 0) {
            values.push(nil);
            continue;
          }
        }

        values.push(self.matches[index]);
      }

      return values;
    ;
    }, $MatchData_values_at$27.$$arity = -1), nil) && 'values_at';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/string"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$initialize', '$===', '$format', '$raise', '$respond_to?', '$to_s', '$to_str', '$<=>', '$==', '$=~', '$new', '$force_encoding', '$casecmp', '$empty?', '$ljust', '$ceil', '$/', '$+', '$rjust', '$floor', '$coerce_to!', '$copy_singleton_methods', '$initialize_clone', '$initialize_dup', '$enum_for', '$chomp', '$[]', '$to_i', '$each_line', '$to_proc', '$to_a', '$class', '$match', '$match?', '$captures', '$proc', '$succ', '$escape', '$include?', '$upcase', '$unicode_normalize', '$pristine']);
  
  self.$require("corelib/comparable");
  self.$require("corelib/regexp");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String___id__$1, $String_try_convert$2, $String_new$3, $String_initialize$4, $String_$percent$5, $String_$$6, $String_$plus$7, $String_$lt_eq_gt$8, $String_$eq_eq$9, $String_$eq_tilde$10, $String_$$$11, $String_b$12, $String_capitalize$13, $String_casecmp$14, $String_casecmp$ques$15, $String_center$16, $String_chomp$17, $String_chop$18, $String_chr$19, $String_clone$20, $String_dup$21, $String_count$22, $String_delete$23, $String_delete_prefix$24, $String_delete_suffix$25, $String_downcase$26, $String_each_line$27, $String_empty$ques$28, $String_end_with$ques$29, $String_gsub$30, $String_hash$31, $String_hex$32, $String_include$ques$33, $String_index$34, $String_inspect$35, $String_intern$36, $String_lines$37, $String_ljust$38, $String_lstrip$39, $String_ascii_only$ques$40, $String_match$41, $String_match$ques$42, $String_next$43, $String_oct$44, $String_ord$45, $String_partition$46, $String_reverse$47, $String_rindex$48, $String_rjust$49, $String_rpartition$50, $String_rstrip$51, $String_scan$52, $String_split$53, $String_squeeze$54, $String_start_with$ques$55, $String_strip$56, $String_sub$57, $String_sum$58, $String_swapcase$59, $String_to_f$60, $String_to_i$61, $String_to_proc$62, $String_to_s$64, $String_tr$65, $String_tr_s$66, $String_upcase$67, $String_upto$68, $String_instance_variables$69, $String__load$70, $String_unicode_normalize$71, $String_unicode_normalized$ques$72, $String_unpack$73, $String_unpack1$74, $String_freeze$75, $String_$minus$$76, $String_frozen$ques$77;

    
    self.$include($$($nesting, 'Comparable'));
    
    Opal.defineProperty(self.$$prototype, '$$is_string', true);

    Opal.defineProperty(self.$$prototype, '$$cast', function(string) {
      var klass = this.$$class;
      if (klass.$$constructor === String) {
        return string;
      } else {
        return new klass.$$constructor(string);
      }
    });
  ;
    
    Opal.def(self, '$__id__', $String___id__$1 = function $$__id__() {
      var self = this;

      return self.toString();
    }, $String___id__$1.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    Opal.defs(self, '$try_convert', $String_try_convert$2 = function $$try_convert(what) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](what, $$($nesting, 'String'), "to_str")
    }, $String_try_convert$2.$$arity = 1);
    Opal.defs(self, '$new', $String_new$3 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var str = args[0] || "";
      var opts = args[args.length-1];
      str = $coerce_to(str, $$($nesting, 'String'), 'to_str');
      if (opts && opts.$$is_hash) {
        if (opts.$$smap.encoding) str = str.$force_encoding(opts.$$smap.encoding);
      }
      str = new self.$$constructor(str);
      if (!str.$initialize.$$pristine) $send((str), 'initialize', Opal.to_a(args));
      return str;
    ;
    }, $String_new$3.$$arity = -1);
    
    Opal.def(self, '$initialize', $String_initialize$4 = function $$initialize($a, $b) {
      var $post_args, $kwargs, str, encoding, capacity, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) {
        str = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      encoding = $kwargs.$$smap["encoding"];
      if (encoding == null) {
        encoding = nil
      };
      
      capacity = $kwargs.$$smap["capacity"];
      if (capacity == null) {
        capacity = nil
      };
      return nil;
    }, $String_initialize$4.$$arity = -1);
    
    Opal.def(self, '$%', $String_$percent$5 = function(data) {
      var self = this;

      if ($truthy($$($nesting, 'Array')['$==='](data))) {
        return $send(self, 'format', [self].concat(Opal.to_a(data)))
      } else {
        return self.$format(self, data)
      }
    }, $String_$percent$5.$$arity = 1);
    
    Opal.def(self, '$*', $String_$$6 = function(count) {
      var self = this;

      
      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative argument")
      }

      if (count === 0) {
        return self.$$cast('');
      }

      var result = '',
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count >= 1 << 28) {
        self.$raise($$($nesting, 'RangeError'), "multiply count must not overflow maximum string size")
      }

      for (;;) {
        if ((count & 1) === 1) {
          result += string;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return self.$$cast(result);
    
    }, $String_$$6.$$arity = 1);
    
    Opal.def(self, '$+', $String_$plus$7 = function(other) {
      var self = this;

      
      other = $coerce_to(other, $$($nesting, 'String'), 'to_str');
      
      if (other == "" && self.$$class === Opal.String) return self;
      if (self == "" && other.$$class === Opal.String) return other;
      var out = self + other;
      if (self.encoding === out.encoding && other.encoding === out.encoding) return out;
      if (self.encoding.name === "UTF-8" || other.encoding.name === "UTF-8") return out;
      return Opal.enc(out, self.encoding);
    ;
    }, $String_$plus$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $String_$lt_eq_gt$8 = function(other) {
      var self = this;

      if ($truthy(other['$respond_to?']("to_str"))) {
        
        other = other.$to_str().$to_s();
        return self > other ? 1 : (self < other ? -1 : 0);;
      } else {
        
        var cmp = other['$<=>'](self);

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);
        }
      
      }
    }, $String_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$==', $String_$eq_eq$9 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if ($respond_to(other, '$to_str')) {
        return other['$=='](self);
      }
      return false;
    
    }, $String_$eq_eq$9.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    Opal.alias(self, "===", "==");
    
    Opal.def(self, '$=~', $String_$eq_tilde$10 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        self.$raise($$($nesting, 'TypeError'), "type mismatch: String given");
      }

      return other['$=~'](self);
    
    }, $String_$eq_tilde$10.$$arity = 1);
    
    Opal.def(self, '$[]', $String_$$$11 = function(index, length) {
      var self = this;

      
      ;
      
      var size = self.length, exclude;

      if (index.$$is_range) {
        exclude = index.excl;
        length  = $coerce_to(index.end, $$($nesting, 'Integer'), 'to_int');
        index   = $coerce_to(index.begin, $$($nesting, 'Integer'), 'to_int');

        if (Math.abs(index) > size) {
          return nil;
        }

        if (index < 0) {
          index += size;
        }

        if (length < 0) {
          length += size;
        }

        if (!exclude) {
          length += 1;
        }

        length = length - index;

        if (length < 0) {
          length = 0;
        }

        return self.$$cast(self.substr(index, length));
      }


      if (index.$$is_string) {
        if (length != null) {
          self.$raise($$($nesting, 'TypeError'))
        }
        return self.indexOf(index) !== -1 ? self.$$cast(index) : nil;
      }


      if (index.$$is_regexp) {
        var match = self.match(index);

        if (match === null) {
          ($gvars["~"] = nil)
          return nil;
        }

        ($gvars["~"] = $$($nesting, 'MatchData').$new(index, match))

        if (length == null) {
          return self.$$cast(match[0]);
        }

        length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');

        if (length < 0 && -length < match.length) {
          return self.$$cast(match[length += match.length]);
        }

        if (length >= 0 && length < match.length) {
          return self.$$cast(match[length]);
        }

        return nil;
      }


      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (index < 0) {
        index += size;
      }

      if (length == null) {
        if (index >= size || index < 0) {
          return nil;
        }
        return self.$$cast(self.substr(index, 1));
      }

      length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');

      if (length < 0) {
        return nil;
      }

      if (index > size || index < 0) {
        return nil;
      }

      return self.$$cast(self.substr(index, length));
    ;
    }, $String_$$$11.$$arity = -2);
    Opal.alias(self, "byteslice", "[]");
    
    Opal.def(self, '$b', $String_b$12 = function $$b() {
      var self = this;

      return (new String(self)).$force_encoding("binary")
    }, $String_b$12.$$arity = 0);
    
    Opal.def(self, '$capitalize', $String_capitalize$13 = function $$capitalize() {
      var self = this;

      return self.$$cast(self.charAt(0).toUpperCase() + self.substr(1).toLowerCase());
    }, $String_capitalize$13.$$arity = 0);
    
    Opal.def(self, '$casecmp', $String_casecmp$14 = function $$casecmp(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
      } else {
        return nil
      };
      other = ($coerce_to(other, $$($nesting, 'String'), 'to_str')).$to_s();
      
      var ascii_only = /^[\x00-\x7F]*$/;
      if (ascii_only.test(self) && ascii_only.test(other)) {
        self = self.toLowerCase();
        other = other.toLowerCase();
      }
    ;
      return self['$<=>'](other);
    }, $String_casecmp$14.$$arity = 1);
    
    Opal.def(self, '$casecmp?', $String_casecmp$ques$15 = function(other) {
      var self = this;

      
      var cmp = self.$casecmp(other);
      if (cmp === nil) {
        return nil;
      } else {
        return cmp === 0;
      }
    
    }, $String_casecmp$ques$15.$$arity = 1);
    
    Opal.def(self, '$center', $String_center$16 = function $$center(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $coerce_to(width, $$($nesting, 'Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$($nesting, 'String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),
          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);

      return self.$$cast(rjustified + ljustified.slice(self.length));
    ;
    }, $String_center$16.$$arity = -2);
    
    Opal.def(self, '$chomp', $String_chomp$17 = function $$chomp(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ($truthy(separator === nil || self.length === 0)) {
        return self};
      separator = $$($nesting, 'Opal')['$coerce_to!'](separator, $$($nesting, 'String'), "to_str").$to_s();
      
      var result;

      if (separator === "\n") {
        result = self.replace(/\r?\n?$/, '');
      }
      else if (separator === "") {
        result = self.replace(/(\r?\n)+$/, '');
      }
      else if (self.length >= separator.length) {
        var tail = self.substr(self.length - separator.length, separator.length);

        if (tail === separator) {
          result = self.substr(0, self.length - separator.length);
        }
      }

      if (result != null) {
        return self.$$cast(result);
      }
    ;
      return self;
    }, $String_chomp$17.$$arity = -1);
    
    Opal.def(self, '$chop', $String_chop$18 = function $$chop() {
      var self = this;

      
      var length = self.length, result;

      if (length <= 1) {
        result = "";
      } else if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
        result = self.substr(0, length - 2);
      } else {
        result = self.substr(0, length - 1);
      }

      return self.$$cast(result);
    
    }, $String_chop$18.$$arity = 0);
    
    Opal.def(self, '$chr', $String_chr$19 = function $$chr() {
      var self = this;

      return self.charAt(0);
    }, $String_chr$19.$$arity = 0);
    
    Opal.def(self, '$clone', $String_clone$20 = function $$clone() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, $String_clone$20.$$arity = 0);
    
    Opal.def(self, '$dup', $String_dup$21 = function $$dup() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$initialize_dup(self);
      return copy;
    }, $String_dup$21.$$arity = 0);
    
    Opal.def(self, '$count', $String_count$22 = function $$count($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return 0;
      }
      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;
    ;
    }, $String_count$22.$$arity = -1);
    
    Opal.def(self, '$delete', $String_delete$23 = function($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp(char_class, 'g'), ''));
    ;
    }, $String_delete$23.$$arity = -1);
    
    Opal.def(self, '$delete_prefix', $String_delete_prefix$24 = function $$delete_prefix(prefix) {
      var self = this;

      
      if (!prefix.$$is_string) {
        prefix = $coerce_to(prefix, $$($nesting, 'String'), 'to_str');
      }

      if (self.slice(0, prefix.length) === prefix) {
        return self.$$cast(self.slice(prefix.length));
      } else {
        return self;
      }
    
    }, $String_delete_prefix$24.$$arity = 1);
    
    Opal.def(self, '$delete_suffix', $String_delete_suffix$25 = function $$delete_suffix(suffix) {
      var self = this;

      
      if (!suffix.$$is_string) {
        suffix = $coerce_to(suffix, $$($nesting, 'String'), 'to_str');
      }

      if (self.slice(self.length - suffix.length) === suffix) {
        return self.$$cast(self.slice(0, self.length - suffix.length));
      } else {
        return self;
      }
    
    }, $String_delete_suffix$25.$$arity = 1);
    
    Opal.def(self, '$downcase', $String_downcase$26 = function $$downcase() {
      var self = this;

      return self.$$cast(self.toLowerCase());
    }, $String_downcase$26.$$arity = 0);
    
    Opal.def(self, '$each_line', $String_each_line$27 = function $$each_line(separator) {
      var $iter = $String_each_line$27.$$p, block = $iter || nil, self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $String_each_line$27.$$p = null;
      
      
      if ($iter) $String_each_line$27.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_line", separator)
      };
      
      if (separator === nil) {
        Opal.yield1(block, self);

        return self;
      }

      separator = $coerce_to(separator, $$($nesting, 'String'), 'to_str')

      var a, i, n, length, chomped, trailing, splitted;

      if (separator.length === 0) {
        for (a = self.split(/(\n{2,})/), i = 0, n = a.length; i < n; i += 2) {
          if (a[i] || a[i + 1]) {
            var value = (a[i] || "") + (a[i + 1] || "");
            Opal.yield1(block, self.$$cast(value));
          }
        }

        return self;
      }

      chomped  = self.$chomp(separator);
      trailing = self.length != chomped.length;
      splitted = chomped.split(separator);

      for (i = 0, length = splitted.length; i < length; i++) {
        if (i < length - 1 || trailing) {
          Opal.yield1(block, self.$$cast(splitted[i] + separator));
        }
        else {
          Opal.yield1(block, self.$$cast(splitted[i]));
        }
      }
    ;
      return self;
    }, $String_each_line$27.$$arity = -1);
    
    Opal.def(self, '$empty?', $String_empty$ques$28 = function() {
      var self = this;

      return self.length === 0;
    }, $String_empty$ques$28.$$arity = 0);
    
    Opal.def(self, '$end_with?', $String_end_with$ques$29 = function($a) {
      var $post_args, suffixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      suffixes = $post_args;;
      
      for (var i = 0, length = suffixes.length; i < length; i++) {
        var suffix = $coerce_to(suffixes[i], $$($nesting, 'String'), 'to_str').$to_s();

        if (self.length >= suffix.length &&
            self.substr(self.length - suffix.length, suffix.length) == suffix) {
          return true;
        }
      }
    ;
      return false;
    }, $String_end_with$ques$29.$$arity = -1);
    Opal.alias(self, "equal?", "===");
    
    Opal.def(self, '$gsub', $String_gsub$30 = function $$gsub(pattern, replacement) {
      var $iter = $String_gsub$30.$$p, block = $iter || nil, self = this;

      if ($iter) $String_gsub$30.$$p = null;
      
      
      if ($iter) $String_gsub$30.$$p = null;;
      ;
      
      if (replacement === undefined && block === nil) {
        return self.$enum_for("gsub", pattern);
      }

      var result = '', match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      var lastIndex;
      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          ($gvars["~"] = nil)
          result += self.slice(index);
          break;
        }

        match_data = $$($nesting, 'MatchData').$new(pattern, match);

        if (replacement === undefined) {
          lastIndex = pattern.lastIndex;
          _replacement = block(match[0]);
          pattern.lastIndex = lastIndex; // save and restore lastIndex
        }
        else if (replacement.$$is_hash) {
          _replacement = (replacement)['$[]'](match[0]).$to_s();
        }
        else {
          if (!replacement.$$is_string) {
            replacement = $coerce_to(replacement, $$($nesting, 'String'), 'to_str');
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');
        }

        if (pattern.lastIndex === match.index) {
          result += (self.slice(index, match.index) + _replacement + (self[match.index] || ""));
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      ($gvars["~"] = match_data)
      return self.$$cast(result);
    ;
    }, $String_gsub$30.$$arity = -2);
    
    Opal.def(self, '$hash', $String_hash$31 = function $$hash() {
      var self = this;

      return self.toString();
    }, $String_hash$31.$$arity = 0);
    
    Opal.def(self, '$hex', $String_hex$32 = function $$hex() {
      var self = this;

      return self.$to_i(16)
    }, $String_hex$32.$$arity = 0);
    
    Opal.def(self, '$include?', $String_include$ques$33 = function(other) {
      var self = this;

      
      if (!other.$$is_string) {
        other = $coerce_to(other, $$($nesting, 'String'), 'to_str');
      }
      return self.indexOf(other) !== -1;
    
    }, $String_include$ques$33.$$arity = 1);
    
    Opal.def(self, '$index', $String_index$34 = function $$index(search, offset) {
      var self = this;

      
      ;
      
      var index,
          match,
          regex;

      if (offset === undefined) {
        offset = 0;
      } else {
        offset = $coerce_to(offset, $$($nesting, 'Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        regex = Opal.global_multiline_regexp(search);
        while (true) {
          match = regex.exec(self);
          if (match === null) {
            ($gvars["~"] = nil);
            index = -1;
            break;
          }
          if (match.index >= offset) {
            ($gvars["~"] = $$($nesting, 'MatchData').$new(regex, match))
            index = match.index;
            break;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = $coerce_to(search, $$($nesting, 'String'), 'to_str');
        if (search.length === 0 && offset > self.length) {
          index = -1;
        } else {
          index = self.indexOf(search, offset);
        }
      }

      return index === -1 ? nil : index;
    ;
    }, $String_index$34.$$arity = -2);
    
    Opal.def(self, '$inspect', $String_inspect$35 = function $$inspect() {
      var self = this;

      
      var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          escaped = self.replace(escapable, function (chr) {
            if (meta[chr]) return meta[chr];
            chr = chr.charCodeAt(0);
            if (chr <= 0xff && (self.encoding["$binary?"]() || self.internal_encoding["$binary?"]())) {
              return '\\x' + ('00' + chr.toString(16).toUpperCase()).slice(-2);
            } else {
              return '\\u' + ('0000' + chr.toString(16).toUpperCase()).slice(-4);
            }
          });
      return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
    
    }, $String_inspect$35.$$arity = 0);
    
    Opal.def(self, '$intern', $String_intern$36 = function $$intern() {
      var self = this;

      return self.toString();
    }, $String_intern$36.$$arity = 0);
    
    Opal.def(self, '$lines', $String_lines$37 = function $$lines(separator) {
      var $iter = $String_lines$37.$$p, block = $iter || nil, self = this, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $String_lines$37.$$p = null;
      
      
      if ($iter) $String_lines$37.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      e = $send(self, 'each_line', [separator], block.$to_proc());
      if ($truthy(block)) {
        return self
      } else {
        return e.$to_a()
      };
    }, $String_lines$37.$$arity = -1);
    
    Opal.def(self, '$ljust', $String_ljust$38 = function $$ljust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $coerce_to(width, $$($nesting, 'Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$($nesting, 'String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var index  = -1,
          result = "";

      width -= self.length;

      while (++index < width) {
        result += padstr;
      }

      return self.$$cast(self + result.slice(0, width));
    ;
    }, $String_ljust$38.$$arity = -2);
    
    Opal.def(self, '$lstrip', $String_lstrip$39 = function $$lstrip() {
      var self = this;

      return self.replace(/^\s*/, '');
    }, $String_lstrip$39.$$arity = 0);
    
    Opal.def(self, '$ascii_only?', $String_ascii_only$ques$40 = function() {
      var self = this;

      
      if (!self.encoding.ascii) return false;
      return /^[\x00-\x7F]*$/.test(self);
    
    }, $String_ascii_only$ques$40.$$arity = 0);
    
    Opal.def(self, '$match', $String_match$41 = function $$match(pattern, pos) {
      var $iter = $String_match$41.$$p, block = $iter || nil, self = this, $ret_or_1 = nil;

      if ($iter) $String_match$41.$$p = null;
      
      
      if ($iter) $String_match$41.$$p = null;;
      ;
      if ($truthy((function() {if ($truthy(($ret_or_1 = $$($nesting, 'String')['$==='](pattern)))) {
        return $ret_or_1
      } else {
        return pattern['$respond_to?']("to_str")
      }; return nil; })())) {
        pattern = $$($nesting, 'Regexp').$new(pattern.$to_str())};
      if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return $send(pattern, 'match', [self, pos], block.$to_proc());
    }, $String_match$41.$$arity = -2);
    
    Opal.def(self, '$match?', $String_match$ques$42 = function(pattern, pos) {
      var self = this, $ret_or_2 = nil;

      
      ;
      if ($truthy((function() {if ($truthy(($ret_or_2 = $$($nesting, 'String')['$==='](pattern)))) {
        return $ret_or_2
      } else {
        return pattern['$respond_to?']("to_str")
      }; return nil; })())) {
        pattern = $$($nesting, 'Regexp').$new(pattern.$to_str())};
      if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return pattern['$match?'](self, pos);
    }, $String_match$ques$42.$$arity = -2);
    
    Opal.def(self, '$next', $String_next$43 = function $$next() {
      var self = this;

      
      var i = self.length;
      if (i === 0) {
        return self.$$cast('');
      }
      var result = self;
      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
      var carry = false;
      var code;
      while (i--) {
        code = self.charCodeAt(i);
        if ((code >= 48 && code <= 57) ||
          (code >= 65 && code <= 90) ||
          (code >= 97 && code <= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
        if (carry && (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCharCode(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) {
          break;
        }
      }
      return self.$$cast(result);
    
    }, $String_next$43.$$arity = 0);
    
    Opal.def(self, '$oct', $String_oct$44 = function $$oct() {
      var self = this;

      
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x') {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          radix = 2;
          break;
        case '0':
        case '0o':
          radix = 8;
          break;
        case '0d':
          radix = 10;
          break;
        case '0x':
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    }, $String_oct$44.$$arity = 0);
    
    Opal.def(self, '$ord', $String_ord$45 = function $$ord() {
      var self = this;

      
      if (typeof self.codePointAt === "function") {
        return self.codePointAt(0);
      }
      else {
        return self.charCodeAt(0);
      }
    
    }, $String_ord$45.$$arity = 0);
    
    Opal.def(self, '$partition', $String_partition$46 = function $$partition(sep) {
      var self = this;

      
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(sep, m);
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = $coerce_to(sep, $$($nesting, 'String'), 'to_str');
        i = self.indexOf(sep);
      }

      if (i === -1) {
        return [self, '', ''];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, $String_partition$46.$$arity = 1);
    
    Opal.def(self, '$reverse', $String_reverse$47 = function $$reverse() {
      var self = this;

      return self.split('').reverse().join('');
    }, $String_reverse$47.$$arity = 0);
    
    Opal.def(self, '$rindex', $String_rindex$48 = function $$rindex(search, offset) {
      var self = this;

      
      ;
      
      var i, m, r, _m;

      if (offset === undefined) {
        offset = self.length;
      } else {
        offset = $coerce_to(offset, $$($nesting, 'Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        m = null;
        r = Opal.global_multiline_regexp(search);
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index > offset) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          ($gvars["~"] = nil)
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(r, m);
          i = m.index;
        }
      } else {
        search = $coerce_to(search, $$($nesting, 'String'), 'to_str');
        i = self.lastIndexOf(search, offset);
      }

      return i === -1 ? nil : i;
    ;
    }, $String_rindex$48.$$arity = -2);
    
    Opal.def(self, '$rjust', $String_rjust$49 = function $$rjust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $coerce_to(width, $$($nesting, 'Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$($nesting, 'String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var chars     = Math.floor(width - self.length),
          patterns  = Math.floor(chars / padstr.length),
          result    = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

      return self.$$cast(result + padstr.slice(0, remaining) + self);
    ;
    }, $String_rjust$49.$$arity = -2);
    
    Opal.def(self, '$rpartition', $String_rpartition$50 = function $$rpartition(sep) {
      var self = this;

      
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = Opal.global_multiline_regexp(sep);

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(r, m);
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = $coerce_to(sep, $$($nesting, 'String'), 'to_str');
        i = self.lastIndexOf(sep);
      }

      if (i === -1) {
        return ['', '', self];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, $String_rpartition$50.$$arity = 1);
    
    Opal.def(self, '$rstrip', $String_rstrip$51 = function $$rstrip() {
      var self = this;

      return self.replace(/[\s\u0000]*$/, '');
    }, $String_rstrip$51.$$arity = 0);
    
    Opal.def(self, '$scan', $String_scan$52 = function $$scan(pattern) {
      var $iter = $String_scan$52.$$p, block = $iter || nil, self = this;

      if ($iter) $String_scan$52.$$p = null;
      
      
      if ($iter) $String_scan$52.$$p = null;;
      
      var result = [],
          match_data = nil,
          match;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = $$($nesting, 'MatchData').$new(pattern, match);
        if (block === nil) {
          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());
        } else {
          match.length == 1 ? block(match[0]) : block.call(self, (match_data).$captures());
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      ($gvars["~"] = match_data)

      return (block !== nil ? self : result);
    ;
    }, $String_scan$52.$$arity = 1);
    Opal.alias(self, "slice", "[]");
    
    Opal.def(self, '$split', $String_split$53 = function $$split(pattern, limit) {
      var self = this, $ret_or_3 = nil;
      if ($gvars[";"] == null) $gvars[";"] = nil;

      
      ;
      ;
      
      if (self.length === 0) {
        return [];
      }

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), "to_int");
        if (limit === 1) {
          return [self];
        }
      }

      if (pattern === undefined || pattern === nil) {
        pattern = (function() {if ($truthy(($ret_or_3 = $gvars[";"]))) {
        return $ret_or_3
      } else {
        return " "
      }; return nil; })();
      }

      var result = [],
          string = self.toString(),
          index = 0,
          match,
          i, ii;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str').$to_s();
        if (pattern === ' ') {
          pattern = /\s+/gm;
          string = string.replace(/^\s+/, '');
        } else {
          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
        }
      }

      result = string.split(pattern);

      if (result.length === 1 && result[0] === string) {
        return [self.$$cast(result[0])];
      }

      while ((i = result.indexOf(undefined)) !== -1) {
        result.splice(i, 1);
      }

      function castResult() {
        for (i = 0; i < result.length; i++) {
          result[i] = self.$$cast(result[i]);
        }
      }

      if (limit === 0) {
        while (result[result.length - 1] === '') {
          result.length -= 1;
        }
        castResult();
        return result;
      }

      match = pattern.exec(string);

      if (limit < 0) {
        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
          for (i = 0, ii = match.length; i < ii; i++) {
            result.push('');
          }
        }
        castResult();
        return result;
      }

      if (match !== null && match[0] === '') {
        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));
        castResult();
        return result;
      }

      if (limit >= result.length) {
        castResult();
        return result;
      }

      i = 0;
      while (match !== null) {
        i++;
        index = pattern.lastIndex;
        if (i + 1 === limit) {
          break;
        }
        match = pattern.exec(string);
      }
      result.splice(limit - 1, result.length - 1, string.slice(index));
      castResult();
      return result;
    ;
    }, $String_split$53.$$arity = -1);
    
    Opal.def(self, '$squeeze', $String_squeeze$54 = function $$squeeze($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        return self.$$cast(self.replace(/(.)\1+/g, '$1'));
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp('(' + char_class + ')\\1+', 'g'), '$1'));
    ;
    }, $String_squeeze$54.$$arity = -1);
    
    Opal.def(self, '$start_with?', $String_start_with$ques$55 = function($a) {
      var $post_args, prefixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      prefixes = $post_args;;
      
      for (var i = 0, length = prefixes.length; i < length; i++) {
        if (prefixes[i].$$is_regexp) {
          var regexp = prefixes[i];
          var match = regexp.exec(self);

          if (match != null && match.index === 0) {
            ($gvars["~"] = $$($nesting, 'MatchData').$new(regexp, match));
            return true;
          } else {
            ($gvars["~"] = nil)
          }
        } else {
          var prefix = $coerce_to(prefixes[i], $$($nesting, 'String'), 'to_str').$to_s();

          if (self.indexOf(prefix) === 0) {
            return true;
          }
        }
      }

      return false;
    ;
    }, $String_start_with$ques$55.$$arity = -1);
    
    Opal.def(self, '$strip', $String_strip$56 = function $$strip() {
      var self = this;

      return self.replace(/^\s*/, '').replace(/[\s\u0000]*$/, '');
    }, $String_strip$56.$$arity = 0);
    
    Opal.def(self, '$sub', $String_sub$57 = function $$sub(pattern, replacement) {
      var $iter = $String_sub$57.$$p, block = $iter || nil, self = this;

      if ($iter) $String_sub$57.$$p = null;
      
      
      if ($iter) $String_sub$57.$$p = null;;
      ;
      
      if (!pattern.$$is_regexp) {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      }

      var result, match = pattern.exec(self);

      if (match === null) {
        ($gvars["~"] = nil)
        result = self.toString();
      } else {
        $$($nesting, 'MatchData').$new(pattern, match)

        if (replacement === undefined) {

          if (block === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 2)")
          }
          result = self.slice(0, match.index) + block(match[0]) + self.slice(match.index + match[0].length);

        } else if (replacement.$$is_hash) {

          result = self.slice(0, match.index) + (replacement)['$[]'](match[0]).$to_s() + self.slice(match.index + match[0].length);

        } else {

          replacement = $coerce_to(replacement, $$($nesting, 'String'), 'to_str');

          replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');

          result = self.slice(0, match.index) + replacement + self.slice(match.index + match[0].length);
        }
      }

      return self.$$cast(result);
    ;
    }, $String_sub$57.$$arity = -2);
    Opal.alias(self, "succ", "next");
    
    Opal.def(self, '$sum', $String_sum$58 = function $$sum(n) {
      var self = this;

      
      
      if (n == null) {
        n = 16;
      };
      
      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');

      var result = 0,
          length = self.length,
          i = 0;

      for (; i < length; i++) {
        result += self.charCodeAt(i);
      }

      if (n <= 0) {
        return result;
      }

      return result & (Math.pow(2, n) - 1);
    ;
    }, $String_sum$58.$$arity = -1);
    
    Opal.def(self, '$swapcase', $String_swapcase$59 = function $$swapcase() {
      var self = this;

      
      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
        return $1 ? $0.toUpperCase() : $0.toLowerCase();
      });

      if (self.constructor === String) {
        return str;
      }

      return self.$class().$new(str);
    
    }, $String_swapcase$59.$$arity = 0);
    
    Opal.def(self, '$to_f', $String_to_f$60 = function $$to_f() {
      var self = this;

      
      if (self.charAt(0) === '_') {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, ''));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    
    }, $String_to_f$60.$$arity = 0);
    
    Opal.def(self, '$to_i', $String_to_i$61 = function $$to_i(base) {
      var self = this;

      
      
      if (base == null) {
        base = 10;
      };
      
      var result,
          string = self.toLowerCase(),
          radix = $coerce_to(base, $$($nesting, 'Integer'), 'to_int');

      if (radix === 1 || radix < 0 || radix > 36) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (radix))
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case '0':
        case '0o':
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case '0d':
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case '0x':
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    ;
    }, $String_to_i$61.$$arity = -1);
    
    Opal.def(self, '$to_proc', $String_to_proc$62 = function $$to_proc() {
      var $$63, $iter = $String_to_proc$62.$$p, $yield = $iter || nil, self = this, method_name = nil;

      if ($iter) $String_to_proc$62.$$p = null;
      
      method_name = $rb_plus("$", self.valueOf());
      return $send(self, 'proc', [], ($$63 = function($a){var self = $$63.$$s == null ? this : $$63.$$s, $iter = $$63.$$p, block = $iter || nil, $post_args, args;

      
        
        if ($iter) $$63.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        
        if (args.length === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "no receiver given")
        }

        var recv = args[0];

        if (recv == null) recv = nil;

        var body = recv[method_name];

        if (!body) {
          return recv.$method_missing.apply(recv, args);
        }

        if (typeof block === 'function') {
          body.$$p = block;
        }

        if (args.length === 1) {
          return body.call(recv);
        } else {
          return body.apply(recv, args.slice(1));
        }
      ;}, $$63.$$s = self, $$63.$$arity = -1, $$63));
    }, $String_to_proc$62.$$arity = 0);
    
    Opal.def(self, '$to_s', $String_to_s$64 = function $$to_s() {
      var self = this;

      return self.toString();
    }, $String_to_s$64.$$arity = 0);
    Opal.alias(self, "to_str", "to_s");
    Opal.alias(self, "to_sym", "intern");
    
    Opal.def(self, '$tr', $String_tr$65 = function $$tr(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$($nesting, 'String'), 'to_str').$to_s();
      to = $coerce_to(to, $$($nesting, 'String'), 'to_str').$to_s();

      if (from.length == 0 || from === to) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_to == null) {
              last_to = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_to.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_to = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      var new_str = ''
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch];
        if (inverse) {
          new_str += (sub == null ? global_sub : ch);
        }
        else {
          new_str += (sub != null ? sub : ch);
        }
      }
      return self.$$cast(new_str);
    
    }, $String_tr$65.$$arity = 2);
    
    Opal.def(self, '$tr_s', $String_tr_s$66 = function $$tr_s(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$($nesting, 'String'), 'to_str').$to_s();
      to = $coerce_to(to, $$($nesting, 'String'), 'to_str').$to_s();

      if (from.length == 0) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }
      var new_str = ''
      var last_substitute = null
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch]
        if (inverse) {
          if (sub == null) {
            if (last_substitute == null) {
              new_str += global_sub;
              last_substitute = true;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
        else {
          if (sub != null) {
            if (last_substitute == null || last_substitute !== sub) {
              new_str += sub;
              last_substitute = sub;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
      }
      return self.$$cast(new_str);
    
    }, $String_tr_s$66.$$arity = 2);
    
    Opal.def(self, '$upcase', $String_upcase$67 = function $$upcase() {
      var self = this;

      return self.$$cast(self.toUpperCase());
    }, $String_upcase$67.$$arity = 0);
    
    Opal.def(self, '$upto', $String_upto$68 = function $$upto(stop, excl) {
      var $iter = $String_upto$68.$$p, block = $iter || nil, self = this;

      if ($iter) $String_upto$68.$$p = null;
      
      
      if ($iter) $String_upto$68.$$p = null;;
      
      if (excl == null) {
        excl = false;
      };
      if ((block !== nil)) {
      } else {
        return self.$enum_for("upto", stop, excl)
      };
      
      var a, b, s = self.toString();

      stop = $coerce_to(stop, $$($nesting, 'String'), 'to_str');

      if (s.length === 1 && stop.length === 1) {

        a = s.charCodeAt(0);
        b = stop.charCodeAt(0);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(String.fromCharCode(a));

          a += 1;
        }

      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {

        a = parseInt(s, 10);
        b = parseInt(stop, 10);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(a.toString());

          a += 1;
        }

      } else {

        while (s.length <= stop.length && s <= stop) {
          if (excl && s === stop) {
            break;
          }

          block(s);

          s = (s).$succ();
        }

      }
      return self;
    ;
    }, $String_upto$68.$$arity = -2);
    
    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = '',
            i, len = set.length,
            curr_char,
            skip_next_dash,
            char_code_from,
            char_code_upto,
            char_code;
        for (i = 0; i < len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from > char_code_upto) {
              self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (char_code_from) + "-" + (char_code_upto) + "\" in string transliteration")
            }
            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === '\\');
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = '',
            i, len = setA.length,
            chr;
        for (i = 0; i < len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i, len, set, neg, chr, tmp,
          pos_intersection = '',
          neg_intersection = '';

      for (i = 0, len = sets.length; i < len; i++) {
        set = $coerce_to(sets[i], $$($nesting, 'String'), 'to_str');
        neg = (set.charAt(0) === '^' && set.length > 1);
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = '';
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = '';
      }

      if (pos_intersection.length > 0) {
        return '[' + $$($nesting, 'Regexp').$escape(pos_intersection) + ']';
      }

      if (neg_intersection.length > 0) {
        return '[^' + $$($nesting, 'Regexp').$escape(neg_intersection) + ']';
      }

      return null;
    }
  ;
    
    Opal.def(self, '$instance_variables', $String_instance_variables$69 = function $$instance_variables() {
      var self = this;

      return []
    }, $String_instance_variables$69.$$arity = 0);
    Opal.defs(self, '$_load', $String__load$70 = function $$_load($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self, 'new', Opal.to_a(args));
    }, $String__load$70.$$arity = -1);
    
    Opal.def(self, '$unicode_normalize', $String_unicode_normalize$71 = function $$unicode_normalize(form) {
      var self = this;

      
      
      if (form == null) {
        form = "nfc";
      };
      if ($truthy(["nfc", "nfd", "nfkc", "nfkd"]['$include?'](form))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "Invalid normalization form " + (form))
      };
      return self.normalize(form.$upcase());
    }, $String_unicode_normalize$71.$$arity = -1);
    
    Opal.def(self, '$unicode_normalized?', $String_unicode_normalized$ques$72 = function(form) {
      var self = this;

      
      
      if (form == null) {
        form = "nfc";
      };
      return self.$unicode_normalize(form)['$=='](self);
    }, $String_unicode_normalized$ques$72.$$arity = -1);
    
    Opal.def(self, '$unpack', $String_unpack$73 = function $$unpack(format) {
      var self = this;

      return self.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.")
    }, $String_unpack$73.$$arity = 1);
    
    Opal.def(self, '$unpack1', $String_unpack1$74 = function $$unpack1(format) {
      var self = this;

      return self.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.")
    }, $String_unpack1$74.$$arity = 1);
    
    Opal.def(self, '$freeze', $String_freeze$75 = function $$freeze() {
      var self = this;

      
      if (typeof self === 'string') return self;
      self.$$frozen = true;
      return self;
    
    }, $String_freeze$75.$$arity = 0);
    Opal.alias(self, "+@", "dup");
    
    Opal.def(self, '$-@', $String_$minus$$76 = function() {
      var self = this;

      
      if (typeof self === 'string') return self;
      if (self.$$frozen === true) return self;
      if (self.encoding.name == 'UTF-8' && self.internal_encoding.name == 'UTF-8') return self.toString();
      return self.$dup().$freeze();
    
    }, $String_$minus$$76.$$arity = 0);
    
    Opal.def(self, '$frozen?', $String_frozen$ques$77 = function() {
      var self = this;

      return typeof self === 'string' || self.$$frozen === true;
    }, $String_frozen$ques$77.$$arity = 0);
    return $$($nesting, 'Opal').$pristine(self, "initialize");
  })($nesting[0], String, $nesting);
  return Opal.const_set($nesting[0], 'Symbol', $$($nesting, 'String'));
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/enumerable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $falsy = Opal.falsy, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $module = Opal.module, $send = Opal.send, $hash2 = Opal.hash2, $lambda = Opal.lambda;

  Opal.add_stubs(['$each', '$public_send', '$destructure', '$to_enum', '$enumerator_size', '$new', '$yield', '$raise', '$slice_when', '$!', '$enum_for', '$flatten', '$map', '$warn', '$proc', '$==', '$nil?', '$respond_to?', '$coerce_to!', '$>', '$*', '$try_convert', '$<', '$+', '$-', '$ceil', '$/', '$size', '$select', '$to_proc', '$__send__', '$length', '$<=', '$[]', '$push', '$<<', '$[]=', '$===', '$inspect', '$<=>', '$first', '$reverse', '$sort', '$take', '$sort_by', '$compare', '$call', '$dup', '$to_a', '$sort!', '$map!', '$key?', '$values', '$transform_values', '$group_by', '$to_h', '$coerce_to?', '$class', '$zip']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $Enumerable_all$ques$1, $Enumerable_any$ques$5, $Enumerable_chunk$9, $Enumerable_chunk_while$12, $Enumerable_collect$14, $Enumerable_collect_concat$16, $Enumerable_count$19, $Enumerable_cycle$23, $Enumerable_detect$25, $Enumerable_drop$27, $Enumerable_drop_while$28, $Enumerable_each_cons$29, $Enumerable_each_entry$31, $Enumerable_each_slice$33, $Enumerable_each_with_index$35, $Enumerable_each_with_object$37, $Enumerable_entries$39, $Enumerable_filter_map$40, $Enumerable_find_all$42, $Enumerable_find_index$44, $Enumerable_first$47, $Enumerable_grep$50, $Enumerable_grep_v$52, $Enumerable_group_by$54, $Enumerable_include$ques$56, $Enumerable_inject$58, $Enumerable_lazy$59, $Enumerable_enumerator_size$61, $Enumerable_max$62, $Enumerable_max_by$63, $Enumerable_min$65, $Enumerable_min_by$67, $Enumerable_minmax$69, $Enumerable_minmax_by$71, $Enumerable_none$ques$73, $Enumerable_one$ques$77, $Enumerable_partition$81, $Enumerable_reject$83, $Enumerable_reverse_each$85, $Enumerable_slice_before$87, $Enumerable_slice_after$89, $Enumerable_slice_when$92, $Enumerable_sort$94, $Enumerable_sort_by$96, $Enumerable_sum$101, $Enumerable_take$103, $Enumerable_take_while$104, $Enumerable_uniq$106, $Enumerable_tally$108, $Enumerable_to_h$109, $Enumerable_zip$110;

    
    
    function comparableForPattern(value) {
      if (value.length === 0) {
        value = [nil];
      }

      if (value.length > 1) {
        value = [value];
      }

      return value;
    }
  ;
    
    Opal.def(self, '$all?', $Enumerable_all$ques$1 = function(pattern) {try {

      var $iter = $Enumerable_all$ques$1.$$p, block = $iter || nil, $$2, $$3, $$4, self = this;

      if ($iter) $Enumerable_all$ques$1.$$p = null;
      
      
      if ($iter) $Enumerable_all$ques$1.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$2 = function($a){var self = $$2.$$s == null ? this : $$2.$$s, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$2.$$s = self, $$2.$$arity = -1, $$2))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$3 = function($a){var self = $$3.$$s == null ? this : $$3.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$3.$$s = self, $$3.$$arity = -1, $$3))
      } else {
        $send(self, 'each', [], ($$4 = function($a){var self = $$4.$$s == null ? this : $$4.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$4.$$s = self, $$4.$$arity = -1, $$4))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_all$ques$1.$$arity = -1);
    
    Opal.def(self, '$any?', $Enumerable_any$ques$5 = function(pattern) {try {

      var $iter = $Enumerable_any$ques$5.$$p, block = $iter || nil, $$6, $$7, $$8, self = this;

      if ($iter) $Enumerable_any$ques$5.$$p = null;
      
      
      if ($iter) $Enumerable_any$ques$5.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$6 = function($a){var self = $$6.$$s == null ? this : $$6.$$s, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$6.$$s = self, $$6.$$arity = -1, $$6))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$7 = function($a){var self = $$7.$$s == null ? this : $$7.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$7.$$s = self, $$7.$$arity = -1, $$7))
      } else {
        $send(self, 'each', [], ($$8 = function($a){var self = $$8.$$s == null ? this : $$8.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$8.$$s = self, $$8.$$arity = -1, $$8))
      };
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_any$ques$5.$$arity = -1);
    
    Opal.def(self, '$chunk', $Enumerable_chunk$9 = function $$chunk() {
      var $iter = $Enumerable_chunk$9.$$p, block = $iter || nil, $$10, $$11, self = this;

      if ($iter) $Enumerable_chunk$9.$$p = null;
      
      
      if ($iter) $Enumerable_chunk$9.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'to_enum', ["chunk"], ($$10 = function(){var self = $$10.$$s == null ? this : $$10.$$s;

        return self.$enumerator_size()}, $$10.$$s = self, $$10.$$arity = 0, $$10))
      };
      return $send($$$('::', 'Enumerator'), 'new', [], ($$11 = function(yielder){var self = $$11.$$s == null ? this : $$11.$$s;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var previous = nil, accumulate = [];

        function releaseAccumulate() {
          if (accumulate.length > 0) {
            yielder.$yield(previous, accumulate)
          }
        }

        self.$each.$$p = function(value) {
          var key = Opal.yield1(block, value);

          if (key === nil) {
            releaseAccumulate();
            accumulate = [];
            previous = nil;
          } else {
            if (previous === nil || previous === key) {
              accumulate.push(value);
            } else {
              releaseAccumulate();
              accumulate = [value];
            }

            previous = key;
          }
        }

        self.$each();

        releaseAccumulate();
      ;}, $$11.$$s = self, $$11.$$arity = 1, $$11));
    }, $Enumerable_chunk$9.$$arity = 0);
    
    Opal.def(self, '$chunk_while', $Enumerable_chunk_while$12 = function $$chunk_while() {
      var $iter = $Enumerable_chunk_while$12.$$p, block = $iter || nil, $$13, self = this;

      if ($iter) $Enumerable_chunk_while$12.$$p = null;
      
      
      if ($iter) $Enumerable_chunk_while$12.$$p = null;;
      if ((block !== nil)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "no block given")
      };
      return $send(self, 'slice_when', [], ($$13 = function(before, after){var self = $$13.$$s == null ? this : $$13.$$s;

      
        
        if (before == null) {
          before = nil;
        };
        
        if (after == null) {
          after = nil;
        };
        return Opal.yieldX(block, [before, after])['$!']();}, $$13.$$s = self, $$13.$$arity = 2, $$13));
    }, $Enumerable_chunk_while$12.$$arity = 0);
    
    Opal.def(self, '$collect', $Enumerable_collect$14 = function $$collect() {
      var $iter = $Enumerable_collect$14.$$p, block = $iter || nil, $$15, self = this;

      if ($iter) $Enumerable_collect$14.$$p = null;
      
      
      if ($iter) $Enumerable_collect$14.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect"], ($$15 = function(){var self = $$15.$$s == null ? this : $$15.$$s;

        return self.$enumerator_size()}, $$15.$$s = self, $$15.$$arity = 0, $$15))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var value = Opal.yieldX(block, arguments);

        result.push(value);
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_collect$14.$$arity = 0);
    
    Opal.def(self, '$collect_concat', $Enumerable_collect_concat$16 = function $$collect_concat() {
      var $iter = $Enumerable_collect_concat$16.$$p, block = $iter || nil, $$17, $$18, self = this;

      if ($iter) $Enumerable_collect_concat$16.$$p = null;
      
      
      if ($iter) $Enumerable_collect_concat$16.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect_concat"], ($$17 = function(){var self = $$17.$$s == null ? this : $$17.$$s;

        return self.$enumerator_size()}, $$17.$$s = self, $$17.$$arity = 0, $$17))
      };
      return $send(self, 'map', [], ($$18 = function(item){var self = $$18.$$s == null ? this : $$18.$$s;

      
        
        if (item == null) {
          item = nil;
        };
        return Opal.yield1(block, item);;}, $$18.$$s = self, $$18.$$arity = 1, $$18)).$flatten(1);
    }, $Enumerable_collect_concat$16.$$arity = 0);
    
    Opal.def(self, '$count', $Enumerable_count$19 = function $$count(object) {
      var $iter = $Enumerable_count$19.$$p, block = $iter || nil, $$20, $$21, $$22, self = this, result = nil;

      if ($iter) $Enumerable_count$19.$$p = null;
      
      
      if ($iter) $Enumerable_count$19.$$p = null;;
      ;
      result = 0;
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      if ($truthy(object != null)) {
        block = $send(self, 'proc', [], ($$20 = function($a){var self = $$20.$$s == null ? this : $$20.$$s, $post_args, args;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $$($nesting, 'Opal').$destructure(args)['$=='](object);}, $$20.$$s = self, $$20.$$arity = -1, $$20))
      } else if ($truthy(block['$nil?']())) {
        block = $send(self, 'proc', [], ($$21 = function(){var self = $$21.$$s == null ? this : $$21.$$s;

        return true}, $$21.$$s = self, $$21.$$arity = 0, $$21))};
      $send(self, 'each', [], ($$22 = function($a){var self = $$22.$$s == null ? this : $$22.$$s, $post_args, args;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        if ($truthy(Opal.yieldX(block, args))) {
          return result++;
        } else {
          return nil
        };}, $$22.$$s = self, $$22.$$arity = -1, $$22));
      return result;
    }, $Enumerable_count$19.$$arity = -1);
    
    Opal.def(self, '$cycle', $Enumerable_cycle$23 = function $$cycle(n) {
      var $iter = $Enumerable_cycle$23.$$p, block = $iter || nil, $$24, self = this;

      if ($iter) $Enumerable_cycle$23.$$p = null;
      
      
      if ($iter) $Enumerable_cycle$23.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["cycle", n], ($$24 = function(){var self = $$24.$$s == null ? this : $$24.$$s;

        if ($truthy(n['$nil?']())) {
            if ($truthy(self['$respond_to?']("size"))) {
              return $$$($$($nesting, 'Float'), 'INFINITY')
            } else {
              return nil
            }
          } else {
            
            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, $$24.$$s = self, $$24.$$arity = 0, $$24))
      };
      if ($truthy(n['$nil?']())) {
      } else {
        
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        if ($truthy(n <= 0)) {
          return nil};
      };
      
      var all = [], i, length, value;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        all.push(param);
      }

      self.$each();

      if (all.length === 0) {
        return nil;
      }

      if (n === nil) {
        while (true) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }
        }
      }
      else {
        while (n > 1) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }

          n--;
        }
      }
    ;
    }, $Enumerable_cycle$23.$$arity = -1);
    
    Opal.def(self, '$detect', $Enumerable_detect$25 = function $$detect(ifnone) {try {

      var $iter = $Enumerable_detect$25.$$p, block = $iter || nil, $$26, self = this;

      if ($iter) $Enumerable_detect$25.$$p = null;
      
      
      if ($iter) $Enumerable_detect$25.$$p = null;;
      ;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("detect", ifnone)
      };
      $send(self, 'each', [], ($$26 = function($a){var self = $$26.$$s == null ? this : $$26.$$s, $post_args, args, value = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          Opal.ret(value)
        } else {
          return nil
        };}, $$26.$$s = self, $$26.$$arity = -1, $$26));
      
      if (ifnone !== undefined) {
        if (typeof(ifnone) === 'function') {
          return ifnone();
        } else {
          return ifnone;
        }
      }
    ;
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_detect$25.$$arity = -1);
    
    Opal.def(self, '$drop', $Enumerable_drop$27 = function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(number < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size")};
      
      var result  = [],
          current = 0;

      self.$each.$$p = function() {
        if (number <= current) {
          result.push($$($nesting, 'Opal').$destructure(arguments));
        }

        current++;
      };

      self.$each()

      return result;
    ;
    }, $Enumerable_drop$27.$$arity = 1);
    
    Opal.def(self, '$drop_while', $Enumerable_drop_while$28 = function $$drop_while() {
      var $iter = $Enumerable_drop_while$28.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_drop_while$28.$$p = null;
      
      
      if ($iter) $Enumerable_drop_while$28.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("drop_while")
      };
      
      var result   = [],
          dropping = true;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        if (dropping) {
          var value = Opal.yield1(block, param);

          if ($falsy(value)) {
            dropping = false;
            result.push(param);
          }
        }
        else {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_drop_while$28.$$arity = 0);
    
    Opal.def(self, '$each_cons', $Enumerable_each_cons$29 = function $$each_cons(n) {
      var $iter = $Enumerable_each_cons$29.$$p, block = $iter || nil, $$30, self = this;

      if ($iter) $Enumerable_each_cons$29.$$p = null;
      
      
      if ($iter) $Enumerable_each_cons$29.$$p = null;;
      if ($truthy(arguments.length != 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 1)")};
      n = $$($nesting, 'Opal').$try_convert(n, $$($nesting, 'Integer'), "to_int");
      if ($truthy(n <= 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid size")};
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_cons", n], ($$30 = function(){var self = $$30.$$s == null ? this : $$30.$$s, enum_size = nil, $ret_or_1 = nil;

        
          enum_size = self.$enumerator_size();
          if ($truthy(enum_size['$nil?']())) {
            return nil
          } else if ($truthy((function() {if ($truthy(($ret_or_1 = enum_size['$=='](0)))) {
            return $ret_or_1
          } else {
            return $rb_lt(enum_size, n)
          }; return nil; })())) {
            return 0
          } else {
            return $rb_plus($rb_minus(enum_size, n), 1)
          };}, $$30.$$s = self, $$30.$$arity = 0, $$30))
      };
      
      var buffer = [];

      self.$each.$$p = function() {
        var element = $$($nesting, 'Opal').$destructure(arguments);
        buffer.push(element);
        if (buffer.length > n) {
          buffer.shift();
        }
        if (buffer.length == n) {
          Opal.yield1(block, buffer.slice(0, n));
        }
      }

      self.$each();

      return nil;
    ;
    }, $Enumerable_each_cons$29.$$arity = 1);
    
    Opal.def(self, '$each_entry', $Enumerable_each_entry$31 = function $$each_entry($a) {
      var $iter = $Enumerable_each_entry$31.$$p, block = $iter || nil, $post_args, data, $$32, self = this;

      if ($iter) $Enumerable_each_entry$31.$$p = null;
      
      
      if ($iter) $Enumerable_each_entry$31.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      data = $post_args;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'to_enum', ["each_entry"].concat(Opal.to_a(data)), ($$32 = function(){var self = $$32.$$s == null ? this : $$32.$$s;

        return self.$enumerator_size()}, $$32.$$s = self, $$32.$$arity = 0, $$32))
      };
      
      self.$each.$$p = function() {
        var item = $$($nesting, 'Opal').$destructure(arguments);

        Opal.yield1(block, item);
      }

      self.$each.apply(self, data);

      return self;
    ;
    }, $Enumerable_each_entry$31.$$arity = -1);
    
    Opal.def(self, '$each_slice', $Enumerable_each_slice$33 = function $$each_slice(n) {
      var $iter = $Enumerable_each_slice$33.$$p, block = $iter || nil, $$34, self = this;

      if ($iter) $Enumerable_each_slice$33.$$p = null;
      
      
      if ($iter) $Enumerable_each_slice$33.$$p = null;;
      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(n <= 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid slice size")};
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_slice", n], ($$34 = function(){var self = $$34.$$s == null ? this : $$34.$$s;

        if ($truthy(self['$respond_to?']("size"))) {
            return $rb_divide(self.$size(), n).$ceil()
          } else {
            return nil
          }}, $$34.$$s = self, $$34.$$arity = 0, $$34))
      };
      
      var slice = []

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        slice.push(param);

        if (slice.length === n) {
          Opal.yield1(block, slice);
          slice = [];
        }
      };

      self.$each();

      // our "last" group, if smaller than n then won't have been yielded
      if (slice.length > 0) {
        Opal.yield1(block, slice);
      }
    ;
      return nil;
    }, $Enumerable_each_slice$33.$$arity = 1);
    
    Opal.def(self, '$each_with_index', $Enumerable_each_with_index$35 = function $$each_with_index($a) {
      var $iter = $Enumerable_each_with_index$35.$$p, block = $iter || nil, $post_args, args, $$36, self = this;

      if ($iter) $Enumerable_each_with_index$35.$$p = null;
      
      
      if ($iter) $Enumerable_each_with_index$35.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_index"].concat(Opal.to_a(args)), ($$36 = function(){var self = $$36.$$s == null ? this : $$36.$$s;

        return self.$enumerator_size()}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      
      var index = 0;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        block(param, index);

        index++;
      };

      self.$each.apply(self, args);
    ;
      return self;
    }, $Enumerable_each_with_index$35.$$arity = -1);
    
    Opal.def(self, '$each_with_object', $Enumerable_each_with_object$37 = function $$each_with_object(object) {
      var $iter = $Enumerable_each_with_object$37.$$p, block = $iter || nil, $$38, self = this;

      if ($iter) $Enumerable_each_with_object$37.$$p = null;
      
      
      if ($iter) $Enumerable_each_with_object$37.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_object", object], ($$38 = function(){var self = $$38.$$s == null ? this : $$38.$$s;

        return self.$enumerator_size()}, $$38.$$s = self, $$38.$$arity = 0, $$38))
      };
      
      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        block(param, object);
      };

      self.$each();
    ;
      return object;
    }, $Enumerable_each_with_object$37.$$arity = 1);
    
    Opal.def(self, '$entries', $Enumerable_entries$39 = function $$entries($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = [];

      self.$each.$$p = function() {
        result.push($$($nesting, 'Opal').$destructure(arguments));
      };

      self.$each.apply(self, args);

      return result;
    ;
    }, $Enumerable_entries$39.$$arity = -1);
    
    Opal.def(self, '$filter_map', $Enumerable_filter_map$40 = function $$filter_map() {
      var $iter = $Enumerable_filter_map$40.$$p, block = $iter || nil, $$41, self = this;

      if ($iter) $Enumerable_filter_map$40.$$p = null;
      
      
      if ($iter) $Enumerable_filter_map$40.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["filter_map"], ($$41 = function(){var self = $$41.$$s == null ? this : $$41.$$s;

        return self.$enumerator_size()}, $$41.$$s = self, $$41.$$arity = 0, $$41))
      };
      return $send($send(self, 'map', [], block.$to_proc()), 'select', [], "itself".$to_proc());
    }, $Enumerable_filter_map$40.$$arity = 0);
    Opal.alias(self, "find", "detect");
    
    Opal.def(self, '$find_all', $Enumerable_find_all$42 = function $$find_all() {
      var $iter = $Enumerable_find_all$42.$$p, block = $iter || nil, $$43, self = this;

      if ($iter) $Enumerable_find_all$42.$$p = null;
      
      
      if ($iter) $Enumerable_find_all$42.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["find_all"], ($$43 = function(){var self = $$43.$$s == null ? this : $$43.$$s;

        return self.$enumerator_size()}, $$43.$$s = self, $$43.$$arity = 0, $$43))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_find_all$42.$$arity = 0);
    Opal.alias(self, "filter", "find_all");
    
    Opal.def(self, '$find_index', $Enumerable_find_index$44 = function $$find_index(object) {try {

      var $iter = $Enumerable_find_index$44.$$p, block = $iter || nil, $$45, $$46, self = this, index = nil;

      if ($iter) $Enumerable_find_index$44.$$p = null;
      
      
      if ($iter) $Enumerable_find_index$44.$$p = null;;
      ;
      if ($truthy(object === undefined && block === nil)) {
        return self.$enum_for("find_index")};
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      index = 0;
      if ($truthy(object != null)) {
        $send(self, 'each', [], ($$45 = function($a){var self = $$45.$$s == null ? this : $$45.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($$($nesting, 'Opal').$destructure(value)['$=='](object)) {
            Opal.ret(index)};
          return index += 1;;}, $$45.$$s = self, $$45.$$arity = -1, $$45))
      } else {
        $send(self, 'each', [], ($$46 = function($a){var self = $$46.$$s == null ? this : $$46.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(index)};
          return index += 1;;}, $$46.$$s = self, $$46.$$arity = -1, $$46))
      };
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_find_index$44.$$arity = -1);
    
    Opal.def(self, '$first', $Enumerable_first$47 = function $$first(number) {try {

      var $$48, $$49, self = this, result = nil, current = nil;

      
      ;
      if ($truthy(number === undefined)) {
        return $send(self, 'each', [], ($$48 = function(value){var self = $$48.$$s == null ? this : $$48.$$s;

        
          
          if (value == null) {
            value = nil;
          };
          Opal.ret(value);}, $$48.$$s = self, $$48.$$arity = 1, $$48))
      } else {
        
        result = [];
        number = $coerce_to(number, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(number < 0)) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size")};
        if ($truthy(number == 0)) {
          return []};
        current = 0;
        $send(self, 'each', [], ($$49 = function($a){var self = $$49.$$s == null ? this : $$49.$$s, $post_args, args;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          result.push($$($nesting, 'Opal').$destructure(args));
          if ($truthy(number <= ++current)) {
            Opal.ret(result)
          } else {
            return nil
          };}, $$49.$$s = self, $$49.$$arity = -1, $$49));
        return result;
      };
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_first$47.$$arity = -1);
    Opal.alias(self, "flat_map", "collect_concat");
    
    Opal.def(self, '$grep', $Enumerable_grep$50 = function $$grep(pattern) {
      var $iter = $Enumerable_grep$50.$$p, block = $iter || nil, $$51, self = this, result = nil;

      if ($iter) $Enumerable_grep$50.$$p = null;
      
      
      if ($iter) $Enumerable_grep$50.$$p = null;;
      result = [];
      $send(self, 'each', [], ($$51 = function($a){var self = $$51.$$s == null ? this : $$51.$$s, $post_args, value, cmp = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat(Opal.to_a(cmp))))) {
        } else {
          return nil;
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]};
          value = Opal.yieldX(block, Opal.to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)};
        return result.$push(value);}, $$51.$$s = self, $$51.$$arity = -1, $$51));
      return result;
    }, $Enumerable_grep$50.$$arity = 1);
    
    Opal.def(self, '$grep_v', $Enumerable_grep_v$52 = function $$grep_v(pattern) {
      var $iter = $Enumerable_grep_v$52.$$p, block = $iter || nil, $$53, self = this, result = nil;

      if ($iter) $Enumerable_grep_v$52.$$p = null;
      
      
      if ($iter) $Enumerable_grep_v$52.$$p = null;;
      result = [];
      $send(self, 'each', [], ($$53 = function($a){var self = $$53.$$s == null ? this : $$53.$$s, $post_args, value, cmp = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat(Opal.to_a(cmp))))) {
          return nil;};
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]};
          value = Opal.yieldX(block, Opal.to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)};
        return result.$push(value);}, $$53.$$s = self, $$53.$$arity = -1, $$53));
      return result;
    }, $Enumerable_grep_v$52.$$arity = 1);
    
    Opal.def(self, '$group_by', $Enumerable_group_by$54 = function $$group_by() {
      var $iter = $Enumerable_group_by$54.$$p, block = $iter || nil, $$55, self = this, hash = nil, $ret_or_2 = nil, $writer = nil;

      if ($iter) $Enumerable_group_by$54.$$p = null;
      
      
      if ($iter) $Enumerable_group_by$54.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["group_by"], ($$55 = function(){var self = $$55.$$s == null ? this : $$55.$$s;

        return self.$enumerator_size()}, $$55.$$s = self, $$55.$$arity = 0, $$55))
      };
      hash = $hash2([], {});
      
      var result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        (function() {if ($truthy(($ret_or_2 = hash['$[]'](value)))) {
        return $ret_or_2
      } else {
        
        $writer = [value, []];
        $send(hash, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }; return nil; })()['$<<'](param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return hash;
    }, $Enumerable_group_by$54.$$arity = 0);
    
    Opal.def(self, '$include?', $Enumerable_include$ques$56 = function(obj) {try {

      var $$57, self = this;

      
      $send(self, 'each', [], ($$57 = function($a){var self = $$57.$$s == null ? this : $$57.$$s, $post_args, args;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        if ($$($nesting, 'Opal').$destructure(args)['$=='](obj)) {
          Opal.ret(true)
        } else {
          return nil
        };}, $$57.$$s = self, $$57.$$arity = -1, $$57));
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_include$ques$56.$$arity = 1);
    
    Opal.def(self, '$inject', $Enumerable_inject$58 = function $$inject(object, sym) {
      var $iter = $Enumerable_inject$58.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_inject$58.$$p = null;
      
      
      if ($iter) $Enumerable_inject$58.$$p = null;;
      ;
      ;
      
      var result = object;

      if (block !== nil && sym === undefined) {
        self.$each.$$p = function() {
          var value = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          value = Opal.yieldX(block, [result, value]);

          result = value;
        };
      }
      else {
        if (sym === undefined) {
          if (!$$($nesting, 'Symbol')['$==='](object)) {
            self.$raise($$($nesting, 'TypeError'), "" + (object.$inspect()) + " is not a Symbol");
          }

          sym    = object;
          result = undefined;
        }

        self.$each.$$p = function() {
          var value = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          result = (result).$__send__(sym, value);
        };
      }

      self.$each();

      return result == undefined ? nil : result;
    ;
    }, $Enumerable_inject$58.$$arity = -1);
    
    Opal.def(self, '$lazy', $Enumerable_lazy$59 = function $$lazy() {
      var $$60, self = this;

      return $send($$$($$($nesting, 'Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], ($$60 = function(enum$, $a){var self = $$60.$$s == null ? this : $$60.$$s, $post_args, args;

      
        
        if (enum$ == null) {
          enum$ = nil;
        };
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        args = $post_args;;
        return $send(enum$, 'yield', Opal.to_a(args));}, $$60.$$s = self, $$60.$$arity = -2, $$60))
    }, $Enumerable_lazy$59.$$arity = 0);
    
    Opal.def(self, '$enumerator_size', $Enumerable_enumerator_size$61 = function $$enumerator_size() {
      var self = this;

      if ($truthy(self['$respond_to?']("size"))) {
        return self.$size()
      } else {
        return nil
      }
    }, $Enumerable_enumerator_size$61.$$arity = 0);
    Opal.alias(self, "map", "collect");
    
    Opal.def(self, '$max', $Enumerable_max$62 = function $$max(n) {
      var $iter = $Enumerable_max$62.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_max$62.$$p = null;
      
      
      if ($iter) $Enumerable_max$62.$$p = null;;
      ;
      
      if (n === undefined || n === nil) {
        var result, value;

        self.$each.$$p = function() {
          var item = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = item;
            return;
          }

          if (block !== nil) {
            value = Opal.yieldX(block, [item, result]);
          } else {
            value = (item)['$<=>'](result);
          }

          if (value === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value > 0) {
            result = item;
          }
        }

        self.$each();

        if (result === undefined) {
          return nil;
        } else {
          return result;
        }
      }

      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
    ;
      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
    }, $Enumerable_max$62.$$arity = -1);
    
    Opal.def(self, '$max_by', $Enumerable_max_by$63 = function $$max_by(n) {
      var $iter = $Enumerable_max_by$63.$$p, block = $iter || nil, $$64, self = this;

      if ($iter) $Enumerable_max_by$63.$$p = null;
      
      
      if ($iter) $Enumerable_max_by$63.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["max_by", n], ($$64 = function(){var self = $$64.$$s == null ? this : $$64.$$s;

        return self.$enumerator_size()}, $$64.$$s = self, $$64.$$arity = 0, $$64))
      };
      if ($truthy(n['$nil?']())) {
      } else {
        return $send(self, 'sort_by', [], block.$to_proc()).$reverse().$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) > 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_max_by$63.$$arity = -1);
    Opal.alias(self, "member?", "include?");
    
    Opal.def(self, '$min', $Enumerable_min$65 = function $$min(n) {
      var $iter = $Enumerable_min$65.$$p, block = $iter || nil, $$66, self = this;

      if ($iter) $Enumerable_min$65.$$p = null;
      
      
      if ($iter) $Enumerable_min$65.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ($truthy(n['$nil?']())) {
      } else if ((block !== nil)) {
        return $send(self, 'sort', [], ($$66 = function(a, b){var self = $$66.$$s == null ? this : $$66.$$s;

        
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          return Opal.yieldX(block, [a, b]);;}, $$66.$$s = self, $$66.$$arity = 2, $$66)).$take(n)
      } else {
        return self.$sort().$take(n)
      };
      
      var result;

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          var value = block(param, result);

          if (value === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value < 0) {
            result = param;
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          if ($$($nesting, 'Opal').$compare(param, result) < 0) {
            result = param;
          }
        };
      }

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_min$65.$$arity = -1);
    
    Opal.def(self, '$min_by', $Enumerable_min_by$67 = function $$min_by(n) {
      var $iter = $Enumerable_min_by$67.$$p, block = $iter || nil, $$68, self = this;

      if ($iter) $Enumerable_min_by$67.$$p = null;
      
      
      if ($iter) $Enumerable_min_by$67.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["min_by", n], ($$68 = function(){var self = $$68.$$s == null ? this : $$68.$$s;

        return self.$enumerator_size()}, $$68.$$s = self, $$68.$$arity = 0, $$68))
      };
      if ($truthy(n['$nil?']())) {
      } else {
        return $send(self, 'sort_by', [], block.$to_proc()).$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) < 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_min_by$67.$$arity = -1);
    
    Opal.def(self, '$minmax', $Enumerable_minmax$69 = function $$minmax() {
      var $iter = $Enumerable_minmax$69.$$p, block = $iter || nil, $$70, self = this, $ret_or_3 = nil;

      if ($iter) $Enumerable_minmax$69.$$p = null;
      
      
      if ($iter) $Enumerable_minmax$69.$$p = null;;
      block = (function() {if ($truthy(($ret_or_3 = block))) {
        return $ret_or_3
      } else {
        return $send(self, 'proc', [], ($$70 = function(a, b){var self = $$70.$$s == null ? this : $$70.$$s;

        
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          return a['$<=>'](b);}, $$70.$$s = self, $$70.$$arity = 2, $$70))
      }; return nil; })();
      
      var min = nil, max = nil, first_time = true;

      self.$each.$$p = function() {
        var element = $$($nesting, 'Opal').$destructure(arguments);
        if (first_time) {
          min = max = element;
          first_time = false;
        } else {
          var min_cmp = block.$call(min, element);

          if (min_cmp === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed")
          } else if (min_cmp > 0) {
            min = element;
          }

          var max_cmp = block.$call(max, element);

          if (max_cmp === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed")
          } else if (max_cmp < 0) {
            max = element;
          }
        }
      }

      self.$each();

      return [min, max];
    ;
    }, $Enumerable_minmax$69.$$arity = 0);
    
    Opal.def(self, '$minmax_by', $Enumerable_minmax_by$71 = function $$minmax_by() {
      var $iter = $Enumerable_minmax_by$71.$$p, block = $iter || nil, $$72, self = this;

      if ($iter) $Enumerable_minmax_by$71.$$p = null;
      
      
      if ($iter) $Enumerable_minmax_by$71.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["minmax_by"], ($$72 = function(){var self = $$72.$$s == null ? this : $$72.$$s;

        return self.$enumerator_size()}, $$72.$$s = self, $$72.$$arity = 0, $$72))
      };
      
      var min_result = nil,
          max_result = nil,
          min_by,
          max_by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ((min_by === undefined) || (value)['$<=>'](min_by) < 0) {
          min_result = param;
          min_by     = value;
        }

        if ((max_by === undefined) || (value)['$<=>'](max_by) > 0) {
          max_result = param;
          max_by     = value;
        }
      };

      self.$each();

      return [min_result, max_result];
    ;
    }, $Enumerable_minmax_by$71.$$arity = 0);
    
    Opal.def(self, '$none?', $Enumerable_none$ques$73 = function(pattern) {try {

      var $iter = $Enumerable_none$ques$73.$$p, block = $iter || nil, $$74, $$75, $$76, self = this;

      if ($iter) $Enumerable_none$ques$73.$$p = null;
      
      
      if ($iter) $Enumerable_none$ques$73.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$74 = function($a){var self = $$74.$$s == null ? this : $$74.$$s, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$74.$$s = self, $$74.$$arity = -1, $$74))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$75 = function($a){var self = $$75.$$s == null ? this : $$75.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$75.$$s = self, $$75.$$arity = -1, $$75))
      } else {
        $send(self, 'each', [], ($$76 = function($a){var self = $$76.$$s == null ? this : $$76.$$s, $post_args, value, item = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          item = $$($nesting, 'Opal').$destructure(value);
          if ($truthy(item)) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$76.$$s = self, $$76.$$arity = -1, $$76))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_none$ques$73.$$arity = -1);
    
    Opal.def(self, '$one?', $Enumerable_one$ques$77 = function(pattern) {try {

      var $iter = $Enumerable_one$ques$77.$$p, block = $iter || nil, $$78, $$79, $$80, self = this, count = nil;

      if ($iter) $Enumerable_one$ques$77.$$p = null;
      
      
      if ($iter) $Enumerable_one$ques$77.$$p = null;;
      ;
      count = 0;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$78 = function($a){var self = $$78.$$s == null ? this : $$78.$$s, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              Opal.ret(false)
            } else {
              return nil
            };
          } else {
            return nil
          };}, $$78.$$s = self, $$78.$$arity = -1, $$78))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$79 = function($a){var self = $$79.$$s == null ? this : $$79.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
          } else {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$79.$$s = self, $$79.$$arity = -1, $$79))
      } else {
        $send(self, 'each', [], ($$80 = function($a){var self = $$80.$$s == null ? this : $$80.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
          } else {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$80.$$s = self, $$80.$$arity = -1, $$80))
      };
      return count['$=='](1);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_one$ques$77.$$arity = -1);
    
    Opal.def(self, '$partition', $Enumerable_partition$81 = function $$partition() {
      var $iter = $Enumerable_partition$81.$$p, block = $iter || nil, $$82, self = this;

      if ($iter) $Enumerable_partition$81.$$p = null;
      
      
      if ($iter) $Enumerable_partition$81.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["partition"], ($$82 = function(){var self = $$82.$$s == null ? this : $$82.$$s;

        return self.$enumerator_size()}, $$82.$$s = self, $$82.$$arity = 0, $$82))
      };
      
      var truthy = [], falsy = [], result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          truthy.push(param);
        }
        else {
          falsy.push(param);
        }
      };

      self.$each();

      return [truthy, falsy];
    ;
    }, $Enumerable_partition$81.$$arity = 0);
    Opal.alias(self, "reduce", "inject");
    
    Opal.def(self, '$reject', $Enumerable_reject$83 = function $$reject() {
      var $iter = $Enumerable_reject$83.$$p, block = $iter || nil, $$84, self = this;

      if ($iter) $Enumerable_reject$83.$$p = null;
      
      
      if ($iter) $Enumerable_reject$83.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$84 = function(){var self = $$84.$$s == null ? this : $$84.$$s;

        return self.$enumerator_size()}, $$84.$$s = self, $$84.$$arity = 0, $$84))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($falsy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_reject$83.$$arity = 0);
    
    Opal.def(self, '$reverse_each', $Enumerable_reverse_each$85 = function $$reverse_each() {
      var $iter = $Enumerable_reverse_each$85.$$p, block = $iter || nil, $$86, self = this;

      if ($iter) $Enumerable_reverse_each$85.$$p = null;
      
      
      if ($iter) $Enumerable_reverse_each$85.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reverse_each"], ($$86 = function(){var self = $$86.$$s == null ? this : $$86.$$s;

        return self.$enumerator_size()}, $$86.$$s = self, $$86.$$arity = 0, $$86))
      };
      
      var result = [];

      self.$each.$$p = function() {
        result.push(arguments);
      };

      self.$each();

      for (var i = result.length - 1; i >= 0; i--) {
        Opal.yieldX(block, result[i]);
      }

      return result;
    ;
    }, $Enumerable_reverse_each$85.$$arity = 0);
    Opal.alias(self, "select", "find_all");
    
    Opal.def(self, '$slice_before', $Enumerable_slice_before$87 = function $$slice_before(pattern) {
      var $iter = $Enumerable_slice_before$87.$$p, block = $iter || nil, $$88, self = this;

      if ($iter) $Enumerable_slice_before$87.$$p = null;
      
      
      if ($iter) $Enumerable_slice_before$87.$$p = null;;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$88 = function(e){var self = $$88.$$s == null ? this : $$88.$$s;

      
        
        if (e == null) {
          e = nil;
        };
        
        var slice = [];

        if (block !== nil) {
          if (pattern === undefined) {
            self.$each.$$p = function() {
              var param = $$($nesting, 'Opal').$destructure(arguments),
                  value = Opal.yield1(block, param);

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
          else {
            self.$each.$$p = function() {
              var param = $$($nesting, 'Opal').$destructure(arguments),
                  value = block(param, pattern.$dup());

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
        }
        else {
          self.$each.$$p = function() {
            var param = $$($nesting, 'Opal').$destructure(arguments),
                value = pattern['$==='](param);

            if ($truthy(value) && slice.length > 0) {
              e['$<<'](slice);
              slice = [];
            }

            slice.push(param);
          };
        }

        self.$each();

        if (slice.length > 0) {
          e['$<<'](slice);
        }
      ;}, $$88.$$s = self, $$88.$$arity = 1, $$88));
    }, $Enumerable_slice_before$87.$$arity = -1);
    
    Opal.def(self, '$slice_after', $Enumerable_slice_after$89 = function $$slice_after(pattern) {
      var $iter = $Enumerable_slice_after$89.$$p, block = $iter || nil, $$90, $$91, self = this;

      if ($iter) $Enumerable_slice_after$89.$$p = null;
      
      
      if ($iter) $Enumerable_slice_after$89.$$p = null;;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      if ($truthy(pattern !== undefined)) {
        block = $send(self, 'proc', [], ($$90 = function(e){var self = $$90.$$s == null ? this : $$90.$$s;

        
          
          if (e == null) {
            e = nil;
          };
          return pattern['$==='](e);}, $$90.$$s = self, $$90.$$arity = 1, $$90))};
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$91 = function(yielder){var self = $$91.$$s == null ? this : $$91.$$s;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var accumulate;

        self.$each.$$p = function() {
          var element = $$($nesting, 'Opal').$destructure(arguments),
              end_chunk = Opal.yield1(block, element);

          if (accumulate == null) {
            accumulate = [];
          }

          if ($truthy(end_chunk)) {
            accumulate.push(element);
            yielder.$yield(accumulate);
            accumulate = null;
          } else {
            accumulate.push(element)
          }
        }

        self.$each();

        if (accumulate != null) {
          yielder.$yield(accumulate);
        }
      ;}, $$91.$$s = self, $$91.$$arity = 1, $$91));
    }, $Enumerable_slice_after$89.$$arity = -1);
    
    Opal.def(self, '$slice_when', $Enumerable_slice_when$92 = function $$slice_when() {
      var $iter = $Enumerable_slice_when$92.$$p, block = $iter || nil, $$93, self = this;

      if ($iter) $Enumerable_slice_when$92.$$p = null;
      
      
      if ($iter) $Enumerable_slice_when$92.$$p = null;;
      if ((block !== nil)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1)")
      };
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$93 = function(yielder){var self = $$93.$$s == null ? this : $$93.$$s;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var slice = nil, last_after = nil;

        self.$each_cons.$$p = function() {
          var params = $$($nesting, 'Opal').$destructure(arguments),
              before = params[0],
              after = params[1],
              match = Opal.yieldX(block, [before, after]);

          last_after = after;

          if (slice === nil) {
            slice = [];
          }

          if ($truthy(match)) {
            slice.push(before);
            yielder.$yield(slice);
            slice = [];
          } else {
            slice.push(before);
          }
        }

        self.$each_cons(2);

        if (slice !== nil) {
          slice.push(last_after);
          yielder.$yield(slice);
        }
      ;}, $$93.$$s = self, $$93.$$arity = 1, $$93));
    }, $Enumerable_slice_when$92.$$arity = 0);
    
    Opal.def(self, '$sort', $Enumerable_sort$94 = function $$sort() {
      var $iter = $Enumerable_sort$94.$$p, block = $iter || nil, $$95, self = this, ary = nil;

      if ($iter) $Enumerable_sort$94.$$p = null;
      
      
      if ($iter) $Enumerable_sort$94.$$p = null;;
      ary = self.$to_a();
      if ((block !== nil)) {
      } else {
        block = $lambda(($$95 = function(a, b){var self = $$95.$$s == null ? this : $$95.$$s;

        
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          return a['$<=>'](b);}, $$95.$$s = self, $$95.$$arity = 2, $$95))
      };
      return $send(ary, 'sort', [], block.$to_proc());
    }, $Enumerable_sort$94.$$arity = 0);
    
    Opal.def(self, '$sort_by', $Enumerable_sort_by$96 = function $$sort_by() {
      var $iter = $Enumerable_sort_by$96.$$p, block = $iter || nil, $$97, $$98, $$99, $$100, self = this, dup = nil;

      if ($iter) $Enumerable_sort_by$96.$$p = null;
      
      
      if ($iter) $Enumerable_sort_by$96.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["sort_by"], ($$97 = function(){var self = $$97.$$s == null ? this : $$97.$$s;

        return self.$enumerator_size()}, $$97.$$s = self, $$97.$$arity = 0, $$97))
      };
      dup = $send(self, 'map', [], ($$98 = function(){var self = $$98.$$s == null ? this : $$98.$$s, arg = nil;

      
        arg = $$($nesting, 'Opal').$destructure(arguments);
        return [Opal.yield1(block, arg), arg];}, $$98.$$s = self, $$98.$$arity = 0, $$98));
      $send(dup, 'sort!', [], ($$99 = function(a, b){var self = $$99.$$s == null ? this : $$99.$$s;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return (a[0])['$<=>'](b[0]);}, $$99.$$s = self, $$99.$$arity = 2, $$99));
      return $send(dup, 'map!', [], ($$100 = function(i){var self = $$100.$$s == null ? this : $$100.$$s;

      
        
        if (i == null) {
          i = nil;
        };
        return i[1];;}, $$100.$$s = self, $$100.$$arity = 1, $$100));
    }, $Enumerable_sort_by$96.$$arity = 0);
    
    Opal.def(self, '$sum', $Enumerable_sum$101 = function $$sum(initial) {
      var $$102, $iter = $Enumerable_sum$101.$$p, $yield = $iter || nil, self = this, result = nil;

      if ($iter) $Enumerable_sum$101.$$p = null;
      
      
      if (initial == null) {
        initial = 0;
      };
      result = initial;
      $send(self, 'each', [], ($$102 = function($a){var self = $$102.$$s == null ? this : $$102.$$s, $post_args, args, item = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        item = (function() {if (($yield !== nil)) {
          return Opal.yieldX($yield, Opal.to_a(args));
        } else {
          return $$($nesting, 'Opal').$destructure(args)
        }; return nil; })();
        return (result = $rb_plus(result, item));}, $$102.$$s = self, $$102.$$arity = -1, $$102));
      return result;
    }, $Enumerable_sum$101.$$arity = -1);
    
    Opal.def(self, '$take', $Enumerable_take$103 = function $$take(num) {
      var self = this;

      return self.$first(num)
    }, $Enumerable_take$103.$$arity = 1);
    
    Opal.def(self, '$take_while', $Enumerable_take_while$104 = function $$take_while() {try {

      var $iter = $Enumerable_take_while$104.$$p, block = $iter || nil, $$105, self = this, result = nil;

      if ($iter) $Enumerable_take_while$104.$$p = null;
      
      
      if ($iter) $Enumerable_take_while$104.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("take_while")
      };
      result = [];
      return $send(self, 'each', [], ($$105 = function($a){var self = $$105.$$s == null ? this : $$105.$$s, $post_args, args, value = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
        } else {
          Opal.ret(result)
        };
        return result.push(value);;}, $$105.$$s = self, $$105.$$arity = -1, $$105));
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_take_while$104.$$arity = 0);
    
    Opal.def(self, '$uniq', $Enumerable_uniq$106 = function $$uniq() {
      var $iter = $Enumerable_uniq$106.$$p, block = $iter || nil, $$107, self = this, hash = nil;

      if ($iter) $Enumerable_uniq$106.$$p = null;
      
      
      if ($iter) $Enumerable_uniq$106.$$p = null;;
      hash = $hash2([], {});
      $send(self, 'each', [], ($$107 = function($a){var self = $$107.$$s == null ? this : $$107.$$s, $post_args, args, value = nil, produced = nil, $writer = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        produced = (function() {if ((block !== nil)) {
          return Opal.yield1(block, value);
        } else {
          return value
        }; return nil; })();
        if ($truthy(hash['$key?'](produced))) {
          return nil
        } else {
          
          $writer = [produced, value];
          $send(hash, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        };}, $$107.$$s = self, $$107.$$arity = -1, $$107));
      return hash.$values();
    }, $Enumerable_uniq$106.$$arity = 0);
    
    Opal.def(self, '$tally', $Enumerable_tally$108 = function $$tally() {
      var self = this;

      return $send($send(self, 'group_by', [], "itself".$to_proc()), 'transform_values', [], "count".$to_proc())
    }, $Enumerable_tally$108.$$arity = 0);
    Opal.alias(self, "to_a", "entries");
    
    Opal.def(self, '$to_h', $Enumerable_to_h$109 = function $$to_h($a) {
      var $iter = $Enumerable_to_h$109.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Enumerable_to_h$109.$$p = null;
      
      
      if ($iter) $Enumerable_to_h$109.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', Opal.to_a(args))};
      
      var hash = $hash2([], {});

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);
        var ary = $$($nesting, 'Opal')['$coerce_to?'](param, $$($nesting, 'Array'), "to_ary"), key, val;
        if (!ary.$$is_array) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong element type " + ((ary).$class()) + " (expected array)")
        }
        if (ary.length !== 2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong array length (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];

        Opal.hash_put(hash, key, val);
      };

      self.$each.apply(self, args);

      return hash;
    ;
    }, $Enumerable_to_h$109.$$arity = -1);
    return (Opal.def(self, '$zip', $Enumerable_zip$110 = function $$zip($a) {
      var $iter = $Enumerable_zip$110.$$p, block = $iter || nil, $post_args, others, self = this;

      if ($iter) $Enumerable_zip$110.$$p = null;
      
      
      if ($iter) $Enumerable_zip$110.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      return $send(self.$to_a(), 'zip', Opal.to_a(others));
    }, $Enumerable_zip$110.$$arity = -1), nil) && 'zip';
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/enumerator"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $breaker = Opal.breaker, $slice = Opal.slice, $falsy = Opal.falsy, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send = Opal.send, $send2 = Opal.send2;

  Opal.add_stubs(['$require', '$include', '$allocate', '$new', '$to_proc', '$!', '$respond_to?', '$nil?', '$empty?', '$+', '$class', '$__send__', '$call', '$enum_for', '$size', '$destructure', '$inspect', '$any?', '$[]', '$raise', '$yield', '$each', '$enumerator_size', '$try_convert', '$<', '$===', '$for']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting), $Enumerator_for$1, $Enumerator_initialize$2, $Enumerator_each$3, $Enumerator_size$4, $Enumerator_with_index$5, $Enumerator_each_with_index$7, $Enumerator_inspect$9;

    self.$$prototype.size = self.$$prototype.args = self.$$prototype.object = self.$$prototype.method = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_enumerator = true;
    Opal.defs(self, '$for', $Enumerator_for$1 = function(object, $a, $b) {
      var $iter = $Enumerator_for$1.$$p, block = $iter || nil, $post_args, method, args, self = this;

      if ($iter) $Enumerator_for$1.$$p = null;
      
      
      if ($iter) $Enumerator_for$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      if ($post_args.length > 0) {
        method = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (method == null) {
        method = "each";
      };
      
      args = $post_args;;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;

      return obj;
    ;
    }, $Enumerator_for$1.$$arity = -2);
    
    Opal.def(self, '$initialize', $Enumerator_initialize$2 = function $$initialize($a) {
      var $iter = $Enumerator_initialize$2.$$p, block = $iter || nil, $post_args, self = this, $ret_or_1 = nil;

      if ($iter) $Enumerator_initialize$2.$$p = null;
      
      
      if ($iter) $Enumerator_initialize$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      if ($truthy(block)) {
        
        self.object = $send($$($nesting, 'Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if ($truthy((function() {if ($truthy(($ret_or_1 = self.size))) {
          return self.size['$respond_to?']("call")['$!']()
        } else {
          return $ret_or_1
        }; return nil; })())) {
          return (self.size = $coerce_to(self.size, $$($nesting, 'Integer'), 'to_int'))
        } else {
          return nil
        };
      } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice.call(arguments, 2);
        return (self.size = nil);
      };
    }, $Enumerator_initialize$2.$$arity = -1);
    
    Opal.def(self, '$each', $Enumerator_each$3 = function $$each($a) {
      var $iter = $Enumerator_each$3.$$p, block = $iter || nil, $post_args, args, self = this, $ret_or_2 = nil;

      if ($iter) $Enumerator_each$3.$$p = null;
      
      
      if ($iter) $Enumerator_each$3.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_2 = block['$nil?']()))) {
        return args['$empty?']()
      } else {
        return $ret_or_2
      }; return nil; })())) {
        return self};
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat(Opal.to_a(args)))};
      return $send(self.object, '__send__', [self.method].concat(Opal.to_a(args)), block.$to_proc());
    }, $Enumerator_each$3.$$arity = -1);
    
    Opal.def(self, '$size', $Enumerator_size$4 = function $$size() {
      var self = this;

      if ($truthy(self.size['$respond_to?']("call"))) {
        return $send(self.size, 'call', Opal.to_a(self.args))
      } else {
        return self.size
      }
    }, $Enumerator_size$4.$$arity = 0);
    
    Opal.def(self, '$with_index', $Enumerator_with_index$5 = function $$with_index(offset) {
      var $iter = $Enumerator_with_index$5.$$p, block = $iter || nil, $$6, self = this;

      if ($iter) $Enumerator_with_index$5.$$p = null;
      
      
      if ($iter) $Enumerator_with_index$5.$$p = null;;
      
      if (offset == null) {
        offset = 0;
      };
      offset = (function() {if ($truthy(offset)) {
        return $coerce_to(offset, $$($nesting, 'Integer'), 'to_int')
      } else {
        return 0
      }; return nil; })();
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["with_index", offset], ($$6 = function(){var self = $$6.$$s == null ? this : $$6.$$s;

        return self.$size()}, $$6.$$s = self, $$6.$$arity = 0, $$6))
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, $Enumerator_with_index$5.$$arity = -1);
    Opal.alias(self, "with_object", "each_with_object");
    
    Opal.def(self, '$each_with_index', $Enumerator_each_with_index$7 = function $$each_with_index() {
      var $iter = $Enumerator_each_with_index$7.$$p, block = $iter || nil, $$8, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Enumerator_each_with_index$7.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Enumerator_each_with_index$7.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_index"], ($$8 = function(){var self = $$8.$$s == null ? this : $$8.$$s;

        return self.$size()}, $$8.$$s = self, $$8.$$arity = 0, $$8))
      };
      $send2(self, Opal.find_super_dispatcher(self, 'each_with_index', $Enumerator_each_with_index$7, false, true), 'each_with_index', $zuper, $iter);
      return self.object;
    }, $Enumerator_each_with_index$7.$$arity = 0);
    
    Opal.def(self, '$inspect', $Enumerator_inspect$9 = function $$inspect() {
      var self = this, result = nil;

      
      result = "" + "#<" + (self.$class()) + ": " + (self.object.$inspect()) + ":" + (self.method);
      if ($truthy(self.args['$any?']())) {
        result = $rb_plus(result, "" + "(" + (self.args.$inspect()['$[]']($$($nesting, 'Range').$new(1, -2))) + ")")};
      return $rb_plus(result, ">");
    }, $Enumerator_inspect$9.$$arity = 0);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $Generator_initialize$10, $Generator_each$11;

      self.$$prototype.block = nil;
      
      self.$include($$($nesting, 'Enumerable'));
      
      Opal.def(self, '$initialize', $Generator_initialize$10 = function $$initialize() {
        var $iter = $Generator_initialize$10.$$p, block = $iter || nil, self = this;

        if ($iter) $Generator_initialize$10.$$p = null;
        
        
        if ($iter) $Generator_initialize$10.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'LocalJumpError'), "no block given")
        };
        return (self.block = block);
      }, $Generator_initialize$10.$$arity = 0);
      return (Opal.def(self, '$each', $Generator_each$11 = function $$each($a) {
        var $iter = $Generator_each$11.$$p, block = $iter || nil, $post_args, args, self = this, yielder = nil;

        if ($iter) $Generator_each$11.$$p = null;
        
        
        if ($iter) $Generator_each$11.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        yielder = $send($$($nesting, 'Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e === $breaker) {
            return $breaker.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, $Generator_each$11.$$arity = -1), nil) && 'each';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Yielder');

      var $nesting = [self].concat($parent_nesting), $Yielder_initialize$12, $Yielder_yield$13, $Yielder_$lt$lt$14;

      self.$$prototype.block = nil;
      
      
      Opal.def(self, '$initialize', $Yielder_initialize$12 = function $$initialize() {
        var $iter = $Yielder_initialize$12.$$p, block = $iter || nil, self = this;

        if ($iter) $Yielder_initialize$12.$$p = null;
        
        
        if ($iter) $Yielder_initialize$12.$$p = null;;
        return (self.block = block);
      }, $Yielder_initialize$12.$$arity = 0);
      
      Opal.def(self, '$yield', $Yielder_yield$13 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        
        var value = Opal.yieldX(self.block, values);

        if (value === $breaker) {
          throw $breaker;
        }

        return value;
      ;
      }, $Yielder_yield$13.$$arity = -1);
      return (Opal.def(self, '$<<', $Yielder_$lt$lt$14 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        $send(self, 'yield', Opal.to_a(values));
        return self;
      }, $Yielder_$lt$lt$14.$$arity = -1), nil) && '<<';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Lazy');

      var $nesting = [self].concat($parent_nesting), $Lazy_initialize$15, $Lazy_lazy$18, $Lazy_collect$19, $Lazy_collect_concat$21, $Lazy_drop$25, $Lazy_drop_while$27, $Lazy_enum_for$29, $Lazy_find_all$30, $Lazy_grep$32, $Lazy_reject$35, $Lazy_take$37, $Lazy_take_while$39, $Lazy_inspect$41;

      self.$$prototype.enumerator = nil;
      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StopLazyError');

        var $nesting = [self].concat($parent_nesting);

        return nil
      })($nesting[0], $$($nesting, 'Exception'), $nesting);
      
      Opal.def(self, '$initialize', $Lazy_initialize$15 = function $$initialize(object, size) {
        var $iter = $Lazy_initialize$15.$$p, block = $iter || nil, $$16, self = this;

        if ($iter) $Lazy_initialize$15.$$p = null;
        
        
        if ($iter) $Lazy_initialize$15.$$p = null;;
        
        if (size == null) {
          size = nil;
        };
        if ((block !== nil)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send2(self, Opal.find_super_dispatcher(self, 'initialize', $Lazy_initialize$15, false, true), 'initialize', [size], ($$16 = function(yielder, $a){var self = $$16.$$s == null ? this : $$16.$$s, $post_args, each_args, $$17;

        
          
          if (yielder == null) {
            yielder = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          each_args = $post_args;;
          try {
            return $send(object, 'each', Opal.to_a(each_args), ($$17 = function($b){var self = $$17.$$s == null ? this : $$17.$$s, $post_args, args;

            
              
              $post_args = Opal.slice.call(arguments, 0, arguments.length);
              
              args = $post_args;;
              
            args.unshift(yielder);

            Opal.yieldX(block, args);
          ;}, $$17.$$s = self, $$17.$$arity = -1, $$17))
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, 'Exception')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          };}, $$16.$$s = self, $$16.$$arity = -2, $$16));
      }, $Lazy_initialize$15.$$arity = -2);
      Opal.alias(self, "force", "to_a");
      
      Opal.def(self, '$lazy', $Lazy_lazy$18 = function $$lazy() {
        var self = this;

        return self
      }, $Lazy_lazy$18.$$arity = 0);
      
      Opal.def(self, '$collect', $Lazy_collect$19 = function $$collect() {
        var $iter = $Lazy_collect$19.$$p, block = $iter || nil, $$20, self = this;

        if ($iter) $Lazy_collect$19.$$p = null;
        
        
        if ($iter) $Lazy_collect$19.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, self.$enumerator_size()], ($$20 = function(enum$, $a){var self = $$20.$$s == null ? this : $$20.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          enum$.$yield(value);
        ;}, $$20.$$s = self, $$20.$$arity = -2, $$20));
      }, $Lazy_collect$19.$$arity = 0);
      
      Opal.def(self, '$collect_concat', $Lazy_collect_concat$21 = function $$collect_concat() {
        var $iter = $Lazy_collect_concat$21.$$p, block = $iter || nil, $$22, self = this;

        if ($iter) $Lazy_collect_concat$21.$$p = null;
        
        
        if ($iter) $Lazy_collect_concat$21.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$22 = function(enum$, $a){var self = $$22.$$s == null ? this : $$22.$$s, $post_args, args, $$23, $$24;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], ($$23 = function(v){var self = $$23.$$s == null ? this : $$23.$$s;

          
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$23.$$s = self, $$23.$$arity = 1, $$23))
          }
          else {
            var array = $$($nesting, 'Opal').$try_convert(value, $$($nesting, 'Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], ($$24 = function(v){var self = $$24.$$s == null ? this : $$24.$$s;

          
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$24.$$s = self, $$24.$$arity = 1, $$24));
            }
          }
        ;}, $$22.$$s = self, $$22.$$arity = -2, $$22));
      }, $Lazy_collect_concat$21.$$arity = 0);
      
      Opal.def(self, '$drop', $Lazy_drop$25 = function $$drop(n) {
        var $$26, self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        dropped = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$26 = function(enum$, $a){var self = $$26.$$s == null ? this : $$26.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$26.$$s = self, $$26.$$arity = -2, $$26));
      }, $Lazy_drop$25.$$arity = 1);
      
      Opal.def(self, '$drop_while', $Lazy_drop_while$27 = function $$drop_while() {
        var $iter = $Lazy_drop_while$27.$$p, block = $iter || nil, $$28, self = this, succeeding = nil;

        if ($iter) $Lazy_drop_while$27.$$p = null;
        
        
        if ($iter) $Lazy_drop_while$27.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$28 = function(enum$, $a){var self = $$28.$$s == null ? this : $$28.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy(succeeding)) {
            
            var value = Opal.yieldX(block, args);

            if ($falsy(value)) {
              succeeding = false;

              $send(enum$, 'yield', Opal.to_a(args));
            }
          
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$28.$$s = self, $$28.$$arity = -2, $$28));
      }, $Lazy_drop_while$27.$$arity = 0);
      
      Opal.def(self, '$enum_for', $Lazy_enum_for$29 = function $$enum_for($a, $b) {
        var $iter = $Lazy_enum_for$29.$$p, block = $iter || nil, $post_args, method, args, self = this;

        if ($iter) $Lazy_enum_for$29.$$p = null;
        
        
        if ($iter) $Lazy_enum_for$29.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        if ($post_args.length > 0) {
          method = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (method == null) {
          method = "each";
        };
        
        args = $post_args;;
        return $send(self.$class(), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc());
      }, $Lazy_enum_for$29.$$arity = -1);
      Opal.alias(self, "filter", "find_all");
      
      Opal.def(self, '$find_all', $Lazy_find_all$30 = function $$find_all() {
        var $iter = $Lazy_find_all$30.$$p, block = $iter || nil, $$31, self = this;

        if ($iter) $Lazy_find_all$30.$$p = null;
        
        
        if ($iter) $Lazy_find_all$30.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy select without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$31 = function(enum$, $a){var self = $$31.$$s == null ? this : $$31.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$31.$$s = self, $$31.$$arity = -2, $$31));
      }, $Lazy_find_all$30.$$arity = 0);
      Opal.alias(self, "flat_map", "collect_concat");
      
      Opal.def(self, '$grep', $Lazy_grep$32 = function $$grep(pattern) {
        var $iter = $Lazy_grep$32.$$p, block = $iter || nil, $$33, $$34, self = this;

        if ($iter) $Lazy_grep$32.$$p = null;
        
        
        if ($iter) $Lazy_grep$32.$$p = null;;
        if ($truthy(block)) {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$33 = function(enum$, $a){var self = $$33.$$s == null ? this : $$33.$$s, $post_args, args;

          
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = Opal.yield1(block, param);

              enum$.$yield(Opal.yield1(block, param));
            }
          ;}, $$33.$$s = self, $$33.$$arity = -2, $$33))
        } else {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$34 = function(enum$, $a){var self = $$34.$$s == null ? this : $$34.$$s, $post_args, args;

          
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          ;}, $$34.$$s = self, $$34.$$arity = -2, $$34))
        };
      }, $Lazy_grep$32.$$arity = 1);
      Opal.alias(self, "map", "collect");
      Opal.alias(self, "select", "find_all");
      
      Opal.def(self, '$reject', $Lazy_reject$35 = function $$reject() {
        var $iter = $Lazy_reject$35.$$p, block = $iter || nil, $$36, self = this;

        if ($iter) $Lazy_reject$35.$$p = null;
        
        
        if ($iter) $Lazy_reject$35.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$36 = function(enum$, $a){var self = $$36.$$s == null ? this : $$36.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($falsy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$36.$$s = self, $$36.$$arity = -2, $$36));
      }, $Lazy_reject$35.$$arity = 0);
      
      Opal.def(self, '$take', $Lazy_take$37 = function $$take(n) {
        var $$38, self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        taken = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$38 = function(enum$, $a){var self = $$38.$$s == null ? this : $$38.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', Opal.to_a(args));
            return (taken = $rb_plus(taken, 1));
          } else {
            return self.$raise($$($nesting, 'StopLazyError'))
          };}, $$38.$$s = self, $$38.$$arity = -2, $$38));
      }, $Lazy_take$37.$$arity = 1);
      
      Opal.def(self, '$take_while', $Lazy_take_while$39 = function $$take_while() {
        var $iter = $Lazy_take_while$39.$$p, block = $iter || nil, $$40, self = this;

        if ($iter) $Lazy_take_while$39.$$p = null;
        
        
        if ($iter) $Lazy_take_while$39.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$40 = function(enum$, $a){var self = $$40.$$s == null ? this : $$40.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
          else {
            self.$raise($$($nesting, 'StopLazyError'));
          }
        ;}, $$40.$$s = self, $$40.$$arity = -2, $$40));
      }, $Lazy_take_while$39.$$arity = 0);
      Opal.alias(self, "to_enum", "enum_for");
      return (Opal.def(self, '$inspect', $Lazy_inspect$41 = function $$inspect() {
        var self = this;

        return "" + "#<" + (self.$class()) + ": " + (self.enumerator.$inspect()) + ">"
      }, $Lazy_inspect$41.$$arity = 0), nil) && 'inspect';
    })($nesting[0], self, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ArithmeticSequence');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/numeric"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$instance_of?', '$class', '$Float', '$respond_to?', '$coerce', '$__send__', '$===', '$raise', '$equal?', '$-', '$*', '$div', '$<', '$-@', '$ceil', '$to_f', '$denominator', '$to_r', '$==', '$floor', '$/', '$%', '$Complex', '$zero?', '$numerator', '$abs', '$arg', '$coerce_to!', '$round', '$<=>', '$compare', '$enum_for', '$to_proc', '$negative?', '$>=', '$<=', '$+', '$to_i', '$truncate', '$>']);
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $Numeric_coerce$1, $Numeric___coerced__$2, $Numeric_$lt_eq_gt$3, $Numeric_$plus$$4, $Numeric_$minus$$5, $Numeric_$percent$6, $Numeric_abs$7, $Numeric_abs2$8, $Numeric_angle$9, $Numeric_ceil$10, $Numeric_conj$11, $Numeric_denominator$12, $Numeric_div$13, $Numeric_divmod$14, $Numeric_fdiv$15, $Numeric_floor$16, $Numeric_i$17, $Numeric_imag$18, $Numeric_integer$ques$19, $Numeric_nonzero$ques$20, $Numeric_numerator$21, $Numeric_polar$22, $Numeric_quo$23, $Numeric_real$24, $Numeric_real$ques$25, $Numeric_rect$26, $Numeric_round$27, $Numeric_step$28, $Numeric_to_c$29, $Numeric_to_int$30, $Numeric_truncate$31, $Numeric_zero$ques$32, $Numeric_positive$ques$33, $Numeric_negative$ques$34, $Numeric_dup$35, $Numeric_clone$36, $Numeric_finite$ques$37, $Numeric_infinite$ques$38;

    
    self.$include($$($nesting, 'Comparable'));
    
    Opal.def(self, '$coerce', $Numeric_coerce$1 = function $$coerce(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        return [other, self]};
      return [self.$Float(other), self.$Float(self)];
    }, $Numeric_coerce$1.$$arity = 1);
    
    Opal.def(self, '$__coerced__', $Numeric___coerced__$2 = function $$__coerced__(method, other) {
      var $a, $b, self = this, a = nil, b = nil, $case = nil;

      if ($truthy(other['$respond_to?']("coerce"))) {
        
        $b = other.$coerce(self), $a = Opal.to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b;
        return a.$__send__(method, b);
      } else {
        return (function() {$case = method;
        if ("+"['$===']($case) || "-"['$===']($case) || "*"['$===']($case) || "/"['$===']($case) || "%"['$===']($case) || "&"['$===']($case) || "|"['$===']($case) || "^"['$===']($case) || "**"['$===']($case)) {return self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Numeric")}
        else if (">"['$===']($case) || ">="['$===']($case) || "<"['$===']($case) || "<="['$===']($case) || "<=>"['$===']($case)) {return self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")}
        else { return nil }})()
      }
    }, $Numeric___coerced__$2.$$arity = 2);
    
    Opal.def(self, '$<=>', $Numeric_$lt_eq_gt$3 = function(other) {
      var self = this;

      
      if ($truthy(self['$equal?'](other))) {
        return 0};
      return nil;
    }, $Numeric_$lt_eq_gt$3.$$arity = 1);
    
    Opal.def(self, '$+@', $Numeric_$plus$$4 = function() {
      var self = this;

      return self
    }, $Numeric_$plus$$4.$$arity = 0);
    
    Opal.def(self, '$-@', $Numeric_$minus$$5 = function() {
      var self = this;

      return $rb_minus(0, self)
    }, $Numeric_$minus$$5.$$arity = 0);
    
    Opal.def(self, '$%', $Numeric_$percent$6 = function(other) {
      var self = this;

      return $rb_minus(self, $rb_times(other, self.$div(other)))
    }, $Numeric_$percent$6.$$arity = 1);
    
    Opal.def(self, '$abs', $Numeric_abs$7 = function $$abs() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return self['$-@']()
      } else {
        return self
      }
    }, $Numeric_abs$7.$$arity = 0);
    
    Opal.def(self, '$abs2', $Numeric_abs2$8 = function $$abs2() {
      var self = this;

      return $rb_times(self, self)
    }, $Numeric_abs2$8.$$arity = 0);
    
    Opal.def(self, '$angle', $Numeric_angle$9 = function $$angle() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return $$$($$($nesting, 'Math'), 'PI')
      } else {
        return 0
      }
    }, $Numeric_angle$9.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    
    Opal.def(self, '$ceil', $Numeric_ceil$10 = function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$ceil(ndigits);
    }, $Numeric_ceil$10.$$arity = -1);
    
    Opal.def(self, '$conj', $Numeric_conj$11 = function $$conj() {
      var self = this;

      return self
    }, $Numeric_conj$11.$$arity = 0);
    Opal.alias(self, "conjugate", "conj");
    
    Opal.def(self, '$denominator', $Numeric_denominator$12 = function $$denominator() {
      var self = this;

      return self.$to_r().$denominator()
    }, $Numeric_denominator$12.$$arity = 0);
    
    Opal.def(self, '$div', $Numeric_div$13 = function $$div(other) {
      var self = this;

      
      if (other['$=='](0)) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by o")};
      return $rb_divide(self, other).$floor();
    }, $Numeric_div$13.$$arity = 1);
    
    Opal.def(self, '$divmod', $Numeric_divmod$14 = function $$divmod(other) {
      var self = this;

      return [self.$div(other), self['$%'](other)]
    }, $Numeric_divmod$14.$$arity = 1);
    
    Opal.def(self, '$fdiv', $Numeric_fdiv$15 = function $$fdiv(other) {
      var self = this;

      return $rb_divide(self.$to_f(), other)
    }, $Numeric_fdiv$15.$$arity = 1);
    
    Opal.def(self, '$floor', $Numeric_floor$16 = function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$floor(ndigits);
    }, $Numeric_floor$16.$$arity = -1);
    
    Opal.def(self, '$i', $Numeric_i$17 = function $$i() {
      var self = this;

      return self.$Complex(0, self)
    }, $Numeric_i$17.$$arity = 0);
    
    Opal.def(self, '$imag', $Numeric_imag$18 = function $$imag() {
      var self = this;

      return 0
    }, $Numeric_imag$18.$$arity = 0);
    Opal.alias(self, "imaginary", "imag");
    
    Opal.def(self, '$integer?', $Numeric_integer$ques$19 = function() {
      var self = this;

      return false
    }, $Numeric_integer$ques$19.$$arity = 0);
    Opal.alias(self, "magnitude", "abs");
    Opal.alias(self, "modulo", "%");
    
    Opal.def(self, '$nonzero?', $Numeric_nonzero$ques$20 = function() {
      var self = this;

      if ($truthy(self['$zero?']())) {
        return nil
      } else {
        return self
      }
    }, $Numeric_nonzero$ques$20.$$arity = 0);
    
    Opal.def(self, '$numerator', $Numeric_numerator$21 = function $$numerator() {
      var self = this;

      return self.$to_r().$numerator()
    }, $Numeric_numerator$21.$$arity = 0);
    Opal.alias(self, "phase", "arg");
    
    Opal.def(self, '$polar', $Numeric_polar$22 = function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, $Numeric_polar$22.$$arity = 0);
    
    Opal.def(self, '$quo', $Numeric_quo$23 = function $$quo(other) {
      var self = this;

      return $rb_divide($$($nesting, 'Opal')['$coerce_to!'](self, $$($nesting, 'Rational'), "to_r"), other)
    }, $Numeric_quo$23.$$arity = 1);
    
    Opal.def(self, '$real', $Numeric_real$24 = function $$real() {
      var self = this;

      return self
    }, $Numeric_real$24.$$arity = 0);
    
    Opal.def(self, '$real?', $Numeric_real$ques$25 = function() {
      var self = this;

      return true
    }, $Numeric_real$ques$25.$$arity = 0);
    
    Opal.def(self, '$rect', $Numeric_rect$26 = function $$rect() {
      var self = this;

      return [self, 0]
    }, $Numeric_rect$26.$$arity = 0);
    Opal.alias(self, "rectangular", "rect");
    
    Opal.def(self, '$round', $Numeric_round$27 = function $$round(digits) {
      var self = this;

      
      ;
      return self.$to_f().$round(digits);
    }, $Numeric_round$27.$$arity = -1);
    
    Opal.def(self, '$step', $Numeric_step$28 = function $$step($a, $b, $c) {
      var $iter = $Numeric_step$28.$$p, block = $iter || nil, $post_args, $kwargs, limit, step, to, by, $d, self = this, counter = nil;

      if ($iter) $Numeric_step$28.$$p = null;
      
      
      if ($iter) $Numeric_step$28.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) {
        limit = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      if ($post_args.length > 0) {
        step = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      to = $kwargs.$$smap["to"];;
      
      by = $kwargs.$$smap["by"];;
      
      if (limit !== undefined && to !== undefined) {
        self.$raise($$($nesting, 'ArgumentError'), "to is given twice")
      }

      if (step !== undefined && by !== undefined) {
        self.$raise($$($nesting, 'ArgumentError'), "step is given twice")
      }

      if (to !== undefined) {
        limit = to;
      }

      if (by !== undefined) {
        step = by;
      }

      if (limit === undefined) {
        limit = nil;
      }

      function validateParameters() {
        if (step === nil) {
          self.$raise($$($nesting, 'TypeError'), "step must be numeric")
        }

        if (step != null && step['$=='](0)) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be 0")
        }

        if (step === nil || step == null) {
          step = 1;
        }

        var sign = step['$<=>'](0);

        if (sign === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "0 can't be coerced into " + (step.$class()))
        }

        if (limit === nil || limit == null) {
          limit = sign > 0 ? $$$($$($nesting, 'Float'), 'INFINITY') : $$$($$($nesting, 'Float'), 'INFINITY')['$-@']();
        }

        $$($nesting, 'Opal').$compare(self, limit)
      }

      function stepFloatSize() {
        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else if (step === Infinity || step === -Infinity) {
          return 1;
        } else {
          var abs = Math.abs, floor = Math.floor,
              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$($nesting, 'Float'), 'EPSILON');

          if (err === Infinity || err === -Infinity) {
            return 0;
          } else {
            if (err > 0.5) {
              err = 0.5;
            }

            return floor((limit - self) / step + err) + 1
          }
        }
      }

      function stepSize() {
        validateParameters();

        if (step === 0) {
          return Infinity;
        }

        if (step % 1 !== 0) {
          return stepFloatSize();
        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else {
          var ceil = Math.ceil, abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

          return ceil(lhs / rhs);
        }
      }

    ;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["step", limit, step], (stepSize).$to_proc())
      };
      
      validateParameters();

      var isDesc = step['$negative?'](),
          isInf = step['$=='](0) ||
                  (limit === Infinity && !isDesc) ||
                  (limit === -Infinity && isDesc);

      if (self.$$is_number && step.$$is_number && limit.$$is_number) {
        if (self % 1 === 0 && (isInf || limit % 1 === 0) && step % 1 === 0) {
          var value = self;

          if (isInf) {
            for (;; value += step) {
              block(value);
            }
          } else if (isDesc) {
            for (; value >= limit; value += step) {
              block(value);
            }
          } else {
            for (; value <= limit; value += step) {
              block(value);
            }
          }

          return self;
        } else {
          var begin = self.$to_f().valueOf();
          step = step.$to_f().valueOf();
          limit = limit.$to_f().valueOf();

          var n = stepFloatSize();

          if (!isFinite(step)) {
            if (n !== 0) block(begin);
          } else if (step === 0) {
            while (true) {
              block(begin);
            }
          } else {
            for (var i = 0; i < n; i++) {
              var d = i * step + self;
              if (step >= 0 ? limit < d : limit > d) {
                d = limit;
              }
              block(d);
            }
          }

          return self;
        }
      }
    ;
      counter = self;
      while ($truthy(isDesc ? $rb_ge(counter, limit) : $rb_le(counter, limit))) {
        
        Opal.yield1(block, counter);
        counter = $rb_plus(counter, step);
      };
    }, $Numeric_step$28.$$arity = -1);
    
    Opal.def(self, '$to_c', $Numeric_to_c$29 = function $$to_c() {
      var self = this;

      return self.$Complex(self, 0)
    }, $Numeric_to_c$29.$$arity = 0);
    
    Opal.def(self, '$to_int', $Numeric_to_int$30 = function $$to_int() {
      var self = this;

      return self.$to_i()
    }, $Numeric_to_int$30.$$arity = 0);
    
    Opal.def(self, '$truncate', $Numeric_truncate$31 = function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$truncate(ndigits);
    }, $Numeric_truncate$31.$$arity = -1);
    
    Opal.def(self, '$zero?', $Numeric_zero$ques$32 = function() {
      var self = this;

      return self['$=='](0)
    }, $Numeric_zero$ques$32.$$arity = 0);
    
    Opal.def(self, '$positive?', $Numeric_positive$ques$33 = function() {
      var self = this;

      return $rb_gt(self, 0)
    }, $Numeric_positive$ques$33.$$arity = 0);
    
    Opal.def(self, '$negative?', $Numeric_negative$ques$34 = function() {
      var self = this;

      return $rb_lt(self, 0)
    }, $Numeric_negative$ques$34.$$arity = 0);
    
    Opal.def(self, '$dup', $Numeric_dup$35 = function $$dup() {
      var self = this;

      return self
    }, $Numeric_dup$35.$$arity = 0);
    
    Opal.def(self, '$clone', $Numeric_clone$36 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return self;
    }, $Numeric_clone$36.$$arity = -1);
    
    Opal.def(self, '$finite?', $Numeric_finite$ques$37 = function() {
      var self = this;

      return true
    }, $Numeric_finite$ques$37.$$arity = 0);
    return (Opal.def(self, '$infinite?', $Numeric_infinite$ques$38 = function() {
      var self = this;

      return nil
    }, $Numeric_infinite$ques$38.$$arity = 0), nil) && 'infinite?';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/array"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $falsy = Opal.falsy, $hash_ids = Opal.hash_ids, $yield1 = Opal.yield1, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $klass = Opal.klass, $hash2 = Opal.hash2, $send2 = Opal.send2, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$to_a', '$warn', '$raise', '$replace', '$respond_to?', '$to_ary', '$coerce_to?', '$===', '$join', '$to_str', '$hash', '$<=>', '$==', '$object_id', '$inspect', '$enum_for', '$class', '$bsearch_index', '$to_proc', '$nil?', '$coerce_to!', '$>', '$*', '$enumerator_size', '$empty?', '$size', '$map', '$equal?', '$dup', '$each', '$reduce', '$-', '$[]', '$dig', '$eql?', '$length', '$exclude_end?', '$flatten', '$__id__', '$&', '$to_s', '$new', '$max', '$min', '$!', '$>=', '$**', '$delete_if', '$reverse', '$rotate', '$rand', '$at', '$keep_if', '$shuffle!', '$<', '$sort', '$sort_by', '$!=', '$times', '$[]=', '$<<', '$uniq', '$|', '$values', '$is_a?', '$last', '$first', '$upto', '$reject', '$pristine', '$singleton_class']);
  
  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_$$$1, $Array_initialize$2, $Array_try_convert$3, $Array_$$4, $Array_$$5, $Array_$$6, $Array_$plus$7, $Array_$minus$8, $Array_$lt$lt$9, $Array_$lt_eq_gt$10, $Array_$eq_eq$11, $Array_$$$12, $Array_$$$eq$13, $Array_any$ques$14, $Array_assoc$15, $Array_at$16, $Array_bsearch_index$17, $Array_bsearch$18, $Array_cycle$19, $Array_clear$21, $Array_count$22, $Array_initialize_copy$23, $Array_collect$24, $Array_collect$excl$26, $Array_combination$28, $Array_repeated_combination$30, $Array_compact$32, $Array_compact$excl$33, $Array_concat$34, $Array_delete$37, $Array_delete_at$38, $Array_delete_if$39, $Array_difference$41, $Array_dig$43, $Array_drop$44, $Array_dup$45, $Array_each$46, $Array_each_index$48, $Array_empty$ques$50, $Array_eql$ques$51, $Array_fetch$52, $Array_fill$53, $Array_first$54, $Array_flatten$55, $Array_flatten$excl$56, $Array_hash$57, $Array_include$ques$58, $Array_index$59, $Array_insert$60, $Array_inspect$61, $Array_intersection$62, $Array_join$64, $Array_keep_if$65, $Array_last$67, $Array_length$68, $Array_max$69, $Array_min$70, $Array_permutation$71, $Array_repeated_permutation$73, $Array_pop$75, $Array_product$76, $Array_push$77, $Array_rassoc$78, $Array_reject$79, $Array_reject$excl$81, $Array_replace$83, $Array_reverse$84, $Array_reverse$excl$85, $Array_reverse_each$86, $Array_rindex$88, $Array_rotate$89, $Array_rotate$excl$90, $Array_sample$93, $Array_select$94, $Array_select$excl$96, $Array_shift$98, $Array_shuffle$99, $Array_shuffle$excl$100, $Array_slice$excl$101, $Array_sort$102, $Array_sort$excl$103, $Array_sort_by$excl$104, $Array_take$106, $Array_take_while$107, $Array_to_a$108, $Array_to_ary$109, $Array_to_h$110, $Array_transpose$111, $Array_union$114, $Array_uniq$116, $Array_uniq$excl$117, $Array_unshift$118, $Array_values_at$119, $Array_zip$122, $Array_inherited$123, $Array_instance_variables$124, $Array_pack$126;

    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defineProperty(self.$$prototype, '$$is_array', true);
    
    // Recent versions of V8 (> 7.1) only use an optimized implementation when Array.prototype is unmodified.
    // For instance, "array-splice.tq" has a "fast path" (ExtractFastJSArray, defined in "src/codegen/code-stub-assembler.cc")
    // but it's only enabled when "IsPrototypeInitialArrayPrototype()" is true.
    //
    // Older versions of V8 were using relatively fast JS-with-extensions code even when Array.prototype is modified:
    // https://github.com/v8/v8/blob/7.0.1/src/js/array.js#L599-L642
    //
    // In short, Array operations are slow in recent versions of V8 when the Array.prototype has been tampered.
    // So, when possible, we are using faster open-coded version to boost the performance.

    // As of V8 8.4, depending on the size of the array, this is up to ~25x times faster than Array#shift()
    // Implementation is heavily inspired by: https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L341-L347
    function shiftNoArg(list) {
      var r = list[0];
      var index = 1;
      var length = list.length;
      for (; index < length; index++) {
        list[index - 1] = list[index];
      }
      list.pop();
      return r;
    }

    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace((obj).$to_a());
      }
    }

    // A helper for keep_if and delete_if, filter is either Opal.truthy
    // or Opal.falsy.
    function filterIf(self, filter, block) {
      var value, raised = null, updated = new Array(self.length);

      for (var i = 0, i2 = 0, length = self.length; i < length; i++) {
        if (!raised) {
          try {
            value = $yield1(block, self[i])
          } catch(error) {
            raised = error;
          }
        }

        if (raised || filter(value)) {
          updated[i2] = self[i]
          i2 += 1;
        }
      }

      if (i2 !== i) {
        self.splice.apply(self, [0, updated.length].concat(updated));
        self.splice(i2, updated.length);
      }

      if (raised) throw raised;
    }
  ;
    Opal.defs(self, '$[]', $Array_$$$1 = function($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      return toArraySubclass(objects, self);;
    }, $Array_$$$1.$$arity = -1);
    
    Opal.def(self, '$initialize', $Array_initialize$2 = function $$initialize(size, obj) {
      var $iter = $Array_initialize$2.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_initialize$2.$$p = null;
      
      
      if ($iter) $Array_initialize$2.$$p = null;;
      
      if (size == null) {
        size = nil;
      };
      
      if (obj == null) {
        obj = nil;
      };
      
      if (obj !== nil && block !== nil) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (size > $$$($$($nesting, 'Integer'), 'MAX')) {
        self.$raise($$($nesting, 'ArgumentError'), "array size too big")
      }

      if (arguments.length > 2) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..2)")
      }

      if (arguments.length === 0) {
        self.splice(0, self.length);
        return self;
      }

      if (arguments.length === 1) {
        if (size.$$is_array) {
          self.$replace(size.$to_a())
          return self;
        } else if (size['$respond_to?']("to_ary")) {
          self.$replace(size.$to_ary())
          return self;
        }
      }

      size = $coerce_to(size, $$($nesting, 'Integer'), 'to_int');

      if (size < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")
      }

      self.splice(0, self.length);
      var i, value;

      if (block === nil) {
        for (i = 0; i < size; i++) {
          self.push(obj);
        }
      }
      else {
        for (i = 0, value; i < size; i++) {
          value = block(i);
          self[i] = value;
        }
      }

      return self;
    ;
    }, $Array_initialize$2.$$arity = -1);
    Opal.defs(self, '$try_convert', $Array_try_convert$3 = function $$try_convert(obj) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Array'), "to_ary")
    }, $Array_try_convert$3.$$arity = 1);
    
    Opal.def(self, '$&', $Array_$$4 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_delete(hash, item) !== undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_$$4.$$arity = 1);
    
    Opal.def(self, '$|', $Array_$$5 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      
      var hash = $hash2([], {}), i, length, item;

      for (i = 0, length = self.length; i < length; i++) {
        $hash_put(hash, self[i], true);
      }

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      return hash.$keys();
    ;
    }, $Array_$$5.$$arity = 1);
    
    Opal.def(self, '$*', $Array_$$6 = function(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
        return self.$join(other.$to_str())};
      other = $coerce_to(other, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(other < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative argument")};
      
      var result = [],
          converted = self.$to_a();

      for (var i = 0; i < other; i++) {
        result = result.concat(converted);
      }

      return result;
    ;
    }, $Array_$$6.$$arity = 1);
    
    Opal.def(self, '$+', $Array_$plus$7 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      return self.concat(other);;
    }, $Array_$plus$7.$$arity = 1);
    
    Opal.def(self, '$-', $Array_$minus$8 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(other.length === 0)) {
        return self.slice()};
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_get(hash, item) === undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_$minus$8.$$arity = 1);
    
    Opal.def(self, '$<<', $Array_$lt$lt$9 = function(object) {
      var self = this;

      
      self.push(object);
      return self;
    }, $Array_$lt$lt$9.$$arity = 1);
    
    Opal.def(self, '$<=>', $Array_$lt_eq_gt$10 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Array')['$==='](other))) {
        other = other.$to_a()
      } else if ($truthy(other['$respond_to?']("to_ary"))) {
        other = other.$to_ary().$to_a()
      } else {
        return nil
      };
      
      if (self.$hash() === other.$hash()) {
        return 0;
      }

      var count = Math.min(self.length, other.length);

      for (var i = 0; i < count; i++) {
        var tmp = (self[i])['$<=>'](other[i]);

        if (tmp !== 0) {
          return tmp;
        }
      }

      return (self.length)['$<=>'](other.length);
    ;
    }, $Array_$lt_eq_gt$10.$$arity = 1);
    
    Opal.def(self, '$==', $Array_$eq_eq$11 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eqeq(array, other) {
        var i, length, a, b;

        if (array === other)
          return true;

        if (!other.$$is_array) {
          if ($respond_to(other, '$to_ary')) {
            return (other)['$=='](array);
          } else {
            return false;
          }
        }

        if (array.$$constructor !== Array)
          array = (array).$to_a();
        if (other.$$constructor !== Array)
          other = (other).$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    
    }, $Array_$eq_eq$11.$$arity = 1);
    
    function $array_slice_range(self, index) {
      var size = self.length,
          exclude, from, to, result;

      exclude = index.excl;
      from    = $coerce_to(index.begin, Opal.Integer, 'to_int');
      to      = $coerce_to(index.end, Opal.Integer, 'to_int');

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude) {
        to += 1;
      }

      result = self.slice(from, to);
      return result;
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
          exclude, from, to, result;

      index = $coerce_to(index, Opal.Integer, 'to_int');

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      }
      else {
        length = $coerce_to(length, Opal.Integer, 'to_int');

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return result;
    }
  ;
    
    Opal.def(self, '$[]', $Array_$$$12 = function(index, length) {
      var self = this;

      
      ;
      
      if (index.$$is_range) {
        return $array_slice_range(self, index);
      }
      else {
        return $array_slice_index_length(self, index, length);
      }
    ;
    }, $Array_$$$12.$$arity = -2);
    
    Opal.def(self, '$[]=', $Array_$$$eq$13 = function(index, value, extra) {
      var self = this, data = nil, length = nil;

      
      ;
            var i, size = self.length;;
      if ($truthy($$($nesting, 'Range')['$==='](index))) {
        
        data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {
          return value.$to_a()
        } else if ($truthy(value['$respond_to?']("to_ary"))) {
          return value.$to_ary().$to_a()
        } else {
          return [value]
        }; return nil; })();
        
        var exclude = index.excl,
            from    = $coerce_to(index.begin, $$($nesting, 'Integer'), 'to_int'),
            to      = $coerce_to(index.end, $$($nesting, 'Integer'), 'to_int');

        if (from < 0) {
          from += size;

          if (from < 0) {
            self.$raise($$($nesting, 'RangeError'), "" + (index.$inspect()) + " out of range");
          }
        }

        if (to < 0) {
          to += size;
        }

        if (!exclude) {
          to += 1;
        }

        if (from > size) {
          for (i = size; i < from; i++) {
            self[i] = nil;
          }
        }

        if (to < 0) {
          self.splice.apply(self, [from, 0].concat(data));
        }
        else {
          self.splice.apply(self, [from, to - from].concat(data));
        }

        return value;
      ;
      } else {
        
        if ($truthy(extra === undefined)) {
          length = 1
        } else {
          
          length = value;
          value = extra;
          data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {
            return value.$to_a()
          } else if ($truthy(value['$respond_to?']("to_ary"))) {
            return value.$to_ary().$to_a()
          } else {
            return [value]
          }; return nil; })();
        };
        
        var old;

        index  = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');
        length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');

        if (index < 0) {
          old    = index;
          index += size;

          if (index < 0) {
            self.$raise($$($nesting, 'IndexError'), "" + "index " + (old) + " too small for array; minimum " + (-self.length));
          }
        }

        if (length < 0) {
          self.$raise($$($nesting, 'IndexError'), "" + "negative length (" + (length) + ")")
        }

        if (index > size) {
          for (i = size; i < index; i++) {
            self[i] = nil;
          }
        }

        if (extra === undefined) {
          self[index] = value;
        }
        else {
          self.splice.apply(self, [index, length].concat(data));
        }

        return value;
      ;
      };
    }, $Array_$$$eq$13.$$arity = -3);
    
    Opal.def(self, '$any?', $Array_any$ques$14 = function(pattern) {
      var $iter = $Array_any$ques$14.$$p, block = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_any$ques$14.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Array_any$ques$14.$$p = null;;
      ;
      if (self.length === 0) return false;
      return $send2(self, Opal.find_super_dispatcher(self, 'any?', $Array_any$ques$14, false, true), 'any?', $zuper, $iter);
    }, $Array_any$ques$14.$$arity = -1);
    
    Opal.def(self, '$assoc', $Array_assoc$15 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        if (item = self[i], item.length && (item[0])['$=='](object)) {
          return item;
        }
      }

      return nil;
    
    }, $Array_assoc$15.$$arity = 1);
    
    Opal.def(self, '$at', $Array_at$16 = function $$at(index) {
      var self = this;

      
      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int')

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      return self[index];
    
    }, $Array_at$16.$$arity = 1);
    
    Opal.def(self, '$bsearch_index', $Array_bsearch_index$17 = function $$bsearch_index() {
      var $iter = $Array_bsearch_index$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_bsearch_index$17.$$p = null;
      
      
      if ($iter) $Array_bsearch_index$17.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch_index")
      };
      
      var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

      while (min < max) {
        mid = min + Math.floor((max - min) / 2);
        val = self[mid];
        ret = $yield1(block, val);

        if (ret === true) {
          satisfied = mid;
          smaller = true;
        }
        else if (ret === false || ret === nil) {
          smaller = false;
        }
        else if (ret.$$is_number) {
          if (ret === 0) { return mid; }
          smaller = (ret < 0);
        }
        else {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((ret).$class()) + " (must be numeric, true, false or nil)")
        }

        if (smaller) { max = mid; } else { min = mid + 1; }
      }

      return satisfied;
    ;
    }, $Array_bsearch_index$17.$$arity = 0);
    
    Opal.def(self, '$bsearch', $Array_bsearch$18 = function $$bsearch() {
      var $iter = $Array_bsearch$18.$$p, block = $iter || nil, self = this, index = nil;

      if ($iter) $Array_bsearch$18.$$p = null;
      
      
      if ($iter) $Array_bsearch$18.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch")
      };
      index = $send(self, 'bsearch_index', [], block.$to_proc());
      
      if (index != null && index.$$is_number) {
        return self[index];
      } else {
        return index;
      }
    ;
    }, $Array_bsearch$18.$$arity = 0);
    
    Opal.def(self, '$cycle', $Array_cycle$19 = function $$cycle(n) {
      var $iter = $Array_cycle$19.$$p, block = $iter || nil, $$20, self = this, $ret_or_1 = nil;

      if ($iter) $Array_cycle$19.$$p = null;
      
      
      if ($iter) $Array_cycle$19.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["cycle", n], ($$20 = function(){var self = $$20.$$s == null ? this : $$20.$$s;

        if ($truthy(n['$nil?']())) {
            return $$$($$($nesting, 'Float'), 'INFINITY')
          } else {
            
            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, $$20.$$s = self, $$20.$$arity = 0, $$20))
      };
      if ($truthy((function() {if ($truthy(($ret_or_1 = self['$empty?']()))) {
        return $ret_or_1
      } else {
        return n['$=='](0)
      }; return nil; })())) {
        return nil};
      
      var i, length, value;

      if (n === nil) {
        while (true) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }
        }
      }
      else {
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        if (n <= 0) {
          return self;
        }

        while (n > 0) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }

          n--;
        }
      }
    ;
      return self;
    }, $Array_cycle$19.$$arity = -1);
    
    Opal.def(self, '$clear', $Array_clear$21 = function $$clear() {
      var self = this;

      
      self.splice(0, self.length);
      return self;
    }, $Array_clear$21.$$arity = 0);
    
    Opal.def(self, '$count', $Array_count$22 = function $$count(object) {
      var $iter = $Array_count$22.$$p, block = $iter || nil, self = this, $ret_or_2 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_count$22.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Array_count$22.$$p = null;;
      
      if (object == null) {
        object = nil;
      };
      if ($truthy((function() {if ($truthy(($ret_or_2 = object))) {
        return $ret_or_2
      } else {
        return block
      }; return nil; })())) {
        return $send2(self, Opal.find_super_dispatcher(self, 'count', $Array_count$22, false, true), 'count', $zuper, $iter)
      } else {
        return self.$size()
      };
    }, $Array_count$22.$$arity = -1);
    
    Opal.def(self, '$initialize_copy', $Array_initialize_copy$23 = function $$initialize_copy(other) {
      var self = this;

      return self.$replace(other)
    }, $Array_initialize_copy$23.$$arity = 1);
    
    Opal.def(self, '$collect', $Array_collect$24 = function $$collect() {
      var $iter = $Array_collect$24.$$p, block = $iter || nil, $$25, self = this;

      if ($iter) $Array_collect$24.$$p = null;
      
      
      if ($iter) $Array_collect$24.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect"], ($$25 = function(){var self = $$25.$$s == null ? this : $$25.$$s;

        return self.$size()}, $$25.$$s = self, $$25.$$arity = 0, $$25))
      };
      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        result.push(value);
      }

      return result;
    ;
    }, $Array_collect$24.$$arity = 0);
    
    Opal.def(self, '$collect!', $Array_collect$excl$26 = function() {
      var $iter = $Array_collect$excl$26.$$p, block = $iter || nil, $$27, self = this;

      if ($iter) $Array_collect$excl$26.$$p = null;
      
      
      if ($iter) $Array_collect$excl$26.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect!"], ($$27 = function(){var self = $$27.$$s == null ? this : $$27.$$s;

        return self.$size()}, $$27.$$s = self, $$27.$$arity = 0, $$27))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        self[i] = value;
      }
    ;
      return self;
    }, $Array_collect$excl$26.$$arity = 0);
    
    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
      }

      return 0;
    }
  ;
    
    Opal.def(self, '$combination', $Array_combination$28 = function $$combination(n) {
      var $$29, $iter = $Array_combination$28.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_combination$28.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["combination", num], ($$29 = function(){var self = $$29.$$s == null ? this : $$29.$$s;

        return binomial_coefficient(self.length, num)}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      var i, length, stack, chosen, lev, done, next;

      if (num === 0) {
        Opal.yield1($yield, [])
      } else if (num === 1) {
        for (i = 0, length = self.length; i < length; i++) {
          Opal.yield1($yield, [self[i]])
        }
      }
      else if (num === self.length) {
        Opal.yield1($yield, self.slice())
      }
      else if (num >= 0 && num < self.length) {
        stack = [];
        for (i = 0; i <= num + 1; i++) {
          stack.push(0);
        }

        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;

        while (!done) {
          chosen[lev] = self[stack[lev+1]];
          while (lev < num - 1) {
            lev++;
            next = stack[lev+1] = stack[lev] + 1;
            chosen[lev] = self[next];
          }
          Opal.yield1($yield, chosen.slice())
          lev++;
          do {
            done = (lev === 0);
            stack[lev]++;
            lev--;
          } while ( stack[lev+1] + num === self.length + lev + 1 );
        }
      }
    ;
      return self;
    }, $Array_combination$28.$$arity = 1);
    
    Opal.def(self, '$repeated_combination', $Array_repeated_combination$30 = function $$repeated_combination(n) {
      var $$31, $iter = $Array_repeated_combination$30.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_repeated_combination$30.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["repeated_combination", num], ($$31 = function(){var self = $$31.$$s == null ? this : $$31.$$s;

        return binomial_coefficient(self.length + num - 1, num);}, $$31.$$s = self, $$31.$$arity = 0, $$31))
      };
      
      function iterate(max, from, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = from; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, i, buffer, self);
          buffer.pop();
        }
      }

      if (num >= 0) {
        iterate(num, 0, [], self);
      }
    ;
      return self;
    }, $Array_repeated_combination$30.$$arity = 1);
    
    Opal.def(self, '$compact', $Array_compact$32 = function $$compact() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length, item; i < length; i++) {
        if ((item = self[i]) !== nil) {
          result.push(item);
        }
      }

      return result;
    
    }, $Array_compact$32.$$arity = 0);
    
    Opal.def(self, '$compact!', $Array_compact$excl$33 = function() {
      var self = this;

      
      var original = self.length;

      for (var i = 0, length = self.length; i < length; i++) {
        if (self[i] === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      return self.length === original ? nil : self;
    
    }, $Array_compact$excl$33.$$arity = 0);
    
    Opal.def(self, '$concat', $Array_concat$34 = function $$concat($a) {
      var $post_args, others, $$35, $$36, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      others = $send(others, 'map', [], ($$35 = function(other){var self = $$35.$$s == null ? this : $$35.$$s;

      
        
        if (other == null) {
          other = nil;
        };
        other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
          return other.$to_a()
        } else {
          return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
        }; return nil; })();
        if ($truthy(other['$equal?'](self))) {
          other = other.$dup()};
        return other;}, $$35.$$s = self, $$35.$$arity = 1, $$35));
      $send(others, 'each', [], ($$36 = function(other){var self = $$36.$$s == null ? this : $$36.$$s;

      
        
        if (other == null) {
          other = nil;
        };
        
        for (var i = 0, length = other.length; i < length; i++) {
          self.push(other[i]);
        }
      ;}, $$36.$$s = self, $$36.$$arity = 1, $$36));
      return self;
    }, $Array_concat$34.$$arity = -1);
    
    Opal.def(self, '$delete', $Array_delete$37 = function(object) {
      var $iter = $Array_delete$37.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Array_delete$37.$$p = null;
      
      var original = self.length;

      for (var i = 0, length = original; i < length; i++) {
        if ((self[i])['$=='](object)) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      if (self.length === original) {
        if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        }
        return nil;
      }
      return object;
    
    }, $Array_delete$37.$$arity = 1);
    
    Opal.def(self, '$delete_at', $Array_delete_at$38 = function $$delete_at(index) {
      var self = this;

      
      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      var result = self[index];

      self.splice(index, 1);

      return result;
    
    }, $Array_delete_at$38.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Array_delete_if$39 = function $$delete_if() {
      var $iter = $Array_delete_if$39.$$p, block = $iter || nil, $$40, self = this;

      if ($iter) $Array_delete_if$39.$$p = null;
      
      
      if ($iter) $Array_delete_if$39.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["delete_if"], ($$40 = function(){var self = $$40.$$s == null ? this : $$40.$$s;

        return self.$size()}, $$40.$$s = self, $$40.$$arity = 0, $$40))
      };
      filterIf(self, $falsy, block);
      return self;
    }, $Array_delete_if$39.$$arity = 0);
    
    Opal.def(self, '$difference', $Array_difference$41 = function $$difference($a) {
      var $post_args, arrays, $$42, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      arrays = $post_args;;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], ($$42 = function(a, b){var self = $$42.$$s == null ? this : $$42.$$s;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return $rb_minus(a, b);}, $$42.$$s = self, $$42.$$arity = 2, $$42));
    }, $Array_difference$41.$$arity = -1);
    
    Opal.def(self, '$dig', $Array_dig$43 = function $$dig(idx, $a) {
      var $post_args, idxs, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      idxs = $post_args;;
      item = self['$[]'](idx);
      
      if (item === nil || idxs.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(idxs));
    }, $Array_dig$43.$$arity = -2);
    
    Opal.def(self, '$drop', $Array_drop$44 = function $$drop(number) {
      var self = this;

      
      if (number < 0) {
        self.$raise($$($nesting, 'ArgumentError'))
      }

      return self.slice(number);
    
    }, $Array_drop$44.$$arity = 1);
    
    Opal.def(self, '$dup', $Array_dup$45 = function $$dup() {
      var $iter = $Array_dup$45.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_dup$45.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if (self.$$class === Opal.Array &&
          self.$$class.$allocate.$$pristine &&
          self.$copy_instance_variables.$$pristine &&
          self.$initialize_dup.$$pristine) {
        return self.slice(0);
      }
    ;
      return $send2(self, Opal.find_super_dispatcher(self, 'dup', $Array_dup$45, false, true), 'dup', $zuper, $iter);
    }, $Array_dup$45.$$arity = 0);
    
    Opal.def(self, '$each', $Array_each$46 = function $$each() {
      var $iter = $Array_each$46.$$p, block = $iter || nil, $$47, self = this;

      if ($iter) $Array_each$46.$$p = null;
      
      
      if ($iter) $Array_each$46.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$47 = function(){var self = $$47.$$s == null ? this : $$47.$$s;

        return self.$size()}, $$47.$$s = self, $$47.$$arity = 0, $$47))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
      }
    ;
      return self;
    }, $Array_each$46.$$arity = 0);
    
    Opal.def(self, '$each_index', $Array_each_index$48 = function $$each_index() {
      var $iter = $Array_each_index$48.$$p, block = $iter || nil, $$49, self = this;

      if ($iter) $Array_each_index$48.$$p = null;
      
      
      if ($iter) $Array_each_index$48.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_index"], ($$49 = function(){var self = $$49.$$s == null ? this : $$49.$$s;

        return self.$size()}, $$49.$$s = self, $$49.$$arity = 0, $$49))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, i);
      }
    ;
      return self;
    }, $Array_each_index$48.$$arity = 0);
    
    Opal.def(self, '$empty?', $Array_empty$ques$50 = function() {
      var self = this;

      return self.length === 0;
    }, $Array_empty$ques$50.$$arity = 0);
    
    Opal.def(self, '$eql?', $Array_eql$ques$51 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eql(array, other) {
        var i, length, a, b;

        if (!other.$$is_array) {
          return false;
        }

        other = other.$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eql(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eql(self, other);
    
    }, $Array_eql$ques$51.$$arity = 1);
    
    Opal.def(self, '$fetch', $Array_fetch$52 = function $$fetch(index, defaults) {
      var $iter = $Array_fetch$52.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_fetch$52.$$p = null;
      
      
      if ($iter) $Array_fetch$52.$$p = null;;
      ;
      
      var original = index;

      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index >= 0 && index < self.length) {
        return self[index];
      }

      if (block !== nil && defaults != null) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (block !== nil) {
        return block(original);
      }

      if (defaults != null) {
        return defaults;
      }

      if (self.length === 0) {
        self.$raise($$($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: 0...0")
      }
      else {
        self.$raise($$($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: -" + (self.length) + "..." + (self.length));
      }
    ;
    }, $Array_fetch$52.$$arity = -2);
    
    Opal.def(self, '$fill', $Array_fill$53 = function $$fill($a) {
      var $iter = $Array_fill$53.$$p, block = $iter || nil, $post_args, args, $b, $c, self = this, one = nil, two = nil, obj = nil, left = nil, right = nil;

      if ($iter) $Array_fill$53.$$p = null;
      
      
      if ($iter) $Array_fill$53.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
            var i, length, value;;
      if ($truthy(block)) {
        
        if ($truthy(args.length > 2)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 0..2)")};
        $c = args, $b = Opal.to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;
      } else {
        
        if ($truthy(args.length == 0)) {
          self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        } else if ($truthy(args.length > 3)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 1..3)")};
        $c = args, $b = Opal.to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;
      };
      if ($truthy($$($nesting, 'Range')['$==='](one))) {
        
        if ($truthy(two)) {
          self.$raise($$($nesting, 'TypeError'), "length invalid with range")};
        left = $coerce_to(one.begin, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          self.$raise($$($nesting, 'RangeError'), "" + (one.$inspect()) + " out of range")};
        right = $coerce_to(one.end, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(right < 0)) {
          right += this.length};
        if ($truthy(one['$exclude_end?']())) {
        } else {
          right += 1
        };
        if ($truthy(right <= left)) {
          return self};
      } else if ($truthy(one)) {
        
        left = $coerce_to(one, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          left = 0};
        if ($truthy(two)) {
          
          right = $coerce_to(two, $$($nesting, 'Integer'), 'to_int');
          if ($truthy(right == 0)) {
            return self};
          right += left;
        } else {
          right = this.length
        };
      } else {
        
        left = 0;
        right = this.length;
      };
      if ($truthy(left > this.length)) {
        
        for (i = this.length; i < right; i++) {
          self[i] = nil;
        }
      };
      if ($truthy(right > this.length)) {
        this.length = right};
      if ($truthy(block)) {
        
        for (length = this.length; left < right; left++) {
          value = block(left);
          self[left] = value;
        }
      
      } else {
        
        for (length = this.length; left < right; left++) {
          self[left] = obj;
        }
      
      };
      return self;
    }, $Array_fill$53.$$arity = -1);
    
    Opal.def(self, '$first', $Array_first$54 = function $$first(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[0];
      }

      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size");
      }

      return self.slice(0, count);
    ;
    }, $Array_first$54.$$arity = -1);
    
    Opal.def(self, '$flatten', $Array_flatten$55 = function $$flatten(level) {
      var self = this;

      
      ;
      
      function _flatten(array, level) {
        var result = [],
            i, length,
            item, ary;

        array = (array).$to_a();

        for (i = 0, length = array.length; i < length; i++) {
          item = array[i];

          if (!$respond_to(item, '$to_ary', true)) {
            result.push(item);
            continue;
          }

          ary = (item).$to_ary();

          if (ary === nil) {
            result.push(item);
            continue;
          }

          if (!ary.$$is_array) {
            self.$raise($$($nesting, 'TypeError'));
          }

          if (ary === self) {
            self.$raise($$($nesting, 'ArgumentError'));
          }

          switch (level) {
          case undefined:
            result = result.concat(_flatten(ary));
            break;
          case 0:
            result.push(ary);
            break;
          default:
            result.push.apply(result, _flatten(ary, level - 1));
          }
        }
        return result;
      }

      if (level !== undefined) {
        level = $coerce_to(level, $$($nesting, 'Integer'), 'to_int');
      }

      return _flatten(self, level);
    ;
    }, $Array_flatten$55.$$arity = -1);
    
    Opal.def(self, '$flatten!', $Array_flatten$excl$56 = function(level) {
      var self = this;

      
      ;
      
      var flattened = self.$flatten(level);

      if (self.length == flattened.length) {
        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] !== flattened[i]) {
            break;
          }
        }

        if (i == length) {
          return nil;
        }
      }

      self.$replace(flattened);
    ;
      return self;
    }, $Array_flatten$excl$56.$$arity = -1);
    
    Opal.def(self, '$hash', $Array_hash$57 = function $$hash() {
      var self = this;

      
      var top = ($hash_ids === undefined),
          result = ['A'],
          hash_id = self.$object_id(),
          item, i, key;

      try {
        if (top) {
          $hash_ids = Object.create(null);
        }

        // return early for recursive structures
        if ($hash_ids[hash_id]) {
          return 'self';
        }

        for (key in $hash_ids) {
          item = $hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        $hash_ids[hash_id] = self;

        for (i = 0; i < self.length; i++) {
          item = self[i];
          result.push(item.$hash());
        }

        return result.join(',');
      } finally {
        if (top) {
          $hash_ids = undefined;
        }
      }
    
    }, $Array_hash$57.$$arity = 0);
    
    Opal.def(self, '$include?', $Array_include$ques$58 = function(member) {
      var self = this;

      
      for (var i = 0, length = self.length; i < length; i++) {
        if ((self[i])['$=='](member)) {
          return true;
        }
      }

      return false;
    
    }, $Array_include$ques$58.$$arity = 1);
    
    Opal.def(self, '$index', $Array_index$59 = function $$index(object) {
      var $iter = $Array_index$59.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_index$59.$$p = null;
      
      
      if ($iter) $Array_index$59.$$p = null;;
      ;
      
      var i, length, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = 0, length = self.length; i < length; i++) {
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = 0, length = self.length; i < length; i++) {
          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else {
        return self.$enum_for("index");
      }

      return nil;
    ;
    }, $Array_index$59.$$arity = -1);
    
    Opal.def(self, '$insert', $Array_insert$60 = function $$insert(index, $a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      objects = $post_args;;
      
      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (objects.length > 0) {
        if (index < 0) {
          index += self.length + 1;

          if (index < 0) {
            self.$raise($$($nesting, 'IndexError'), "" + (index) + " is out of bounds");
          }
        }
        if (index > self.length) {
          for (var i = self.length; i < index; i++) {
            self.push(nil);
          }
        }

        self.splice.apply(self, [index, 0].concat(objects));
      }
    ;
      return self;
    }, $Array_insert$60.$$arity = -2);
    
    Opal.def(self, '$inspect', $Array_inspect$61 = function $$inspect() {
      var self = this;

      
      var result = [],
          id     = self.$__id__();

      for (var i = 0, length = self.length; i < length; i++) {
        var item = self['$[]'](i);

        if ((item).$__id__() === id) {
          result.push('[...]');
        }
        else {
          result.push((item).$inspect());
        }
      }

      return '[' + result.join(', ') + ']';
    
    }, $Array_inspect$61.$$arity = 0);
    
    Opal.def(self, '$intersection', $Array_intersection$62 = function $$intersection($a) {
      var $post_args, arrays, $$63, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      arrays = $post_args;;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], ($$63 = function(a, b){var self = $$63.$$s == null ? this : $$63.$$s;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a['$&'](b);}, $$63.$$s = self, $$63.$$arity = 2, $$63));
    }, $Array_intersection$62.$$arity = -1);
    
    Opal.def(self, '$join', $Array_join$64 = function $$join(sep) {
      var self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      
      if (sep == null) {
        sep = nil;
      };
      if ($truthy(self.length === 0)) {
        return ""};
      if ($truthy(sep === nil)) {
        sep = $gvars[","]};
      
      var result = [];
      var i, length, item, tmp;

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];

        if ($respond_to(item, '$to_str')) {
          tmp = (item).$to_str();

          if (tmp !== nil) {
            result.push((tmp).$to_s());

            continue;
          }
        }

        if ($respond_to(item, '$to_ary')) {
          tmp = (item).$to_ary();

          if (tmp === self) {
            self.$raise($$($nesting, 'ArgumentError'));
          }

          if (tmp !== nil) {
            result.push((tmp).$join(sep));

            continue;
          }
        }

        if ($respond_to(item, '$to_s')) {
          tmp = (item).$to_s();

          if (tmp !== nil) {
            result.push(tmp);

            continue;
          }
        }

        self.$raise($$($nesting, 'NoMethodError').$new("" + (Opal.inspect(item)) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
      }

      if (sep === nil) {
        return result.join('');
      }
      else {
        return result.join($$($nesting, 'Opal')['$coerce_to!'](sep, $$($nesting, 'String'), "to_str").$to_s());
      }
    ;
    }, $Array_join$64.$$arity = -1);
    
    Opal.def(self, '$keep_if', $Array_keep_if$65 = function $$keep_if() {
      var $iter = $Array_keep_if$65.$$p, block = $iter || nil, $$66, self = this;

      if ($iter) $Array_keep_if$65.$$p = null;
      
      
      if ($iter) $Array_keep_if$65.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["keep_if"], ($$66 = function(){var self = $$66.$$s == null ? this : $$66.$$s;

        return self.$size()}, $$66.$$s = self, $$66.$$arity = 0, $$66))
      };
      filterIf(self, $truthy, block);
      return self;
    }, $Array_keep_if$65.$$arity = 0);
    
    Opal.def(self, '$last', $Array_last$67 = function $$last(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[self.length - 1];
      }

      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size");
      }

      if (count > self.length) {
        count = self.length;
      }

      return self.slice(self.length - count, self.length);
    ;
    }, $Array_last$67.$$arity = -1);
    
    Opal.def(self, '$length', $Array_length$68 = function $$length() {
      var self = this;

      return self.length;
    }, $Array_length$68.$$arity = 0);
    Opal.alias(self, "map", "collect");
    Opal.alias(self, "map!", "collect!");
    
    Opal.def(self, '$max', $Array_max$69 = function $$max(n) {
      var $iter = $Array_max$69.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_max$69.$$p = null;
      
      
      if ($iter) $Array_max$69.$$p = null;;
      ;
      return $send(self.$each(), 'max', [n], block.$to_proc());
    }, $Array_max$69.$$arity = -1);
    
    Opal.def(self, '$min', $Array_min$70 = function $$min() {
      var $iter = $Array_min$70.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_min$70.$$p = null;
      
      
      if ($iter) $Array_min$70.$$p = null;;
      return $send(self.$each(), 'min', [], block.$to_proc());
    }, $Array_min$70.$$arity = 0);
    
    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
  ;
    
    Opal.def(self, '$permutation', $Array_permutation$71 = function $$permutation(num) {
      var $iter = $Array_permutation$71.$$p, block = $iter || nil, $$72, self = this, perm = nil, used = nil;

      if ($iter) $Array_permutation$71.$$p = null;
      
      
      if ($iter) $Array_permutation$71.$$p = null;;
      ;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["permutation", num], ($$72 = function(){var self = $$72.$$s == null ? this : $$72.$$s;

        return descending_factorial(self.length, num === undefined ? self.length : num);}, $$72.$$s = self, $$72.$$arity = 0, $$72))
      };
      
      var permute, offensive, output;

      if (num === undefined) {
        num = self.length;
      }
      else {
        num = $coerce_to(num, $$($nesting, 'Integer'), 'to_int');
      }

      if (num < 0 || self.length < num) {
        // no permutations, yield nothing
      }
      else if (num === 0) {
        // exactly one permutation: the zero-length array
        Opal.yield1(block, [])
      }
      else if (num === 1) {
        // this is a special, easy case
        for (var i = 0; i < self.length; i++) {
          Opal.yield1(block, [self[i]])
        }
      }
      else {
        // this is the general case
        (perm = $$($nesting, 'Array').$new(num));
        (used = $$($nesting, 'Array').$new(self.length, false));

        permute = function(num, perm, index, used, blk) {
          self = this;
          for(var i = 0; i < self.length; i++){
            if(used['$[]'](i)['$!']()) {
              perm[index] = i;
              if(index < num - 1) {
                used[i] = true;
                permute.call(self, num, perm, index + 1, used, blk);
                used[i] = false;
              }
              else {
                output = [];
                for (var j = 0; j < perm.length; j++) {
                  output.push(self[perm[j]]);
                }
                $yield1(blk, output);
              }
            }
          }
        }

        if ((block !== nil)) {
          // offensive (both definitions) copy.
          offensive = self.slice();
          permute.call(offensive, num, perm, 0, used, block);
        }
        else {
          permute.call(self, num, perm, 0, used, block);
        }
      }
    ;
      return self;
    }, $Array_permutation$71.$$arity = -1);
    
    Opal.def(self, '$repeated_permutation', $Array_repeated_permutation$73 = function $$repeated_permutation(n) {
      var $$74, $iter = $Array_repeated_permutation$73.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_repeated_permutation$73.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["repeated_permutation", num], ($$74 = function(){var self = $$74.$$s == null ? this : $$74.$$s;

        if ($truthy($rb_ge(num, 0))) {
            return self.$size()['$**'](num)
          } else {
            return 0
          }}, $$74.$$s = self, $$74.$$arity = 0, $$74))
      };
      
      function iterate(max, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = 0; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, buffer, self);
          buffer.pop();
        }
      }

      iterate(num, [], self.slice());
    ;
      return self;
    }, $Array_repeated_permutation$73.$$arity = 1);
    
    Opal.def(self, '$pop', $Array_pop$75 = function $$pop(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return self.pop();};
      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(count < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(count === 1)) {
        return [self.pop()];
      } else if ($truthy(count > self.length)) {
        return self.splice(0, self.length);
      } else {
        return self.splice(self.length - count, self.length);
      };
    }, $Array_pop$75.$$arity = -1);
    
    Opal.def(self, '$product', $Array_product$76 = function $$product($a) {
      var $iter = $Array_product$76.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Array_product$76.$$p = null;
      
      
      if ($iter) $Array_product$76.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = (block !== nil) ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths  = new Array(n),
          arrays   = new Array(n),
          i, m, subarray, len, resultlen = 1;

      arrays[0] = self;
      for (i = 1; i < n; i++) {
        arrays[i] = $coerce_to(args[i - 1], $$($nesting, 'Array'), 'to_ary');
      }

      for (i = 0; i < n; i++) {
        len = arrays[i].length;
        if (len === 0) {
          return result || self;
        }
        resultlen *= len;
        if (resultlen > 2147483647) {
          self.$raise($$($nesting, 'RangeError'), "too big to product")
        }
        lengths[i] = len;
        counters[i] = 0;
      }

      outer_loop: for (;;) {
        subarray = [];
        for (i = 0; i < n; i++) {
          subarray.push(arrays[i][counters[i]]);
        }
        if (result) {
          result.push(subarray);
        } else {
          Opal.yield1(block, subarray)
        }
        m = n - 1;
        counters[m]++;
        while (counters[m] === lengths[m]) {
          counters[m] = 0;
          if (--m < 0) break outer_loop;
          counters[m]++;
        }
      }

      return result || self;
    ;
    }, $Array_product$76.$$arity = -1);
    
    Opal.def(self, '$push', $Array_push$77 = function $$push($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      
      for (var i = 0, length = objects.length; i < length; i++) {
        self.push(objects[i]);
      }
    ;
      return self;
    }, $Array_push$77.$$arity = -1);
    Opal.alias(self, "append", "push");
    
    Opal.def(self, '$rassoc', $Array_rassoc$78 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];

        if (item.length && item[1] !== undefined) {
          if ((item[1])['$=='](object)) {
            return item;
          }
        }
      }

      return nil;
    
    }, $Array_rassoc$78.$$arity = 1);
    
    Opal.def(self, '$reject', $Array_reject$79 = function $$reject() {
      var $iter = $Array_reject$79.$$p, block = $iter || nil, $$80, self = this;

      if ($iter) $Array_reject$79.$$p = null;
      
      
      if ($iter) $Array_reject$79.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$80 = function(){var self = $$80.$$s == null ? this : $$80.$$s;

        return self.$size()}, $$80.$$s = self, $$80.$$arity = 0, $$80))
      };
      
      var result = [];

      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          result.push(self[i]);
        }
      }
      return result;
    ;
    }, $Array_reject$79.$$arity = 0);
    
    Opal.def(self, '$reject!', $Array_reject$excl$81 = function() {
      var $iter = $Array_reject$excl$81.$$p, block = $iter || nil, $$82, self = this, original = nil;

      if ($iter) $Array_reject$excl$81.$$p = null;
      
      
      if ($iter) $Array_reject$excl$81.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject!"], ($$82 = function(){var self = $$82.$$s == null ? this : $$82.$$s;

        return self.$size()}, $$82.$$s = self, $$82.$$arity = 0, $$82))
      };
      original = self.$length();
      $send(self, 'delete_if', [], block.$to_proc());
      if (self.$length()['$=='](original)) {
        return nil
      } else {
        return self
      };
    }, $Array_reject$excl$81.$$arity = 0);
    
    Opal.def(self, '$replace', $Array_replace$83 = function $$replace(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      
      self.splice(0, self.length);
      self.push.apply(self, other);
    ;
      return self;
    }, $Array_replace$83.$$arity = 1);
    
    Opal.def(self, '$reverse', $Array_reverse$84 = function $$reverse() {
      var self = this;

      return self.slice(0).reverse();
    }, $Array_reverse$84.$$arity = 0);
    
    Opal.def(self, '$reverse!', $Array_reverse$excl$85 = function() {
      var self = this;

      return self.reverse();
    }, $Array_reverse$excl$85.$$arity = 0);
    
    Opal.def(self, '$reverse_each', $Array_reverse_each$86 = function $$reverse_each() {
      var $iter = $Array_reverse_each$86.$$p, block = $iter || nil, $$87, self = this;

      if ($iter) $Array_reverse_each$86.$$p = null;
      
      
      if ($iter) $Array_reverse_each$86.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reverse_each"], ($$87 = function(){var self = $$87.$$s == null ? this : $$87.$$s;

        return self.$size()}, $$87.$$s = self, $$87.$$arity = 0, $$87))
      };
      $send(self.$reverse(), 'each', [], block.$to_proc());
      return self;
    }, $Array_reverse_each$86.$$arity = 0);
    
    Opal.def(self, '$rindex', $Array_rindex$88 = function $$rindex(object) {
      var $iter = $Array_rindex$88.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_rindex$88.$$p = null;
      
      
      if ($iter) $Array_rindex$88.$$p = null;;
      ;
      
      var i, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }

          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else if (object == null) {
        return self.$enum_for("rindex");
      }

      return nil;
    ;
    }, $Array_rindex$88.$$arity = -1);
    
    Opal.def(self, '$rotate', $Array_rotate$89 = function $$rotate(n) {
      var self = this;

      
      
      if (n == null) {
        n = 1;
      };
      
      var ary, idx, firstPart, lastPart;

      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int')

      if (self.length === 1) {
        return self.slice();
      }
      if (self.length === 0) {
        return [];
      }

      ary = self.slice();
      idx = n % ary.length;

      firstPart = ary.slice(idx);
      lastPart = ary.slice(0, idx);
      return firstPart.concat(lastPart);
    ;
    }, $Array_rotate$89.$$arity = -1);
    
    Opal.def(self, '$rotate!', $Array_rotate$excl$90 = function(cnt) {
      var self = this, ary = nil;

      
      
      if (cnt == null) {
        cnt = 1;
      };
      
      if (self.length === 0 || self.length === 1) {
        return self;
      }
      cnt = $coerce_to(cnt, $$($nesting, 'Integer'), 'to_int');
    ;
      ary = self.$rotate(cnt);
      return self.$replace(ary);
    }, $Array_rotate$excl$90.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'SampleRandom');

      var $nesting = [self].concat($parent_nesting), $SampleRandom_initialize$91, $SampleRandom_rand$92;

      self.$$prototype.rng = nil;
      
      
      Opal.def(self, '$initialize', $SampleRandom_initialize$91 = function $$initialize(rng) {
        var self = this;

        return (self.rng = rng)
      }, $SampleRandom_initialize$91.$$arity = 1);
      return (Opal.def(self, '$rand', $SampleRandom_rand$92 = function $$rand(size) {
        var self = this, random = nil;

        
        random = $coerce_to(self.rng.$rand(size), $$($nesting, 'Integer'), 'to_int');
        if ($truthy(random < 0)) {
          self.$raise($$($nesting, 'RangeError'), "random value must be >= 0")};
        if ($truthy(random < size)) {
        } else {
          self.$raise($$($nesting, 'RangeError'), "random value must be less than Array size")
        };
        return random;
      }, $SampleRandom_rand$92.$$arity = 1), nil) && 'rand';
    })($nesting[0], null, $nesting);
    
    Opal.def(self, '$sample', $Array_sample$93 = function $$sample(count, options) {
      var self = this, o = nil, $ret_or_3 = nil, rng = nil, $ret_or_4 = nil;

      
      ;
      ;
      if ($truthy(count === undefined)) {
        return self.$at($$($nesting, 'Kernel').$rand(self.length))};
      if ($truthy(options === undefined)) {
        if ($truthy((o = $$($nesting, 'Opal')['$coerce_to?'](count, $$($nesting, 'Hash'), "to_hash")))) {
          
          options = o;
          count = nil;
        } else {
          
          options = nil;
          count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
        }
      } else {
        
        count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
        options = $coerce_to(options, $$($nesting, 'Hash'), 'to_hash');
      };
      if ($truthy((function() {if ($truthy(($ret_or_3 = count))) {
        return count < 0;
      } else {
        return $ret_or_3
      }; return nil; })())) {
        self.$raise($$($nesting, 'ArgumentError'), "count must be greater than 0")};
      if ($truthy(options)) {
        rng = options['$[]']("random")};
      rng = (function() {if ($truthy((function() {if ($truthy(($ret_or_4 = rng))) {
        return rng['$respond_to?']("rand")
      } else {
        return $ret_or_4
      }; return nil; })())) {
        return $$($nesting, 'SampleRandom').$new(rng)
      } else {
        return $$($nesting, 'Kernel')
      }; return nil; })();
      if ($truthy(count)) {
      } else {
        return self[rng.$rand(self.length)]
      };
      

      var abandon, spin, result, i, j, k, targetIndex, oldValue;

      if (count > self.length) {
        count = self.length;
      }

      switch (count) {
        case 0:
          return [];
          break;
        case 1:
          return [self[rng.$rand(self.length)]];
          break;
        case 2:
          i = rng.$rand(self.length);
          j = rng.$rand(self.length);
          if (i === j) {
            j = i === 0 ? i + 1 : i - 1;
          }
          return [self[i], self[j]];
          break;
        default:
          if (self.length / count > 3) {
            abandon = false;
            spin = 0;

            result = $$($nesting, 'Array').$new(count);
            i = 1;

            result[0] = rng.$rand(self.length);
            while (i < count) {
              k = rng.$rand(self.length);
              j = 0;

              while (j < i) {
                while (k === result[j]) {
                  spin++;
                  if (spin > 100) {
                    abandon = true;
                    break;
                  }
                  k = rng.$rand(self.length);
                }
                if (abandon) { break; }

                j++;
              }

              if (abandon) { break; }

              result[i] = k;

              i++;
            }

            if (!abandon) {
              i = 0;
              while (i < count) {
                result[i] = self[result[i]];
                i++;
              }

              return result;
            }
          }

          result = self.slice();

          for (var c = 0; c < count; c++) {
            targetIndex = rng.$rand(self.length);
            oldValue = result[c];
            result[c] = result[targetIndex];
            result[targetIndex] = oldValue;
          }

          return count === self.length ? result : (result)['$[]'](0, count);
      }
    ;
    }, $Array_sample$93.$$arity = -1);
    
    Opal.def(self, '$select', $Array_select$94 = function $$select() {
      var $iter = $Array_select$94.$$p, block = $iter || nil, $$95, self = this;

      if ($iter) $Array_select$94.$$p = null;
      
      
      if ($iter) $Array_select$94.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["select"], ($$95 = function(){var self = $$95.$$s == null ? this : $$95.$$s;

        return self.$size()}, $$95.$$s = self, $$95.$$arity = 0, $$95))
      };
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = $yield1(block, item);

        if ($truthy(value)) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_select$94.$$arity = 0);
    
    Opal.def(self, '$select!', $Array_select$excl$96 = function() {
      var $iter = $Array_select$excl$96.$$p, block = $iter || nil, $$97, self = this;

      if ($iter) $Array_select$excl$96.$$p = null;
      
      
      if ($iter) $Array_select$excl$96.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["select!"], ($$97 = function(){var self = $$97.$$s == null ? this : $$97.$$s;

        return self.$size()}, $$97.$$s = self, $$97.$$arity = 0, $$97))
      };
      
      var original = self.length;
      $send(self, 'keep_if', [], block.$to_proc());
      return self.length === original ? nil : self;
    ;
    }, $Array_select$excl$96.$$arity = 0);
    Opal.alias(self, "filter", "select");
    Opal.alias(self, "filter!", "select!");
    
    Opal.def(self, '$shift', $Array_shift$98 = function $$shift(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return shiftNoArg(self);};
      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(count < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      return self.splice(0, count);;
    }, $Array_shift$98.$$arity = -1);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$shuffle', $Array_shuffle$99 = function $$shuffle(rng) {
      var self = this;

      
      ;
      return self.$dup().$to_a()['$shuffle!'](rng);
    }, $Array_shuffle$99.$$arity = -1);
    
    Opal.def(self, '$shuffle!', $Array_shuffle$excl$100 = function(rng) {
      var self = this;

      
      ;
      
      var randgen, i = self.length, j, tmp;

      if (rng !== undefined) {
        rng = $$($nesting, 'Opal')['$coerce_to?'](rng, $$($nesting, 'Hash'), "to_hash");

        if (rng !== nil) {
          rng = rng['$[]']("random");

          if (rng !== nil && rng['$respond_to?']("rand")) {
            randgen = rng;
          }
        }
      }

      while (i) {
        if (randgen) {
          j = randgen.$rand(i).$to_int();

          if (j < 0) {
            self.$raise($$($nesting, 'RangeError'), "" + "random number too small " + (j))
          }

          if (j >= i) {
            self.$raise($$($nesting, 'RangeError'), "" + "random number too big " + (j))
          }
        }
        else {
          j = self.$rand(i);
        }

        tmp = self[--i];
        self[i] = self[j];
        self[j] = tmp;
      }

      return self;
    ;
    }, $Array_shuffle$excl$100.$$arity = -1);
    Opal.alias(self, "slice", "[]");
    
    Opal.def(self, '$slice!', $Array_slice$excl$101 = function(index, length) {
      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;

      
      ;
      result = nil;
      if ($truthy(length === undefined)) {
        if ($truthy($$($nesting, 'Range')['$==='](index))) {
          
          range = index;
          result = self['$[]'](range);
          range_start = $coerce_to(range.begin, $$($nesting, 'Integer'), 'to_int');
          range_end = $coerce_to(range.end, $$($nesting, 'Integer'), 'to_int');
          
          if (range_start < 0) {
            range_start += self.length;
          }

          if (range_end < 0) {
            range_end += self.length;
          } else if (range_end >= self.length) {
            range_end = self.length - 1;
            if (range.excl) {
              range_end += 1;
            }
          }

          var range_length = range_end - range_start;
          if (range.excl) {
            range_end -= 1;
          } else {
            range_length += 1;
          }

          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
            self.splice(range_start, range_length);
          }
        ;
        } else {
          
          start = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');
          
          if (start < 0) {
            start += self.length;
          }

          if (start < 0 || start >= self.length) {
            return nil;
          }

          result = self[start];

          if (start === 0) {
            self.shift();
          } else {
            self.splice(start, 1);
          }
        ;
        }
      } else {
        
        start = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');
        length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');
        
        if (length < 0) {
          return nil;
        }

        var end = start + length;

        result = self['$[]'](start, length);

        if (start < 0) {
          start += self.length;
        }

        if (start + length > self.length) {
          length = self.length - start;
        }

        if (start < self.length && start >= 0) {
          self.splice(start, length);
        }
      ;
      };
      return result;
    }, $Array_slice$excl$101.$$arity = -2);
    
    Opal.def(self, '$sort', $Array_sort$102 = function $$sort() {
      var $iter = $Array_sort$102.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_sort$102.$$p = null;
      
      
      if ($iter) $Array_sort$102.$$p = null;;
      if ($truthy(self.length > 1)) {
      } else {
        return self
      };
      
      if (block === nil) {
        block = function(a, b) {
          return (a)['$<=>'](b);
        };
      }

      return self.slice().sort(function(x, y) {
        var ret = block(x, y);

        if (ret === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + ((x).$inspect()) + " with " + ((y).$inspect()) + " failed");
        }

        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);
      });
    ;
    }, $Array_sort$102.$$arity = 0);
    
    Opal.def(self, '$sort!', $Array_sort$excl$103 = function() {
      var $iter = $Array_sort$excl$103.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_sort$excl$103.$$p = null;
      
      
      if ($iter) $Array_sort$excl$103.$$p = null;;
      
      var result;

      if ((block !== nil)) {
        result = $send((self.slice()), 'sort', [], block.$to_proc());
      }
      else {
        result = (self.slice()).$sort();
      }

      self.length = 0;
      for(var i = 0, length = result.length; i < length; i++) {
        self.push(result[i]);
      }

      return self;
    ;
    }, $Array_sort$excl$103.$$arity = 0);
    
    Opal.def(self, '$sort_by!', $Array_sort_by$excl$104 = function() {
      var $iter = $Array_sort_by$excl$104.$$p, block = $iter || nil, $$105, self = this;

      if ($iter) $Array_sort_by$excl$104.$$p = null;
      
      
      if ($iter) $Array_sort_by$excl$104.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["sort_by!"], ($$105 = function(){var self = $$105.$$s == null ? this : $$105.$$s;

        return self.$size()}, $$105.$$s = self, $$105.$$arity = 0, $$105))
      };
      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));
    }, $Array_sort_by$excl$104.$$arity = 0);
    
    Opal.def(self, '$take', $Array_take$106 = function $$take(count) {
      var self = this;

      
      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'));
      }

      return self.slice(0, count);
    
    }, $Array_take$106.$$arity = 1);
    
    Opal.def(self, '$take_while', $Array_take_while$107 = function $$take_while() {
      var $iter = $Array_take_while$107.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_take_while$107.$$p = null;
      
      
      if ($iter) $Array_take_while$107.$$p = null;;
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = block(item);

        if (value === false || value === nil) {
          return result;
        }

        result.push(item);
      }

      return result;
    ;
    }, $Array_take_while$107.$$arity = 0);
    
    Opal.def(self, '$to_a', $Array_to_a$108 = function $$to_a() {
      var self = this;

      
      if (self.$$class === Opal.Array) {
        return self;
      }
      else {
        return Opal.Array.$new(self);
      }
    
    }, $Array_to_a$108.$$arity = 0);
    
    Opal.def(self, '$to_ary', $Array_to_ary$109 = function $$to_ary() {
      var self = this;

      return self
    }, $Array_to_ary$109.$$arity = 0);
    
    Opal.def(self, '$to_h', $Array_to_h$110 = function $$to_h() {
      var $iter = $Array_to_h$110.$$p, block = $iter || nil, self = this, array = nil;

      if ($iter) $Array_to_h$110.$$p = null;
      
      
      if ($iter) $Array_to_h$110.$$p = null;;
      array = self;
      if ((block !== nil)) {
        array = $send(array, 'map', [], block.$to_proc())};
      
      var i, len = array.length, ary, key, val, hash = $hash2([], {});

      for (i = 0; i < len; i++) {
        ary = $$($nesting, 'Opal')['$coerce_to?'](array[i], $$($nesting, 'Array'), "to_ary");
        if (!ary.$$is_array) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong element type " + ((ary).$class()) + " at " + (i) + " (expected array)")
        }
        if (ary.length !== 2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong array length at " + (i) + " (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];
        $hash_put(hash, key, val);
      }

      return hash;
    ;
    }, $Array_to_h$110.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$transpose', $Array_transpose$111 = function $$transpose() {
      var $$112, self = this, result = nil, max = nil;

      
      if ($truthy(self['$empty?']())) {
        return []};
      result = [];
      max = nil;
      $send(self, 'each', [], ($$112 = function(row){var self = $$112.$$s == null ? this : $$112.$$s, $$113, $ret_or_5 = nil;

      
        
        if (row == null) {
          row = nil;
        };
        row = (function() {if ($truthy($$($nesting, 'Array')['$==='](row))) {
          return row.$to_a()
        } else {
          return ($coerce_to(row, $$($nesting, 'Array'), 'to_ary')).$to_a()
        }; return nil; })();
        max = (function() {if ($truthy(($ret_or_5 = max))) {
          return $ret_or_5
        } else {
          return row.length;
        }; return nil; })();
        if ($truthy((row.length)['$!='](max))) {
          self.$raise($$($nesting, 'IndexError'), "" + "element size differs (" + (row.length) + " should be " + (max) + ")")};
        return $send((row.length), 'times', [], ($$113 = function(i){var self = $$113.$$s == null ? this : $$113.$$s, entry = nil, $ret_or_6 = nil, $writer = nil;

        
          
          if (i == null) {
            i = nil;
          };
          entry = (function() {if ($truthy(($ret_or_6 = result['$[]'](i)))) {
            return $ret_or_6
          } else {
            
            $writer = [i, []];
            $send(result, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }; return nil; })();
          return entry['$<<'](row.$at(i));}, $$113.$$s = self, $$113.$$arity = 1, $$113));}, $$112.$$s = self, $$112.$$arity = 1, $$112));
      return result;
    }, $Array_transpose$111.$$arity = 0);
    
    Opal.def(self, '$union', $Array_union$114 = function $$union($a) {
      var $post_args, arrays, $$115, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      arrays = $post_args;;
      return $send(arrays, 'reduce', [self.$uniq()], ($$115 = function(a, b){var self = $$115.$$s == null ? this : $$115.$$s;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a['$|'](b);}, $$115.$$s = self, $$115.$$arity = 2, $$115));
    }, $Array_union$114.$$arity = -1);
    
    Opal.def(self, '$uniq', $Array_uniq$116 = function $$uniq() {
      var $iter = $Array_uniq$116.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_uniq$116.$$p = null;
      
      
      if ($iter) $Array_uniq$116.$$p = null;;
      
      var hash = $hash2([], {}), i, length, item, key;

      if (block === nil) {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if ($hash_get(hash, item) === undefined) {
            $hash_put(hash, item, item);
          }
        }
      }
      else {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          key = $yield1(block, item);
          if ($hash_get(hash, key) === undefined) {
            $hash_put(hash, key, item);
          }
        }
      }

      return (hash).$values();
    ;
    }, $Array_uniq$116.$$arity = 0);
    
    Opal.def(self, '$uniq!', $Array_uniq$excl$117 = function() {
      var $iter = $Array_uniq$excl$117.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_uniq$excl$117.$$p = null;
      
      
      if ($iter) $Array_uniq$excl$117.$$p = null;;
      
      var original_length = self.length, hash = $hash2([], {}), i, length, item, key;

      for (i = 0, length = original_length; i < length; i++) {
        item = self[i];
        key = (block === nil ? item : $yield1(block, item));

        if ($hash_get(hash, key) === undefined) {
          $hash_put(hash, key, item);
          continue;
        }

        self.splice(i, 1);
        length--;
        i--;
      }

      return self.length === original_length ? nil : self;
    ;
    }, $Array_uniq$excl$117.$$arity = 0);
    
    Opal.def(self, '$unshift', $Array_unshift$118 = function $$unshift($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      
      var selfLength = self.length
      var objectsLength = objects.length
      if (objectsLength == 0) return self;
      var index = selfLength - objectsLength
      for (var i = 0; i < objectsLength; i++) {
        self.push(self[index + i])
      }
      var len = selfLength - 1
      while (len - objectsLength >= 0) {
        self[len] = self[len - objectsLength]
        len--
      }
      for (var j = 0; j < objectsLength; j++) {
        self[j] = objects[j]
      }
      return self;
    ;
    }, $Array_unshift$118.$$arity = -1);
    Opal.alias(self, "prepend", "unshift");
    
    Opal.def(self, '$values_at', $Array_values_at$119 = function $$values_at($a) {
      var $post_args, args, $$120, self = this, out = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      out = [];
      $send(args, 'each', [], ($$120 = function(elem){var self = $$120.$$s == null ? this : $$120.$$s, $$121, finish = nil, start = nil, i = nil;

      
        
        if (elem == null) {
          elem = nil;
        };
        if ($truthy(elem['$is_a?']($$($nesting, 'Range')))) {
          
          finish = $coerce_to(elem.$last(), $$($nesting, 'Integer'), 'to_int');
          start = $coerce_to(elem.$first(), $$($nesting, 'Integer'), 'to_int');
          
          if (start < 0) {
            start = start + self.length;
            return nil;;
          }
        ;
          
          if (finish < 0) {
            finish = finish + self.length;
          }
          if (elem['$exclude_end?']()) {
            finish--;
          }
          if (finish < start) {
            return nil;;
          }
        ;
          return $send(start, 'upto', [finish], ($$121 = function(i){var self = $$121.$$s == null ? this : $$121.$$s;

          
            
            if (i == null) {
              i = nil;
            };
            return out['$<<'](self.$at(i));}, $$121.$$s = self, $$121.$$arity = 1, $$121));
        } else {
          
          i = $coerce_to(elem, $$($nesting, 'Integer'), 'to_int');
          return out['$<<'](self.$at(i));
        };}, $$120.$$s = self, $$120.$$arity = 1, $$120));
      return out;
    }, $Array_values_at$119.$$arity = -1);
    
    Opal.def(self, '$zip', $Array_zip$122 = function $$zip($a) {
      var $iter = $Array_zip$122.$$p, block = $iter || nil, $post_args, others, self = this, $ret_or_7 = nil;

      if ($iter) $Array_zip$122.$$p = null;
      
      
      if ($iter) $Array_zip$122.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      
      var result = [], size = self.length, part, o, i, j, jj;

      for (j = 0, jj = others.length; j < jj; j++) {
        o = others[j];
        if (o.$$is_array) {
          continue;
        }
        if (o.$$is_range || o.$$is_enumerator) {
          others[j] = o.$take(size);
          continue;
        }
        others[j] = (function() {if ($truthy(($ret_or_7 = $$($nesting, 'Opal')['$coerce_to?'](o, $$($nesting, 'Array'), "to_ary")))) {
        return $ret_or_7
      } else {
        return $$($nesting, 'Opal')['$coerce_to!'](o, $$($nesting, 'Enumerator'), "to_enum", "each")
      }; return nil; })().$to_a();
      }

      for (i = 0; i < size; i++) {
        part = [self[i]];

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j][i];

          if (o == null) {
            o = nil;
          }

          part[j + 1] = o;
        }

        result[i] = part;
      }

      if (block !== nil) {
        for (i = 0; i < size; i++) {
          block(result[i]);
        }

        return nil;
      }

      return result;
    ;
    }, $Array_zip$122.$$arity = -1);
    Opal.defs(self, '$inherited', $Array_inherited$123 = function $$inherited(klass) {
      var self = this;

      
      klass.$$prototype.$to_a = function() {
        return this.slice(0, this.length);
      }
    
    }, $Array_inherited$123.$$arity = 1);
    
    Opal.def(self, '$instance_variables', $Array_instance_variables$124 = function $$instance_variables() {
      var $$125, $iter = $Array_instance_variables$124.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_instance_variables$124.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      return $send($send2(self, Opal.find_super_dispatcher(self, 'instance_variables', $Array_instance_variables$124, false, true), 'instance_variables', $zuper, $iter), 'reject', [], ($$125 = function(ivar){var self = $$125.$$s == null ? this : $$125.$$s, $ret_or_8 = nil;

      
        
        if (ivar == null) {
          ivar = nil;
        };
        if ($truthy(($ret_or_8 = /^@\d+$/.test(ivar)))) {
          return $ret_or_8
        } else {
          return ivar['$==']("@length")
        };}, $$125.$$s = self, $$125.$$arity = 1, $$125))
    }, $Array_instance_variables$124.$$arity = 0);
    $$($nesting, 'Opal').$pristine(self.$singleton_class(), "allocate");
    $$($nesting, 'Opal').$pristine(self, "copy_instance_variables", "initialize_dup");
    return (Opal.def(self, '$pack', $Array_pack$126 = function $$pack($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
    }, $Array_pack$126.$$arity = -1), nil) && 'pack';
  })($nesting[0], Array, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/hash"] = function(Opal) {
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$[]', '$merge!', '$allocate', '$raise', '$coerce_to!', '$each', '$fetch', '$>=', '$>', '$==', '$compare_by_identity', '$lambda?', '$abs', '$arity', '$enum_for', '$size', '$respond_to?', '$class', '$dig', '$except!', '$dup', '$delete', '$new', '$inspect', '$map', '$to_proc', '$flatten', '$eql?', '$default', '$default_proc', '$default_proc=', '$-', '$default=', '$to_h', '$proc']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $Hash_$$$1, $Hash_allocate$2, $Hash_try_convert$3, $Hash_initialize$4, $Hash_$eq_eq$5, $Hash_$gt_eq$6, $Hash_$gt$8, $Hash_$lt$9, $Hash_$lt_eq$10, $Hash_$$$11, $Hash_$$$eq$12, $Hash_assoc$13, $Hash_clear$14, $Hash_clone$15, $Hash_compact$16, $Hash_compact$excl$17, $Hash_compare_by_identity$18, $Hash_compare_by_identity$ques$19, $Hash_default$20, $Hash_default$eq$21, $Hash_default_proc$22, $Hash_default_proc$eq$23, $Hash_delete$24, $Hash_delete_if$25, $Hash_dig$27, $Hash_each$28, $Hash_each_key$30, $Hash_each_value$32, $Hash_empty$ques$34, $Hash_except$35, $Hash_except$excl$36, $Hash_fetch$38, $Hash_fetch_values$39, $Hash_flatten$41, $Hash_has_key$ques$42, $Hash_has_value$ques$43, $Hash_hash$44, $Hash_index$45, $Hash_indexes$46, $Hash_inspect$47, $Hash_invert$48, $Hash_keep_if$49, $Hash_keys$51, $Hash_length$52, $Hash_merge$53, $Hash_merge$excl$54, $Hash_rassoc$55, $Hash_rehash$56, $Hash_reject$57, $Hash_reject$excl$59, $Hash_replace$61, $Hash_select$62, $Hash_select$excl$64, $Hash_shift$66, $Hash_slice$67, $Hash_to_a$68, $Hash_to_h$69, $Hash_to_hash$70, $Hash_to_proc$71, $Hash_transform_keys$73, $Hash_transform_keys$excl$75, $Hash_transform_values$77, $Hash_transform_values$excl$79, $Hash_values$81;

    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_hash = true;
    Opal.defs(self, '$[]', $Hash_$$$1 = function($a) {
      var $post_args, argv, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      argv = $post_args;;
      
      var hash, argc = argv.length, i;

      if (argc === 1) {
        hash = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Array'), "to_ary");
        if (argv === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash")
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          if (!argv[i].$$is_array) continue;
          switch(argv[i].length) {
          case 1:
            hash.$store(argv[i][0], nil);
            break;
          case 2:
            hash.$store(argv[i][0], argv[i][1]);
            break;
          default:
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid number of elements (" + (argv[i].length) + " for 1..2)")
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    ;
    }, $Hash_$$$1.$$arity = -1);
    Opal.defs(self, '$allocate', $Hash_allocate$2 = function $$allocate() {
      var self = this;

      
      var hash = new self.$$constructor();

      Opal.hash_init(hash);

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    }, $Hash_allocate$2.$$arity = 0);
    Opal.defs(self, '$try_convert', $Hash_try_convert$3 = function $$try_convert(obj) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Hash'), "to_hash")
    }, $Hash_try_convert$3.$$arity = 1);
    
    Opal.def(self, '$initialize', $Hash_initialize$4 = function $$initialize(defaults) {
      var $iter = $Hash_initialize$4.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_initialize$4.$$p = null;
      
      
      if ($iter) $Hash_initialize$4.$$p = null;;
      ;
      
      if (defaults !== undefined && block !== nil) {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;

      return self;
    ;
    }, $Hash_initialize$4.$$arity = -1);
    
    Opal.def(self, '$==', $Hash_$eq_eq$5 = function(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.$$keys.length !== other.$$keys.length) {
        return false;
      }

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
          other_value = other.$$smap[key];
        } else {
          value = key.value;
          other_value = Opal.hash_get(other, key.key);
        }

        if (other_value === undefined || !value['$eql?'](other_value)) {
          return false;
        }
      }

      return true;
    
    }, $Hash_$eq_eq$5.$$arity = 1);
    
    Opal.def(self, '$>=', $Hash_$gt_eq$6 = function(other) {
      var $$7, self = this, result = nil;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length < other.$$keys.length) {
        return false
      }
    ;
      result = true;
      $send(other, 'each', [], ($$7 = function(other_key, other_val){var self = $$7.$$s == null ? this : $$7.$$s, val = nil;

      
        
        if (other_key == null) {
          other_key = nil;
        };
        
        if (other_val == null) {
          other_val = nil;
        };
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, $$7.$$s = self, $$7.$$arity = 2, $$7));
      return result;
    }, $Hash_$gt_eq$6.$$arity = 1);
    
    Opal.def(self, '$>', $Hash_$gt$8 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length <= other.$$keys.length) {
        return false
      }
    ;
      return $rb_ge(self, other);
    }, $Hash_$gt$8.$$arity = 1);
    
    Opal.def(self, '$<', $Hash_$lt$9 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      return $rb_gt(other, self);
    }, $Hash_$lt$9.$$arity = 1);
    
    Opal.def(self, '$<=', $Hash_$lt_eq$10 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      return $rb_ge(other, self);
    }, $Hash_$lt_eq$10.$$arity = 1);
    
    Opal.def(self, '$[]', $Hash_$$$11 = function(key) {
      var self = this;

      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    }, $Hash_$$$11.$$arity = 1);
    
    Opal.def(self, '$[]=', $Hash_$$$eq$12 = function(key, value) {
      var self = this;

      
      Opal.hash_put(self, key, value);
      return value;
    
    }, $Hash_$$$eq$12.$$arity = 2);
    
    Opal.def(self, '$assoc', $Hash_assoc$13 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          if ((key)['$=='](object)) {
            return [key, self.$$smap[key]];
          }
        } else {
          if ((key.key)['$=='](object)) {
            return [key.key, key.value];
          }
        }
      }

      return nil;
    
    }, $Hash_assoc$13.$$arity = 1);
    
    Opal.def(self, '$clear', $Hash_clear$14 = function $$clear() {
      var self = this;

      
      Opal.hash_init(self);
      return self;
    
    }, $Hash_clear$14.$$arity = 0);
    
    Opal.def(self, '$clone', $Hash_clone$15 = function $$clone() {
      var self = this;

      
      var hash = new self.$$class();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, $Hash_clone$15.$$arity = 0);
    
    Opal.def(self, '$compact', $Hash_compact$16 = function $$compact() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    
    }, $Hash_compact$16.$$arity = 0);
    
    Opal.def(self, '$compact!', $Hash_compact$excl$17 = function() {
      var self = this;

      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    
    }, $Hash_compact$excl$17.$$arity = 0);
    
    Opal.def(self, '$compare_by_identity', $Hash_compare_by_identity$18 = function $$compare_by_identity() {
      var self = this;

      
      var i, ii, key, keys = self.$$keys, identity_hash;

      if (self.$$by_identity) return self;
      if (self.$$keys.length === 0) {
        self.$$by_identity = true
        return self;
      }

      identity_hash = $hash2([], {}).$compare_by_identity();
      for(i = 0, ii = keys.length; i < ii; i++) {
        key = keys[i];
        if (!key.$$is_string) key = key.key;
        Opal.hash_put(identity_hash, key, Opal.hash_get(self, key));
      }

      self.$$by_identity = true;
      self.$$map = identity_hash.$$map;
      self.$$smap = identity_hash.$$smap;
      return self;
    
    }, $Hash_compare_by_identity$18.$$arity = 0);
    
    Opal.def(self, '$compare_by_identity?', $Hash_compare_by_identity$ques$19 = function() {
      var self = this;

      return self.$$by_identity === true;
    }, $Hash_compare_by_identity$ques$19.$$arity = 0);
    
    Opal.def(self, '$default', $Hash_default$20 = function(key) {
      var self = this;

      
      ;
      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    ;
    }, $Hash_default$20.$$arity = -1);
    
    Opal.def(self, '$default=', $Hash_default$eq$21 = function(object) {
      var self = this;

      
      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    }, $Hash_default$eq$21.$$arity = 1);
    
    Opal.def(self, '$default_proc', $Hash_default_proc$22 = function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    }, $Hash_default_proc$22.$$arity = 0);
    
    Opal.def(self, '$default_proc=', $Hash_default_proc$eq$23 = function(default_proc) {
      var self = this;

      
      var proc = default_proc;

      if (proc !== nil) {
        proc = $$($nesting, 'Opal')['$coerce_to!'](proc, $$($nesting, 'Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          self.$raise($$($nesting, 'TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    }, $Hash_default_proc$eq$23.$$arity = 1);
    
    Opal.def(self, '$delete', $Hash_delete$24 = function(key) {
      var $iter = $Hash_delete$24.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_delete$24.$$p = null;
      
      
      if ($iter) $Hash_delete$24.$$p = null;;
      
      var value = Opal.hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return Opal.yield1(block, key);
      }

      return nil;
    ;
    }, $Hash_delete$24.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Hash_delete_if$25 = function $$delete_if() {
      var $iter = $Hash_delete_if$25.$$p, block = $iter || nil, $$26, self = this;

      if ($iter) $Hash_delete_if$25.$$p = null;
      
      
      if ($iter) $Hash_delete_if$25.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["delete_if"], ($$26 = function(){var self = $$26.$$s == null ? this : $$26.$$s;

        return self.$size()}, $$26.$$s = self, $$26.$$arity = 0, $$26))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, $Hash_delete_if$25.$$arity = 0);
    Opal.alias(self, "dup", "clone");
    
    Opal.def(self, '$dig', $Hash_dig$27 = function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      keys = $post_args;;
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, $Hash_dig$27.$$arity = -2);
    
    Opal.def(self, '$each', $Hash_each$28 = function $$each() {
      var $iter = $Hash_each$28.$$p, block = $iter || nil, $$29, self = this;

      if ($iter) $Hash_each$28.$$p = null;
      
      
      if ($iter) $Hash_each$28.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$29 = function(){var self = $$29.$$s == null ? this : $$29.$$s;

        return self.$size()}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.yield1(block, [key, value]);
      }

      return self;
    ;
    }, $Hash_each$28.$$arity = 0);
    
    Opal.def(self, '$each_key', $Hash_each_key$30 = function $$each_key() {
      var $iter = $Hash_each_key$30.$$p, block = $iter || nil, $$31, self = this;

      if ($iter) $Hash_each_key$30.$$p = null;
      
      
      if ($iter) $Hash_each_key$30.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each_key"], ($$31 = function(){var self = $$31.$$s == null ? this : $$31.$$s;

        return self.$size()}, $$31.$$s = self, $$31.$$arity = 0, $$31))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? key : key.key);
      }

      return self;
    ;
    }, $Hash_each_key$30.$$arity = 0);
    Opal.alias(self, "each_pair", "each");
    
    Opal.def(self, '$each_value', $Hash_each_value$32 = function $$each_value() {
      var $iter = $Hash_each_value$32.$$p, block = $iter || nil, $$33, self = this;

      if ($iter) $Hash_each_value$32.$$p = null;
      
      
      if ($iter) $Hash_each_value$32.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each_value"], ($$33 = function(){var self = $$33.$$s == null ? this : $$33.$$s;

        return self.$size()}, $$33.$$s = self, $$33.$$arity = 0, $$33))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? self.$$smap[key] : key.value);
      }

      return self;
    ;
    }, $Hash_each_value$32.$$arity = 0);
    
    Opal.def(self, '$empty?', $Hash_empty$ques$34 = function() {
      var self = this;

      return self.$$keys.length === 0;
    }, $Hash_empty$ques$34.$$arity = 0);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$except', $Hash_except$35 = function $$except($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      return $send(self.$dup(), 'except!', Opal.to_a(keys));
    }, $Hash_except$35.$$arity = -1);
    
    Opal.def(self, '$except!', $Hash_except$excl$36 = function($a) {
      var $post_args, keys, $$37, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      $send(keys, 'each', [], ($$37 = function(key){var self = $$37.$$s == null ? this : $$37.$$s;

      
        
        if (key == null) {
          key = nil;
        };
        return self.$delete(key);}, $$37.$$s = self, $$37.$$arity = 1, $$37));
      return self;
    }, $Hash_except$excl$36.$$arity = -1);
    
    Opal.def(self, '$fetch', $Hash_fetch$38 = function $$fetch(key, defaults) {
      var $iter = $Hash_fetch$38.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_fetch$38.$$p = null;
      
      
      if ($iter) $Hash_fetch$38.$$p = null;;
      ;
      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return self.$raise($$($nesting, 'KeyError').$new("" + "key not found: " + (key.$inspect()), $hash2(["key", "receiver"], {"key": key, "receiver": self})));
    }, $Hash_fetch$38.$$arity = -2);
    
    Opal.def(self, '$fetch_values', $Hash_fetch_values$39 = function $$fetch_values($a) {
      var $iter = $Hash_fetch_values$39.$$p, block = $iter || nil, $post_args, keys, $$40, self = this;

      if ($iter) $Hash_fetch_values$39.$$p = null;
      
      
      if ($iter) $Hash_fetch_values$39.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      return $send(keys, 'map', [], ($$40 = function(key){var self = $$40.$$s == null ? this : $$40.$$s;

      
        
        if (key == null) {
          key = nil;
        };
        return $send(self, 'fetch', [key], block.$to_proc());}, $$40.$$s = self, $$40.$$arity = 1, $$40));
    }, $Hash_fetch_values$39.$$arity = -1);
    
    Opal.def(self, '$flatten', $Hash_flatten$41 = function $$flatten(level) {
      var self = this;

      
      
      if (level == null) {
        level = 1;
      };
      level = $$($nesting, 'Opal')['$coerce_to!'](level, $$($nesting, 'Integer'), "to_int");
      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            continue;
          }

          result = result.concat((value).$flatten(level - 2));
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, $Hash_flatten$41.$$arity = -1);
    
    Opal.def(self, '$has_key?', $Hash_has_key$ques$42 = function(key) {
      var self = this;

      return Opal.hash_get(self, key) !== undefined;
    }, $Hash_has_key$ques$42.$$arity = 1);
    
    Opal.def(self, '$has_value?', $Hash_has_value$ques$43 = function(value) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (((key.$$is_string ? self.$$smap[key] : key.value))['$=='](value)) {
          return true;
        }
      }

      return false;
    
    }, $Hash_has_value$ques$43.$$arity = 1);
    
    Opal.def(self, '$hash', $Hash_hash$44 = function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          hash_id = self.$object_id(),
          result = ['Hash'],
          key, item;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        if (Opal[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (var i = 0, keys = self.$$keys, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            result.push([key, self.$$smap[key].$hash()]);
          } else {
            result.push([key.key_hash, key.value.$hash()]);
          }
        }

        return result.sort().join();

      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, $Hash_hash$44.$$arity = 0);
    Opal.alias(self, "include?", "has_key?");
    
    Opal.def(self, '$index', $Hash_index$45 = function $$index(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return key;
        }
      }

      return nil;
    
    }, $Hash_index$45.$$arity = 1);
    
    Opal.def(self, '$indexes', $Hash_indexes$46 = function $$indexes($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = Opal.hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, $Hash_indexes$46.$$arity = -1);
    Opal.alias(self, "indices", "indexes");
    var inspect_ids;
    
    Opal.def(self, '$inspect', $Hash_inspect$47 = function $$inspect() {
      var self = this;

      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];

      try {
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          result.push(key.$inspect() + '=>' + value.$inspect());
        }

        return '{' + result.join(', ') + '}';

      } finally {
        if (top) {
          inspect_ids = undefined;
        }
      }
    
    }, $Hash_inspect$47.$$arity = 0);
    
    Opal.def(self, '$invert', $Hash_invert$48 = function $$invert() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.hash_put(hash, value, key);
      }

      return hash;
    
    }, $Hash_invert$48.$$arity = 0);
    
    Opal.def(self, '$keep_if', $Hash_keep_if$49 = function $$keep_if() {
      var $iter = $Hash_keep_if$49.$$p, block = $iter || nil, $$50, self = this;

      if ($iter) $Hash_keep_if$49.$$p = null;
      
      
      if ($iter) $Hash_keep_if$49.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["keep_if"], ($$50 = function(){var self = $$50.$$s == null ? this : $$50.$$s;

        return self.$size()}, $$50.$$s = self, $$50.$$arity = 0, $$50))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, $Hash_keep_if$49.$$arity = 0);
    Opal.alias(self, "key", "index");
    Opal.alias(self, "key?", "has_key?");
    
    Opal.def(self, '$keys', $Hash_keys$51 = function $$keys() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(key);
        } else {
          result.push(key.key);
        }
      }

      return result;
    
    }, $Hash_keys$51.$$arity = 0);
    
    Opal.def(self, '$length', $Hash_length$52 = function $$length() {
      var self = this;

      return self.$$keys.length;
    }, $Hash_length$52.$$arity = 0);
    Opal.alias(self, "member?", "has_key?");
    
    Opal.def(self, '$merge', $Hash_merge$53 = function $$merge($a) {
      var $iter = $Hash_merge$53.$$p, block = $iter || nil, $post_args, others, self = this;

      if ($iter) $Hash_merge$53.$$p = null;
      
      
      if ($iter) $Hash_merge$53.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      return $send(self.$dup(), 'merge!', Opal.to_a(others), block.$to_proc());
    }, $Hash_merge$53.$$arity = -1);
    
    Opal.def(self, '$merge!', $Hash_merge$excl$54 = function($a) {
      var $iter = $Hash_merge$excl$54.$$p, block = $iter || nil, $post_args, others, self = this;

      if ($iter) $Hash_merge$excl$54.$$p = null;
      
      
      if ($iter) $Hash_merge$excl$54.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      
      var i, j, other, other_keys, length, key, value, other_value;
      for (i = 0; i < others.length; ++i) {
        other = $$($nesting, 'Opal')['$coerce_to!'](others[i], $$($nesting, 'Hash'), "to_hash");
        other_keys = other.$$keys, length = other_keys.length;

        if (block === nil) {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            Opal.hash_put(self, key, other_value);
          }
        } else {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            value = Opal.hash_get(self, key);

            if (value === undefined) {
              Opal.hash_put(self, key, other_value);
              continue;
            }

            Opal.hash_put(self, key, block(key, value, other_value));
          }
        }
      }

      return self;
    ;
    }, $Hash_merge$excl$54.$$arity = -1);
    
    Opal.def(self, '$rassoc', $Hash_rassoc$55 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return [key, value];
        }
      }

      return nil;
    
    }, $Hash_rassoc$55.$$arity = 1);
    
    Opal.def(self, '$rehash', $Hash_rehash$56 = function $$rehash() {
      var self = this;

      
      Opal.hash_rehash(self);
      return self;
    
    }, $Hash_rehash$56.$$arity = 0);
    
    Opal.def(self, '$reject', $Hash_reject$57 = function $$reject() {
      var $iter = $Hash_reject$57.$$p, block = $iter || nil, $$58, self = this;

      if ($iter) $Hash_reject$57.$$p = null;
      
      
      if ($iter) $Hash_reject$57.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$58 = function(){var self = $$58.$$s == null ? this : $$58.$$s;

        return self.$size()}, $$58.$$s = self, $$58.$$arity = 0, $$58))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, $Hash_reject$57.$$arity = 0);
    
    Opal.def(self, '$reject!', $Hash_reject$excl$59 = function() {
      var $iter = $Hash_reject$excl$59.$$p, block = $iter || nil, $$60, self = this;

      if ($iter) $Hash_reject$excl$59.$$p = null;
      
      
      if ($iter) $Hash_reject$excl$59.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["reject!"], ($$60 = function(){var self = $$60.$$s == null ? this : $$60.$$s;

        return self.$size()}, $$60.$$s = self, $$60.$$arity = 0, $$60))
      };
      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    ;
    }, $Hash_reject$excl$59.$$arity = 0);
    
    Opal.def(self, '$replace', $Hash_replace$61 = function $$replace(other) {
      var self = this, $writer = nil;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      Opal.hash_init(self);

      for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        Opal.hash_put(self, key, other_value);
      }
    ;
      if ($truthy(other.$default_proc())) {
        
        $writer = [other.$default_proc()];
        $send(self, 'default_proc=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      } else {
        
        $writer = [other.$default()];
        $send(self, 'default=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      return self;
    }, $Hash_replace$61.$$arity = 1);
    
    Opal.def(self, '$select', $Hash_select$62 = function $$select() {
      var $iter = $Hash_select$62.$$p, block = $iter || nil, $$63, self = this;

      if ($iter) $Hash_select$62.$$p = null;
      
      
      if ($iter) $Hash_select$62.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["select"], ($$63 = function(){var self = $$63.$$s == null ? this : $$63.$$s;

        return self.$size()}, $$63.$$s = self, $$63.$$arity = 0, $$63))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, $Hash_select$62.$$arity = 0);
    
    Opal.def(self, '$select!', $Hash_select$excl$64 = function() {
      var $iter = $Hash_select$excl$64.$$p, block = $iter || nil, $$65, self = this;

      if ($iter) $Hash_select$excl$64.$$p = null;
      
      
      if ($iter) $Hash_select$excl$64.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["select!"], ($$65 = function(){var self = $$65.$$s == null ? this : $$65.$$s;

        return self.$size()}, $$65.$$s = self, $$65.$$arity = 0, $$65))
      };
      
      var result = nil;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
          result = self;
        }
      }

      return result;
    ;
    }, $Hash_select$excl$64.$$arity = 0);
    Opal.alias(self, "filter", "select");
    Opal.alias(self, "filter!", "select!");
    
    Opal.def(self, '$shift', $Hash_shift$66 = function $$shift() {
      var self = this;

      
      var keys = self.$$keys,
          key;

      if (keys.length > 0) {
        key = keys[0];

        key = key.$$is_string ? key : key.key;

        return [key, Opal.hash_delete(self, key)];
      }

      return self.$default(nil);
    
    }, $Hash_shift$66.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$slice', $Hash_slice$67 = function $$slice($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      
      var result = Opal.hash();

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i], value = Opal.hash_get(self, key);

        if (value !== undefined) {
          Opal.hash_put(result, key, value);
        }
      }

      return result;
    ;
    }, $Hash_slice$67.$$arity = -1);
    Opal.alias(self, "store", "[]=");
    
    Opal.def(self, '$to_a', $Hash_to_a$68 = function $$to_a() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push([key, value]);
      }

      return result;
    
    }, $Hash_to_a$68.$$arity = 0);
    
    Opal.def(self, '$to_h', $Hash_to_h$69 = function $$to_h() {
      var $iter = $Hash_to_h$69.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_to_h$69.$$p = null;
      
      
      if ($iter) $Hash_to_h$69.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'map', [], block.$to_proc()).$to_h()};
      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Opal.Hash();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    ;
    }, $Hash_to_h$69.$$arity = 0);
    
    Opal.def(self, '$to_hash', $Hash_to_hash$70 = function $$to_hash() {
      var self = this;

      return self
    }, $Hash_to_hash$70.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Hash_to_proc$71 = function $$to_proc() {
      var $$72, self = this;

      return $send(self, 'proc', [], ($$72 = function(key){var self = $$72.$$s == null ? this : $$72.$$s;

      
        ;
        
        if (key == null) {
          self.$raise($$($nesting, 'ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, $$72.$$s = self, $$72.$$arity = -1, $$72))
    }, $Hash_to_proc$71.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$transform_keys', $Hash_transform_keys$73 = function $$transform_keys() {
      var $iter = $Hash_transform_keys$73.$$p, block = $iter || nil, $$74, self = this;

      if ($iter) $Hash_transform_keys$73.$$p = null;
      
      
      if ($iter) $Hash_transform_keys$73.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_keys"], ($$74 = function(){var self = $$74.$$s == null ? this : $$74.$$s;

        return self.$size()}, $$74.$$s = self, $$74.$$arity = 0, $$74))
      };
      
      var result = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        key = Opal.yield1(block, key);

        Opal.hash_put(result, key, value);
      }

      return result;
    ;
    }, $Hash_transform_keys$73.$$arity = 0);
    
    Opal.def(self, '$transform_keys!', $Hash_transform_keys$excl$75 = function() {
      var $iter = $Hash_transform_keys$excl$75.$$p, block = $iter || nil, $$76, self = this;

      if ($iter) $Hash_transform_keys$excl$75.$$p = null;
      
      
      if ($iter) $Hash_transform_keys$excl$75.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_keys!"], ($$76 = function(){var self = $$76.$$s == null ? this : $$76.$$s;

        return self.$size()}, $$76.$$s = self, $$76.$$arity = 0, $$76))
      };
      
      var keys = Opal.slice.call(self.$$keys),
          i, length = keys.length, key, value, new_key;

      for (i = 0; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        new_key = Opal.yield1(block, key);

        Opal.hash_delete(self, key);
        Opal.hash_put(self, new_key, value);
      }

      return self;
    ;
    }, $Hash_transform_keys$excl$75.$$arity = 0);
    
    Opal.def(self, '$transform_values', $Hash_transform_values$77 = function $$transform_values() {
      var $iter = $Hash_transform_values$77.$$p, block = $iter || nil, $$78, self = this;

      if ($iter) $Hash_transform_values$77.$$p = null;
      
      
      if ($iter) $Hash_transform_values$77.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_values"], ($$78 = function(){var self = $$78.$$s == null ? this : $$78.$$s;

        return self.$size()}, $$78.$$s = self, $$78.$$arity = 0, $$78))
      };
      
      var result = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(result, key, value);
      }

      return result;
    ;
    }, $Hash_transform_values$77.$$arity = 0);
    
    Opal.def(self, '$transform_values!', $Hash_transform_values$excl$79 = function() {
      var $iter = $Hash_transform_values$excl$79.$$p, block = $iter || nil, $$80, self = this;

      if ($iter) $Hash_transform_values$excl$79.$$p = null;
      
      
      if ($iter) $Hash_transform_values$excl$79.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_values!"], ($$80 = function(){var self = $$80.$$s == null ? this : $$80.$$s;

        return self.$size()}, $$80.$$s = self, $$80.$$arity = 0, $$80))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(self, key, value);
      }

      return self;
    ;
    }, $Hash_transform_values$excl$79.$$arity = 0);
    Opal.alias(self, "update", "merge!");
    Opal.alias(self, "value?", "has_value?");
    Opal.alias(self, "values_at", "indexes");
    return (Opal.def(self, '$values', $Hash_values$81 = function $$values() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(self.$$smap[key]);
        } else {
          result.push(key.value);
        }
      }

      return result;
    
    }, $Hash_values$81.$$arity = 0), nil) && 'values';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/number"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $send2 = Opal.send2, $send = Opal.send;

  Opal.add_stubs(['$require', '$bridge', '$raise', '$name', '$class', '$Float', '$respond_to?', '$coerce_to!', '$__coerced__', '$===', '$!', '$>', '$**', '$new', '$<', '$to_f', '$==', '$nan?', '$infinite?', '$enum_for', '$+', '$-', '$gcd', '$lcm', '$%', '$/', '$frexp', '$to_i', '$ldexp', '$rationalize', '$*', '$<<', '$to_r', '$truncate', '$-@', '$size', '$<=', '$>=']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting), $Number_coerce$2, $Number___id__$3, $Number_$plus$4, $Number_$minus$5, $Number_$$6, $Number_$slash$7, $Number_$percent$8, $Number_$$9, $Number_$$10, $Number_$$11, $Number_$lt$12, $Number_$lt_eq$13, $Number_$gt$14, $Number_$gt_eq$15, $Number_$lt_eq_gt$16, $Number_$lt$lt$17, $Number_$gt$gt$18, $Number_$$$19, $Number_$plus$$20, $Number_$minus$$21, $Number_$$22, $Number_$$$23, $Number_$eq_eq_eq$24, $Number_$eq_eq$25, $Number_abs$26, $Number_abs2$27, $Number_allbits$ques$28, $Number_anybits$ques$29, $Number_angle$30, $Number_bit_length$31, $Number_ceil$32, $Number_chr$33, $Number_denominator$34, $Number_downto$35, $Number_equal$ques$37, $Number_even$ques$38, $Number_floor$39, $Number_gcd$40, $Number_gcdlcm$41, $Number_integer$ques$42, $Number_is_a$ques$43, $Number_instance_of$ques$44, $Number_lcm$45, $Number_next$46, $Number_nobits$ques$47, $Number_nonzero$ques$48, $Number_numerator$49, $Number_odd$ques$50, $Number_ord$51, $Number_pow$52, $Number_pred$53, $Number_quo$54, $Number_rationalize$55, $Number_remainder$56, $Number_round$57, $Number_times$58, $Number_to_f$60, $Number_to_i$61, $Number_to_r$62, $Number_to_s$63, $Number_truncate$64, $Number_digits$65, $Number_divmod$66, $Number_upto$67, $Number_zero$ques$69, $Number_size$70, $Number_nan$ques$71, $Number_finite$ques$72, $Number_infinite$ques$73, $Number_positive$ques$74, $Number_negative$ques$75;

    
    $$($nesting, 'Opal').$bridge(Number, self);
    Opal.defineProperty(self.$$prototype, '$$is_number', true);
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$coerce', $Number_coerce$2 = function $$coerce(other) {
      var self = this;

      
      if (other === nil) {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
      else if (other.$$is_string) {
        return [self.$Float(other), self];
      }
      else if (other['$respond_to?']("to_f")) {
        return [$$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Float'), "to_f"), self];
      }
      else if (other.$$is_number) {
        return [other, self];
      }
      else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
    
    }, $Number_coerce$2.$$arity = 1);
    
    Opal.def(self, '$__id__', $Number___id__$3 = function $$__id__() {
      var self = this;

      return (self * 2) + 1;
    }, $Number___id__$3.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$+', $Number_$plus$4 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self + other;
      }
      else {
        return self.$__coerced__("+", other);
      }
    
    }, $Number_$plus$4.$$arity = 1);
    
    Opal.def(self, '$-', $Number_$minus$5 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self - other;
      }
      else {
        return self.$__coerced__("-", other);
      }
    
    }, $Number_$minus$5.$$arity = 1);
    
    Opal.def(self, '$*', $Number_$$6 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self * other;
      }
      else {
        return self.$__coerced__("*", other);
      }
    
    }, $Number_$$6.$$arity = 1);
    
    Opal.def(self, '$/', $Number_$slash$7 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self / other;
      }
      else {
        return self.$__coerced__("/", other);
      }
    
    }, $Number_$slash$7.$$arity = 1);
    Opal.alias(self, "fdiv", "/");
    
    Opal.def(self, '$%', $Number_$percent$8 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        if (other == -Infinity) {
          return other;
        }
        else if (other == 0) {
          self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0");
        }
        else if (other < 0 || self < 0) {
          return (self % other + other) % other;
        }
        else {
          return self % other;
        }
      }
      else {
        return self.$__coerced__("%", other);
      }
    
    }, $Number_$percent$8.$$arity = 1);
    
    Opal.def(self, '$&', $Number_$$9 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self & other;
      }
      else {
        return self.$__coerced__("&", other);
      }
    
    }, $Number_$$9.$$arity = 1);
    
    Opal.def(self, '$|', $Number_$$10 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self | other;
      }
      else {
        return self.$__coerced__("|", other);
      }
    
    }, $Number_$$10.$$arity = 1);
    
    Opal.def(self, '$^', $Number_$$11 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self ^ other;
      }
      else {
        return self.$__coerced__("^", other);
      }
    
    }, $Number_$$11.$$arity = 1);
    
    Opal.def(self, '$<', $Number_$lt$12 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self < other;
      }
      else {
        return self.$__coerced__("<", other);
      }
    
    }, $Number_$lt$12.$$arity = 1);
    
    Opal.def(self, '$<=', $Number_$lt_eq$13 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self <= other;
      }
      else {
        return self.$__coerced__("<=", other);
      }
    
    }, $Number_$lt_eq$13.$$arity = 1);
    
    Opal.def(self, '$>', $Number_$gt$14 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self > other;
      }
      else {
        return self.$__coerced__(">", other);
      }
    
    }, $Number_$gt$14.$$arity = 1);
    
    Opal.def(self, '$>=', $Number_$gt_eq$15 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self >= other;
      }
      else {
        return self.$__coerced__(">=", other);
      }
    
    }, $Number_$gt_eq$15.$$arity = 1);
    
    var spaceship_operator = function(self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      }
      else {
        return self.$__coerced__("<=>", other);
      }
    }
  ;
    
    Opal.def(self, '$<=>', $Number_$lt_eq_gt$16 = function(other) {
      var self = this;

      try {
        return spaceship_operator(self, other);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return nil
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Number_$lt_eq_gt$16.$$arity = 1);
    
    Opal.def(self, '$<<', $Number_$lt$lt$17 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), "to_int");
      return count > 0 ? self << count : self >> -count;
    }, $Number_$lt$lt$17.$$arity = 1);
    
    Opal.def(self, '$>>', $Number_$gt$gt$18 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), "to_int");
      return count > 0 ? self >> count : self << -count;
    }, $Number_$gt$gt$18.$$arity = 1);
    
    Opal.def(self, '$[]', $Number_$$$19 = function(bit) {
      var self = this;

      
      bit = $$($nesting, 'Opal')['$coerce_to!'](bit, $$($nesting, 'Integer'), "to_int");
      
      if (bit < 0) {
        return 0;
      }
      if (bit >= 32) {
        return self < 0 ? 1 : 0;
      }
      return (self >> bit) & 1;
    ;
    }, $Number_$$$19.$$arity = 1);
    
    Opal.def(self, '$+@', $Number_$plus$$20 = function() {
      var self = this;

      return +self;
    }, $Number_$plus$$20.$$arity = 0);
    
    Opal.def(self, '$-@', $Number_$minus$$21 = function() {
      var self = this;

      return -self;
    }, $Number_$minus$$21.$$arity = 0);
    
    Opal.def(self, '$~', $Number_$$22 = function() {
      var self = this;

      return ~self;
    }, $Number_$$22.$$arity = 0);
    
    Opal.def(self, '$**', $Number_$$$23 = function(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
        if ($truthy((function() {if ($truthy(($ret_or_1 = $$($nesting, 'Integer')['$==='](self)['$!']()))) {
          return $ret_or_1
        } else {
          return $rb_gt(other, 0)
        }; return nil; })())) {
          return Math.pow(self, other);
        } else {
          return $$($nesting, 'Rational').$new(self, 1)['$**'](other)
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_2 = $rb_lt(self, 0)))) {
        
        if ($truthy(($ret_or_3 = $$($nesting, 'Float')['$==='](other)))) {
          return $ret_or_3
        } else {
          return $$($nesting, 'Rational')['$==='](other)
        };
      } else {
        return $ret_or_2
      }; return nil; })())) {
        return $$($nesting, 'Complex').$new(self, 0)['$**'](other.$to_f())
      } else if ($truthy(other.$$is_number != null)) {
        return Math.pow(self, other);
      } else {
        return self.$__coerced__("**", other)
      }
    }, $Number_$$$23.$$arity = 1);
    
    Opal.def(self, '$===', $Number_$eq_eq_eq$24 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, $Number_$eq_eq_eq$24.$$arity = 1);
    
    Opal.def(self, '$==', $Number_$eq_eq$25 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, $Number_$eq_eq$25.$$arity = 1);
    
    Opal.def(self, '$abs', $Number_abs$26 = function $$abs() {
      var self = this;

      return Math.abs(self);
    }, $Number_abs$26.$$arity = 0);
    
    Opal.def(self, '$abs2', $Number_abs2$27 = function $$abs2() {
      var self = this;

      return Math.abs(self * self);
    }, $Number_abs2$27.$$arity = 0);
    
    Opal.def(self, '$allbits?', $Number_allbits$ques$28 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) == mask;;
    }, $Number_allbits$ques$28.$$arity = 1);
    
    Opal.def(self, '$anybits?', $Number_anybits$ques$29 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) !== 0;;
    }, $Number_anybits$ques$29.$$arity = 1);
    
    Opal.def(self, '$angle', $Number_angle$30 = function $$angle() {
      var self = this;

      
      if ($truthy(self['$nan?']())) {
        return self};
      
      if (self == 0) {
        if (1 / self > 0) {
          return 0;
        }
        else {
          return Math.PI;
        }
      }
      else if (self < 0) {
        return Math.PI;
      }
      else {
        return 0;
      }
    ;
    }, $Number_angle$30.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    Opal.alias(self, "phase", "angle");
    
    Opal.def(self, '$bit_length', $Number_bit_length$31 = function $$bit_length() {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
      } else {
        self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `bit_length` for " + (self) + ":Float", "bit_length"))
      };
      
      if (self === 0 || self === -1) {
        return 0;
      }

      var result = 0,
          value  = self < 0 ? ~self : self;

      while (value != 0) {
        result   += 1;
        value  >>>= 1;
      }

      return result;
    ;
    }, $Number_bit_length$31.$$arity = 0);
    
    Opal.def(self, '$ceil', $Number_ceil$32 = function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.ceil(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_ceil$32.$$arity = -1);
    
    Opal.def(self, '$chr', $Number_chr$33 = function $$chr(encoding) {
      var self = this;

      
      ;
      return Opal.enc(String.fromCharCode(self), encoding || "BINARY");;
    }, $Number_chr$33.$$arity = -1);
    
    Opal.def(self, '$denominator', $Number_denominator$34 = function $$denominator() {
      var $iter = $Number_denominator$34.$$p, $yield = $iter || nil, self = this, $ret_or_4 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_denominator$34.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy((function() {if ($truthy(($ret_or_4 = self['$nan?']()))) {
        return $ret_or_4
      } else {
        return self['$infinite?']()
      }; return nil; })())) {
        return 1
      } else {
        return $send2(self, Opal.find_super_dispatcher(self, 'denominator', $Number_denominator$34, false, true), 'denominator', $zuper, $iter)
      }
    }, $Number_denominator$34.$$arity = 0);
    
    Opal.def(self, '$downto', $Number_downto$35 = function $$downto(stop) {
      var $iter = $Number_downto$35.$$p, block = $iter || nil, $$36, self = this;

      if ($iter) $Number_downto$35.$$p = null;
      
      
      if ($iter) $Number_downto$35.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["downto", stop], ($$36 = function(){var self = $$36.$$s == null ? this : $$36.$$s;

        
          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_gt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(self, stop), 1)
          };}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      
      if (!stop.$$is_number) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i >= stop; i--) {
        block(i);
      }
    ;
      return self;
    }, $Number_downto$35.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$equal?', $Number_equal$ques$37 = function(other) {
      var self = this, $ret_or_5 = nil;

      if ($truthy(($ret_or_5 = self['$=='](other)))) {
        return $ret_or_5
      } else {
        return isNaN(self) && isNaN(other);
      }
    }, $Number_equal$ques$37.$$arity = 1);
    
    Opal.def(self, '$even?', $Number_even$ques$38 = function() {
      var self = this;

      return self % 2 === 0;
    }, $Number_even$ques$38.$$arity = 0);
    
    Opal.def(self, '$floor', $Number_floor$39 = function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.floor(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_floor$39.$$arity = -1);
    
    Opal.def(self, '$gcd', $Number_gcd$40 = function $$gcd(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an integer")
      };
      
      var min = Math.abs(self),
          max = Math.abs(other);

      while (min > 0) {
        var tmp = min;

        min = max % min;
        max = tmp;
      }

      return max;
    ;
    }, $Number_gcd$40.$$arity = 1);
    
    Opal.def(self, '$gcdlcm', $Number_gcdlcm$41 = function $$gcdlcm(other) {
      var self = this;

      return [self.$gcd(other), self.$lcm(other)]
    }, $Number_gcdlcm$41.$$arity = 1);
    
    Opal.def(self, '$integer?', $Number_integer$ques$42 = function() {
      var self = this;

      return self % 1 === 0;
    }, $Number_integer$ques$42.$$arity = 0);
    
    Opal.def(self, '$is_a?', $Number_is_a$ques$43 = function(klass) {
      var $iter = $Number_is_a$ques$43.$$p, $yield = $iter || nil, self = this, $ret_or_6 = nil, $ret_or_7 = nil, $ret_or_8 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_is_a$ques$43.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((function() {if ($truthy(($ret_or_6 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_6
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_7 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_7
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_8 = klass['$==']($$($nesting, 'Float'))))) {
        return $$($nesting, 'Float')['$==='](self)
      } else {
        return $ret_or_8
      }; return nil; })())) {
        return true};
      return $send2(self, Opal.find_super_dispatcher(self, 'is_a?', $Number_is_a$ques$43, false, true), 'is_a?', $zuper, $iter);
    }, $Number_is_a$ques$43.$$arity = 1);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$instance_of?', $Number_instance_of$ques$44 = function(klass) {
      var $iter = $Number_instance_of$ques$44.$$p, $yield = $iter || nil, self = this, $ret_or_9 = nil, $ret_or_10 = nil, $ret_or_11 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_instance_of$ques$44.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((function() {if ($truthy(($ret_or_9 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_9
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_10 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_10
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_11 = klass['$==']($$($nesting, 'Float'))))) {
        return $$($nesting, 'Float')['$==='](self)
      } else {
        return $ret_or_11
      }; return nil; })())) {
        return true};
      return $send2(self, Opal.find_super_dispatcher(self, 'instance_of?', $Number_instance_of$ques$44, false, true), 'instance_of?', $zuper, $iter);
    }, $Number_instance_of$ques$44.$$arity = 1);
    
    Opal.def(self, '$lcm', $Number_lcm$45 = function $$lcm(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an integer")
      };
      
      if (self == 0 || other == 0) {
        return 0;
      }
      else {
        return Math.abs(self * other / self.$gcd(other));
      }
    ;
    }, $Number_lcm$45.$$arity = 1);
    Opal.alias(self, "magnitude", "abs");
    Opal.alias(self, "modulo", "%");
    
    Opal.def(self, '$next', $Number_next$46 = function $$next() {
      var self = this;

      return self + 1;
    }, $Number_next$46.$$arity = 0);
    
    Opal.def(self, '$nobits?', $Number_nobits$ques$47 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) == 0;;
    }, $Number_nobits$ques$47.$$arity = 1);
    
    Opal.def(self, '$nonzero?', $Number_nonzero$ques$48 = function() {
      var self = this;

      return self == 0 ? nil : self;
    }, $Number_nonzero$ques$48.$$arity = 0);
    
    Opal.def(self, '$numerator', $Number_numerator$49 = function $$numerator() {
      var $iter = $Number_numerator$49.$$p, $yield = $iter || nil, self = this, $ret_or_12 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_numerator$49.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy((function() {if ($truthy(($ret_or_12 = self['$nan?']()))) {
        return $ret_or_12
      } else {
        return self['$infinite?']()
      }; return nil; })())) {
        return self
      } else {
        return $send2(self, Opal.find_super_dispatcher(self, 'numerator', $Number_numerator$49, false, true), 'numerator', $zuper, $iter)
      }
    }, $Number_numerator$49.$$arity = 0);
    
    Opal.def(self, '$odd?', $Number_odd$ques$50 = function() {
      var self = this;

      return self % 2 !== 0;
    }, $Number_odd$ques$50.$$arity = 0);
    
    Opal.def(self, '$ord', $Number_ord$51 = function $$ord() {
      var self = this;

      return self
    }, $Number_ord$51.$$arity = 0);
    
    Opal.def(self, '$pow', $Number_pow$52 = function $$pow(b, m) {
      var self = this;

      
      ;
      
      if (self == 0) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      }

      if (m === undefined) {
        return self['$**'](b);
      } else {
        if (!($$($nesting, 'Integer')['$==='](b))) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer")
        }

        if (b < 0) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 1st argument cannot be negative when 2nd argument specified")
        }

        if (!($$($nesting, 'Integer')['$==='](m))) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 2nd argument not allowed unless all arguments are integers")
        }

        if (m === 0) {
          self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
        }

        return self['$**'](b)['$%'](m)
      }
    ;
    }, $Number_pow$52.$$arity = -2);
    
    Opal.def(self, '$pred', $Number_pred$53 = function $$pred() {
      var self = this;

      return self - 1;
    }, $Number_pred$53.$$arity = 0);
    
    Opal.def(self, '$quo', $Number_quo$54 = function $$quo(other) {
      var $iter = $Number_quo$54.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_quo$54.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $send2(self, Opal.find_super_dispatcher(self, 'quo', $Number_quo$54, false, true), 'quo', $zuper, $iter)
      } else {
        return $rb_divide(self, other)
      }
    }, $Number_quo$54.$$arity = 1);
    
    Opal.def(self, '$rationalize', $Number_rationalize$55 = function $$rationalize(eps) {
      var $a, $b, self = this, f = nil, n = nil;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $$($nesting, 'Rational').$new(self, 1)
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "Infinity")
      } else if ($truthy(self['$nan?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(eps == null)) {
        
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;
        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();
        n = $rb_minus(n, $$$($$($nesting, 'Float'), 'MANT_DIG'));
        return $$($nesting, 'Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize($$($nesting, 'Rational').$new(1, (1)['$<<']($rb_minus(1, n))));
      } else {
        return self.$to_r().$rationalize(eps)
      };
    }, $Number_rationalize$55.$$arity = -1);
    
    Opal.def(self, '$remainder', $Number_remainder$56 = function $$remainder(y) {
      var self = this;

      return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()))
    }, $Number_remainder$56.$$arity = 1);
    
    Opal.def(self, '$round', $Number_round$57 = function $$round(ndigits) {
      var $a, $b, self = this, $ret_or_13 = nil, $ret_or_14 = nil, $ret_or_15 = nil, _ = nil, exp = nil;

      
      ;
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        
        if ($truthy(ndigits == null)) {
          return self};
        if ($truthy((function() {if ($truthy(($ret_or_13 = $$($nesting, 'Float')['$==='](ndigits)))) {
          return ndigits['$infinite?']()
        } else {
          return $ret_or_13
        }; return nil; })())) {
          self.$raise($$($nesting, 'RangeError'), "Infinity")};
        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(ndigits, $$$($$($nesting, 'Integer'), 'MIN')))) {
          self.$raise($$($nesting, 'RangeError'), "out of bounds")};
        if ($truthy(ndigits >= 0)) {
          return self};
        ndigits = ndigits['$-@']();
        
        if (0.415241 * ndigits - 0.125 > self.$size()) {
          return 0;
        }

        var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(self) + f / 2) / f) * f;

        return self < 0 ? -x : x;
      ;
      } else {
        
        if ($truthy((function() {if ($truthy(($ret_or_14 = self['$nan?']()))) {
          return ndigits == null;
        } else {
          return $ret_or_14
        }; return nil; })())) {
          self.$raise($$($nesting, 'FloatDomainError'), "NaN")};
        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits || 0, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_le(ndigits, 0))) {
          if ($truthy(self['$nan?']())) {
            self.$raise($$($nesting, 'RangeError'), "NaN")
          } else if ($truthy(self['$infinite?']())) {
            self.$raise($$($nesting, 'FloatDomainError'), "Infinity")}
        } else if (ndigits['$=='](0)) {
          return Math.round(self)
        } else if ($truthy((function() {if ($truthy(($ret_or_15 = self['$nan?']()))) {
          return $ret_or_15
        } else {
          return self['$infinite?']()
        }; return nil; })())) {
          return self};
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$($nesting, 'Float'), 'DIG'), 2), (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_divide(exp, 4)
        } else {
          return $rb_minus($rb_divide(exp, 3), 1)
        }; return nil; })())))) {
          return self};
        if ($truthy($rb_lt(ndigits, (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_plus($rb_divide(exp, 3), 1)
        } else {
          return $rb_divide(exp, 4)
        }; return nil; })()['$-@']()))) {
          return 0};
        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);;
      };
    }, $Number_round$57.$$arity = -1);
    Opal.alias(self, "succ", "next");
    
    Opal.def(self, '$times', $Number_times$58 = function $$times() {
      var $iter = $Number_times$58.$$p, block = $iter || nil, $$59, self = this;

      if ($iter) $Number_times$58.$$p = null;
      
      
      if ($iter) $Number_times$58.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["times"], ($$59 = function(){var self = $$59.$$s == null ? this : $$59.$$s;

        return self}, $$59.$$s = self, $$59.$$arity = 0, $$59))
      };
      
      for (var i = 0; i < self; i++) {
        block(i);
      }
    ;
      return self;
    }, $Number_times$58.$$arity = 0);
    
    Opal.def(self, '$to_f', $Number_to_f$60 = function $$to_f() {
      var self = this;

      return self
    }, $Number_to_f$60.$$arity = 0);
    
    Opal.def(self, '$to_i', $Number_to_i$61 = function $$to_i() {
      var self = this;

      return self < 0 ? Math.ceil(self) : Math.floor(self);
    }, $Number_to_i$61.$$arity = 0);
    Opal.alias(self, "to_int", "to_i");
    
    Opal.def(self, '$to_r', $Number_to_r$62 = function $$to_r() {
      var $a, $b, self = this, f = nil, e = nil;

      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $$($nesting, 'Rational').$new(self, 1)
      } else {
        
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;
        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();
        e = $rb_minus(e, $$$($$($nesting, 'Float'), 'MANT_DIG'));
        return $rb_times(f, $$$($$($nesting, 'Float'), 'RADIX')['$**'](e)).$to_r();
      }
    }, $Number_to_r$62.$$arity = 0);
    
    Opal.def(self, '$to_s', $Number_to_s$63 = function $$to_s(base) {
      var self = this, $ret_or_16 = nil;

      
      
      if (base == null) {
        base = 10;
      };
      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), "to_int");
      if ($truthy((function() {if ($truthy(($ret_or_16 = $rb_lt(base, 2)))) {
        return $ret_or_16
      } else {
        return $rb_gt(base, 36)
      }; return nil; })())) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))};
      return self.toString(base);;
    }, $Number_to_s$63.$$arity = -1);
    
    Opal.def(self, '$truncate', $Number_truncate$64 = function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = parseInt(f * factor, 10) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_truncate$64.$$arity = -1);
    Opal.alias(self, "inspect", "to_s");
    
    Opal.def(self, '$digits', $Number_digits$65 = function $$digits(base) {
      var self = this;

      
      
      if (base == null) {
        base = 10;
      };
      if ($rb_lt(self, 0)) {
        self.$raise($$$($$($nesting, 'Math'), 'DomainError'), "out of domain")};
      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(base, 2))) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))};
      
      var value = self, result = [];

      while (value !== 0) {
        result.push(value % base);
        value = parseInt(value / base, 10);
      }

      return result;
    ;
    }, $Number_digits$65.$$arity = -1);
    
    Opal.def(self, '$divmod', $Number_divmod$66 = function $$divmod(other) {
      var $iter = $Number_divmod$66.$$p, $yield = $iter || nil, self = this, $ret_or_17 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_divmod$66.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy((function() {if ($truthy(($ret_or_17 = self['$nan?']()))) {
        return $ret_or_17
      } else {
        return other['$nan?']()
      }; return nil; })())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "Infinity")
      } else {
        return $send2(self, Opal.find_super_dispatcher(self, 'divmod', $Number_divmod$66, false, true), 'divmod', $zuper, $iter)
      }
    }, $Number_divmod$66.$$arity = 1);
    
    Opal.def(self, '$upto', $Number_upto$67 = function $$upto(stop) {
      var $iter = $Number_upto$67.$$p, block = $iter || nil, $$68, self = this;

      if ($iter) $Number_upto$67.$$p = null;
      
      
      if ($iter) $Number_upto$67.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["upto", stop], ($$68 = function(){var self = $$68.$$s == null ? this : $$68.$$s;

        
          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_lt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(stop, self), 1)
          };}, $$68.$$s = self, $$68.$$arity = 0, $$68))
      };
      
      if (!stop.$$is_number) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i <= stop; i++) {
        block(i);
      }
    ;
      return self;
    }, $Number_upto$67.$$arity = 1);
    
    Opal.def(self, '$zero?', $Number_zero$ques$69 = function() {
      var self = this;

      return self == 0;
    }, $Number_zero$ques$69.$$arity = 0);
    
    Opal.def(self, '$size', $Number_size$70 = function $$size() {
      var self = this;

      return 4
    }, $Number_size$70.$$arity = 0);
    
    Opal.def(self, '$nan?', $Number_nan$ques$71 = function() {
      var self = this;

      return isNaN(self);
    }, $Number_nan$ques$71.$$arity = 0);
    
    Opal.def(self, '$finite?', $Number_finite$ques$72 = function() {
      var self = this;

      return self != Infinity && self != -Infinity && !isNaN(self);
    }, $Number_finite$ques$72.$$arity = 0);
    
    Opal.def(self, '$infinite?', $Number_infinite$ques$73 = function() {
      var self = this;

      
      if (self == Infinity) {
        return +1;
      }
      else if (self == -Infinity) {
        return -1;
      }
      else {
        return nil;
      }
    
    }, $Number_infinite$ques$73.$$arity = 0);
    
    Opal.def(self, '$positive?', $Number_positive$ques$74 = function() {
      var self = this;

      return self != 0 && (self == Infinity || 1 / self > 0);
    }, $Number_positive$ques$74.$$arity = 0);
    return (Opal.def(self, '$negative?', $Number_negative$ques$75 = function() {
      var self = this;

      return self == -Infinity || 1 / self < 0;
    }, $Number_negative$ques$75.$$arity = 0), nil) && 'negative?';
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  Opal.const_set($nesting[0], 'Fixnum', $$($nesting, 'Number'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Integer');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    self.$$is_integer_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$76, $sqrt$77;

      
      
      Opal.def(self, '$allocate', $allocate$76 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$76.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      return (Opal.def(self, '$sqrt', $sqrt$77 = function $$sqrt(n) {
        var self = this;

        
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        
        if (n < 0) {
          self.$raise($$$($$($nesting, 'Math'), 'DomainError'), "Numerical argument is out of domain - \"isqrt\"")
        }

        return parseInt(Math.sqrt(n), 10);
      ;
      }, $sqrt$77.$$arity = 1), nil) && 'sqrt';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'MAX', Math.pow(2, 30) - 1);
    return Opal.const_set($nesting[0], 'MIN', -Math.pow(2, 30));
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Float');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$78, $eq_eq_eq$79;

      
      
      Opal.def(self, '$allocate', $allocate$78 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$78.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      return (Opal.def(self, '$===', $eq_eq_eq$79 = function(other) {
        var self = this;

        return !!other.$$is_number;
      }, $eq_eq_eq$79.$$arity = 1), nil) && '===';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'INFINITY', Infinity);
    Opal.const_set($nesting[0], 'MAX', Number.MAX_VALUE);
    Opal.const_set($nesting[0], 'MIN', Number.MIN_VALUE);
    Opal.const_set($nesting[0], 'NAN', NaN);
    Opal.const_set($nesting[0], 'DIG', 15);
    Opal.const_set($nesting[0], 'MANT_DIG', 53);
    Opal.const_set($nesting[0], 'RADIX', 2);
    return Opal.const_set($nesting[0], 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/range"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $send2 = Opal.send2, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$attr_reader', '$raise', '$<=>', '$nil?', '$include?', '$!', '$<', '$<=', '$enum_for', '$size', '$upto', '$to_proc', '$respond_to?', '$class', '$succ', '$==', '$===', '$exclude_end?', '$eql?', '$begin', '$end', '$last', '$to_a', '$>', '$-@', '$-', '$to_i', '$coerce_to!', '$ceil', '$/', '$loop', '$+', '$*', '$>=', '$each_with_index', '$%', '$bsearch', '$inspect', '$[]', '$hash']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Range');

    var $nesting = [self].concat($parent_nesting), $Range_initialize$1, $Range_$eq_eq_eq$2, $Range_count$3, $Range_to_a$4, $Range_cover$ques$5, $Range_each$6, $Range_eql$ques$8, $Range_exclude_end$ques$9, $Range_first$10, $Range_last$11, $Range_max$12, $Range_min$13, $Range_size$14, $Range_step$15, $Range_bsearch$19, $Range_to_s$20, $Range_inspect$21, $Range_marshal_load$22, $Range_hash$23;

    self.$$prototype.begin = self.$$prototype.end = self.$$prototype.excl = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_range = true;
    self.$attr_reader("begin", "end");
    
    Opal.def(self, '$initialize', $Range_initialize$1 = function $$initialize(first, last, exclude) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      
      
      if (exclude == null) {
        exclude = false;
      };
      if ($truthy(self.begin)) {
        self.$raise($$($nesting, 'NameError'), "'initialize' called twice")};
      if ($truthy((function() {if ($truthy(($ret_or_1 = (function() {if ($truthy(($ret_or_2 = first['$<=>'](last)))) {
        return $ret_or_2
      } else {
        return first['$nil?']()
      }; return nil; })()))) {
        return $ret_or_1
      } else {
        return last['$nil?']()
      }; return nil; })())) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "bad value for range")
      };
      self.begin = first;
      self.end = last;
      return (self.excl = exclude);
    }, $Range_initialize$1.$$arity = -3);
    
    Opal.def(self, '$===', $Range_$eq_eq_eq$2 = function(value) {
      var self = this;

      return self['$include?'](value)
    }, $Range_$eq_eq_eq$2.$$arity = 1);
    
    function is_infinite(self) {
      if (self.begin === nil || self.end === nil ||
          self.begin === -Infinity || self.end === Infinity ||
          self.begin === Infinity || self.end === -Infinity) return true;
      return false;
    }
  ;
    
    Opal.def(self, '$count', $Range_count$3 = function $$count() {
      var $iter = $Range_count$3.$$p, block = $iter || nil, self = this, $ret_or_3 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_count$3.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Range_count$3.$$p = null;;
      if ($truthy((function() {if ($truthy(($ret_or_3 = (block !== nil)['$!']()))) {
        return is_infinite(self);
      } else {
        return $ret_or_3
      }; return nil; })())) {
        return $$$($$($nesting, 'Float'), 'INFINITY')};
      return $send2(self, Opal.find_super_dispatcher(self, 'count', $Range_count$3, false, true), 'count', $zuper, $iter);
    }, $Range_count$3.$$arity = 0);
    
    Opal.def(self, '$to_a', $Range_to_a$4 = function $$to_a() {
      var $iter = $Range_to_a$4.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_to_a$4.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy(is_infinite(self))) {
        self.$raise($$($nesting, 'TypeError'), "cannot convert endless range to an array")};
      return $send2(self, Opal.find_super_dispatcher(self, 'to_a', $Range_to_a$4, false, true), 'to_a', $zuper, $iter);
    }, $Range_to_a$4.$$arity = 0);
    
    Opal.def(self, '$cover?', $Range_cover$ques$5 = function(value) {
      var self = this, beg_cmp = nil, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil, end_cmp = nil, $ret_or_7 = nil, $ret_or_8 = nil, $ret_or_9 = nil, $ret_or_10 = nil, $ret_or_11 = nil, $ret_or_12 = nil, $ret_or_13 = nil;

      
      beg_cmp = (function() {if ($truthy(($ret_or_4 = (function() {if ($truthy(($ret_or_5 = (function() {if ($truthy(($ret_or_6 = self.begin['$nil?']()))) {
        return -1
      } else {
        return $ret_or_6
      }; return nil; })()))) {
        return $ret_or_5
      } else {
        
        return self.begin['$<=>'](value);
      }; return nil; })()))) {
        return $ret_or_4
      } else {
        return false
      }; return nil; })();
      end_cmp = (function() {if ($truthy(($ret_or_7 = (function() {if ($truthy(($ret_or_8 = (function() {if ($truthy(($ret_or_9 = self.end['$nil?']()))) {
        return -1
      } else {
        return $ret_or_9
      }; return nil; })()))) {
        return $ret_or_8
      } else {
        
        return value['$<=>'](self.end);
      }; return nil; })()))) {
        return $ret_or_7
      } else {
        return false
      }; return nil; })();
      if ($truthy(($ret_or_10 = (function() {if ($truthy(($ret_or_11 = (function() {if ($truthy(self.excl)) {
        if ($truthy(($ret_or_12 = end_cmp))) {
          return $rb_lt(end_cmp, 0)
        } else {
          return $ret_or_12
        }
      } else if ($truthy(($ret_or_13 = end_cmp))) {
        return $rb_le(end_cmp, 0)
      } else {
        return $ret_or_13
      }; return nil; })()))) {
        return beg_cmp
      } else {
        return $ret_or_11
      }; return nil; })()))) {
        return $rb_le(beg_cmp, 0)
      } else {
        return $ret_or_10
      };
    }, $Range_cover$ques$5.$$arity = 1);
    
    Opal.def(self, '$each', $Range_each$6 = function $$each() {
      var $iter = $Range_each$6.$$p, block = $iter || nil, $$7, $a, self = this, current = nil, last = nil, $ret_or_14 = nil, $ret_or_15 = nil;

      if ($iter) $Range_each$6.$$p = null;
      
      
      if ($iter) $Range_each$6.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$7 = function(){var self = $$7.$$s == null ? this : $$7.$$s;

        return self.$size()}, $$7.$$s = self, $$7.$$arity = 0, $$7))
      };
      
      var i, limit;

      if (self.begin.$$is_number && self.end.$$is_number) {
        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
          self.$raise($$($nesting, 'TypeError'), "can't iterate from Float")
        }

        for (i = self.begin, limit = self.end + (function() {if ($truthy(self.excl)) {
        return 0
      } else {
        return 1
      }; return nil; })(); i < limit; i++) {
          block(i);
        }

        return self;
      }

      if (self.begin.$$is_string && self.end.$$is_string) {
        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())
        return self;
      }
    ;
      current = self.begin;
      last = self.end;
      if ($truthy(current['$respond_to?']("succ"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't iterate from " + (current.$class()))
      };
      while ($truthy((function() {if ($truthy(($ret_or_14 = self.end['$nil?']()))) {
        return $ret_or_14
      } else {
        return $rb_lt(current['$<=>'](last), 0)
      }; return nil; })())) {
        
        Opal.yield1(block, current);
        current = current.$succ();
      };
      if ($truthy((function() {if ($truthy(($ret_or_15 = self.excl['$!']()))) {
        return current['$=='](last)
      } else {
        return $ret_or_15
      }; return nil; })())) {
        Opal.yield1(block, current)};
      return self;
    }, $Range_each$6.$$arity = 0);
    
    Opal.def(self, '$eql?', $Range_eql$ques$8 = function(other) {
      var self = this, $ret_or_16 = nil, $ret_or_17 = nil;

      
      if ($truthy($$($nesting, 'Range')['$==='](other))) {
      } else {
        return false
      };
      if ($truthy(($ret_or_16 = (function() {if ($truthy(($ret_or_17 = self.excl['$==='](other['$exclude_end?']())))) {
        return self.begin['$eql?'](other.$begin())
      } else {
        return $ret_or_17
      }; return nil; })()))) {
        return self.end['$eql?'](other.$end())
      } else {
        return $ret_or_16
      };
    }, $Range_eql$ques$8.$$arity = 1);
    Opal.alias(self, "==", "eql?");
    
    Opal.def(self, '$exclude_end?', $Range_exclude_end$ques$9 = function() {
      var self = this;

      return self.excl
    }, $Range_exclude_end$ques$9.$$arity = 0);
    
    Opal.def(self, '$first', $Range_first$10 = function $$first(n) {
      var $iter = $Range_first$10.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_first$10.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      ;
      if ($truthy(self.begin['$nil?']())) {
        self.$raise($$($nesting, 'RangeError'), "cannot get the minimum of beginless range")};
      if ($truthy(n == null)) {
        return self.begin};
      return $send2(self, Opal.find_super_dispatcher(self, 'first', $Range_first$10, false, true), 'first', $zuper, $iter);
    }, $Range_first$10.$$arity = -1);
    Opal.alias(self, "include?", "cover?");
    
    Opal.def(self, '$last', $Range_last$11 = function $$last(n) {
      var self = this;

      
      ;
      if ($truthy(self.end['$nil?']())) {
        self.$raise($$($nesting, 'RangeError'), "cannot get the maximum of endless range")};
      if ($truthy(n == null)) {
        return self.end};
      return self.$to_a().$last(n);
    }, $Range_last$11.$$arity = -1);
    
    Opal.def(self, '$max', $Range_max$12 = function $$max() {
      var $iter = $Range_max$12.$$p, $yield = $iter || nil, self = this, $ret_or_18 = nil, $ret_or_19 = nil, $ret_or_20 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_max$12.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(self.end['$nil?']())) {
        return self.$raise($$($nesting, 'RangeError'), "cannot get the maximum of endless range")
      } else if (($yield !== nil)) {
        return $send2(self, Opal.find_super_dispatcher(self, 'max', $Range_max$12, false, true), 'max', $zuper, $iter)
      } else if ($truthy((function() {if ($truthy(($ret_or_18 = self.begin['$nil?']()['$!']()))) {
        
        if ($truthy(($ret_or_19 = $rb_gt(self.begin, self.end)))) {
          return $ret_or_19
        } else if ($truthy(($ret_or_20 = self.excl))) {
          return self.begin['$=='](self.end)
        } else {
          return $ret_or_20
        };
      } else {
        return $ret_or_18
      }; return nil; })())) {
        return nil
      } else {
        return self.excl ? self.end - 1 : self.end
      }
    }, $Range_max$12.$$arity = 0);
    Opal.alias(self, "member?", "cover?");
    
    Opal.def(self, '$min', $Range_min$13 = function $$min() {
      var $iter = $Range_min$13.$$p, $yield = $iter || nil, self = this, $ret_or_21 = nil, $ret_or_22 = nil, $ret_or_23 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_min$13.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(self.begin['$nil?']())) {
        return self.$raise($$($nesting, 'RangeError'), "cannot get the minimum of beginless range")
      } else if (($yield !== nil)) {
        return $send2(self, Opal.find_super_dispatcher(self, 'min', $Range_min$13, false, true), 'min', $zuper, $iter)
      } else if ($truthy((function() {if ($truthy(($ret_or_21 = self.end['$nil?']()['$!']()))) {
        
        if ($truthy(($ret_or_22 = $rb_gt(self.begin, self.end)))) {
          return $ret_or_22
        } else if ($truthy(($ret_or_23 = self.excl))) {
          return self.begin['$=='](self.end)
        } else {
          return $ret_or_23
        };
      } else {
        return $ret_or_21
      }; return nil; })())) {
        return nil
      } else {
        return self.begin
      }
    }, $Range_min$13.$$arity = 0);
    
    Opal.def(self, '$size', $Range_size$14 = function $$size() {
      var self = this, infinity = nil, $ret_or_24 = nil, $ret_or_25 = nil, $ret_or_26 = nil, $ret_or_27 = nil, range_begin = nil, range_end = nil;

      
      infinity = $$$($$($nesting, 'Float'), 'INFINITY');
      if ($truthy((function() {if ($truthy(($ret_or_24 = (function() {if ($truthy(($ret_or_25 = self.begin['$=='](infinity)))) {
        return self.end['$nil?']()['$!']()
      } else {
        return $ret_or_25
      }; return nil; })()))) {
        return $ret_or_24
      } else {
        
        if ($truthy(($ret_or_26 = self.end['$=='](infinity['$-@']())))) {
          return self.begin['$nil?']()['$!']()
        } else {
          return $ret_or_26
        };
      }; return nil; })())) {
        return 0};
      if ($truthy(is_infinite(self))) {
        return infinity};
      if ($truthy((function() {if ($truthy(($ret_or_27 = $$($nesting, 'Numeric')['$==='](self.begin)))) {
        return $$($nesting, 'Numeric')['$==='](self.end)
      } else {
        return $ret_or_27
      }; return nil; })())) {
      } else {
        return nil
      };
      range_begin = self.begin;
      range_end = self.end;
      if ($truthy(self.excl)) {
        range_end = $rb_minus(range_end, 1)};
      if ($truthy($rb_lt(range_end, range_begin))) {
        return 0};
      return (Math.abs(range_end - range_begin) + 1).$to_i();
    }, $Range_size$14.$$arity = 0);
    
    Opal.def(self, '$step', $Range_step$15 = function $$step(n) {
      var $$16, $$17, $$18, $iter = $Range_step$15.$$p, $yield = $iter || nil, self = this, i = nil;

      if ($iter) $Range_step$15.$$p = null;
      
      
      if (n == null) {
        n = 1;
      };
      
      function coerceStepSize() {
        if (!n.$$is_number) {
          n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int")
        }

        if (n < 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be negative")
        } else if (n === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be 0")
        }
      }

      function enumeratorSize() {
        if (!self.begin['$respond_to?']("succ")) {
          return nil;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          return nil;
        }

        if (n % 1 === 0) {
          return $rb_divide(self.$size(), n).$ceil();
        } else {
          // n is a float
          var begin = self.begin, end = self.end,
              abs = Math.abs, floor = Math.floor,
              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$($nesting, 'Float'), 'EPSILON'),
              size;

          if (err > 0.5) {
            err = 0.5;
          }

          if (self.excl) {
            size = floor((end - begin) / n - err);
            if (size * n + begin < end) {
              size++;
            }
          } else {
            size = floor((end - begin) / n + err) + 1
          }

          return size;
        }
      }
    ;
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["step", n], ($$16 = function(){var self = $$16.$$s == null ? this : $$16.$$s;

        
          coerceStepSize();
          return enumeratorSize();
        }, $$16.$$s = self, $$16.$$arity = 0, $$16))
      };
      coerceStepSize();
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        
        i = 0;
        (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], ($$17 = function(){var self = $$17.$$s == null ? this : $$17.$$s, current = nil;
          if (self.begin == null) self.begin = nil;
          if (self.excl == null) self.excl = nil;
          if (self.end == null) self.end = nil;

        
          current = $rb_plus(self.begin, $rb_times(i, n));
          if ($truthy(self.excl)) {
            if ($truthy($rb_ge(current, self.end))) {
              
              Opal.brk(nil, $brk)}
          } else if ($truthy($rb_gt(current, self.end))) {
            
            Opal.brk(nil, $brk)};
          Opal.yield1($yield, current);
          return (i = $rb_plus(i, 1));}, $$17.$$s = self, $$17.$$brk = $brk, $$17.$$arity = 0, $$17))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      } else {
        
        
        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
          self.$raise($$($nesting, 'TypeError'), "no implicit conversion to float from string")
        }
      ;
        $send(self, 'each_with_index', [], ($$18 = function(value, idx){var self = $$18.$$s == null ? this : $$18.$$s;

        
          
          if (value == null) {
            value = nil;
          };
          
          if (idx == null) {
            idx = nil;
          };
          if (idx['$%'](n)['$=='](0)) {
            return Opal.yield1($yield, value);
          } else {
            return nil
          };}, $$18.$$s = self, $$18.$$arity = 2, $$18));
      };
      return self;
    }, $Range_step$15.$$arity = -1);
    
    Opal.def(self, '$bsearch', $Range_bsearch$19 = function $$bsearch() {
      var $iter = $Range_bsearch$19.$$p, block = $iter || nil, self = this;

      if ($iter) $Range_bsearch$19.$$p = null;
      
      
      if ($iter) $Range_bsearch$19.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch")
      };
      if ($truthy(is_infinite(self) && (self.begin.$$is_number || self.end.$$is_number))) {
        self.$raise($$($nesting, 'NotImplementedError'), "Can't #bsearch an infinite range")};
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't do binary search for " + (self.begin.$class()))
      };
      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
    }, $Range_bsearch$19.$$arity = 0);
    
    Opal.def(self, '$to_s', $Range_to_s$20 = function $$to_s() {
      var self = this, $ret_or_28 = nil, $ret_or_29 = nil;

      return "" + ((function() {if ($truthy(($ret_or_28 = self.begin))) {
        return $ret_or_28
      } else {
        return ""
      }; return nil; })()) + ((function() {if ($truthy(self.excl)) {
        return "..."
      } else {
        return ".."
      }; return nil; })()) + ((function() {if ($truthy(($ret_or_29 = self.end))) {
        return $ret_or_29
      } else {
        return ""
      }; return nil; })())
    }, $Range_to_s$20.$$arity = 0);
    
    Opal.def(self, '$inspect', $Range_inspect$21 = function $$inspect() {
      var self = this, $ret_or_30 = nil, $ret_or_31 = nil;

      return "" + ((function() {if ($truthy(($ret_or_30 = self.begin))) {
        return self.begin.$inspect()
      } else {
        return $ret_or_30
      }; return nil; })()) + ((function() {if ($truthy(self.excl)) {
        return "..."
      } else {
        return ".."
      }; return nil; })()) + ((function() {if ($truthy(($ret_or_31 = self.end))) {
        return self.end.$inspect()
      } else {
        return $ret_or_31
      }; return nil; })())
    }, $Range_inspect$21.$$arity = 0);
    
    Opal.def(self, '$marshal_load', $Range_marshal_load$22 = function $$marshal_load(args) {
      var self = this;

      
      self.begin = args['$[]']("begin");
      self.end = args['$[]']("end");
      return (self.excl = args['$[]']("excl"));
    }, $Range_marshal_load$22.$$arity = 1);
    return (Opal.def(self, '$hash', $Range_hash$23 = function $$hash() {
      var self = this;

      return [self.begin, self.end, self.excl].$hash()
    }, $Range_hash$23.$$arity = 0), nil) && 'hash';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/proc"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$raise', '$proc', '$call', '$to_proc', '$coerce_to!']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $Proc_new$1, $Proc_call$2, $Proc_$gt$gt$3, $Proc_$lt$lt$5, $Proc_to_proc$7, $Proc_lambda$ques$8, $Proc_arity$9, $Proc_source_location$10, $Proc_binding$11, $Proc_parameters$12, $Proc_curry$13, $Proc_dup$14;

    
    Opal.defineProperty(self.$$prototype, '$$is_proc', true);
    Opal.defineProperty(self.$$prototype, '$$is_lambda', false);
    Opal.defs(self, '$new', $Proc_new$1 = function() {
      var $iter = $Proc_new$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Proc_new$1.$$p = null;
      
      
      if ($iter) $Proc_new$1.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    }, $Proc_new$1.$$arity = 0);
    
    Opal.def(self, '$call', $Proc_call$2 = function $$call($a) {
      var $iter = $Proc_call$2.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Proc_call$2.$$p = null;
      
      
      if ($iter) $Proc_call$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (block !== nil) {
        self.$$p = block;
      }

      var result, $brk = self.$$brk;

      if ($brk) {
        try {
          if (self.$$is_lambda) {
            result = self.apply(null, args);
          }
          else {
            result = Opal.yieldX(self, args);
          }
        } catch (err) {
          if (err === $brk) {
            return $brk.$v
          }
          else {
            throw err
          }
        }
      }
      else {
        if (self.$$is_lambda) {
          result = self.apply(null, args);
        }
        else {
          result = Opal.yieldX(self, args);
        }
      }

      return result;
    ;
    }, $Proc_call$2.$$arity = -1);
    Opal.alias(self, "[]", "call");
    Opal.alias(self, "===", "call");
    Opal.alias(self, "yield", "call");
    
    Opal.def(self, '$>>', $Proc_$gt$gt$3 = function(other) {
      var $$4, $iter = $Proc_$gt$gt$3.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Proc_$gt$gt$3.$$p = null;
      return $send(self, 'proc', [], ($$4 = function($a){var self = $$4.$$s == null ? this : $$4.$$s, $iter = $$4.$$p, block = $iter || nil, $post_args, args, out = nil;

      
        
        if ($iter) $$4.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        out = $send(self, 'call', Opal.to_a(args), block.$to_proc());
        return other.$call(out);}, $$4.$$s = self, $$4.$$arity = -1, $$4))
    }, $Proc_$gt$gt$3.$$arity = 1);
    
    Opal.def(self, '$<<', $Proc_$lt$lt$5 = function(other) {
      var $$6, $iter = $Proc_$lt$lt$5.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Proc_$lt$lt$5.$$p = null;
      return $send(self, 'proc', [], ($$6 = function($a){var self = $$6.$$s == null ? this : $$6.$$s, $iter = $$6.$$p, block = $iter || nil, $post_args, args, out = nil;

      
        
        if ($iter) $$6.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        out = $send(other, 'call', Opal.to_a(args), block.$to_proc());
        return self.$call(out);}, $$6.$$s = self, $$6.$$arity = -1, $$6))
    }, $Proc_$lt$lt$5.$$arity = 1);
    
    Opal.def(self, '$to_proc', $Proc_to_proc$7 = function $$to_proc() {
      var self = this;

      return self
    }, $Proc_to_proc$7.$$arity = 0);
    
    Opal.def(self, '$lambda?', $Proc_lambda$ques$8 = function() {
      var self = this;

      return !!self.$$is_lambda;
    }, $Proc_lambda$ques$8.$$arity = 0);
    
    Opal.def(self, '$arity', $Proc_arity$9 = function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else {
        return self.$$arity;
      }
    
    }, $Proc_arity$9.$$arity = 0);
    
    Opal.def(self, '$source_location', $Proc_source_location$10 = function $$source_location() {
      var self = this;

      
      if (self.$$is_curried) { return nil; };
      return nil;
    }, $Proc_source_location$10.$$arity = 0);
    
    Opal.def(self, '$binding', $Proc_binding$11 = function $$binding() {
      var self = this;

      
      if (self.$$is_curried) { self.$raise($$($nesting, 'ArgumentError'), "Can't create Binding") };
      return nil;
    }, $Proc_binding$11.$$arity = 0);
    
    Opal.def(self, '$parameters', $Proc_parameters$12 = function $$parameters() {
      var self = this;

      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (self.$$is_lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    
    }, $Proc_parameters$12.$$arity = 0);
    
    Opal.def(self, '$curry', $Proc_curry$13 = function $$curry(arity) {
      var self = this;

      
      ;
      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = $$($nesting, 'Opal')['$coerce_to!'](arity, $$($nesting, 'Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arity) + " for " + (self.length) + ")")
        }
      }

      function curried () {
        var args = $slice.call(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (length) + " for " + (arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice.call(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    ;
    }, $Proc_curry$13.$$arity = -1);
    
    Opal.def(self, '$dup', $Proc_dup$14 = function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      for (var prop in self) {
        if (self.hasOwnProperty(prop)) {
          proc[prop] = self[prop];
        }
      }

      return proc;
    
    }, $Proc_dup$14.$$arity = 0);
    return Opal.alias(self, "clone", "dup");
  })($nesting[0], Function, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/method"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$arity', '$>>', '$<<', '$new', '$class', '$join', '$source_location', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Method');

    var $nesting = [self].concat($parent_nesting), $Method_initialize$1, $Method_arity$2, $Method_parameters$3, $Method_source_location$4, $Method_comments$5, $Method_call$6, $Method_$gt$gt$7, $Method_$lt$lt$8, $Method_unbind$9, $Method_to_proc$10, $Method_inspect$11;

    self.$$prototype.method = self.$$prototype.receiver = self.$$prototype.owner = self.$$prototype.name = nil;
    
    self.$attr_reader("owner", "receiver", "name");
    
    Opal.def(self, '$initialize', $Method_initialize$1 = function $$initialize(receiver, owner, method, name) {
      var self = this;

      
      self.receiver = receiver;
      self.owner = owner;
      self.name = name;
      return (self.method = method);
    }, $Method_initialize$1.$$arity = 4);
    
    Opal.def(self, '$arity', $Method_arity$2 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, $Method_arity$2.$$arity = 0);
    
    Opal.def(self, '$parameters', $Method_parameters$3 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, $Method_parameters$3.$$arity = 0);
    
    Opal.def(self, '$source_location', $Method_source_location$4 = function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    }, $Method_source_location$4.$$arity = 0);
    
    Opal.def(self, '$comments', $Method_comments$5 = function $$comments() {
      var self = this, $ret_or_2 = nil;

      if ($truthy(($ret_or_2 = self.method.$$comments))) {
        return $ret_or_2
      } else {
        return []
      }
    }, $Method_comments$5.$$arity = 0);
    
    Opal.def(self, '$call', $Method_call$6 = function $$call($a) {
      var $iter = $Method_call$6.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Method_call$6.$$p = null;
      
      
      if ($iter) $Method_call$6.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      self.method.$$p = block;

      return self.method.apply(self.receiver, args);
    ;
    }, $Method_call$6.$$arity = -1);
    Opal.alias(self, "[]", "call");
    
    Opal.def(self, '$>>', $Method_$gt$gt$7 = function(other) {
      var self = this;

      return self.method['$>>'](other)
    }, $Method_$gt$gt$7.$$arity = 1);
    
    Opal.def(self, '$<<', $Method_$lt$lt$8 = function(other) {
      var self = this;

      return self.method['$<<'](other)
    }, $Method_$lt$lt$8.$$arity = 1);
    
    Opal.def(self, '$unbind', $Method_unbind$9 = function $$unbind() {
      var self = this;

      return $$($nesting, 'UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)
    }, $Method_unbind$9.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Method_to_proc$10 = function $$to_proc() {
      var self = this;

      
      var proc = self.$call.bind(self);
      proc.$$unbound = self.method;
      proc.$$is_lambda = true;
      proc.$$arity = self.method.$$arity;
      proc.$$parameters = self.method.$$parameters;
      return proc;
    
    }, $Method_to_proc$10.$$arity = 0);
    return (Opal.def(self, '$inspect', $Method_inspect$11 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.receiver.$class()) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, $Method_inspect$11.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'UnboundMethod');

    var $nesting = [self].concat($parent_nesting), $UnboundMethod_initialize$12, $UnboundMethod_arity$13, $UnboundMethod_parameters$14, $UnboundMethod_source_location$15, $UnboundMethod_comments$16, $UnboundMethod_bind$17, $UnboundMethod_inspect$18;

    self.$$prototype.method = self.$$prototype.owner = self.$$prototype.name = self.$$prototype.source = nil;
    
    self.$attr_reader("source", "owner", "name");
    
    Opal.def(self, '$initialize', $UnboundMethod_initialize$12 = function $$initialize(source, owner, method, name) {
      var self = this;

      
      self.source = source;
      self.owner = owner;
      self.method = method;
      return (self.name = name);
    }, $UnboundMethod_initialize$12.$$arity = 4);
    
    Opal.def(self, '$arity', $UnboundMethod_arity$13 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, $UnboundMethod_arity$13.$$arity = 0);
    
    Opal.def(self, '$parameters', $UnboundMethod_parameters$14 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, $UnboundMethod_parameters$14.$$arity = 0);
    
    Opal.def(self, '$source_location', $UnboundMethod_source_location$15 = function $$source_location() {
      var self = this, $ret_or_3 = nil;

      if ($truthy(($ret_or_3 = self.method.$$source_location))) {
        return $ret_or_3
      } else {
        return ["(eval)", 0]
      }
    }, $UnboundMethod_source_location$15.$$arity = 0);
    
    Opal.def(self, '$comments', $UnboundMethod_comments$16 = function $$comments() {
      var self = this, $ret_or_4 = nil;

      if ($truthy(($ret_or_4 = self.method.$$comments))) {
        return $ret_or_4
      } else {
        return []
      }
    }, $UnboundMethod_comments$16.$$arity = 0);
    
    Opal.def(self, '$bind', $UnboundMethod_bind$17 = function $$bind(object) {
      var self = this;

      
      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
        return $$($nesting, 'Method').$new(object, self.owner, self.method, self.name);
      }
      else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't bind singleton method to a different class (expected " + (object) + ".kind_of?(" + (self.owner) + " to be true)");
      }
    
    }, $UnboundMethod_bind$17.$$arity = 1);
    return (Opal.def(self, '$inspect', $UnboundMethod_inspect$18 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.source) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, $UnboundMethod_inspect$18.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/variables"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $gvars = Opal.gvars, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new']);
  
  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = ($gvars["\""] = Opal.loaded_features);
  $gvars.LOAD_PATH = ($gvars[":"] = []);
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  Opal.const_set($nesting[0], 'ARGV', []);
  Opal.const_set($nesting[0], 'ARGF', $$($nesting, 'Object').$new());
  Opal.const_set($nesting[0], 'ENV', $hash2([], {}));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/io"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $module = Opal.module, $gvars = Opal.gvars, $send = Opal.send, $writer = nil;

  Opal.add_stubs(['$attr_accessor', '$size', '$write', '$String', '$chomp', '$getbyte', '$getc', '$raise', '$new', '$write_proc=', '$-', '$extend']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IO');

    var $nesting = [self].concat($parent_nesting), $IO_tty$ques$1, $IO_closed$ques$2, $IO_write$3, $IO_flush$4;

    self.$$prototype.tty = self.$$prototype.closed = nil;
    
    Opal.const_set($nesting[0], 'SEEK_SET', 0);
    Opal.const_set($nesting[0], 'SEEK_CUR', 1);
    Opal.const_set($nesting[0], 'SEEK_END', 2);
    
    Opal.def(self, '$tty?', $IO_tty$ques$1 = function() {
      var self = this;

      return self.tty
    }, $IO_tty$ques$1.$$arity = 0);
    
    Opal.def(self, '$closed?', $IO_closed$ques$2 = function() {
      var self = this;

      return self.closed
    }, $IO_closed$ques$2.$$arity = 0);
    self.$attr_accessor("write_proc");
    
    Opal.def(self, '$write', $IO_write$3 = function $$write(string) {
      var self = this;

      
      self.write_proc(string);
      return string.$size();
    }, $IO_write$3.$$arity = 1);
    self.$attr_accessor("sync", "tty");
    
    Opal.def(self, '$flush', $IO_flush$4 = function $$flush() {
      var self = this;

      return nil
    }, $IO_flush$4.$$arity = 0);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Writable');

      var $nesting = [self].concat($parent_nesting), $Writable_$lt$lt$5, $Writable_print$6, $Writable_puts$7;

      
      
      Opal.def(self, '$<<', $Writable_$lt$lt$5 = function(string) {
        var self = this;

        
        self.$write(string);
        return self;
      }, $Writable_$lt$lt$5.$$arity = 1);
      
      Opal.def(self, '$print', $Writable_print$6 = function $$print($a) {
        var $post_args, args, self = this;
        if ($gvars[","] == null) $gvars[","] = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        
        for (var i = 0, ii = args.length; i < ii; i++) {
          args[i] = self.$String(args[i])
        }
        self.$write(args.join($gvars[","]));
      ;
        return nil;
      }, $Writable_print$6.$$arity = -1);
      return (Opal.def(self, '$puts', $Writable_puts$7 = function $$puts($a) {
        var $post_args, args, self = this;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        
        for (var i = 0, ii = args.length; i < ii; i++) {
          args[i] = self.$String(args[i]).$chomp()
        }
        self.$write(args.concat([nil]).join($gvars["/"]));
      ;
        return nil;
      }, $Writable_puts$7.$$arity = -1), nil) && 'puts';
    })($nesting[0], $nesting);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'Readable');

      var $nesting = [self].concat($parent_nesting), $Readable_readbyte$8, $Readable_readchar$9, $Readable_readline$10, $Readable_readpartial$11;

      
      
      Opal.def(self, '$readbyte', $Readable_readbyte$8 = function $$readbyte() {
        var self = this;

        return self.$getbyte()
      }, $Readable_readbyte$8.$$arity = 0);
      
      Opal.def(self, '$readchar', $Readable_readchar$9 = function $$readchar() {
        var self = this;

        return self.$getc()
      }, $Readable_readchar$9.$$arity = 0);
      
      Opal.def(self, '$readline', $Readable_readline$10 = function $$readline(sep) {
        var self = this;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        
        
        if (sep == null) {
          sep = $gvars["/"];
        };
        return self.$raise($$($nesting, 'NotImplementedError'));
      }, $Readable_readline$10.$$arity = -1);
      return (Opal.def(self, '$readpartial', $Readable_readpartial$11 = function $$readpartial(integer, outbuf) {
        var self = this;

        
        
        if (outbuf == null) {
          outbuf = nil;
        };
        return self.$raise($$($nesting, 'NotImplementedError'));
      }, $Readable_readpartial$11.$$arity = -2), nil) && 'readpartial';
    })($nesting[0], $nesting);
  })($nesting[0], null, $nesting);
  Opal.const_set($nesting[0], 'STDERR', ($gvars.stderr = $$($nesting, 'IO').$new()));
  Opal.const_set($nesting[0], 'STDIN', ($gvars.stdin = $$($nesting, 'IO').$new()));
  Opal.const_set($nesting[0], 'STDOUT', ($gvars.stdout = $$($nesting, 'IO').$new()));
  var console = Opal.global.console;
  
  $writer = [typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)}];
  $send($$($nesting, 'STDOUT'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)}];
  $send($$($nesting, 'STDERR'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  $$($nesting, 'STDOUT').$extend($$$($$($nesting, 'IO'), 'Writable'));
  return $$($nesting, 'STDERR').$extend($$$($$($nesting, 'IO'), 'Writable'));
};

/* Generated by Opal 1.2.0 */
Opal.modules["opal/regexp_anchors"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module;

  Opal.add_stubs(['$new']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    
    Opal.const_set($nesting[0], 'REGEXP_START', "^");
    Opal.const_set($nesting[0], 'REGEXP_END', "$");
    Opal.const_set($nesting[0], 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'INLINE_IDENTIFIER_REGEXP', $$($nesting, 'Regexp').$new("" + "[^" + ($$($nesting, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + ($$($nesting, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    Opal.const_set($nesting[0], 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    return Opal.const_set($nesting[0], 'CONST_NAME_REGEXP', $$($nesting, 'Regexp').$new("" + ($$($nesting, 'REGEXP_START')) + "(::)?[A-Z][^" + ($$($nesting, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + ($$($nesting, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["opal/mini"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("corelib/nil");
  self.$require("corelib/boolean");
  self.$require("corelib/string");
  self.$require("corelib/comparable");
  self.$require("corelib/enumerable");
  self.$require("corelib/enumerator");
  self.$require("corelib/array");
  self.$require("corelib/hash");
  self.$require("corelib/number");
  self.$require("corelib/range");
  self.$require("corelib/proc");
  self.$require("corelib/method");
  self.$require("corelib/regexp");
  self.$require("corelib/variables");
  self.$require("corelib/io");
  return self.$require("opal/regexp_anchors");
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/kernel/format"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$==', '$length', '$respond_to?', '$[]', '$coerce_to?', '$nil?', '$to_a', '$raise', '$to_int', '$fetch', '$Integer', '$Float', '$to_ary', '$to_str', '$inspect', '$to_s']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_format$1;

    
    
    Opal.def(self, '$format', $Kernel_format$1 = function $$format(format_string, $a) {
      var $post_args, args, self = this, $ret_or_1 = nil, ary = nil;
      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_1 = args.$length()['$=='](1)))) {
        return args['$[]'](0)['$respond_to?']("to_ary")
      } else {
        return $ret_or_1
      }; return nil; })())) {
        
        ary = $$($nesting, 'Opal')['$coerce_to?'](args['$[]'](0), $$($nesting, 'Array'), "to_ary");
        if ($truthy(ary['$nil?']())) {
        } else {
          args = ary.$to_a()
        };};
      
      var result = '',
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %<> fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE  = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS  = 4,
          FZERO  = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC  = 64,
          FPREC0 = 128;

      function CHECK_FOR_FLAGS() {
        if (flags&FWIDTH) { self.$raise($$($nesting, 'ArgumentError'), "flag after width") }
        if (flags&FPREC0) { self.$raise($$($nesting, 'ArgumentError'), "flag after precision") }
      }

      function CHECK_FOR_WIDTH() {
        if (flags&FWIDTH) { self.$raise($$($nesting, 'ArgumentError'), "width given twice") }
        if (flags&FPREC0) { self.$raise($$($nesting, 'ArgumentError'), "width after precision") }
      }

      function GET_NTH_ARG(num) {
        if (num >= args.length) { self.$raise($$($nesting, 'ArgumentError'), "too few arguments") }
        return args[num];
      }

      function GET_NEXT_ARG() {
        switch (pos_arg_num) {
        case -1: self.$raise($$($nesting, 'ArgumentError'), "" + "unnumbered(" + (seq_arg_num) + ") mixed with numbered")
        case -2: self.$raise($$($nesting, 'ArgumentError'), "" + "unnumbered(" + (seq_arg_num) + ") mixed with named")
        }
        pos_arg_num = seq_arg_num++;
        return GET_NTH_ARG(pos_arg_num - 1);
      }

      function GET_POS_ARG(num) {
        if (pos_arg_num > 0) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "numbered(" + (num) + ") after unnumbered(" + (pos_arg_num) + ")")
        }
        if (pos_arg_num === -2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "numbered(" + (num) + ") after named")
        }
        if (num < 1) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid index - " + (num) + "$")
        }
        pos_arg_num = -1;
        return GET_NTH_ARG(num - 1);
      }

      function GET_ARG() {
        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);
      }

      function READ_NUM(label) {
        var num, str = '';
        for (;; i++) {
          if (i === len) {
            self.$raise($$($nesting, 'ArgumentError'), "malformed format string - %*[0-9]")
          }
          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {
            i--;
            num = parseInt(str, 10) || 0;
            if (num > 2147483647) {
              self.$raise($$($nesting, 'ArgumentError'), "" + (label) + " too big")
            }
            return num;
          }
          str += format_string.charAt(i);
        }
      }

      function READ_NUM_AFTER_ASTER(label) {
        var arg, num = READ_NUM(label);
        if (format_string.charAt(i + 1) === '$') {
          i++;
          arg = GET_POS_ARG(num);
        } else {
          arg = GET_NEXT_ARG();
        }
        return (arg).$to_int();
      }

      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {
        str = undefined;

        flags = FNONE;
        width = -1;
        precision = -1;
        next_arg = undefined;

        end_slice = i;

        i++;

        switch (format_string.charAt(i)) {
        case '%':
          begin_slice = i;
        case '':
        case '\n':
        case '\0':
          i++;
          continue;
        }

        format_sequence: for (; i < len; i++) {
          switch (format_string.charAt(i)) {

          case ' ':
            CHECK_FOR_FLAGS();
            flags |= FSPACE;
            continue format_sequence;

          case '#':
            CHECK_FOR_FLAGS();
            flags |= FSHARP;
            continue format_sequence;

          case '+':
            CHECK_FOR_FLAGS();
            flags |= FPLUS;
            continue format_sequence;

          case '-':
            CHECK_FOR_FLAGS();
            flags |= FMINUS;
            continue format_sequence;

          case '0':
            CHECK_FOR_FLAGS();
            flags |= FZERO;
            continue format_sequence;

          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            tmp_num = READ_NUM('width');
            if (format_string.charAt(i + 1) === '$') {
              if (i + 2 === len) {
                str = '%';
                i++;
                break format_sequence;
              }
              if (next_arg !== undefined) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "value given twice - %" + (tmp_num) + "$")
              }
              next_arg = GET_POS_ARG(tmp_num);
              i++;
            } else {
              CHECK_FOR_WIDTH();
              flags |= FWIDTH;
              width = tmp_num;
            }
            continue format_sequence;

          case '<':
          case '\{':
            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\}');
            hash_parameter_key = '';

            i++;

            for (;; i++) {
              if (i === len) {
                self.$raise($$($nesting, 'ArgumentError'), "malformed name - unmatched parenthesis")
              }
              if (format_string.charAt(i) === closing_brace_char) {

                if (pos_arg_num > 0) {
                  self.$raise($$($nesting, 'ArgumentError'), "" + "named " + (hash_parameter_key) + " after unnumbered(" + (pos_arg_num) + ")")
                }
                if (pos_arg_num === -1) {
                  self.$raise($$($nesting, 'ArgumentError'), "" + "named " + (hash_parameter_key) + " after numbered")
                }
                pos_arg_num = -2;

                if (args[0] === undefined || !args[0].$$is_hash) {
                  self.$raise($$($nesting, 'ArgumentError'), "one hash required")
                }

                next_arg = (args[0]).$fetch(hash_parameter_key);

                if (closing_brace_char === '>') {
                  continue format_sequence;
                } else {
                  str = next_arg.toString();
                  if (precision !== -1) { str = str.slice(0, precision); }
                  if (flags&FMINUS) {
                    while (str.length < width) { str = str + ' '; }
                  } else {
                    while (str.length < width) { str = ' ' + str; }
                  }
                  break format_sequence;
                }
              }
              hash_parameter_key += format_string.charAt(i);
            }

          case '*':
            i++;
            CHECK_FOR_WIDTH();
            flags |= FWIDTH;
            width = READ_NUM_AFTER_ASTER('width');
            if (width < 0) {
              flags |= FMINUS;
              width = -width;
            }
            continue format_sequence;

          case '.':
            if (flags&FPREC0) {
              self.$raise($$($nesting, 'ArgumentError'), "precision given twice")
            }
            flags |= FPREC|FPREC0;
            precision = 0;
            i++;
            if (format_string.charAt(i) === '*') {
              i++;
              precision = READ_NUM_AFTER_ASTER('precision');
              if (precision < 0) {
                flags &= ~FPREC;
              }
              continue format_sequence;
            }
            precision = READ_NUM('precision');
            continue format_sequence;

          case 'd':
          case 'i':
          case 'u':
            arg = self.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              str = (-arg).toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            break format_sequence;

          case 'b':
          case 'B':
          case 'o':
          case 'x':
          case 'X':
            switch (format_string.charAt(i)) {
            case 'b':
            case 'B':
              base_number = 2;
              base_prefix = '0b';
              base_neg_zero_regex = /^1+/;
              base_neg_zero_digit = '1';
              break;
            case 'o':
              base_number = 8;
              base_prefix = '0';
              base_neg_zero_regex = /^3?7+/;
              base_neg_zero_digit = '7';
              break;
            case 'x':
            case 'X':
              base_number = 16;
              base_prefix = '0x';
              base_neg_zero_regex = /^f+/;
              base_neg_zero_digit = 'f';
              break;
            }
            arg = self.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString(base_number);
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (flags&FPLUS || flags&FSPACE) {
                str = (-arg).toString(base_number);
                while (str.length < precision) { str = '0' + str; }
                if (flags&FMINUS) {
                  if (flags&FSHARP) { str = base_prefix + str; }
                  str = '-' + str;
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                  } else {
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              } else {
                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }
                if (flags&FMINUS) {
                  str = '..' + str;
                  if (flags&FSHARP) { str = base_prefix + str; }
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                  } else {
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
              str = str.toUpperCase();
            }
            break format_sequence;

          case 'f':
          case 'e':
          case 'E':
          case 'g':
          case 'G':
            arg = self.$Float(GET_ARG());
            if (arg >= 0 || isNaN(arg)) {
              if (arg === Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = arg.toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = arg.toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = arg.toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (arg === -Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = (-arg).toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = (-arg).toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = (-arg).toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== -Infinity) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {
              str = str.toUpperCase();
            }
            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');
            break format_sequence;

          case 'a':
          case 'A':
            // Not implemented because there are no specs for this field type.
            self.$raise($$($nesting, 'NotImplementedError'), "`A` and `a` format field types are not implemented in Opal yet")

          case 'c':
            arg = GET_ARG();
            if ((arg)['$respond_to?']("to_ary")) { arg = (arg).$to_ary()[0]; }
            if ((arg)['$respond_to?']("to_str")) {
              str = (arg).$to_str();
            } else {
              str = String.fromCharCode($coerce_to(arg, $$($nesting, 'Integer'), 'to_int'));
            }
            if (str.length !== 1) {
              self.$raise($$($nesting, 'ArgumentError'), "%c requires a character")
            }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 'p':
            str = (GET_ARG()).$inspect();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 's':
            str = (GET_ARG()).$to_s();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          default:
            self.$raise($$($nesting, 'ArgumentError'), "" + "malformed format string - %" + (format_string.charAt(i)))
          }
        }

        if (str === undefined) {
          self.$raise($$($nesting, 'ArgumentError'), "malformed format string - %")
        }

        result += format_string.slice(begin_slice, end_slice) + str;
        begin_slice = i + 1;
      }

      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
        self.$raise($$($nesting, 'ArgumentError'), "too many arguments for format string")
      }

      return result + format_string.slice(begin_slice);
    ;
    }, $Kernel_format$1.$$arity = -2);
    return Opal.alias(self, "sprintf", "format");
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/string/encoding"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var $$14, $$17, $$20, $$22, $$25, $$27, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $writer = nil;

  Opal.add_stubs(['$require', '$+', '$[]', '$clone', '$initialize', '$new', '$instance_eval', '$to_proc', '$each', '$const_set', '$tr', '$==', '$default_external', '$attr_accessor', '$singleton_class', '$attr_reader', '$raise', '$register', '$length', '$bytes', '$force_encoding', '$dup', '$bytesize', '$enum_for', '$each_byte', '$to_a', '$each_char', '$each_codepoint', '$coerce_to!', '$find', '$<', '$default_external=', '$-']);
  
  self.$require("corelib/string");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Encoding');

    var $nesting = [self].concat($parent_nesting), $Encoding_register$1, $Encoding_find$3, $Encoding_initialize$4, $Encoding_ascii_compatible$ques$5, $Encoding_dummy$ques$6, $Encoding_binary$ques$7, $Encoding_to_s$8, $Encoding_inspect$9, $Encoding_charsize$10, $Encoding_each_char$11, $Encoding_each_byte$12, $Encoding_bytesize$13;

    self.$$prototype.ascii = self.$$prototype.dummy = self.$$prototype.name = nil;
    
    Opal.defs(self, '$register', $Encoding_register$1 = function $$register(name, options) {
      var $iter = $Encoding_register$1.$$p, block = $iter || nil, $$2, self = this, names = nil, $ret_or_1 = nil, ascii = nil, $ret_or_2 = nil, dummy = nil, $ret_or_3 = nil, encoding = nil, register = nil;

      if ($iter) $Encoding_register$1.$$p = null;
      
      
      if ($iter) $Encoding_register$1.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      names = $rb_plus([name], (function() {if ($truthy(($ret_or_1 = options['$[]']("aliases")))) {
        return $ret_or_1
      } else {
        return []
      }; return nil; })());
      ascii = (function() {if ($truthy(($ret_or_2 = options['$[]']("ascii")))) {
        return $ret_or_2
      } else {
        return false
      }; return nil; })();
      dummy = (function() {if ($truthy(($ret_or_3 = options['$[]']("dummy")))) {
        return $ret_or_3
      } else {
        return false
      }; return nil; })();
      if ($truthy(options['$[]']("inherits"))) {
        
        encoding = options['$[]']("inherits").$clone();
        encoding.$initialize(name, names, ascii, dummy);
      } else {
        encoding = self.$new(name, names, ascii, dummy)
      };
      if ((block !== nil)) {
        $send(encoding, 'instance_eval', [], block.$to_proc())};
      register = Opal.encodings;
      return $send(names, 'each', [], ($$2 = function(encoding_name){var self = $$2.$$s == null ? this : $$2.$$s;

      
        
        if (encoding_name == null) {
          encoding_name = nil;
        };
        self.$const_set(encoding_name.$tr("-", "_"), encoding);
        return register[encoding_name] = encoding;}, $$2.$$s = self, $$2.$$arity = 1, $$2));
    }, $Encoding_register$1.$$arity = -2);
    Opal.defs(self, '$find', $Encoding_find$3 = function $$find(name) {
      var self = this;

      
      if (name['$==']("default_external")) {
        return self.$default_external()};
      return Opal.find_encoding(name);;
    }, $Encoding_find$3.$$arity = 1);
    self.$singleton_class().$attr_accessor("default_external");
    self.$attr_reader("name", "names");
    
    Opal.def(self, '$initialize', $Encoding_initialize$4 = function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    }, $Encoding_initialize$4.$$arity = 4);
    
    Opal.def(self, '$ascii_compatible?', $Encoding_ascii_compatible$ques$5 = function() {
      var self = this;

      return self.ascii
    }, $Encoding_ascii_compatible$ques$5.$$arity = 0);
    
    Opal.def(self, '$dummy?', $Encoding_dummy$ques$6 = function() {
      var self = this;

      return self.dummy
    }, $Encoding_dummy$ques$6.$$arity = 0);
    
    Opal.def(self, '$binary?', $Encoding_binary$ques$7 = function() {
      var self = this;

      return false
    }, $Encoding_binary$ques$7.$$arity = 0);
    
    Opal.def(self, '$to_s', $Encoding_to_s$8 = function $$to_s() {
      var self = this;

      return self.name
    }, $Encoding_to_s$8.$$arity = 0);
    
    Opal.def(self, '$inspect', $Encoding_inspect$9 = function $$inspect() {
      var self = this;

      return "" + "#<Encoding:" + (self.name) + ((function() {if ($truthy(self.dummy)) {
        return " (dummy)"
      } else {
        return nil
      }; return nil; })()) + ">"
    }, $Encoding_inspect$9.$$arity = 0);
    
    Opal.def(self, '$charsize', $Encoding_charsize$10 = function $$charsize(string) {
      var self = this;

      
      var len = 0;
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        if (!(charcode >= 0xD800 && charcode <= 0xDBFF)) {
          len++;
        }
      }
      return len;
    
    }, $Encoding_charsize$10.$$arity = 1);
    
    Opal.def(self, '$each_char', $Encoding_each_char$11 = function $$each_char(string) {
      var $iter = $Encoding_each_char$11.$$p, block = $iter || nil, self = this;

      if ($iter) $Encoding_each_char$11.$$p = null;
      
      
      if ($iter) $Encoding_each_char$11.$$p = null;;
      
      var low_surrogate = "";
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        var chr = string.charAt(i);
        if (charcode >= 0xDC00 && charcode <= 0xDFFF) {
          low_surrogate = chr;
          continue;
        }
        else if (charcode >= 0xD800 && charcode <= 0xDBFF) {
          chr = low_surrogate + chr;
        }
        if (string.encoding.name != "UTF-8") {
          chr = new String(chr);
          chr.encoding = string.encoding;
        }
        Opal.yield1(block, chr);
      }
    ;
    }, $Encoding_each_char$11.$$arity = 1);
    
    Opal.def(self, '$each_byte', $Encoding_each_byte$12 = function $$each_byte($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_each_byte$12.$$arity = -1);
    
    Opal.def(self, '$bytesize', $Encoding_bytesize$13 = function $$bytesize($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_bytesize$13.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EncodingError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'StandardError'), $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CompatibilityError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'EncodingError'), $nesting);
  })($nesting[0], null, $nesting);
  $send($$($nesting, 'Encoding'), 'register', ["UTF-8", $hash2(["aliases", "ascii"], {"aliases": ["CP65001"], "ascii": true})], ($$14 = function(){var self = $$14.$$s == null ? this : $$14.$$s, $each_byte$15, $bytesize$16;

  
    
    Opal.def(self, '$each_byte', $each_byte$15 = function $$each_byte(string) {
      var $iter = $each_byte$15.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$15.$$p = null;
      
      
      if ($iter) $each_byte$15.$$p = null;;
      
      // Taken from: https://github.com/feross/buffer/blob/f52dffd9df0445b93c0c9065c2f8f0f46b2c729a/index.js#L1954-L2032
      var units = Infinity
      var codePoint
      var length = string.length
      var leadSurrogate = null

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i)

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue
            }

            // valid lead
            leadSurrogate = codePoint

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) {
              Opal.yield1(block, 0xEF);
              Opal.yield1(block, 0xBF);
              Opal.yield1(block, 0xBD);
            }
            leadSurrogate = codePoint
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) {
            Opal.yield1(block, 0xEF);
            Opal.yield1(block, 0xBF);
            Opal.yield1(block, 0xBD);
          }
        }

        leadSurrogate = null

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          Opal.yield1(block, codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          Opal.yield1(block, codePoint >> 0x6 | 0xC0);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          Opal.yield1(block, codePoint >> 0xC | 0xE0);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          Opal.yield1(block, codePoint >> 0x12 | 0xF0);
          Opal.yield1(block, codePoint >> 0xC & 0x3F | 0x80);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else {
          // Invalid code point
        }
      }
    ;
    }, $each_byte$15.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$16 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$16.$$arity = 1), nil) && 'bytesize';}, $$14.$$s = self, $$14.$$arity = 0, $$14));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16LE"], ($$17 = function(){var self = $$17.$$s == null ? this : $$17.$$s, $each_byte$18, $bytesize$19;

  
    
    Opal.def(self, '$each_byte', $each_byte$18 = function $$each_byte(string) {
      var $iter = $each_byte$18.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$18.$$p = null;
      
      
      if ($iter) $each_byte$18.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$18.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$19 = function $$bytesize(string) {
      var self = this;

      return string.length * 2;
    }, $bytesize$19.$$arity = 1), nil) && 'bytesize';}, $$17.$$s = self, $$17.$$arity = 0, $$17));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16BE", $hash2(["inherits"], {"inherits": $$$($$($nesting, 'Encoding'), 'UTF_16LE')})], ($$20 = function(){var self = $$20.$$s == null ? this : $$20.$$s, $each_byte$21;

  return (Opal.def(self, '$each_byte', $each_byte$21 = function $$each_byte(string) {
      var $iter = $each_byte$21.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$21.$$p = null;
      
      
      if ($iter) $each_byte$21.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, $each_byte$21.$$arity = 1), nil) && 'each_byte'}, $$20.$$s = self, $$20.$$arity = 0, $$20));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-32LE"], ($$22 = function(){var self = $$22.$$s == null ? this : $$22.$$s, $each_byte$23, $bytesize$24;

  
    
    Opal.def(self, '$each_byte', $each_byte$23 = function $$each_byte(string) {
      var $iter = $each_byte$23.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$23.$$p = null;
      
      
      if ($iter) $each_byte$23.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
      }
    ;
    }, $each_byte$23.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$24 = function $$bytesize(string) {
      var self = this;

      return string.length * 4;
    }, $bytesize$24.$$arity = 1), nil) && 'bytesize';}, $$22.$$s = self, $$22.$$arity = 0, $$22));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-32BE", $hash2(["inherits"], {"inherits": $$$($$($nesting, 'Encoding'), 'UTF_32LE')})], ($$25 = function(){var self = $$25.$$s == null ? this : $$25.$$s, $each_byte$26;

  return (Opal.def(self, '$each_byte', $each_byte$26 = function $$each_byte(string) {
      var $iter = $each_byte$26.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$26.$$p = null;
      
      
      if ($iter) $each_byte$26.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, $each_byte$26.$$arity = 1), nil) && 'each_byte'}, $$25.$$s = self, $$25.$$arity = 0, $$25));
  $send($$($nesting, 'Encoding'), 'register', ["ASCII-8BIT", $hash2(["aliases", "ascii"], {"aliases": ["BINARY"], "ascii": true})], ($$27 = function(){var self = $$27.$$s == null ? this : $$27.$$s, $each_char$28, $charsize$29, $each_byte$30, $bytesize$31, $binary$ques$32;

  
    
    Opal.def(self, '$each_char', $each_char$28 = function $$each_char(string) {
      var $iter = $each_char$28.$$p, block = $iter || nil, self = this;

      if ($iter) $each_char$28.$$p = null;
      
      
      if ($iter) $each_char$28.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var chr = new String(string.charAt(i));
        chr.encoding = string.encoding;
        Opal.yield1(block, chr);
      }
    ;
    }, $each_char$28.$$arity = 1);
    
    Opal.def(self, '$charsize', $charsize$29 = function $$charsize(string) {
      var self = this;

      return string.length;
    }, $charsize$29.$$arity = 1);
    
    Opal.def(self, '$each_byte', $each_byte$30 = function $$each_byte(string) {
      var $iter = $each_byte$30.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$30.$$p = null;
      
      
      if ($iter) $each_byte$30.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, $each_byte$30.$$arity = 1);
    
    Opal.def(self, '$bytesize', $bytesize$31 = function $$bytesize(string) {
      var self = this;

      return string.length;
    }, $bytesize$31.$$arity = 1);
    return (Opal.def(self, '$binary?', $binary$ques$32 = function() {
      var self = this;

      return true
    }, $binary$ques$32.$$arity = 0), nil) && 'binary?';}, $$27.$$s = self, $$27.$$arity = 0, $$27));
  $$($nesting, 'Encoding').$register("ISO-8859-1", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ISO8859-1"], "ascii": true, "inherits": $$$($$($nesting, 'Encoding'), 'ASCII_8BIT')}));
  $$($nesting, 'Encoding').$register("US-ASCII", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ASCII"], "ascii": true, "inherits": $$$($$($nesting, 'Encoding'), 'ASCII_8BIT')}));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_b$33, $String_bytesize$34, $String_each_byte$35, $String_bytes$37, $String_each_char$38, $String_chars$40, $String_each_codepoint$41, $String_codepoints$42, $String_encode$43, $String_force_encoding$44, $String_getbyte$45, $String_initialize_copy$46, $String_length$47, $String_valid_encoding$ques$48;

    self.$$prototype.internal_encoding = self.$$prototype.bytes = self.$$prototype.encoding = nil;
    
    self.$attr_reader("encoding");
    self.$attr_reader("internal_encoding");
    Opal.defineProperty(String.prototype, 'bytes', nil);
    Opal.defineProperty(String.prototype, 'encoding', $$$($$($nesting, 'Encoding'), 'UTF_8'));
    Opal.defineProperty(String.prototype, 'internal_encoding', $$$($$($nesting, 'Encoding'), 'UTF_8'));
    
    Opal.def(self, '$b', $String_b$33 = function $$b() {
      var self = this;

      return self.$dup().$force_encoding("binary")
    }, $String_b$33.$$arity = 0);
    
    Opal.def(self, '$bytesize', $String_bytesize$34 = function $$bytesize() {
      var self = this;

      return self.internal_encoding.$bytesize(self)
    }, $String_bytesize$34.$$arity = 0);
    
    Opal.def(self, '$each_byte', $String_each_byte$35 = function $$each_byte() {
      var $iter = $String_each_byte$35.$$p, block = $iter || nil, $$36, self = this;

      if ($iter) $String_each_byte$35.$$p = null;
      
      
      if ($iter) $String_each_byte$35.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_byte"], ($$36 = function(){var self = $$36.$$s == null ? this : $$36.$$s;

        return self.$bytesize()}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      $send(self.internal_encoding, 'each_byte', [self], block.$to_proc());
      return self;
    }, $String_each_byte$35.$$arity = 0);
    
    Opal.def(self, '$bytes', $String_bytes$37 = function $$bytes() {
      var self = this, $ret_or_4 = nil;

      
      
      if (typeof self === 'string') {
        return (new String(self)).$each_byte().$to_a();
      }
    ;
      self.bytes = (function() {if ($truthy(($ret_or_4 = self.bytes))) {
        return $ret_or_4
      } else {
        return self.$each_byte().$to_a()
      }; return nil; })();
      return self.bytes.$dup();
    }, $String_bytes$37.$$arity = 0);
    
    Opal.def(self, '$each_char', $String_each_char$38 = function $$each_char() {
      var $iter = $String_each_char$38.$$p, block = $iter || nil, $$39, self = this;

      if ($iter) $String_each_char$38.$$p = null;
      
      
      if ($iter) $String_each_char$38.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_char"], ($$39 = function(){var self = $$39.$$s == null ? this : $$39.$$s;

        return self.$length()}, $$39.$$s = self, $$39.$$arity = 0, $$39))
      };
      $send(self.encoding, 'each_char', [self], block.$to_proc());
      return self;
    }, $String_each_char$38.$$arity = 0);
    
    Opal.def(self, '$chars', $String_chars$40 = function $$chars() {
      var $iter = $String_chars$40.$$p, block = $iter || nil, self = this;

      if ($iter) $String_chars$40.$$p = null;
      
      
      if ($iter) $String_chars$40.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$each_char().$to_a()
      };
      return $send(self, 'each_char', [], block.$to_proc());
    }, $String_chars$40.$$arity = 0);
    
    Opal.def(self, '$each_codepoint', $String_each_codepoint$41 = function $$each_codepoint() {
      var $iter = $String_each_codepoint$41.$$p, block = $iter || nil, self = this;

      if ($iter) $String_each_codepoint$41.$$p = null;
      
      
      if ($iter) $String_each_codepoint$41.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_codepoint")
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.codePointAt(i));
      }
    ;
      return self;
    }, $String_each_codepoint$41.$$arity = 0);
    
    Opal.def(self, '$codepoints', $String_codepoints$42 = function $$codepoints() {
      var $iter = $String_codepoints$42.$$p, block = $iter || nil, self = this;

      if ($iter) $String_codepoints$42.$$p = null;
      
      
      if ($iter) $String_codepoints$42.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'each_codepoint', [], block.$to_proc())};
      return self.$each_codepoint().$to_a();
    }, $String_codepoints$42.$$arity = 0);
    
    Opal.def(self, '$encode', $String_encode$43 = function $$encode(encoding) {
      var self = this;

      return Opal.enc(self, encoding);
    }, $String_encode$43.$$arity = 1);
    
    Opal.def(self, '$force_encoding', $String_force_encoding$44 = function $$force_encoding(encoding) {
      var self = this;

      
      var str = self;

      if (encoding === str.encoding) { return str; }

      encoding = $$($nesting, 'Opal')['$coerce_to!'](encoding, $$($nesting, 'String'), "to_s");
      encoding = $$($nesting, 'Encoding').$find(encoding);

      if (encoding === str.encoding) { return str; }

      str = Opal.set_encoding(str, encoding);

      return str;
    
    }, $String_force_encoding$44.$$arity = 1);
    
    Opal.def(self, '$getbyte', $String_getbyte$45 = function $$getbyte(idx) {
      var self = this, string_bytes = nil;

      
      string_bytes = self.$bytes();
      idx = $$($nesting, 'Opal')['$coerce_to!'](idx, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(string_bytes.$length(), idx))) {
        return nil};
      return string_bytes['$[]'](idx);
    }, $String_getbyte$45.$$arity = 1);
    
    Opal.def(self, '$initialize_copy', $String_initialize_copy$46 = function $$initialize_copy(other) {
      var self = this;

      return "" + "\n" + "      self.encoding = other.encoding;\n" + "      self.internal_encoding = other.internal_encoding;\n" + "    "
    }, $String_initialize_copy$46.$$arity = 1);
    
    Opal.def(self, '$length', $String_length$47 = function $$length() {
      var self = this;

      return self.length;
    }, $String_length$47.$$arity = 0);
    Opal.alias(self, "size", "length");
    return (Opal.def(self, '$valid_encoding?', $String_valid_encoding$ques$48 = function() {
      var self = this;

      return true
    }, $String_valid_encoding$ques$48.$$arity = 0), nil) && 'valid_encoding?';
  })($nesting[0], null, $nesting);
  
  $writer = [$$$($$($nesting, 'Encoding'), 'UTF_8')];
  $send($$($nesting, 'Encoding'), 'default_external=', Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];;
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/math"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $type_error = Opal.type_error, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$raise', '$Float', '$Integer', '$module_function', '$checked', '$float!', '$===', '$gamma', '$-', '$integer!', '$/', '$infinite?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Math');

    var $nesting = [self].concat($parent_nesting), $Math_checked$1, $Math_float$excl$2, $Math_integer$excl$3, $Math_acos$4, $Math_acosh$5, $Math_asin$6, $Math_asinh$7, $Math_atan$8, $Math_atan2$9, $Math_atanh$10, $Math_cbrt$11, $Math_cos$12, $Math_cosh$13, $Math_erf$14, $Math_erfc$15, $Math_exp$16, $Math_frexp$17, $Math_gamma$18, $Math_hypot$19, $Math_ldexp$20, $Math_lgamma$21, $Math_log$22, $Math_log10$23, $Math_log2$24, $Math_sin$25, $Math_sinh$26, $Math_sqrt$27, $Math_tan$28, $Math_tanh$29;

    
    Opal.const_set($nesting[0], 'E', Math.E);
    Opal.const_set($nesting[0], 'PI', Math.PI);
    Opal.const_set($nesting[0], 'DomainError', $$($nesting, 'Class').$new($$($nesting, 'StandardError')));
    Opal.defs(self, '$checked', $Math_checked$1 = function $$checked(method, $a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {
        return NaN;
      }

      var result = Math[method].apply(null, args);

      if (isNaN(result)) {
        self.$raise($$($nesting, 'DomainError'), "" + "Numerical argument is out of domain - \"" + (method) + "\"");
      }

      return result;
    ;
    }, $Math_checked$1.$$arity = -2);
    Opal.defs(self, '$float!', $Math_float$excl$2 = function(value) {
      var self = this;

      try {
        return self.$Float(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return self.$raise($type_error(value, $$($nesting, 'Float')))
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Math_float$excl$2.$$arity = 1);
    Opal.defs(self, '$integer!', $Math_integer$excl$3 = function(value) {
      var self = this;

      try {
        return self.$Integer(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return self.$raise($type_error(value, $$($nesting, 'Integer')))
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Math_integer$excl$3.$$arity = 1);
    self.$module_function();
    
    Opal.def(self, '$acos', $Math_acos$4 = function $$acos(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("acos", $$($nesting, 'Math')['$float!'](x))
    }, $Math_acos$4.$$arity = 1);
    if ($truthy((typeof(Math.acosh) !== "undefined"))) {
    } else {
      
      Math.acosh = function(x) {
        return Math.log(x + Math.sqrt(x * x - 1));
      }
    
    };
    
    Opal.def(self, '$acosh', $Math_acosh$5 = function $$acosh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("acosh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_acosh$5.$$arity = 1);
    
    Opal.def(self, '$asin', $Math_asin$6 = function $$asin(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("asin", $$($nesting, 'Math')['$float!'](x))
    }, $Math_asin$6.$$arity = 1);
    if ($truthy((typeof(Math.asinh) !== "undefined"))) {
    } else {
      
      Math.asinh = function(x) {
        return Math.log(x + Math.sqrt(x * x + 1))
      }
    
    };
    
    Opal.def(self, '$asinh', $Math_asinh$7 = function $$asinh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("asinh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_asinh$7.$$arity = 1);
    
    Opal.def(self, '$atan', $Math_atan$8 = function $$atan(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atan", $$($nesting, 'Math')['$float!'](x))
    }, $Math_atan$8.$$arity = 1);
    
    Opal.def(self, '$atan2', $Math_atan2$9 = function $$atan2(y, x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atan2", $$($nesting, 'Math')['$float!'](y), $$($nesting, 'Math')['$float!'](x))
    }, $Math_atan2$9.$$arity = 2);
    if ($truthy((typeof(Math.atanh) !== "undefined"))) {
    } else {
      
      Math.atanh = function(x) {
        return 0.5 * Math.log((1 + x) / (1 - x));
      }
    
    };
    
    Opal.def(self, '$atanh', $Math_atanh$10 = function $$atanh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atanh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_atanh$10.$$arity = 1);
    if ($truthy((typeof(Math.cbrt) !== "undefined"))) {
    } else {
      
      Math.cbrt = function(x) {
        if (x == 0) {
          return 0;
        }

        if (x < 0) {
          return -Math.cbrt(-x);
        }

        var r  = x,
            ex = 0;

        while (r < 0.125) {
          r *= 8;
          ex--;
        }

        while (r > 1.0) {
          r *= 0.125;
          ex++;
        }

        r = (-0.46946116 * r + 1.072302) * r + 0.3812513;

        while (ex < 0) {
          r *= 0.5;
          ex++;
        }

        while (ex > 0) {
          r *= 2;
          ex--;
        }

        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);

        return r;
      }
    
    };
    
    Opal.def(self, '$cbrt', $Math_cbrt$11 = function $$cbrt(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cbrt", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cbrt$11.$$arity = 1);
    
    Opal.def(self, '$cos', $Math_cos$12 = function $$cos(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cos", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cos$12.$$arity = 1);
    if ($truthy((typeof(Math.cosh) !== "undefined"))) {
    } else {
      
      Math.cosh = function(x) {
        return (Math.exp(x) + Math.exp(-x)) / 2;
      }
    
    };
    
    Opal.def(self, '$cosh', $Math_cosh$13 = function $$cosh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cosh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cosh$13.$$arity = 1);
    if ($truthy((typeof(Math.erf) !== "undefined"))) {
    } else {
      
      Opal.defineProperty(Math, 'erf', function(x) {
        var A1 =  0.254829592,
            A2 = -0.284496736,
            A3 =  1.421413741,
            A4 = -1.453152027,
            A5 =  1.061405429,
            P  =  0.3275911;

        var sign = 1;

        if (x < 0) {
            sign = -1;
        }

        x = Math.abs(x);

        var t = 1.0 / (1.0 + P * x);
        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);

        return sign * y;
      });
    
    };
    
    Opal.def(self, '$erf', $Math_erf$14 = function $$erf(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("erf", $$($nesting, 'Math')['$float!'](x))
    }, $Math_erf$14.$$arity = 1);
    if ($truthy((typeof(Math.erfc) !== "undefined"))) {
    } else {
      
      Opal.defineProperty(Math, 'erfc', function(x) {
        var z = Math.abs(x),
            t = 1.0 / (0.5 * z + 1.0);

        var A1 = t * 0.17087277 + -0.82215223,
            A2 = t * A1 + 1.48851587,
            A3 = t * A2 + -1.13520398,
            A4 = t * A3 + 0.27886807,
            A5 = t * A4 + -0.18628806,
            A6 = t * A5 + 0.09678418,
            A7 = t * A6 + 0.37409196,
            A8 = t * A7 + 1.00002368,
            A9 = t * A8,
            A10 = -z * z - 1.26551223 + A9;

        var a = t * Math.exp(A10);

        if (x < 0.0) {
          return 2.0 - a;
        }
        else {
          return a;
        }
      });
    
    };
    
    Opal.def(self, '$erfc', $Math_erfc$15 = function $$erfc(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("erfc", $$($nesting, 'Math')['$float!'](x))
    }, $Math_erfc$15.$$arity = 1);
    
    Opal.def(self, '$exp', $Math_exp$16 = function $$exp(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("exp", $$($nesting, 'Math')['$float!'](x))
    }, $Math_exp$16.$$arity = 1);
    
    Opal.def(self, '$frexp', $Math_frexp$17 = function $$frexp(x) {
      var self = this;

      
      x = $$($nesting, 'Math')['$float!'](x);
      
      if (isNaN(x)) {
        return [NaN, 0];
      }

      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,
          frac = x / Math.pow(2, ex);

      return [frac, ex];
    ;
    }, $Math_frexp$17.$$arity = 1);
    
    Opal.def(self, '$gamma', $Math_gamma$18 = function $$gamma(n) {
      var self = this;

      
      n = $$($nesting, 'Math')['$float!'](n);
      
      var i, t, x, value, result, twoN, threeN, fourN, fiveN;

      var G = 4.7421875;

      var P = [
         0.99999999999999709182,
         57.156235665862923517,
        -59.597960355475491248,
         14.136097974741747174,
        -0.49191381609762019978,
         0.33994649984811888699e-4,
         0.46523628927048575665e-4,
        -0.98374475304879564677e-4,
         0.15808870322491248884e-3,
        -0.21026444172410488319e-3,
         0.21743961811521264320e-3,
        -0.16431810653676389022e-3,
         0.84418223983852743293e-4,
        -0.26190838401581408670e-4,
         0.36899182659531622704e-5
      ];


      if (isNaN(n)) {
        return NaN;
      }

      if (n === 0 && 1 / n < 0) {
        return -Infinity;
      }

      if (n === -1 || n === -Infinity) {
        self.$raise($$($nesting, 'DomainError'), "Numerical argument is out of domain - \"gamma\"");
      }

      if ($$($nesting, 'Integer')['$==='](n)) {
        if (n <= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n > 171) {
          return Infinity;
        }

        value  = n - 2;
        result = n - 1;

        while (value > 1) {
          result *= value;
          value--;
        }

        if (result == 0) {
          result = 1;
        }

        return result;
      }

      if (n < 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * $$($nesting, 'Math').$gamma($rb_minus(1, n)));
      }

      if (n >= 171.35) {
        return Infinity;
      }

      if (n > 85.0) {
        twoN   = n * n;
        threeN = twoN * n;
        fourN  = threeN * n;
        fiveN  = fourN * n;

        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -
          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +
          5246819 / (75246796800 * fiveN * n));
      }

      n -= 1;
      x  = P[0];

      for (i = 1; i < P.length; ++i) {
        x += P[i] / (n + i);
      }

      t = n + G + 0.5;

      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
    ;
    }, $Math_gamma$18.$$arity = 1);
    if ($truthy((typeof(Math.hypot) !== "undefined"))) {
    } else {
      
      Math.hypot = function(x, y) {
        return Math.sqrt(x * x + y * y)
      }
    
    };
    
    Opal.def(self, '$hypot', $Math_hypot$19 = function $$hypot(x, y) {
      var self = this;

      return $$($nesting, 'Math').$checked("hypot", $$($nesting, 'Math')['$float!'](x), $$($nesting, 'Math')['$float!'](y))
    }, $Math_hypot$19.$$arity = 2);
    
    Opal.def(self, '$ldexp', $Math_ldexp$20 = function $$ldexp(mantissa, exponent) {
      var self = this;

      
      mantissa = $$($nesting, 'Math')['$float!'](mantissa);
      exponent = $$($nesting, 'Math')['$integer!'](exponent);
      
      if (isNaN(exponent)) {
        self.$raise($$($nesting, 'RangeError'), "float NaN out of range of integer");
      }

      return mantissa * Math.pow(2, exponent);
    ;
    }, $Math_ldexp$20.$$arity = 2);
    
    Opal.def(self, '$lgamma', $Math_lgamma$21 = function $$lgamma(n) {
      var self = this;

      
      if (n == -1) {
        return [Infinity, 1];
      }
      else {
        return [Math.log(Math.abs($$($nesting, 'Math').$gamma(n))), $$($nesting, 'Math').$gamma(n) < 0 ? -1 : 1];
      }
    
    }, $Math_lgamma$21.$$arity = 1);
    
    Opal.def(self, '$log', $Math_log$22 = function $$log(x, base) {
      var self = this;

      
      ;
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($type_error(x, $$($nesting, 'Float')))};
      if ($truthy(base == null)) {
        return $$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](x))
      } else {
        
        if ($truthy($$($nesting, 'String')['$==='](base))) {
          self.$raise($type_error(base, $$($nesting, 'Float')))};
        return $rb_divide($$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](x)), $$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](base)));
      };
    }, $Math_log$22.$$arity = -2);
    if ($truthy((typeof(Math.log10) !== "undefined"))) {
    } else {
      
      Math.log10 = function(x) {
        return Math.log(x) / Math.LN10;
      }
    
    };
    
    Opal.def(self, '$log10', $Math_log10$23 = function $$log10(x) {
      var self = this;

      
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($type_error(x, $$($nesting, 'Float')))};
      return $$($nesting, 'Math').$checked("log10", $$($nesting, 'Math')['$float!'](x));
    }, $Math_log10$23.$$arity = 1);
    if ($truthy((typeof(Math.log2) !== "undefined"))) {
    } else {
      
      Math.log2 = function(x) {
        return Math.log(x) / Math.LN2;
      }
    
    };
    
    Opal.def(self, '$log2', $Math_log2$24 = function $$log2(x) {
      var self = this;

      
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($type_error(x, $$($nesting, 'Float')))};
      return $$($nesting, 'Math').$checked("log2", $$($nesting, 'Math')['$float!'](x));
    }, $Math_log2$24.$$arity = 1);
    
    Opal.def(self, '$sin', $Math_sin$25 = function $$sin(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sin", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sin$25.$$arity = 1);
    if ($truthy((typeof(Math.sinh) !== "undefined"))) {
    } else {
      
      Math.sinh = function(x) {
        return (Math.exp(x) - Math.exp(-x)) / 2;
      }
    
    };
    
    Opal.def(self, '$sinh', $Math_sinh$26 = function $$sinh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sinh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sinh$26.$$arity = 1);
    
    Opal.def(self, '$sqrt', $Math_sqrt$27 = function $$sqrt(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sqrt", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sqrt$27.$$arity = 1);
    
    Opal.def(self, '$tan', $Math_tan$28 = function $$tan(x) {
      var self = this;

      
      x = $$($nesting, 'Math')['$float!'](x);
      if ($truthy(x['$infinite?']())) {
        return $$$($$($nesting, 'Float'), 'NAN')};
      return $$($nesting, 'Math').$checked("tan", $$($nesting, 'Math')['$float!'](x));
    }, $Math_tan$28.$$arity = 1);
    if ($truthy((typeof(Math.tanh) !== "undefined"))) {
    } else {
      
      Math.tanh = function(x) {
        if (x == Infinity) {
          return 1;
        }
        else if (x == -Infinity) {
          return -1;
        }
        else {
          return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
        }
      }
    
    };
    return (Opal.def(self, '$tanh', $Math_tanh$29 = function $$tanh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("tanh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_tanh$29.$$arity = 1), nil) && 'tanh';
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/complex"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;

  Opal.add_stubs(['$require', '$===', '$real?', '$raise', '$new', '$*', '$cos', '$sin', '$attr_reader', '$class', '$==', '$real', '$imag', '$Complex', '$-@', '$+', '$__coerced__', '$-', '$nan?', '$/', '$conj', '$abs2', '$quo', '$polar', '$exp', '$log', '$>', '$!=', '$divmod', '$**', '$hypot', '$atan2', '$lcm', '$denominator', '$finite?', '$infinite?', '$numerator', '$abs', '$arg', '$rationalize', '$to_f', '$to_i', '$to_r', '$inspect', '$positive?', '$zero?', '$Rational']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Complex');

    var $nesting = [self].concat($parent_nesting), $Complex_rect$1, $Complex_polar$2, $Complex_initialize$3, $Complex_coerce$4, $Complex_$eq_eq$5, $Complex_$minus$$6, $Complex_$plus$7, $Complex_$minus$8, $Complex_$$9, $Complex_$slash$10, $Complex_$$$11, $Complex_abs$12, $Complex_abs2$13, $Complex_angle$14, $Complex_conj$15, $Complex_denominator$16, $Complex_eql$ques$17, $Complex_fdiv$18, $Complex_finite$ques$19, $Complex_hash$20, $Complex_infinite$ques$21, $Complex_inspect$22, $Complex_numerator$23, $Complex_polar$24, $Complex_rationalize$25, $Complex_real$ques$26, $Complex_rect$27, $Complex_to_f$28, $Complex_to_i$29, $Complex_to_r$30, $Complex_to_s$31;

    self.$$prototype.real = self.$$prototype.imag = nil;
    
    Opal.defs(self, '$rect', $Complex_rect$1 = function $$rect(real, imag) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

      
      
      if (imag == null) {
        imag = 0;
      };
      if ($truthy((function() {if ($truthy(($ret_or_1 = (function() {if ($truthy(($ret_or_2 = (function() {if ($truthy(($ret_or_3 = $$($nesting, 'Numeric')['$==='](real)))) {
        return real['$real?']()
      } else {
        return $ret_or_3
      }; return nil; })()))) {
        return $$($nesting, 'Numeric')['$==='](imag)
      } else {
        return $ret_or_2
      }; return nil; })()))) {
        return imag['$real?']()
      } else {
        return $ret_or_1
      }; return nil; })())) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not a real")
      };
      return self.$new(real, imag);
    }, $Complex_rect$1.$$arity = -2);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return Opal.alias(self, "rectangular", "rect")
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(self, '$polar', $Complex_polar$2 = function $$polar(r, theta) {
      var self = this, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil;

      
      
      if (theta == null) {
        theta = 0;
      };
      if ($truthy((function() {if ($truthy(($ret_or_4 = (function() {if ($truthy(($ret_or_5 = (function() {if ($truthy(($ret_or_6 = $$($nesting, 'Numeric')['$==='](r)))) {
        return r['$real?']()
      } else {
        return $ret_or_6
      }; return nil; })()))) {
        return $$($nesting, 'Numeric')['$==='](theta)
      } else {
        return $ret_or_5
      }; return nil; })()))) {
        return theta['$real?']()
      } else {
        return $ret_or_4
      }; return nil; })())) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not a real")
      };
      return self.$new($rb_times(r, $$($nesting, 'Math').$cos(theta)), $rb_times(r, $$($nesting, 'Math').$sin(theta)));
    }, $Complex_polar$2.$$arity = -2);
    self.$attr_reader("real", "imag");
    
    Opal.def(self, '$initialize', $Complex_initialize$3 = function $$initialize(real, imag) {
      var self = this;

      
      
      if (imag == null) {
        imag = 0;
      };
      self.real = real;
      return (self.imag = imag);
    }, $Complex_initialize$3.$$arity = -2);
    
    Opal.def(self, '$coerce', $Complex_coerce$4 = function $$coerce(other) {
      var self = this, $ret_or_7 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return [other, self]
      } else if ($truthy((function() {if ($truthy(($ret_or_7 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_7
      }; return nil; })())) {
        return [$$($nesting, 'Complex').$new(other, 0), self]
      } else {
        return self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      }
    }, $Complex_coerce$4.$$arity = 1);
    
    Opal.def(self, '$==', $Complex_$eq_eq$5 = function(other) {
      var self = this, $ret_or_8 = nil, $ret_or_9 = nil, $ret_or_10 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        if ($truthy(($ret_or_8 = self.real['$=='](other.$real())))) {
          return self.imag['$=='](other.$imag())
        } else {
          return $ret_or_8
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_9 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_9
      }; return nil; })())) {
        if ($truthy(($ret_or_10 = self.real['$=='](other)))) {
          return self.imag['$=='](0)
        } else {
          return $ret_or_10
        }
      } else {
        return other['$=='](self)
      }
    }, $Complex_$eq_eq$5.$$arity = 1);
    
    Opal.def(self, '$-@', $Complex_$minus$$6 = function() {
      var self = this;

      return self.$Complex(self.real['$-@'](), self.imag['$-@']())
    }, $Complex_$minus$$6.$$arity = 0);
    
    Opal.def(self, '$+', $Complex_$plus$7 = function(other) {
      var self = this, $ret_or_11 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))
      } else if ($truthy((function() {if ($truthy(($ret_or_11 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_11
      }; return nil; })())) {
        return self.$Complex($rb_plus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("+", other)
      }
    }, $Complex_$plus$7.$$arity = 1);
    
    Opal.def(self, '$-', $Complex_$minus$8 = function(other) {
      var self = this, $ret_or_12 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))
      } else if ($truthy((function() {if ($truthy(($ret_or_12 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_12
      }; return nil; })())) {
        return self.$Complex($rb_minus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("-", other)
      }
    }, $Complex_$minus$8.$$arity = 1);
    
    Opal.def(self, '$*', $Complex_$$9 = function(other) {
      var self = this, $ret_or_13 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))
      } else if ($truthy((function() {if ($truthy(($ret_or_13 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_13
      }; return nil; })())) {
        return self.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))
      } else {
        return self.$__coerced__("*", other)
      }
    }, $Complex_$$9.$$arity = 1);
    
    Opal.def(self, '$/', $Complex_$slash$10 = function(other) {
      var self = this, $ret_or_14 = nil, $ret_or_15 = nil, $ret_or_16 = nil, $ret_or_17 = nil, $ret_or_18 = nil, $ret_or_19 = nil, $ret_or_20 = nil, $ret_or_21 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        if ($truthy((function() {if ($truthy(($ret_or_14 = (function() {if ($truthy(($ret_or_15 = (function() {if ($truthy(($ret_or_16 = (function() {if ($truthy(($ret_or_17 = $$($nesting, 'Number')['$==='](self.real)))) {
          return self.real['$nan?']()
        } else {
          return $ret_or_17
        }; return nil; })()))) {
          return $ret_or_16
        } else {
          
          if ($truthy(($ret_or_18 = $$($nesting, 'Number')['$==='](self.imag)))) {
            return self.imag['$nan?']()
          } else {
            return $ret_or_18
          };
        }; return nil; })()))) {
          return $ret_or_15
        } else {
          
          if ($truthy(($ret_or_19 = $$($nesting, 'Number')['$==='](other.$real())))) {
            return other.$real()['$nan?']()
          } else {
            return $ret_or_19
          };
        }; return nil; })()))) {
          return $ret_or_14
        } else {
          
          if ($truthy(($ret_or_20 = $$($nesting, 'Number')['$==='](other.$imag())))) {
            return other.$imag()['$nan?']()
          } else {
            return $ret_or_20
          };
        }; return nil; })())) {
          return $$($nesting, 'Complex').$new($$$($$($nesting, 'Float'), 'NAN'), $$$($$($nesting, 'Float'), 'NAN'))
        } else {
          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_21 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_21
      }; return nil; })())) {
        return self.$Complex(self.real.$quo(other), self.imag.$quo(other))
      } else {
        return self.$__coerced__("/", other)
      }
    }, $Complex_$slash$10.$$arity = 1);
    
    Opal.def(self, '$**', $Complex_$$$11 = function(other) {
      var $a, $b, $c, $d, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil, $ret_or_22 = nil;

      
      if (other['$=='](0)) {
        return $$($nesting, 'Complex').$new(1, 0)};
      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        
        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        ore = other.$real();
        oim = other.$imag();
        nr = $$($nesting, 'Math').$exp($rb_minus($rb_times(ore, $$($nesting, 'Math').$log(r)), $rb_times(oim, theta)));
        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$($nesting, 'Math').$log(r)));
        return $$($nesting, 'Complex').$polar(nr, ntheta);
      } else if ($truthy($$($nesting, 'Integer')['$==='](other))) {
        if ($truthy($rb_gt(other, 0))) {
          
          x = self;
          z = x;
          n = $rb_minus(other, 1);
          while ($truthy(n['$!='](0))) {
            
            $c = n.$divmod(2), $b = Opal.to_ary($c), (div = ($b[0] == null ? nil : $b[0])), (mod = ($b[1] == null ? nil : $b[1])), $c;
            while (mod['$=='](0)) {
              
              x = self.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
              n = div;
              $d = n.$divmod(2), $c = Opal.to_ary($d), (div = ($c[0] == null ? nil : $c[0])), (mod = ($c[1] == null ? nil : $c[1])), $d;
            };
            z = $rb_times(z, x);
            n = $rb_minus(n, 1);
          };
          return z;
        } else {
          return $rb_divide($$($nesting, 'Rational').$new(1, 1), self)['$**'](other['$-@']())
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_22 = $$($nesting, 'Float')['$==='](other)))) {
        return $ret_or_22
      } else {
        return $$($nesting, 'Rational')['$==='](other)
      }; return nil; })())) {
        
        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        return $$($nesting, 'Complex').$polar(r['$**'](other), $rb_times(theta, other));
      } else {
        return self.$__coerced__("**", other)
      };
    }, $Complex_$$$11.$$arity = 1);
    
    Opal.def(self, '$abs', $Complex_abs$12 = function $$abs() {
      var self = this;

      return $$($nesting, 'Math').$hypot(self.real, self.imag)
    }, $Complex_abs$12.$$arity = 0);
    
    Opal.def(self, '$abs2', $Complex_abs2$13 = function $$abs2() {
      var self = this;

      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))
    }, $Complex_abs2$13.$$arity = 0);
    
    Opal.def(self, '$angle', $Complex_angle$14 = function $$angle() {
      var self = this;

      return $$($nesting, 'Math').$atan2(self.imag, self.real)
    }, $Complex_angle$14.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    
    Opal.def(self, '$conj', $Complex_conj$15 = function $$conj() {
      var self = this;

      return self.$Complex(self.real, self.imag['$-@']())
    }, $Complex_conj$15.$$arity = 0);
    Opal.alias(self, "conjugate", "conj");
    
    Opal.def(self, '$denominator', $Complex_denominator$16 = function $$denominator() {
      var self = this;

      return self.real.$denominator().$lcm(self.imag.$denominator())
    }, $Complex_denominator$16.$$arity = 0);
    Opal.alias(self, "divide", "/");
    
    Opal.def(self, '$eql?', $Complex_eql$ques$17 = function(other) {
      var self = this, $ret_or_23 = nil, $ret_or_24 = nil;

      if ($truthy(($ret_or_23 = (function() {if ($truthy(($ret_or_24 = $$($nesting, 'Complex')['$==='](other)))) {
        return self.real.$class()['$=='](self.imag.$class())
      } else {
        return $ret_or_24
      }; return nil; })()))) {
        return self['$=='](other)
      } else {
        return $ret_or_23
      }
    }, $Complex_eql$ques$17.$$arity = 1);
    
    Opal.def(self, '$fdiv', $Complex_fdiv$18 = function $$fdiv(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Numeric')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      };
      return $rb_divide(self, other);
    }, $Complex_fdiv$18.$$arity = 1);
    
    Opal.def(self, '$finite?', $Complex_finite$ques$19 = function() {
      var self = this, $ret_or_25 = nil;

      if ($truthy(($ret_or_25 = self.real['$finite?']()))) {
        return self.imag['$finite?']()
      } else {
        return $ret_or_25
      }
    }, $Complex_finite$ques$19.$$arity = 0);
    
    Opal.def(self, '$hash', $Complex_hash$20 = function $$hash() {
      var self = this;

      return "" + "Complex:" + (self.real) + ":" + (self.imag)
    }, $Complex_hash$20.$$arity = 0);
    Opal.alias(self, "imaginary", "imag");
    
    Opal.def(self, '$infinite?', $Complex_infinite$ques$21 = function() {
      var self = this, $ret_or_26 = nil;

      if ($truthy(($ret_or_26 = self.real['$infinite?']()))) {
        return $ret_or_26
      } else {
        return self.imag['$infinite?']()
      }
    }, $Complex_infinite$ques$21.$$arity = 0);
    
    Opal.def(self, '$inspect', $Complex_inspect$22 = function $$inspect() {
      var self = this;

      return "" + "(" + (self) + ")"
    }, $Complex_inspect$22.$$arity = 0);
    Opal.alias(self, "magnitude", "abs");
    
    Opal.udef(self, '$' + "negative?");;
    
    Opal.def(self, '$numerator', $Complex_numerator$23 = function $$numerator() {
      var self = this, d = nil;

      
      d = self.$denominator();
      return self.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));
    }, $Complex_numerator$23.$$arity = 0);
    Opal.alias(self, "phase", "arg");
    
    Opal.def(self, '$polar', $Complex_polar$24 = function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, $Complex_polar$24.$$arity = 0);
    
    Opal.udef(self, '$' + "positive?");;
    Opal.alias(self, "quo", "/");
    
    Opal.def(self, '$rationalize', $Complex_rationalize$25 = function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($truthy(self.imag['$!='](0))) {
        self.$raise($$($nesting, 'RangeError'), "" + "can't' convert " + (self) + " into Rational")};
      return self.$real().$rationalize(eps);
    }, $Complex_rationalize$25.$$arity = -1);
    
    Opal.def(self, '$real?', $Complex_real$ques$26 = function() {
      var self = this;

      return false
    }, $Complex_real$ques$26.$$arity = 0);
    
    Opal.def(self, '$rect', $Complex_rect$27 = function $$rect() {
      var self = this;

      return [self.real, self.imag]
    }, $Complex_rect$27.$$arity = 0);
    Opal.alias(self, "rectangular", "rect");
    
    Opal.udef(self, '$' + "step");;
    
    Opal.def(self, '$to_f', $Complex_to_f$28 = function $$to_f() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Float")
      };
      return self.real.$to_f();
    }, $Complex_to_f$28.$$arity = 0);
    
    Opal.def(self, '$to_i', $Complex_to_i$29 = function $$to_i() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Integer")
      };
      return self.real.$to_i();
    }, $Complex_to_i$29.$$arity = 0);
    
    Opal.def(self, '$to_r', $Complex_to_r$30 = function $$to_r() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Rational")
      };
      return self.real.$to_r();
    }, $Complex_to_r$30.$$arity = 0);
    
    Opal.def(self, '$to_s', $Complex_to_s$31 = function $$to_s() {
      var self = this, result = nil, $ret_or_27 = nil, $ret_or_28 = nil, $ret_or_29 = nil, $ret_or_30 = nil, $ret_or_31 = nil;

      
      result = self.real.$inspect();
      result = $rb_plus(result, (function() {if ($truthy((function() {if ($truthy(($ret_or_27 = (function() {if ($truthy(($ret_or_28 = (function() {if ($truthy(($ret_or_29 = $$($nesting, 'Number')['$==='](self.imag)))) {
        return self.imag['$nan?']()
      } else {
        return $ret_or_29
      }; return nil; })()))) {
        return $ret_or_28
      } else {
        return self.imag['$positive?']()
      }; return nil; })()))) {
        return $ret_or_27
      } else {
        return self.imag['$zero?']()
      }; return nil; })())) {
        return "+"
      } else {
        return "-"
      }; return nil; })());
      result = $rb_plus(result, self.imag.$abs().$inspect());
      if ($truthy((function() {if ($truthy(($ret_or_30 = $$($nesting, 'Number')['$==='](self.imag)))) {
        
        if ($truthy(($ret_or_31 = self.imag['$nan?']()))) {
          return $ret_or_31
        } else {
          return self.imag['$infinite?']()
        };
      } else {
        return $ret_or_30
      }; return nil; })())) {
        result = $rb_plus(result, "*")};
      return $rb_plus(result, "i");
    }, $Complex_to_s$31.$$arity = 0);
    return Opal.const_set($nesting[0], 'I', self.$new(0, 1));
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_Complex$32;

    return (Opal.def(self, '$Complex', $Kernel_Complex$32 = function $$Complex(real, imag) {
      var self = this;

      
      
      if (imag == null) {
        imag = nil;
      };
      if ($truthy(imag)) {
        return $$($nesting, 'Complex').$new(real, imag)
      } else {
        return $$($nesting, 'Complex').$new(real, 0)
      };
    }, $Kernel_Complex$32.$$arity = -2), nil) && 'Complex'
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_c$33;

    return (Opal.def(self, '$to_c', $String_to_c$33 = function $$to_c() {
      var self = this;

      
      var str = self,
          re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/,
          match = str.match(re),
          real, imag, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      // handles both floats and rationals
      function cutNumber() {
        if (isFloat()) {
          var numerator = parseFloat(cutFloat());

          if (str[0] === '/') {
            // rational real part
            str = str.slice(1);

            if (isFloat()) {
              var denominator = parseFloat(cutFloat());
              return self.$Rational(numerator, denominator);
            } else {
              // reverting '/'
              str = '/' + str;
              return numerator;
            }
          } else {
            // float real part, no denominator
            return numerator;
          }
        } else {
          return null;
        }
      }

      real = cutNumber();

      if (!real) {
        if (str[0] === 'i') {
          // i => Complex(0, 1)
          return self.$Complex(0, 1);
        }
        if (str[0] === '-' && str[1] === 'i') {
          // -i => Complex(0, -1)
          return self.$Complex(0, -1);
        }
        if (str[0] === '+' && str[1] === 'i') {
          // +i => Complex(0, 1)
          return self.$Complex(0, 1);
        }
        // anything => Complex(0, 0)
        return self.$Complex(0, 0);
      }

      imag = cutNumber();
      if (!imag) {
        if (str[0] === 'i') {
          // 3i => Complex(0, 3)
          return self.$Complex(0, real);
        } else {
          // 3 => Complex(3, 0)
          return self.$Complex(real, 0);
        }
      } else {
        // 3+2i => Complex(3, 2)
        return self.$Complex(real, imag);
      }
    
    }, $String_to_c$33.$$arity = 0), nil) && 'to_c'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/rational"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;

  Opal.add_stubs(['$require', '$to_i', '$==', '$raise', '$<', '$-@', '$new', '$gcd', '$/', '$nil?', '$===', '$reduce', '$to_r', '$equal?', '$!', '$coerce_to!', '$to_f', '$numerator', '$denominator', '$<=>', '$-', '$*', '$__coerced__', '$+', '$Rational', '$>', '$**', '$abs', '$ceil', '$with_precision', '$floor', '$<=', '$truncate', '$send', '$convert']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Rational');

    var $nesting = [self].concat($parent_nesting), $Rational_reduce$1, $Rational_convert$2, $Rational_initialize$3, $Rational_numerator$4, $Rational_denominator$5, $Rational_coerce$6, $Rational_$eq_eq$7, $Rational_$lt_eq_gt$8, $Rational_$plus$9, $Rational_$minus$10, $Rational_$$11, $Rational_$slash$12, $Rational_$$$13, $Rational_abs$14, $Rational_ceil$15, $Rational_floor$16, $Rational_hash$17, $Rational_inspect$18, $Rational_rationalize$19, $Rational_round$20, $Rational_to_f$21, $Rational_to_i$22, $Rational_to_r$23, $Rational_to_s$24, $Rational_truncate$25, $Rational_with_precision$26;

    self.$$prototype.num = self.$$prototype.den = nil;
    
    Opal.defs(self, '$reduce', $Rational_reduce$1 = function $$reduce(num, den) {
      var self = this, gcd = nil;

      
      num = num.$to_i();
      den = den.$to_i();
      if (den['$=='](0)) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      } else if ($truthy($rb_lt(den, 0))) {
        
        num = num['$-@']();
        den = den['$-@']();
      } else if (den['$=='](1)) {
        return self.$new(num, den)};
      gcd = num.$gcd(den);
      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
    }, $Rational_reduce$1.$$arity = 2);
    Opal.defs(self, '$convert', $Rational_convert$2 = function $$convert(num, den) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil, $ret_or_7 = nil, $ret_or_8 = nil;

      
      if ($truthy((function() {if ($truthy(($ret_or_1 = num['$nil?']()))) {
        return $ret_or_1
      } else {
        return den['$nil?']()
      }; return nil; })())) {
        self.$raise($$($nesting, 'TypeError'), "cannot convert nil into Rational")};
      if ($truthy((function() {if ($truthy(($ret_or_2 = $$($nesting, 'Integer')['$==='](num)))) {
        return $$($nesting, 'Integer')['$==='](den)
      } else {
        return $ret_or_2
      }; return nil; })())) {
        return self.$reduce(num, den)};
      if ($truthy((function() {if ($truthy(($ret_or_3 = (function() {if ($truthy(($ret_or_4 = $$($nesting, 'Float')['$==='](num)))) {
        return $ret_or_4
      } else {
        return $$($nesting, 'String')['$==='](num)
      }; return nil; })()))) {
        return $ret_or_3
      } else {
        return $$($nesting, 'Complex')['$==='](num)
      }; return nil; })())) {
        num = num.$to_r()};
      if ($truthy((function() {if ($truthy(($ret_or_5 = (function() {if ($truthy(($ret_or_6 = $$($nesting, 'Float')['$==='](den)))) {
        return $ret_or_6
      } else {
        return $$($nesting, 'String')['$==='](den)
      }; return nil; })()))) {
        return $ret_or_5
      } else {
        return $$($nesting, 'Complex')['$==='](den)
      }; return nil; })())) {
        den = den.$to_r()};
      if ($truthy((function() {if ($truthy(($ret_or_7 = den['$equal?'](1)))) {
        return $$($nesting, 'Integer')['$==='](num)['$!']()
      } else {
        return $ret_or_7
      }; return nil; })())) {
        return $$($nesting, 'Opal')['$coerce_to!'](num, $$($nesting, 'Rational'), "to_r")
      } else if ($truthy((function() {if ($truthy(($ret_or_8 = $$($nesting, 'Numeric')['$==='](num)))) {
        return $$($nesting, 'Numeric')['$==='](den)
      } else {
        return $ret_or_8
      }; return nil; })())) {
        return $rb_divide(num, den)
      } else {
        return self.$reduce(num, den)
      };
    }, $Rational_convert$2.$$arity = 2);
    
    Opal.def(self, '$initialize', $Rational_initialize$3 = function $$initialize(num, den) {
      var self = this;

      
      self.num = num;
      return (self.den = den);
    }, $Rational_initialize$3.$$arity = 2);
    
    Opal.def(self, '$numerator', $Rational_numerator$4 = function $$numerator() {
      var self = this;

      return self.num
    }, $Rational_numerator$4.$$arity = 0);
    
    Opal.def(self, '$denominator', $Rational_denominator$5 = function $$denominator() {
      var self = this;

      return self.den
    }, $Rational_denominator$5.$$arity = 0);
    
    Opal.def(self, '$coerce', $Rational_coerce$6 = function $$coerce(other) {
      var self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {return [other, self]}
      else if ($$($nesting, 'Integer')['$===']($case)) {return [other.$to_r(), self]}
      else if ($$($nesting, 'Float')['$===']($case)) {return [other, self.$to_f()]}
      else { return nil }})()
    }, $Rational_coerce$6.$$arity = 1);
    
    Opal.def(self, '$==', $Rational_$eq_eq$7 = function(other) {
      var self = this, $case = nil, $ret_or_9 = nil, $ret_or_10 = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {if ($truthy(($ret_or_9 = self.num['$=='](other.$numerator())))) {
        return self.den['$=='](other.$denominator())
      } else {
        return $ret_or_9
      }}
      else if ($$($nesting, 'Integer')['$===']($case)) {if ($truthy(($ret_or_10 = self.num['$=='](other)))) {
        return self.den['$=='](1)
      } else {
        return $ret_or_10
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$=='](other)}
      else {return other['$=='](self)}})()
    }, $Rational_$eq_eq$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Rational_$lt_eq_gt$8 = function(other) {
      var self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)}
      else if ($$($nesting, 'Integer')['$===']($case)) {return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$<=>'](other)}
      else {return self.$__coerced__("<=>", other)}})()
    }, $Rational_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$+', $Rational_$plus$9 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_plus(self.$to_f(), other)}
      else {return self.$__coerced__("+", other)}})()
    }, $Rational_$plus$9.$$arity = 1);
    
    Opal.def(self, '$-', $Rational_$minus$10 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_minus(self.$to_f(), other)}
      else {return self.$__coerced__("-", other)}})()
    }, $Rational_$minus$10.$$arity = 1);
    
    Opal.def(self, '$*', $Rational_$$11 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_times(self.num, other.$numerator());
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_times(self.num, other), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_times(self.$to_f(), other)}
      else {return self.$__coerced__("*", other)}})()
    }, $Rational_$$11.$$arity = 1);
    
    Opal.def(self, '$/', $Rational_$slash$12 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_times(self.num, other.$denominator());
      den = $rb_times(self.den, other.$numerator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {if (other['$=='](0)) {
        return $rb_divide(self.$to_f(), 0.0)
      } else {
        return self.$Rational(self.num, $rb_times(self.den, other))
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_divide(self.$to_f(), other)}
      else {return self.$__coerced__("/", other)}})()
    }, $Rational_$slash$12.$$arity = 1);
    
    Opal.def(self, '$**', $Rational_$$$13 = function(other) {
      var self = this, $case = nil, $ret_or_11 = nil, $ret_or_12 = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Integer')['$===']($case)) {if ($truthy((function() {if ($truthy(($ret_or_11 = self['$=='](0)))) {
        return $rb_lt(other, 0)
      } else {
        return $ret_or_11
      }; return nil; })())) {
        return $$$($$($nesting, 'Float'), 'INFINITY')
      } else if ($truthy($rb_gt(other, 0))) {
        return self.$Rational(self.num['$**'](other), self.den['$**'](other))
      } else if ($truthy($rb_lt(other, 0))) {
        return self.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))
      } else {
        return self.$Rational(1, 1)
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$**'](other)}
      else if ($$($nesting, 'Rational')['$===']($case)) {if (other['$=='](0)) {
        return self.$Rational(1, 1)
      } else if (other.$denominator()['$=='](1)) {
        if ($truthy($rb_lt(other, 0))) {
          return self.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))
        } else {
          return self.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_12 = self['$=='](0)))) {
        return $rb_lt(other, 0)
      } else {
        return $ret_or_12
      }; return nil; })())) {
        return self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      } else {
        return self.$to_f()['$**'](other)
      }}
      else {return self.$__coerced__("**", other)}})()
    }, $Rational_$$$13.$$arity = 1);
    
    Opal.def(self, '$abs', $Rational_abs$14 = function $$abs() {
      var self = this;

      return self.$Rational(self.num.$abs(), self.den.$abs())
    }, $Rational_abs$14.$$arity = 0);
    
    Opal.def(self, '$ceil', $Rational_ceil$15 = function $$ceil(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()
      } else {
        return self.$with_precision("ceil", precision)
      };
    }, $Rational_ceil$15.$$arity = -1);
    Opal.alias(self, "divide", "/");
    
    Opal.def(self, '$floor', $Rational_floor$16 = function $$floor(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()
      } else {
        return self.$with_precision("floor", precision)
      };
    }, $Rational_floor$16.$$arity = -1);
    
    Opal.def(self, '$hash', $Rational_hash$17 = function $$hash() {
      var self = this;

      return "" + "Rational:" + (self.num) + ":" + (self.den)
    }, $Rational_hash$17.$$arity = 0);
    
    Opal.def(self, '$inspect', $Rational_inspect$18 = function $$inspect() {
      var self = this;

      return "" + "(" + (self) + ")"
    }, $Rational_inspect$18.$$arity = 0);
    Opal.alias(self, "quo", "/");
    
    Opal.def(self, '$rationalize', $Rational_rationalize$19 = function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }

      if (eps == null) {
        return self;
      }

      var e = eps.$abs(),
          a = $rb_minus(self, e),
          b = $rb_plus(self, e);

      var p0 = 0,
          p1 = 1,
          q0 = 1,
          q1 = 0,
          p2, q2;

      var c, k, t;

      while (true) {
        c = (a).$ceil();

        if ($rb_le(c, b)) {
          break;
        }

        k  = c - 1;
        p2 = k * p1 + p0;
        q2 = k * q1 + q0;
        t  = $rb_divide(1, $rb_minus(b, k));
        b  = $rb_divide(1, $rb_minus(a, k));
        a  = t;

        p0 = p1;
        q0 = q1;
        p1 = p2;
        q1 = q2;
      }

      return self.$Rational(c * p1 + p0, c * q1 + q0);
    ;
    }, $Rational_rationalize$19.$$arity = -1);
    
    Opal.def(self, '$round', $Rational_round$20 = function $$round(precision) {
      var self = this, num = nil, den = nil, approx = nil;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
      } else {
        return self.$with_precision("round", precision)
      };
      if (self.num['$=='](0)) {
        return 0};
      if (self.den['$=='](1)) {
        return self.num};
      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
      den = $rb_times(self.den, 2);
      approx = $rb_divide(num, den).$truncate();
      if ($truthy($rb_lt(self.num, 0))) {
        return approx['$-@']()
      } else {
        return approx
      };
    }, $Rational_round$20.$$arity = -1);
    
    Opal.def(self, '$to_f', $Rational_to_f$21 = function $$to_f() {
      var self = this;

      return $rb_divide(self.num, self.den)
    }, $Rational_to_f$21.$$arity = 0);
    
    Opal.def(self, '$to_i', $Rational_to_i$22 = function $$to_i() {
      var self = this;

      return self.$truncate()
    }, $Rational_to_i$22.$$arity = 0);
    
    Opal.def(self, '$to_r', $Rational_to_r$23 = function $$to_r() {
      var self = this;

      return self
    }, $Rational_to_r$23.$$arity = 0);
    
    Opal.def(self, '$to_s', $Rational_to_s$24 = function $$to_s() {
      var self = this;

      return "" + (self.num) + "/" + (self.den)
    }, $Rational_to_s$24.$$arity = 0);
    
    Opal.def(self, '$truncate', $Rational_truncate$25 = function $$truncate(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        if ($truthy($rb_lt(self.num, 0))) {
          return self.$ceil()
        } else {
          return self.$floor()
        }
      } else {
        return self.$with_precision("truncate", precision)
      };
    }, $Rational_truncate$25.$$arity = -1);
    return (Opal.def(self, '$with_precision', $Rational_with_precision$26 = function $$with_precision(method, precision) {
      var self = this, p = nil, s = nil;

      
      if ($truthy($$($nesting, 'Integer')['$==='](precision))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an Integer")
      };
      p = (10)['$**'](precision);
      s = $rb_times(self, p);
      if ($truthy($rb_lt(precision, 1))) {
        return $rb_divide(s.$send(method), p).$to_i()
      } else {
        return self.$Rational(s.$send(method), p)
      };
    }, $Rational_with_precision$26.$$arity = 2), nil) && 'with_precision';
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_Rational$27;

    return (Opal.def(self, '$Rational', $Kernel_Rational$27 = function $$Rational(numerator, denominator) {
      var self = this;

      
      
      if (denominator == null) {
        denominator = 1;
      };
      return $$($nesting, 'Rational').$convert(numerator, denominator);
    }, $Kernel_Rational$27.$$arity = -2), nil) && 'Rational'
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_r$28;

    return (Opal.def(self, '$to_r', $String_to_r$28 = function $$to_r() {
      var self = this;

      
      var str = self.trimLeft(),
          re = /^[+-]?[\d_]+(\.[\d_]+)?/,
          match = str.match(re),
          numerator, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      if (isFloat()) {
        numerator = parseFloat(cutFloat());

        if (str[0] === '/') {
          // rational real part
          str = str.slice(1);

          if (isFloat()) {
            denominator = parseFloat(cutFloat());
            return self.$Rational(numerator, denominator);
          } else {
            return self.$Rational(numerator, 1);
          }
        } else {
          return self.$Rational(numerator, 1);
        }
      } else {
        return self.$Rational(0, 1);
      }
    
    }, $String_to_r$28.$$arity = 0), nil) && 'to_r'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/time"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range;

  Opal.add_stubs(['$require', '$include', '$===', '$raise', '$coerce_to!', '$respond_to?', '$to_str', '$to_i', '$new', '$<=>', '$to_f', '$nil?', '$>', '$<', '$strftime', '$year', '$month', '$day', '$+', '$round', '$/', '$-', '$copy_instance_variables', '$initialize_dup', '$is_a?', '$zero?', '$wday', '$utc?', '$mon', '$yday', '$hour', '$min', '$sec', '$rjust', '$ljust', '$zone', '$to_s', '$[]', '$cweek_cyear', '$isdst', '$<=', '$!=', '$==', '$ceil']);
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $Time_at$1, $Time_new$2, $Time_local$3, $Time_gm$4, $Time_now$5, $Time_$plus$6, $Time_$minus$7, $Time_$lt_eq_gt$8, $Time_$eq_eq$9, $Time_asctime$10, $Time_day$11, $Time_yday$12, $Time_isdst$13, $Time_dup$14, $Time_eql$ques$15, $Time_friday$ques$16, $Time_hash$17, $Time_hour$18, $Time_inspect$19, $Time_min$20, $Time_mon$21, $Time_monday$ques$22, $Time_saturday$ques$23, $Time_sec$24, $Time_succ$25, $Time_usec$26, $Time_zone$27, $Time_getgm$28, $Time_gmtime$29, $Time_gmt$ques$30, $Time_gmt_offset$31, $Time_strftime$32, $Time_sunday$ques$33, $Time_thursday$ques$34, $Time_to_a$35, $Time_to_f$36, $Time_to_i$37, $Time_tuesday$ques$38, $Time_wday$39, $Time_wednesday$ques$40, $Time_year$41, $Time_cweek_cyear$42;

    
    self.$include($$($nesting, 'Comparable'));
    
    var days_of_week = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        short_days   = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        short_months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        long_months  = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  ;
    Opal.defs(self, '$at', $Time_at$1 = function $$at(seconds, frac) {
      var self = this;

      
      ;
      
      var result;

      if ($$($nesting, 'Time')['$==='](seconds)) {
        if (frac !== undefined) {
          self.$raise($$($nesting, 'TypeError'), "can't convert Time into an exact number")
        }
        result = new Date(seconds.getTime());
        result.is_utc = seconds.is_utc;
        return result;
      }

      if (!seconds.$$is_number) {
        seconds = $$($nesting, 'Opal')['$coerce_to!'](seconds, $$($nesting, 'Integer'), "to_int");
      }

      if (frac === undefined) {
        return new Date(seconds * 1000);
      }

      if (!frac.$$is_number) {
        frac = $$($nesting, 'Opal')['$coerce_to!'](frac, $$($nesting, 'Integer'), "to_int");
      }

      return new Date(seconds * 1000 + (frac / 1000));
    ;
    }, $Time_at$1.$$arity = -2);
    
    function time_params(year, month, day, hour, min, sec) {
      if (year.$$is_string) {
        year = parseInt(year, 10);
      } else {
        year = $$($nesting, 'Opal')['$coerce_to!'](year, $$($nesting, 'Integer'), "to_int");
      }

      if (month === nil) {
        month = 1;
      } else if (!month.$$is_number) {
        if ((month)['$respond_to?']("to_str")) {
          month = (month).$to_str();
          switch (month.toLowerCase()) {
          case 'jan': month =  1; break;
          case 'feb': month =  2; break;
          case 'mar': month =  3; break;
          case 'apr': month =  4; break;
          case 'may': month =  5; break;
          case 'jun': month =  6; break;
          case 'jul': month =  7; break;
          case 'aug': month =  8; break;
          case 'sep': month =  9; break;
          case 'oct': month = 10; break;
          case 'nov': month = 11; break;
          case 'dec': month = 12; break;
          default: month = (month).$to_i();
          }
        } else {
          month = $$($nesting, 'Opal')['$coerce_to!'](month, $$($nesting, 'Integer'), "to_int");
        }
      }

      if (month < 1 || month > 12) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "month out of range: " + (month))
      }
      month = month - 1;

      if (day === nil) {
        day = 1;
      } else if (day.$$is_string) {
        day = parseInt(day, 10);
      } else {
        day = $$($nesting, 'Opal')['$coerce_to!'](day, $$($nesting, 'Integer'), "to_int");
      }

      if (day < 1 || day > 31) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "day out of range: " + (day))
      }

      if (hour === nil) {
        hour = 0;
      } else if (hour.$$is_string) {
        hour = parseInt(hour, 10);
      } else {
        hour = $$($nesting, 'Opal')['$coerce_to!'](hour, $$($nesting, 'Integer'), "to_int");
      }

      if (hour < 0 || hour > 24) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "hour out of range: " + (hour))
      }

      if (min === nil) {
        min = 0;
      } else if (min.$$is_string) {
        min = parseInt(min, 10);
      } else {
        min = $$($nesting, 'Opal')['$coerce_to!'](min, $$($nesting, 'Integer'), "to_int");
      }

      if (min < 0 || min > 59) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "min out of range: " + (min))
      }

      if (sec === nil) {
        sec = 0;
      } else if (!sec.$$is_number) {
        if (sec.$$is_string) {
          sec = parseInt(sec, 10);
        } else {
          sec = $$($nesting, 'Opal')['$coerce_to!'](sec, $$($nesting, 'Integer'), "to_int");
        }
      }

      if (sec < 0 || sec > 60) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "sec out of range: " + (sec))
      }

      return [year, month, day, hour, min, sec];
    }
  ;
    Opal.defs(self, '$new', $Time_new$2 = function(year, month, day, hour, min, sec, utc_offset) {
      var self = this;

      
      ;
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (utc_offset == null) {
        utc_offset = nil;
      };
      
      var args, result;

      if (year === undefined) {
        return new Date();
      }

      if (utc_offset !== nil) {
        self.$raise($$($nesting, 'ArgumentError'), "Opal does not support explicitly specifying UTC offset for Time")
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, $Time_new$2.$$arity = -1);
    Opal.defs(self, '$local', $Time_local$3 = function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      var self = this;

      
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (millisecond == null) {
        millisecond = nil;
      };
      
      if (_dummy1 == null) {
        _dummy1 = nil;
      };
      
      if (_dummy2 == null) {
        _dummy2 = nil;
      };
      
      if (_dummy3 == null) {
        _dummy3 = nil;
      };
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, $Time_local$3.$$arity = -2);
    Opal.defs(self, '$gm', $Time_gm$4 = function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      var self = this;

      
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (millisecond == null) {
        millisecond = nil;
      };
      
      if (_dummy1 == null) {
        _dummy1 = nil;
      };
      
      if (_dummy2 == null) {
        _dummy2 = nil;
      };
      
      if (_dummy3 == null) {
        _dummy3 = nil;
      };
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        result.setUTCFullYear(year);
      }
      result.is_utc = true;
      return result;
    ;
    }, $Time_gm$4.$$arity = -2);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      
      Opal.alias(self, "mktime", "local");
      return Opal.alias(self, "utc", "gm");
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(self, '$now', $Time_now$5 = function $$now() {
      var self = this;

      return self.$new()
    }, $Time_now$5.$$arity = 0);
    
    Opal.def(self, '$+', $Time_$plus$6 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        self.$raise($$($nesting, 'TypeError'), "time + time?")};
      
      if (!other.$$is_number) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), "to_int");
      }
      var result = new Date(self.getTime() + (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, $Time_$plus$6.$$arity = 1);
    
    Opal.def(self, '$-', $Time_$minus$7 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        return (self.getTime() - other.getTime()) / 1000};
      
      if (!other.$$is_number) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), "to_int");
      }
      var result = new Date(self.getTime() - (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, $Time_$minus$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Time_$lt_eq_gt$8 = function(other) {
      var self = this, r = nil;

      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        return self.$to_f()['$<=>'](other.$to_f())
      } else {
        
        r = other['$<=>'](self);
        if ($truthy(r['$nil?']())) {
          return nil
        } else if ($truthy($rb_gt(r, 0))) {
          return -1
        } else if ($truthy($rb_lt(r, 0))) {
          return 1
        } else {
          return 0
        };
      }
    }, $Time_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$==', $Time_$eq_eq$9 = function(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $$($nesting, 'Time')['$==='](other)))) {
        return self.$to_f() === other.$to_f()
      } else {
        return $ret_or_1
      }
    }, $Time_$eq_eq$9.$$arity = 1);
    
    Opal.def(self, '$asctime', $Time_asctime$10 = function $$asctime() {
      var self = this;

      return self.$strftime("%a %b %e %H:%M:%S %Y")
    }, $Time_asctime$10.$$arity = 0);
    Opal.alias(self, "ctime", "asctime");
    
    Opal.def(self, '$day', $Time_day$11 = function $$day() {
      var self = this;

      return self.is_utc ? self.getUTCDate() : self.getDate();
    }, $Time_day$11.$$arity = 0);
    
    Opal.def(self, '$yday', $Time_yday$12 = function $$yday() {
      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;

      
      start_of_year = $$($nesting, 'Time').$new(self.$year()).$to_i();
      start_of_day = $$($nesting, 'Time').$new(self.$year(), self.$month(), self.$day()).$to_i();
      one_day = 86400;
      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
    }, $Time_yday$12.$$arity = 0);
    
    Opal.def(self, '$isdst', $Time_isdst$13 = function $$isdst() {
      var self = this;

      
      var jan = new Date(self.getFullYear(), 0, 1),
          jul = new Date(self.getFullYear(), 6, 1);
      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    
    }, $Time_isdst$13.$$arity = 0);
    Opal.alias(self, "dst?", "isdst");
    
    Opal.def(self, '$dup', $Time_dup$14 = function $$dup() {
      var self = this, copy = nil;

      
      copy = new Date(self.getTime());
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, $Time_dup$14.$$arity = 0);
    
    Opal.def(self, '$eql?', $Time_eql$ques$15 = function(other) {
      var self = this, $ret_or_2 = nil;

      if ($truthy(($ret_or_2 = other['$is_a?']($$($nesting, 'Time'))))) {
        return self['$<=>'](other)['$zero?']()
      } else {
        return $ret_or_2
      }
    }, $Time_eql$ques$15.$$arity = 1);
    
    Opal.def(self, '$friday?', $Time_friday$ques$16 = function() {
      var self = this;

      return self.$wday() == 5
    }, $Time_friday$ques$16.$$arity = 0);
    
    Opal.def(self, '$hash', $Time_hash$17 = function $$hash() {
      var self = this;

      return 'Time:' + self.getTime();
    }, $Time_hash$17.$$arity = 0);
    
    Opal.def(self, '$hour', $Time_hour$18 = function $$hour() {
      var self = this;

      return self.is_utc ? self.getUTCHours() : self.getHours();
    }, $Time_hour$18.$$arity = 0);
    
    Opal.def(self, '$inspect', $Time_inspect$19 = function $$inspect() {
      var self = this;

      if ($truthy(self['$utc?']())) {
        return self.$strftime("%Y-%m-%d %H:%M:%S UTC")
      } else {
        return self.$strftime("%Y-%m-%d %H:%M:%S %z")
      }
    }, $Time_inspect$19.$$arity = 0);
    Opal.alias(self, "mday", "day");
    
    Opal.def(self, '$min', $Time_min$20 = function $$min() {
      var self = this;

      return self.is_utc ? self.getUTCMinutes() : self.getMinutes();
    }, $Time_min$20.$$arity = 0);
    
    Opal.def(self, '$mon', $Time_mon$21 = function $$mon() {
      var self = this;

      return (self.is_utc ? self.getUTCMonth() : self.getMonth()) + 1;
    }, $Time_mon$21.$$arity = 0);
    
    Opal.def(self, '$monday?', $Time_monday$ques$22 = function() {
      var self = this;

      return self.$wday() == 1
    }, $Time_monday$ques$22.$$arity = 0);
    Opal.alias(self, "month", "mon");
    
    Opal.def(self, '$saturday?', $Time_saturday$ques$23 = function() {
      var self = this;

      return self.$wday() == 6
    }, $Time_saturday$ques$23.$$arity = 0);
    
    Opal.def(self, '$sec', $Time_sec$24 = function $$sec() {
      var self = this;

      return self.is_utc ? self.getUTCSeconds() : self.getSeconds();
    }, $Time_sec$24.$$arity = 0);
    
    Opal.def(self, '$succ', $Time_succ$25 = function $$succ() {
      var self = this;

      
      var result = new Date(self.getTime() + 1000);
      result.is_utc = self.is_utc;
      return result;
    
    }, $Time_succ$25.$$arity = 0);
    
    Opal.def(self, '$usec', $Time_usec$26 = function $$usec() {
      var self = this;

      return self.getMilliseconds() * 1000;
    }, $Time_usec$26.$$arity = 0);
    
    Opal.def(self, '$zone', $Time_zone$27 = function $$zone() {
      var self = this;

      
      var string = self.toString(),
          result;

      if (string.indexOf('(') == -1) {
        result = string.match(/[A-Z]{3,4}/)[0];
      }
      else {
        result = string.match(/\((.+)\)(?:\s|$)/)[1]
      }

      if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
        return RegExp.$1;
      }
      else {
        return result;
      }
    
    }, $Time_zone$27.$$arity = 0);
    
    Opal.def(self, '$getgm', $Time_getgm$28 = function $$getgm() {
      var self = this;

      
      var result = new Date(self.getTime());
      result.is_utc = true;
      return result;
    
    }, $Time_getgm$28.$$arity = 0);
    Opal.alias(self, "getutc", "getgm");
    
    Opal.def(self, '$gmtime', $Time_gmtime$29 = function $$gmtime() {
      var self = this;

      
      self.is_utc = true;
      return self;
    
    }, $Time_gmtime$29.$$arity = 0);
    Opal.alias(self, "utc", "gmtime");
    
    Opal.def(self, '$gmt?', $Time_gmt$ques$30 = function() {
      var self = this;

      return self.is_utc === true;
    }, $Time_gmt$ques$30.$$arity = 0);
    
    Opal.def(self, '$gmt_offset', $Time_gmt_offset$31 = function $$gmt_offset() {
      var self = this;

      return self.is_utc ? 0 : -self.getTimezoneOffset() * 60;
    }, $Time_gmt_offset$31.$$arity = 0);
    
    Opal.def(self, '$strftime', $Time_strftime$32 = function $$strftime(format) {
      var self = this;

      
      return format.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
        var result = "",
            zero   = flags.indexOf('0') !== -1,
            pad    = flags.indexOf('-') === -1,
            blank  = flags.indexOf('_') !== -1,
            upcase = flags.indexOf('^') !== -1,
            invert = flags.indexOf('#') !== -1,
            colons = (flags.match(':') || []).length;

        width = parseInt(width, 10);

        if (zero && blank) {
          if (flags.indexOf('0') < flags.indexOf('_')) {
            zero = false;
          }
          else {
            blank = false;
          }
        }

        switch (conv) {
          case 'Y':
            result += self.$year();
            break;

          case 'C':
            zero    = !blank;
            result += Math.round(self.$year() / 100);
            break;

          case 'y':
            zero    = !blank;
            result += (self.$year() % 100);
            break;

          case 'm':
            zero    = !blank;
            result += self.$mon();
            break;

          case 'B':
            result += long_months[self.$mon() - 1];
            break;

          case 'b':
          case 'h':
            blank   = !zero;
            result += short_months[self.$mon() - 1];
            break;

          case 'd':
            zero    = !blank
            result += self.$day();
            break;

          case 'e':
            blank   = !zero
            result += self.$day();
            break;

          case 'j':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.$yday();
            break;

          case 'H':
            zero    = !blank;
            result += self.$hour();
            break;

          case 'k':
            blank   = !zero;
            result += self.$hour();
            break;

          case 'I':
            zero    = !blank;
            result += (self.$hour() % 12 || 12);
            break;

          case 'l':
            blank   = !zero;
            result += (self.$hour() % 12 || 12);
            break;

          case 'P':
            result += (self.$hour() >= 12 ? "pm" : "am");
            break;

          case 'p':
            result += (self.$hour() >= 12 ? "PM" : "AM");
            break;

          case 'M':
            zero    = !blank;
            result += self.$min();
            break;

          case 'S':
            zero    = !blank;
            result += self.$sec()
            break;

          case 'L':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.getMilliseconds();
            break;

          case 'N':
            width   = isNaN(width) ? 9 : width;
            result += (self.getMilliseconds().toString()).$rjust(3, "0");
            result  = (result).$ljust(width, "0");
            break;

          case 'z':
            var offset  = self.getTimezoneOffset(),
                hours   = Math.floor(Math.abs(offset) / 60),
                minutes = Math.abs(offset) % 60;

            result += offset < 0 ? "+" : "-";
            result += hours < 10 ? "0" : "";
            result += hours;

            if (colons > 0) {
              result += ":";
            }

            result += minutes < 10 ? "0" : "";
            result += minutes;

            if (colons > 1) {
              result += ":00";
            }

            break;

          case 'Z':
            result += self.$zone();
            break;

          case 'A':
            result += days_of_week[self.$wday()];
            break;

          case 'a':
            result += short_days[self.$wday()];
            break;

          case 'u':
            result += (self.$wday() + 1);
            break;

          case 'w':
            result += self.$wday();
            break;

          case 'V':
            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, "0");
            break;

          case 'G':
            result += self.$cweek_cyear()['$[]'](1);
            break;

          case 'g':
            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));
            break;

          case 's':
            result += self.$to_i();
            break;

          case 'n':
            result += "\n";
            break;

          case 't':
            result += "\t";
            break;

          case '%':
            result += "%";
            break;

          case 'c':
            result += self.$strftime("%a %b %e %T %Y");
            break;

          case 'D':
          case 'x':
            result += self.$strftime("%m/%d/%y");
            break;

          case 'F':
            result += self.$strftime("%Y-%m-%d");
            break;

          case 'v':
            result += self.$strftime("%e-%^b-%4Y");
            break;

          case 'r':
            result += self.$strftime("%I:%M:%S %p");
            break;

          case 'R':
            result += self.$strftime("%H:%M");
            break;

          case 'T':
          case 'X':
            result += self.$strftime("%H:%M:%S");
            break;

          default:
            return full;
        }

        if (upcase) {
          result = result.toUpperCase();
        }

        if (invert) {
          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).
                          replace(/[a-z]/, function(c) { c.toUpperCase() });
        }

        if (pad && (zero || blank)) {
          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
        }

        return result;
      });
    
    }, $Time_strftime$32.$$arity = 1);
    
    Opal.def(self, '$sunday?', $Time_sunday$ques$33 = function() {
      var self = this;

      return self.$wday() == 0
    }, $Time_sunday$ques$33.$$arity = 0);
    
    Opal.def(self, '$thursday?', $Time_thursday$ques$34 = function() {
      var self = this;

      return self.$wday() == 4
    }, $Time_thursday$ques$34.$$arity = 0);
    
    Opal.def(self, '$to_a', $Time_to_a$35 = function $$to_a() {
      var self = this;

      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]
    }, $Time_to_a$35.$$arity = 0);
    
    Opal.def(self, '$to_f', $Time_to_f$36 = function $$to_f() {
      var self = this;

      return self.getTime() / 1000;
    }, $Time_to_f$36.$$arity = 0);
    
    Opal.def(self, '$to_i', $Time_to_i$37 = function $$to_i() {
      var self = this;

      return parseInt(self.getTime() / 1000, 10);
    }, $Time_to_i$37.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$tuesday?', $Time_tuesday$ques$38 = function() {
      var self = this;

      return self.$wday() == 2
    }, $Time_tuesday$ques$38.$$arity = 0);
    Opal.alias(self, "tv_sec", "to_i");
    Opal.alias(self, "tv_usec", "usec");
    Opal.alias(self, "utc?", "gmt?");
    Opal.alias(self, "gmtoff", "gmt_offset");
    Opal.alias(self, "utc_offset", "gmt_offset");
    
    Opal.def(self, '$wday', $Time_wday$39 = function $$wday() {
      var self = this;

      return self.is_utc ? self.getUTCDay() : self.getDay();
    }, $Time_wday$39.$$arity = 0);
    
    Opal.def(self, '$wednesday?', $Time_wednesday$ques$40 = function() {
      var self = this;

      return self.$wday() == 3
    }, $Time_wednesday$ques$40.$$arity = 0);
    
    Opal.def(self, '$year', $Time_year$41 = function $$year() {
      var self = this;

      return self.is_utc ? self.getUTCFullYear() : self.getFullYear();
    }, $Time_year$41.$$arity = 0);
    return (Opal.def(self, '$cweek_cyear', $Time_cweek_cyear$42 = function $$cweek_cyear() {
      var self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, $ret_or_3 = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil, $ret_or_4 = nil;

      
      jan01 = $$($nesting, 'Time').$new(self.$year(), 1, 1);
      jan01_wday = jan01.$wday();
      first_monday = 0;
      year = self.$year();
      if ($truthy((function() {if ($truthy(($ret_or_3 = $rb_le(jan01_wday, 4)))) {
        return jan01_wday['$!='](0)
      } else {
        return $ret_or_3
      }; return nil; })())) {
        offset = $rb_minus(jan01_wday, 1)
      } else {
        
        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
        if (offset['$=='](-8)) {
          offset = -1};
      };
      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
      if ($truthy($rb_le(week, 0))) {
        return $$($nesting, 'Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()
      } else if (week['$=='](53)) {
        
        dec31 = $$($nesting, 'Time').$new(self.$year(), 12, 31);
        dec31_wday = dec31.$wday();
        if ($truthy((function() {if ($truthy(($ret_or_4 = $rb_le(dec31_wday, 3)))) {
          return dec31_wday['$!='](0)
        } else {
          return $ret_or_4
        }; return nil; })())) {
          
          week = 1;
          year = $rb_plus(year, 1);};};
      return [week, year];
    }, $Time_cweek_cyear$42.$$arity = 0), nil) && 'cweek_cyear';
  })($nesting[0], Date, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/struct"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$const_name!', '$unshift', '$map', '$coerce_to!', '$new', '$each', '$define_struct_attribute', '$allocate', '$initialize', '$alias_method', '$module_eval', '$to_proc', '$const_set', '$==', '$raise', '$<<', '$members', '$define_method', '$instance_eval', '$class', '$last', '$>', '$length', '$-', '$keys', '$any?', '$join', '$[]', '$[]=', '$each_with_index', '$hash', '$===', '$<', '$-@', '$size', '$>=', '$include?', '$to_sym', '$instance_of?', '$__id__', '$eql?', '$enum_for', '$name', '$+', '$each_pair', '$inspect', '$to_h', '$args', '$each_with_object', '$flatten', '$to_a', '$respond_to?', '$dig']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $Struct_new$1, $Struct_define_struct_attribute$6, $Struct_members$9, $Struct_inherited$10, $Struct_initialize$12, $Struct_initialize_copy$15, $Struct_members$16, $Struct_hash$17, $Struct_$$$18, $Struct_$$$eq$19, $Struct_$eq_eq$20, $Struct_eql$ques$21, $Struct_each$22, $Struct_each_pair$25, $Struct_length$28, $Struct_to_a$29, $Struct_inspect$31, $Struct_to_h$33, $Struct_values_at$35, $Struct_dig$37;

    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defs(self, '$new', $Struct_new$1 = function(const_name, $a, $b) {
      var $iter = $Struct_new$1.$$p, block = $iter || nil, $post_args, $kwargs, args, keyword_init, $$2, $$3, self = this, klass = nil;

      if ($iter) $Struct_new$1.$$p = null;
      
      
      if ($iter) $Struct_new$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      args = $post_args;;
      
      keyword_init = $kwargs.$$smap["keyword_init"];
      if (keyword_init == null) {
        keyword_init = false
      };
      if ($truthy(const_name)) {
        
        try {
          const_name = $$($nesting, 'Opal')['$const_name!'](const_name)
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'TypeError'), $$($nesting, 'NameError')])) {
            try {
              
              args.$unshift(const_name);
              const_name = nil;
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };};
      $send(args, 'map', [], ($$2 = function(arg){var self = $$2.$$s == null ? this : $$2.$$s;

      
        
        if (arg == null) {
          arg = nil;
        };
        return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'String'), "to_str");}, $$2.$$s = self, $$2.$$arity = 1, $$2));
      klass = $send($$($nesting, 'Class'), 'new', [self], ($$3 = function(){var self = $$3.$$s == null ? this : $$3.$$s, $$4;

      
        $send(args, 'each', [], ($$4 = function(arg){var self = $$4.$$s == null ? this : $$4.$$s;

        
          
          if (arg == null) {
            arg = nil;
          };
          return self.$define_struct_attribute(arg);}, $$4.$$s = self, $$4.$$arity = 1, $$4));
        return (function(self, $parent_nesting) {
          var $nesting = [self].concat($parent_nesting), $new$5;

          
          
          Opal.def(self, '$new', $new$5 = function($a) {
            var $post_args, args, self = this, instance = nil;

            
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            instance = self.$allocate();
            instance.$$data = {};
            $send(instance, 'initialize', Opal.to_a(args));
            return instance;
          }, $new$5.$$arity = -1);
          return self.$alias_method("[]", "new");
        })(Opal.get_singleton_class(self), $nesting);}, $$3.$$s = self, $$3.$$arity = 0, $$3));
      if ($truthy(block)) {
        $send(klass, 'module_eval', [], block.$to_proc())};
      klass.$$keyword_init = keyword_init;
      if ($truthy(const_name)) {
        $$($nesting, 'Struct').$const_set(const_name, klass)};
      return klass;
    }, $Struct_new$1.$$arity = -2);
    Opal.defs(self, '$define_struct_attribute', $Struct_define_struct_attribute$6 = function $$define_struct_attribute(name) {
      var $$7, $$8, self = this;

      
      if (self['$==']($$($nesting, 'Struct'))) {
        self.$raise($$($nesting, 'ArgumentError'), "you cannot define attributes to the Struct class")};
      self.$members()['$<<'](name);
      $send(self, 'define_method', [name], ($$7 = function(){var self = $$7.$$s == null ? this : $$7.$$s;

      return self.$$data[name];}, $$7.$$s = self, $$7.$$arity = 0, $$7));
      return $send(self, 'define_method', ["" + (name) + "="], ($$8 = function(value){var self = $$8.$$s == null ? this : $$8.$$s;

      
        
        if (value == null) {
          value = nil;
        };
        return self.$$data[name] = value;;}, $$8.$$s = self, $$8.$$arity = 1, $$8));
    }, $Struct_define_struct_attribute$6.$$arity = 1);
    Opal.defs(self, '$members', $Struct_members$9 = function $$members() {
      var self = this, $ret_or_1 = nil;
      if (self.members == null) self.members = nil;

      
      if (self['$==']($$($nesting, 'Struct'))) {
        self.$raise($$($nesting, 'ArgumentError'), "the Struct class has no members")};
      return (self.members = (function() {if ($truthy(($ret_or_1 = self.members))) {
        return $ret_or_1
      } else {
        return []
      }; return nil; })());
    }, $Struct_members$9.$$arity = 0);
    Opal.defs(self, '$inherited', $Struct_inherited$10 = function $$inherited(klass) {
      var $$11, self = this, members = nil;
      if (self.members == null) self.members = nil;

      
      members = self.members;
      return $send(klass, 'instance_eval', [], ($$11 = function(){var self = $$11.$$s == null ? this : $$11.$$s;

      return (self.members = members)}, $$11.$$s = self, $$11.$$arity = 0, $$11));
    }, $Struct_inherited$10.$$arity = 1);
    
    Opal.def(self, '$initialize', $Struct_initialize$12 = function $$initialize($a) {
      var $post_args, args, $$13, $$14, self = this, kwargs = nil, $ret_or_2 = nil, $ret_or_3 = nil, extra = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(self.$class().$$keyword_init)) {
        
        kwargs = (function() {if ($truthy(($ret_or_2 = args.$last()))) {
          return $ret_or_2
        } else {
          return $hash2([], {})
        }; return nil; })();
        if ($truthy((function() {if ($truthy(($ret_or_3 = $rb_gt(args.$length(), 1)))) {
          return $ret_or_3
        } else {
          return (args.length === 1 && !kwargs.$$is_hash);
        }; return nil; })())) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (given " + (args.$length()) + ", expected 0)")};
        extra = $rb_minus(kwargs.$keys(), self.$class().$members());
        if ($truthy(extra['$any?']())) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "unknown keywords: " + (extra.$join(", ")))};
        return $send(self.$class().$members(), 'each', [], ($$13 = function(name){var self = $$13.$$s == null ? this : $$13.$$s, $writer = nil;

        
          
          if (name == null) {
            name = nil;
          };
          $writer = [name, kwargs['$[]'](name)];
          $send(self, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$13.$$s = self, $$13.$$arity = 1, $$13));
      } else {
        
        if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {
          self.$raise($$($nesting, 'ArgumentError'), "struct size differs")};
        return $send(self.$class().$members(), 'each_with_index', [], ($$14 = function(name, index){var self = $$14.$$s == null ? this : $$14.$$s, $writer = nil;

        
          
          if (name == null) {
            name = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          $writer = [name, args['$[]'](index)];
          $send(self, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$14.$$s = self, $$14.$$arity = 2, $$14));
      };
    }, $Struct_initialize$12.$$arity = -1);
    
    Opal.def(self, '$initialize_copy', $Struct_initialize_copy$15 = function $$initialize_copy(from) {
      var self = this;

      
      self.$$data = {}
      var keys = Object.keys(from.$$data), i, max, name;
      for (i = 0, max = keys.length; i < max; i++) {
        name = keys[i];
        self.$$data[name] = from.$$data[name];
      }
    
    }, $Struct_initialize_copy$15.$$arity = 1);
    
    Opal.def(self, '$members', $Struct_members$16 = function $$members() {
      var self = this;

      return self.$class().$members()
    }, $Struct_members$16.$$arity = 0);
    
    Opal.def(self, '$hash', $Struct_hash$17 = function $$hash() {
      var self = this;

      return $$($nesting, 'Hash').$new(self.$$data).$hash()
    }, $Struct_hash$17.$$arity = 0);
    
    Opal.def(self, '$[]', $Struct_$$$18 = function(name) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy($$($nesting, 'String')['$==='](name))) {
        
        if(!self.$$data.hasOwnProperty(name)) {
          self.$raise($$($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
      
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      return self.$$data[name];;
    }, $Struct_$$$18.$$arity = 1);
    
    Opal.def(self, '$[]=', $Struct_$$$eq$19 = function(name, value) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy($$($nesting, 'String')['$==='](name))) {
        if ($truthy(self.$class().$members()['$include?'](name.$to_sym()))) {
        } else {
          self.$raise($$($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      return self.$$data[name] = value;;
    }, $Struct_$$$eq$19.$$arity = 2);
    
    Opal.def(self, '$==', $Struct_$eq_eq$20 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
      } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, $Struct_$eq_eq$20.$$arity = 1);
    
    Opal.def(self, '$eql?', $Struct_eql$ques$21 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
      } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, $Struct_eql$ques$21.$$arity = 1);
    
    Opal.def(self, '$each', $Struct_each$22 = function $$each() {
      var $$23, $$24, $iter = $Struct_each$22.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Struct_each$22.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$23 = function(){var self = $$23.$$s == null ? this : $$23.$$s;

        return self.$size()}, $$23.$$s = self, $$23.$$arity = 0, $$23))
      };
      $send(self.$class().$members(), 'each', [], ($$24 = function(name){var self = $$24.$$s == null ? this : $$24.$$s;

      
        
        if (name == null) {
          name = nil;
        };
        return Opal.yield1($yield, self['$[]'](name));;}, $$24.$$s = self, $$24.$$arity = 1, $$24));
      return self;
    }, $Struct_each$22.$$arity = 0);
    
    Opal.def(self, '$each_pair', $Struct_each_pair$25 = function $$each_pair() {
      var $$26, $$27, $iter = $Struct_each_pair$25.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Struct_each_pair$25.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_pair"], ($$26 = function(){var self = $$26.$$s == null ? this : $$26.$$s;

        return self.$size()}, $$26.$$s = self, $$26.$$arity = 0, $$26))
      };
      $send(self.$class().$members(), 'each', [], ($$27 = function(name){var self = $$27.$$s == null ? this : $$27.$$s;

      
        
        if (name == null) {
          name = nil;
        };
        return Opal.yield1($yield, [name, self['$[]'](name)]);;}, $$27.$$s = self, $$27.$$arity = 1, $$27));
      return self;
    }, $Struct_each_pair$25.$$arity = 0);
    
    Opal.def(self, '$length', $Struct_length$28 = function $$length() {
      var self = this;

      return self.$class().$members().$length()
    }, $Struct_length$28.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$to_a', $Struct_to_a$29 = function $$to_a() {
      var $$30, self = this;

      return $send(self.$class().$members(), 'map', [], ($$30 = function(name){var self = $$30.$$s == null ? this : $$30.$$s;

      
        
        if (name == null) {
          name = nil;
        };
        return self['$[]'](name);}, $$30.$$s = self, $$30.$$arity = 1, $$30))
    }, $Struct_to_a$29.$$arity = 0);
    Opal.alias(self, "values", "to_a");
    
    Opal.def(self, '$inspect', $Struct_inspect$31 = function $$inspect() {
      var $$32, self = this, result = nil, $ret_or_4 = nil;

      
      result = "#<struct ";
      if ($truthy((function() {if ($truthy(($ret_or_4 = $$($nesting, 'Struct')['$==='](self)))) {
        return self.$class().$name()
      } else {
        return $ret_or_4
      }; return nil; })())) {
        result = $rb_plus(result, "" + (self.$class()) + " ")};
      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], ($$32 = function(name, value){var self = $$32.$$s == null ? this : $$32.$$s;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (value == null) {
          value = nil;
        };
        return "" + (name) + "=" + (value.$inspect());}, $$32.$$s = self, $$32.$$arity = 2, $$32)).$join(", "));
      result = $rb_plus(result, ">");
      return result;
    }, $Struct_inspect$31.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$to_h', $Struct_to_h$33 = function $$to_h() {
      var $iter = $Struct_to_h$33.$$p, block = $iter || nil, $$34, self = this;

      if ($iter) $Struct_to_h$33.$$p = null;
      
      
      if ($iter) $Struct_to_h$33.$$p = null;;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', Opal.to_a(self.$args()))};
      return $send(self.$class().$members(), 'each_with_object', [$hash2([], {})], ($$34 = function(name, h){var self = $$34.$$s == null ? this : $$34.$$s, $writer = nil;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (h == null) {
          h = nil;
        };
        $writer = [name, self['$[]'](name)];
        $send(h, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, $$34.$$s = self, $$34.$$arity = 2, $$34));
    }, $Struct_to_h$33.$$arity = 0);
    
    Opal.def(self, '$values_at', $Struct_values_at$35 = function $$values_at($a) {
      var $post_args, args, $$36, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      args = $send(args, 'map', [], ($$36 = function(arg){var self = $$36.$$s == null ? this : $$36.$$s;

      
        
        if (arg == null) {
          arg = nil;
        };
        return arg.$$is_range ? arg.$to_a() : arg;}, $$36.$$s = self, $$36.$$arity = 1, $$36)).$flatten();
      
      var result = [];
      for (var i = 0, len = args.length; i < len; i++) {
        if (!args[i].$$is_number) {
          self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + ((args[i]).$class()) + " into Integer")
        }
        result.push(self['$[]'](args[i]));
      }
      return result;
    ;
    }, $Struct_values_at$35.$$arity = -1);
    return (Opal.def(self, '$dig', $Struct_dig$37 = function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      keys = $post_args;;
      item = (function() {if ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key))) {
        return self.$$data[key] || nil;
      } else {
        return nil
      }; return nil; })();
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, $Struct_dig$37.$$arity = -2), nil) && 'dig';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/main"] = function(Opal) {
  var $to_s$1, $include$2, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$include']);
  
  Opal.defs(self, '$to_s', $to_s$1 = function $$to_s() {
    var self = this;

    return "main"
  }, $to_s$1.$$arity = 0);
  return (Opal.defs(self, '$include', $include$2 = function $$include(mod) {
    var self = this;

    return $$($nesting, 'Object').$include(mod)
  }, $include$2.$$arity = 1), nil) && 'include';
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/dir"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$[]']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $chdir$1, $pwd$2, $home$3;

      
      
      Opal.def(self, '$chdir', $chdir$1 = function $$chdir(dir) {
        var $iter = $chdir$1.$$p, $yield = $iter || nil, self = this, prev_cwd = nil;

        if ($iter) $chdir$1.$$p = null;
        return (function() { try {
        
        prev_cwd = Opal.current_dir;
        Opal.current_dir = dir;
        return Opal.yieldX($yield, []);;
        } finally {
          Opal.current_dir = prev_cwd
        }; })()
      }, $chdir$1.$$arity = 1);
      
      Opal.def(self, '$pwd', $pwd$2 = function $$pwd() {
        var self = this;

        return Opal.current_dir || '.';
      }, $pwd$2.$$arity = 0);
      Opal.alias(self, "getwd", "pwd");
      return (Opal.def(self, '$home', $home$3 = function $$home() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$($nesting, 'ENV')['$[]']("HOME")))) {
          return $ret_or_1
        } else {
          return "."
        }
      }, $home$3.$$arity = 0), nil) && 'home';
    })(Opal.get_singleton_class(self), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/file"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $klass = Opal.klass, $range = Opal.range, $send = Opal.send;

  Opal.add_stubs(['$respond_to?', '$to_path', '$pwd', '$split', '$sub', '$+', '$unshift', '$join', '$home', '$raise', '$start_with?', '$absolute_path', '$coerce_to!', '$basename', '$empty?', '$rindex', '$[]', '$nil?', '$==', '$-', '$length', '$gsub', '$find', '$=~', '$map', '$each_with_index', '$flatten', '$reject', '$to_proc', '$end_with?']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    Opal.const_set($nesting[0], 'Separator', Opal.const_set($nesting[0], 'SEPARATOR', "/"));
    Opal.const_set($nesting[0], 'ALT_SEPARATOR', nil);
    Opal.const_set($nesting[0], 'PATH_SEPARATOR', ":");
    Opal.const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $absolute_path$1, $expand_path$2, $dirname$3, $basename$4, $extname$5, $exist$ques$6, $directory$ques$7, $join$9, $split$12;

      
      
      Opal.def(self, '$absolute_path', $absolute_path$1 = function $$absolute_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, new_parts = nil, $ret_or_1 = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = (function() {if ($truthy(path['$respond_to?']("to_path"))) {
          return path.$to_path()
        } else {
          return path
        }; return nil; })();
        basedir = (function() {if ($truthy(($ret_or_1 = basedir))) {
          return $ret_or_1
        } else {
          return $$($nesting, 'Dir').$pwd()
        }; return nil; })();
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split(Opal.regexp(["[", sep_chars, "]"]));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split(Opal.regexp(["[", sep_chars, "]"])), path.$split(Opal.regexp(["[", sep_chars, "]"])));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)};
        return new_path;
      }, $absolute_path$1.$$arity = -2);
      
      Opal.def(self, '$expand_path', $expand_path$2 = function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$($nesting, 'Dir').$home();
          if ($truthy(home)) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          if ($truthy(home['$start_with?'](leading_sep))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = Opal.regexp(["^\\~(?:", sep, "|$)"]);
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)};};
        return self.$absolute_path(path, basedir);
      }, $expand_path$2.$$arity = -2);
      Opal.alias(self, "realpath", "expand_path");
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $$($nesting, 'Opal')['$coerce_to!'](path, $$($nesting, 'String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$($nesting, 'ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$($nesting, 'SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$($nesting, 'SEPARATOR'), $$($nesting, 'ALT_SEPARATOR')));
        }
      }
    ;
      
      Opal.def(self, '$dirname', $dirname$3 = function $$dirname(path) {
        var self = this, sep_chars = nil;

        
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("" + "^[" + (sep_chars) + "]"));

        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("" + "[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          return absolute ? '/' : '.';
        }

        return path;
      ;
      }, $dirname$3.$$arity = 1);
      
      Opal.def(self, '$basename', $basename$4 = function $$basename(name, suffix) {
        var self = this, sep_chars = nil;

        
        
        if (suffix == null) {
          suffix = nil;
        };
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $$($nesting, 'Opal')['$coerce_to!'](suffix, $$($nesting, 'String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("" + "(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("" + "^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, $basename$4.$$arity = -2);
      
      Opal.def(self, '$extname', $extname$5 = function $$extname(path) {
        var self = this, filename = nil, last_dot_idx = nil, $ret_or_2 = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""};
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if ($truthy((function() {if ($truthy(($ret_or_2 = last_dot_idx['$nil?']()))) {
          return $ret_or_2
        } else {
          return $rb_plus(last_dot_idx, 1)['$==']($rb_minus(filename.$length(), 1))
        }; return nil; })())) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      }, $extname$5.$$arity = 1);
      
      Opal.def(self, '$exist?', $exist$ques$6 = function(path) {
        var self = this;

        return Opal.modules[path] != null
      }, $exist$ques$6.$$arity = 1);
      Opal.alias(self, "exists?", "exist?");
      
      Opal.def(self, '$directory?', $directory$ques$7 = function(path) {
        var $$8, self = this, files = nil, file = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub(Opal.regexp(["(^.", $$($nesting, 'SEPARATOR'), "+|", $$($nesting, 'SEPARATOR'), "+$)"]));
        file = $send(files, 'find', [], ($$8 = function(f){var self = $$8.$$s == null ? this : $$8.$$s;

        
          
          if (f == null) {
            f = nil;
          };
          return f['$=~'](Opal.regexp(["^", path]));}, $$8.$$s = self, $$8.$$arity = 1, $$8));
        return file;
      }, $directory$ques$7.$$arity = 1);
      
      Opal.def(self, '$join', $join$9 = function $$join($a) {
        var $post_args, paths, $$10, $$11, self = this, result = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        paths = $post_args;;
        if ($truthy(paths['$empty?']())) {
          return ""};
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], ($$10 = function(item, index){var self = $$10.$$s == null ? this : $$10.$$s, $ret_or_3 = nil, $ret_or_4 = nil;

        
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          if ($truthy((function() {if ($truthy(($ret_or_3 = index['$=='](0)))) {
            return item['$empty?']()
          } else {
            return $ret_or_3
          }; return nil; })())) {
            return $$($nesting, 'SEPARATOR')
          } else if ($truthy((function() {if ($truthy(($ret_or_4 = paths.$length()['$==']($rb_plus(index, 1))))) {
            return item['$empty?']()
          } else {
            return $ret_or_4
          }; return nil; })())) {
            return $$($nesting, 'SEPARATOR')
          } else {
            return item
          };}, $$10.$$s = self, $$10.$$arity = 2, $$10));
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], ($$11 = function(item, index){var self = $$11.$$s == null ? this : $$11.$$s, next_item = nil, $ret_or_5 = nil, $ret_or_6 = nil;

        
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
          } else {
            
            if ($truthy((function() {if ($truthy(($ret_or_5 = item['$end_with?']($$($nesting, 'SEPARATOR'))))) {
              return next_item['$start_with?']($$($nesting, 'SEPARATOR'))
            } else {
              return $ret_or_5
            }; return nil; })())) {
              item = item.$sub(Opal.regexp([$$($nesting, 'SEPARATOR'), "+$"]), "")};
            return (result = (function() {if ($truthy((function() {if ($truthy(($ret_or_6 = item['$end_with?']($$($nesting, 'SEPARATOR'))))) {
              return $ret_or_6
            } else {
              return next_item['$start_with?']($$($nesting, 'SEPARATOR'))
            }; return nil; })())) {
              return "" + (result) + (item)
            } else {
              return "" + (result) + (item) + ($$($nesting, 'SEPARATOR'))
            }; return nil; })());
          };}, $$11.$$s = self, $$11.$$arity = 2, $$11));
        return result;
      }, $join$9.$$arity = -1);
      return (Opal.def(self, '$split', $split$12 = function $$split(path) {
        var self = this;

        return path.$split($$($nesting, 'SEPARATOR'))
      }, $split$12.$$arity = 1), nil) && 'split';
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], $$($nesting, 'IO'), $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/process"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$const_set', '$size', '$<<', '$__register_clock__', '$to_f', '$now', '$new', '$[]', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Process');

    var $nesting = [self].concat($parent_nesting), $Process___register_clock__$1, $Process_pid$2, $Process_times$3, $Process_clock_gettime$4, monotonic = nil;

    
    self.__clocks__ = [];
    Opal.defs(self, '$__register_clock__', $Process___register_clock__$1 = function $$__register_clock__(name, func) {
      var self = this;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      self.$const_set(name, self.__clocks__.$size());
      return self.__clocks__['$<<'](func);
    }, $Process___register_clock__$1.$$arity = 2);
    self.$__register_clock__("CLOCK_REALTIME", function() { return Date.now() });
    monotonic = false;
    
    if (Opal.global.performance) {
      monotonic = function() {
        return performance.now()
      };
    }
    else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function() {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return ((hrtime[0] * 1000) + (us / 1000));
      };
    }
  ;
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic)};
    Opal.defs(self, '$pid', $Process_pid$2 = function $$pid() {
      var self = this;

      return 0
    }, $Process_pid$2.$$arity = 0);
    Opal.defs(self, '$times', $Process_times$3 = function $$times() {
      var self = this, t = nil;

      
      t = $$($nesting, 'Time').$now().$to_f();
      return $$$($$($nesting, 'Benchmark'), 'Tms').$new(t, t, t, t, t);
    }, $Process_times$3.$$arity = 0);
    return (Opal.defs(self, '$clock_gettime', $Process_clock_gettime$4 = function $$clock_gettime(clock_id, unit) {
      var self = this, $ret_or_1 = nil, clock = nil;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      
      if (unit == null) {
        unit = "float_second";
      };
      if ($truthy(($ret_or_1 = (clock = self.__clocks__['$[]'](clock_id))))) {
        $ret_or_1
      } else {
        self.$raise($$$($$($nesting, 'Errno'), 'EINVAL'), "" + "clock_gettime(" + (clock_id) + ") " + (self.__clocks__['$[]'](clock_id)))
      };
      
      var ms = clock();
      switch (unit) {
        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)
        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float
        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float
        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer
        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer
        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer
        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer
        default: self.$raise($$($nesting, 'ArgumentError'), "" + "unexpected unit: " + (unit))
      }
    ;
    }, $Process_clock_gettime$4.$$arity = -2), nil) && 'clock_gettime';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Signal');

    var $nesting = [self].concat($parent_nesting), $Signal_trap$5;

    return (Opal.defs(self, '$trap', $Signal_trap$5 = function $$trap($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Signal_trap$5.$$arity = -1), nil) && 'trap'
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'GC');

    var $nesting = [self].concat($parent_nesting), $GC_start$6;

    return (Opal.defs(self, '$start', $GC_start$6 = function $$start() {
      var self = this;

      return nil
    }, $GC_start$6.$$arity = 0), nil) && 'start'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/random/formatter"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $module = Opal.module, $send = Opal.send, $range = Opal.range;

  Opal.add_stubs(['$_verify_count', '$bytes', '$encode', '$strict_encode64', '$random_bytes', '$urlsafe_encode64', '$split', '$hex', '$[]=', '$-', '$[]', '$map', '$to_proc', '$join', '$times', '$<<', '$|', '$ord', '$/', '$abs', '$random_float', '$raise', '$coerce_to!', '$flatten', '$new', '$random_number', '$length', '$include', '$extend']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $parent_nesting) {
      var self = $module($base, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $Formatter_hex$1, $Formatter_random_bytes$2, $Formatter_base64$3, $Formatter_urlsafe_base64$4, $Formatter_uuid$5, $Formatter_random_float$6, $Formatter_random_number$8, $Formatter_alphanumeric$9;

      
      
      Opal.def(self, '$hex', $Formatter_hex$1 = function $$hex(count) {
        var self = this;

        
        
        if (count == null) {
          count = nil;
        };
        count = $$($nesting, 'Random').$_verify_count(count);
        
        var bytes = self.$bytes(count);
        var out = "";
        for (var i = 0; i < count; i++) {
          out += bytes.charCodeAt(i).toString(16).padStart(2, '0');
        }
        return (out).$encode("US-ASCII");
      ;
      }, $Formatter_hex$1.$$arity = -1);
      
      Opal.def(self, '$random_bytes', $Formatter_random_bytes$2 = function $$random_bytes(count) {
        var self = this;

        
        
        if (count == null) {
          count = nil;
        };
        return self.$bytes(count);
      }, $Formatter_random_bytes$2.$$arity = -1);
      
      Opal.def(self, '$base64', $Formatter_base64$3 = function $$base64(count) {
        var self = this;

        
        
        if (count == null) {
          count = nil;
        };
        return $$($nesting, 'Base64').$strict_encode64(self.$random_bytes(count)).$encode("US-ASCII");
      }, $Formatter_base64$3.$$arity = -1);
      
      Opal.def(self, '$urlsafe_base64', $Formatter_urlsafe_base64$4 = function $$urlsafe_base64(count, padding) {
        var self = this;

        
        
        if (count == null) {
          count = nil;
        };
        
        if (padding == null) {
          padding = false;
        };
        return $$($nesting, 'Base64').$urlsafe_encode64(self.$random_bytes(count), padding).$encode("US-ASCII");
      }, $Formatter_urlsafe_base64$4.$$arity = -1);
      
      Opal.def(self, '$uuid', $Formatter_uuid$5 = function $$uuid() {
        var self = this, str = nil, $writer = nil;

        
        str = self.$hex(16).$split("");
        
        $writer = [12, "4"];
        $send(str, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = [16, (parseInt(str['$[]'](16), 16) & 3 | 8).toString(16)];
        $send(str, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        str = [str['$[]']($range(0, 8, true)), str['$[]']($range(8, 12, true)), str['$[]']($range(12, 16, true)), str['$[]']($range(16, 20, true)), str['$[]']($range(20, 32, true))];
        str = $send(str, 'map', [], "join".$to_proc());
        return str.$join("-");
      }, $Formatter_uuid$5.$$arity = 0);
      
      Opal.def(self, '$random_float', $Formatter_random_float$6 = function $$random_float() {
        var $$7, self = this, bs = nil, num = nil;

        
        bs = self.$bytes(4);
        num = 0;
        $send((4), 'times', [], ($$7 = function(i){var self = $$7.$$s == null ? this : $$7.$$s;

        
          
          if (i == null) {
            i = nil;
          };
          num = num['$<<'](8);
          return (num = num['$|'](bs['$[]'](i).$ord()));}, $$7.$$s = self, $$7.$$arity = 1, $$7));
        return $rb_divide(num.$abs(), 2147483647);
      }, $Formatter_random_float$6.$$arity = 0);
      
      Opal.def(self, '$random_number', $Formatter_random_number$8 = function $$random_number(limit) {
        var self = this;

        
        ;
        
        function randomFloat() {
          return self.$random_float();
        }

        function randomInt(max) {
          return Math.floor(randomFloat() * max);
        }

        function randomRange() {
          var min = limit.begin,
              max = limit.end;

          if (min === nil || max === nil) {
            return nil;
          }

          var length = max - min;

          if (length < 0) {
            return nil;
          }

          if (length === 0) {
            return min;
          }

          if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
            length++;
          }

          return randomInt(length) + min;
        }

        if (limit == null) {
          return randomFloat();
        } else if (limit.$$is_range) {
          return randomRange();
        } else if (limit.$$is_number) {
          if (limit <= 0) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid argument - " + (limit))
          }

          if (limit % 1 === 0) {
            // integer
            return randomInt(limit);
          } else {
            return randomFloat() * limit;
          }
        } else {
          limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), "to_int");

          if (limit <= 0) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid argument - " + (limit))
          }

          return randomInt(limit);
        }
      ;
      }, $Formatter_random_number$8.$$arity = -1);
      return (Opal.def(self, '$alphanumeric', $Formatter_alphanumeric$9 = function $$alphanumeric(count) {
        var $$10, self = this, map = nil;

        
        
        if (count == null) {
          count = nil;
        };
        count = $$($nesting, 'Random').$_verify_count(count);
        map = $send([$range("0", "9", false), $range("a", "z", false), $range("A", "Z", false)], 'map', [], "to_a".$to_proc()).$flatten();
        return $send($$($nesting, 'Array'), 'new', [count], ($$10 = function(i){var self = $$10.$$s == null ? this : $$10.$$s;

        
          
          if (i == null) {
            i = nil;
          };
          return map['$[]'](self.$random_number(map.$length()));}, $$10.$$s = self, $$10.$$arity = 1, $$10)).$join();
      }, $Formatter_alphanumeric$9.$$arity = -1), nil) && 'alphanumeric';
    })($nesting[0], $nesting);
    self.$include($$$($$($nesting, 'Random'), 'Formatter'));
    return self.$extend($$$($$($nesting, 'Random'), 'Formatter'));
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/random"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $falsy = Opal.falsy, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$to_int', '$raise', '$new_seed', '$coerce_to!', '$reseed', '$rand', '$seed', '$bytes', '$===', '$==', '$state', '$_verify_count', '$encode', '$join', '$new', '$chr', '$random_number', '$random_float', '$const_defined?', '$const_set']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting), $Random__verify_count$1, $Random_initialize$2, $Random_reseed$3, $Random_new_seed$4, $Random_rand$5, $Random_srand$6, $Random_urandom$7, $Random_$eq_eq$8, $Random_bytes$9, $Random_bytes$11, $Random_rand$12, $Random_random_float$13, $Random_random_float$14, $Random_generator$eq$15;

    
    self.$attr_reader("seed", "state");
    Opal.defs(self, '$_verify_count', $Random__verify_count$1 = function $$_verify_count(count) {
      var self = this;

      
      if ($falsy(count)) count = 16;
      if (typeof count !== "number") count = (count).$to_int();
      if (count < 0) self.$raise($$($nesting, 'ArgumentError'), "negative string size (or size too big)");
      count = Math.floor(count);
      return count;
    
    }, $Random__verify_count$1.$$arity = 1);
    
    Opal.def(self, '$initialize', $Random_initialize$2 = function $$initialize(seed) {
      var self = this;

      
      
      if (seed == null) {
        seed = $$($nesting, 'Random').$new_seed();
      };
      seed = $$($nesting, 'Opal')['$coerce_to!'](seed, $$($nesting, 'Integer'), "to_int");
      self.state = seed;
      return self.$reseed(seed);
    }, $Random_initialize$2.$$arity = -1);
    
    Opal.def(self, '$reseed', $Random_reseed$3 = function $$reseed(seed) {
      var self = this;

      
      self.seed = seed;
      return self.$rng = Opal.$$rand.reseed(seed);;
    }, $Random_reseed$3.$$arity = 1);
    Opal.defs(self, '$new_seed', $Random_new_seed$4 = function $$new_seed() {
      var self = this;

      return Opal.$$rand.new_seed();
    }, $Random_new_seed$4.$$arity = 0);
    Opal.defs(self, '$rand', $Random_rand$5 = function $$rand(limit) {
      var self = this;

      
      ;
      return $$($nesting, 'DEFAULT').$rand(limit);
    }, $Random_rand$5.$$arity = -1);
    Opal.defs(self, '$srand', $Random_srand$6 = function $$srand(n) {
      var self = this, previous_seed = nil;

      
      
      if (n == null) {
        n = $$($nesting, 'Random').$new_seed();
      };
      n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      previous_seed = $$($nesting, 'DEFAULT').$seed();
      $$($nesting, 'DEFAULT').$reseed(n);
      return previous_seed;
    }, $Random_srand$6.$$arity = -1);
    Opal.defs(self, '$urandom', $Random_urandom$7 = function $$urandom(size) {
      var self = this;

      return $$$('::', 'SecureRandom').$bytes(size)
    }, $Random_urandom$7.$$arity = 1);
    
    Opal.def(self, '$==', $Random_$eq_eq$8 = function(other) {
      var self = this, $ret_or_1 = nil;

      
      if ($truthy($$($nesting, 'Random')['$==='](other))) {
      } else {
        return false
      };
      if ($truthy(($ret_or_1 = self.$seed()['$=='](other.$seed())))) {
        return self.$state()['$=='](other.$state())
      } else {
        return $ret_or_1
      };
    }, $Random_$eq_eq$8.$$arity = 1);
    
    Opal.def(self, '$bytes', $Random_bytes$9 = function $$bytes(length) {
      var $$10, self = this;

      
      length = $$($nesting, 'Random').$_verify_count(length);
      return $send($$($nesting, 'Array'), 'new', [length], ($$10 = function(){var self = $$10.$$s == null ? this : $$10.$$s;

      return self.$rand(255).$chr()}, $$10.$$s = self, $$10.$$arity = 0, $$10)).$join().$encode("ASCII-8BIT");
    }, $Random_bytes$9.$$arity = 1);
    Opal.defs(self, '$bytes', $Random_bytes$11 = function $$bytes(length) {
      var self = this;

      return $$($nesting, 'DEFAULT').$bytes(length)
    }, $Random_bytes$11.$$arity = 1);
    
    Opal.def(self, '$rand', $Random_rand$12 = function $$rand(limit) {
      var self = this;

      
      ;
      return self.$random_number(limit);
    }, $Random_rand$12.$$arity = -1);
    
    Opal.def(self, '$random_float', $Random_random_float$13 = function $$random_float() {
      var self = this;

      
      self.state++;
      return Opal.$$rand.rand(self.$rng);
    
    }, $Random_random_float$13.$$arity = 0);
    Opal.defs(self, '$random_float', $Random_random_float$14 = function $$random_float() {
      var self = this;

      return $$($nesting, 'DEFAULT').$random_float()
    }, $Random_random_float$14.$$arity = 0);
    return (Opal.defs(self, '$generator=', $Random_generator$eq$15 = function(generator) {
      var self = this;

      
      Opal.$$rand = generator;
      if ($truthy(self['$const_defined?']("DEFAULT"))) {
        return $$($nesting, 'DEFAULT').$reseed()
      } else {
        return self.$const_set("DEFAULT", self.$new(self.$new_seed()))
      };
    }, $Random_generator$eq$15.$$arity = 1), nil) && 'generator=';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/random/mersenne_twister"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, mersenne_twister = nil;

  Opal.add_stubs(['$generator=', '$-']);
  
  mersenne_twister = (function() {
  /* Period parameters */
  var N = 624;
  var M = 397;
  var MATRIX_A = 0x9908b0df;      /* constant vector a */
  var UMASK = 0x80000000;         /* most significant w-r bits */
  var LMASK = 0x7fffffff;         /* least significant r bits */
  var MIXBITS = function(u,v) { return ( ((u) & UMASK) | ((v) & LMASK) ); };
  var TWIST = function(u,v) { return (MIXBITS((u),(v)) >>> 1) ^ ((v & 0x1) ? MATRIX_A : 0x0); };

  function init(s) {
    var mt = {left: 0, next: N, state: new Array(N)};
    init_genrand(mt, s);
    return mt;
  }

  /* initializes mt[N] with a seed */
  function init_genrand(mt, s) {
    var j, i;
    mt.state[0] = s >>> 0;
    for (j=1; j<N; j++) {
      mt.state[j] = (1812433253 * ((mt.state[j-1] ^ (mt.state[j-1] >> 30) >>> 0)) + j);
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array state[].                     */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      mt.state[j] &= 0xffffffff;  /* for >32 bit machines */
    }
    mt.left = 1;
    mt.next = N;
  }

  /* generate N words at one time */
  function next_state(mt) {
    var p = 0, _p = mt.state;
    var j;

    mt.left = N;
    mt.next = 0;

    for (j=N-M+1; --j; p++)
      _p[p] = _p[p+(M)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    for (j=M; --j; p++)
      _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[0]);
  }

  /* generates a random number on [0,0xffffffff]-interval */
  function genrand_int32(mt) {
    /* mt must be initialized */
    var y;

    if (--mt.left <= 0) next_state(mt);
    y = mt.state[mt.next++];

    /* Tempering */
    y ^= (y >>> 11);
    y ^= (y << 7) & 0x9d2c5680;
    y ^= (y << 15) & 0xefc60000;
    y ^= (y >>> 18);

    return y >>> 0;
  }

  function int_pair_to_real_exclusive(a, b) {
    a >>>= 5;
    b >>>= 6;
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  // generates a random number on [0,1) with 53-bit resolution
  function genrand_real(mt) {
    /* mt must be initialized */
    var a = genrand_int32(mt), b = genrand_int32(mt);
    return int_pair_to_real_exclusive(a, b);
  }

  return { genrand_real: genrand_real, init: init };
})();
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting), $writer = nil;

    
    var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    Opal.const_set($nesting[0], 'MERSENNE_TWISTER_GENERATOR', {
    new_seed: function() { return Math.round(Math.random() * MAX_INT); },
    reseed: function(seed) { return mersenne_twister.init(seed); },
    rand: function(mt) { return mersenne_twister.genrand_real(mt); }
  });
    
    $writer = [$$($nesting, 'MERSENNE_TWISTER_GENERATOR')];
    $send(self, 'generator=', Opal.to_a($writer));
    return $writer[$rb_minus($writer["length"], 1)];;
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/unsupported"] = function(Opal) {
  var $public$35, $private$36, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $module = Opal.module;

  Opal.add_stubs(['$raise', '$warn', '$%']);
  
  
  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $$($nesting, 'Kernel').$raise($$($nesting, 'NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
;
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_$lt$lt$1, $String_capitalize$excl$2, $String_chomp$excl$3, $String_chop$excl$4, $String_downcase$excl$5, $String_gsub$excl$6, $String_lstrip$excl$7, $String_next$excl$8, $String_reverse$excl$9, $String_slice$excl$10, $String_squeeze$excl$11, $String_strip$excl$12, $String_sub$excl$13, $String_succ$excl$14, $String_swapcase$excl$15, $String_tr$excl$16, $String_tr_s$excl$17, $String_upcase$excl$18, $String_prepend$19, $String_$$$eq$20, $String_clear$21, $String_encode$excl$22, $String_unicode_normalize$excl$23;

    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
    
    Opal.def(self, '$<<', $String_$lt$lt$1 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("<<"));
    }, $String_$lt$lt$1.$$arity = -1);
    
    Opal.def(self, '$capitalize!', $String_capitalize$excl$2 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("capitalize!"));
    }, $String_capitalize$excl$2.$$arity = -1);
    
    Opal.def(self, '$chomp!', $String_chomp$excl$3 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("chomp!"));
    }, $String_chomp$excl$3.$$arity = -1);
    
    Opal.def(self, '$chop!', $String_chop$excl$4 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("chop!"));
    }, $String_chop$excl$4.$$arity = -1);
    
    Opal.def(self, '$downcase!', $String_downcase$excl$5 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("downcase!"));
    }, $String_downcase$excl$5.$$arity = -1);
    
    Opal.def(self, '$gsub!', $String_gsub$excl$6 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("gsub!"));
    }, $String_gsub$excl$6.$$arity = -1);
    
    Opal.def(self, '$lstrip!', $String_lstrip$excl$7 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("lstrip!"));
    }, $String_lstrip$excl$7.$$arity = -1);
    
    Opal.def(self, '$next!', $String_next$excl$8 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("next!"));
    }, $String_next$excl$8.$$arity = -1);
    
    Opal.def(self, '$reverse!', $String_reverse$excl$9 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("reverse!"));
    }, $String_reverse$excl$9.$$arity = -1);
    
    Opal.def(self, '$slice!', $String_slice$excl$10 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("slice!"));
    }, $String_slice$excl$10.$$arity = -1);
    
    Opal.def(self, '$squeeze!', $String_squeeze$excl$11 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("squeeze!"));
    }, $String_squeeze$excl$11.$$arity = -1);
    
    Opal.def(self, '$strip!', $String_strip$excl$12 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("strip!"));
    }, $String_strip$excl$12.$$arity = -1);
    
    Opal.def(self, '$sub!', $String_sub$excl$13 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("sub!"));
    }, $String_sub$excl$13.$$arity = -1);
    
    Opal.def(self, '$succ!', $String_succ$excl$14 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("succ!"));
    }, $String_succ$excl$14.$$arity = -1);
    
    Opal.def(self, '$swapcase!', $String_swapcase$excl$15 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("swapcase!"));
    }, $String_swapcase$excl$15.$$arity = -1);
    
    Opal.def(self, '$tr!', $String_tr$excl$16 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("tr!"));
    }, $String_tr$excl$16.$$arity = -1);
    
    Opal.def(self, '$tr_s!', $String_tr_s$excl$17 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("tr_s!"));
    }, $String_tr_s$excl$17.$$arity = -1);
    
    Opal.def(self, '$upcase!', $String_upcase$excl$18 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("upcase!"));
    }, $String_upcase$excl$18.$$arity = -1);
    
    Opal.def(self, '$prepend', $String_prepend$19 = function $$prepend($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("prepend"));
    }, $String_prepend$19.$$arity = -1);
    
    Opal.def(self, '$[]=', $String_$$$eq$20 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("[]="));
    }, $String_$$$eq$20.$$arity = -1);
    
    Opal.def(self, '$clear', $String_clear$21 = function $$clear($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("clear"));
    }, $String_clear$21.$$arity = -1);
    
    Opal.def(self, '$encode!', $String_encode$excl$22 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("encode!"));
    }, $String_encode$excl$22.$$arity = -1);
    return (Opal.def(self, '$unicode_normalize!', $String_unicode_normalize$excl$23 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("unicode_normalize!"));
    }, $String_unicode_normalize$excl$23.$$arity = -1), nil) && 'unicode_normalize!';
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_freeze$24, $Kernel_frozen$ques$25;

    
    var ERROR = "Object freezing is not supported by Opal";
    
    Opal.def(self, '$freeze', $Kernel_freeze$24 = function $$freeze() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_freeze$24.$$arity = 0);
    return (Opal.def(self, '$frozen?', $Kernel_frozen$ques$25 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, $Kernel_frozen$ques$25.$$arity = 0), nil) && 'frozen?';
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_taint$26, $Kernel_untaint$27, $Kernel_tainted$ques$28;

    
    var ERROR = "Object tainting is not supported by Opal";
    
    Opal.def(self, '$taint', $Kernel_taint$26 = function $$taint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_taint$26.$$arity = 0);
    
    Opal.def(self, '$untaint', $Kernel_untaint$27 = function $$untaint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_untaint$27.$$arity = 0);
    return (Opal.def(self, '$tainted?', $Kernel_tainted$ques$28 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, $Kernel_tainted$ques$28.$$arity = 0), nil) && 'tainted?';
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_public$29, $Module_private_class_method$30, $Module_private_method_defined$ques$31, $Module_private_constant$32;

    
    
    Opal.def(self, '$public', $Module_public$29 = function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = false;
      }

      return nil;
    ;
    }, $Module_public$29.$$arity = -1);
    Opal.alias(self, "private", "public");
    Opal.alias(self, "protected", "public");
    Opal.alias(self, "nesting", "public");
    
    Opal.def(self, '$private_class_method', $Module_private_class_method$30 = function $$private_class_method($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self;
    }, $Module_private_class_method$30.$$arity = -1);
    Opal.alias(self, "public_class_method", "private_class_method");
    
    Opal.def(self, '$private_method_defined?', $Module_private_method_defined$ques$31 = function(obj) {
      var self = this;

      return false
    }, $Module_private_method_defined$ques$31.$$arity = 1);
    
    Opal.def(self, '$private_constant', $Module_private_constant$32 = function $$private_constant($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_private_constant$32.$$arity = -1);
    Opal.alias(self, "protected_method_defined?", "private_method_defined?");
    Opal.alias(self, "public_instance_methods", "instance_methods");
    Opal.alias(self, "public_instance_method", "instance_method");
    return Opal.alias(self, "public_method_defined?", "method_defined?");
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_private_methods$33;

    
    
    Opal.def(self, '$private_methods', $Kernel_private_methods$33 = function $$private_methods($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return [];
    }, $Kernel_private_methods$33.$$arity = -1);
    return Opal.alias(self, "private_instance_methods", "private_methods");
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_eval$34;

    return (Opal.def(self, '$eval', $Kernel_eval$34 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), "" + "To use Kernel#eval, you must first require 'opal-parser'. " + ("" + "See https://github.com/opal/opal/blob/" + ($$($nesting, 'RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."));
    }, $Kernel_eval$34.$$arity = -1), nil) && 'eval'
  })($nesting[0], $nesting);
  Opal.defs(self, '$public', $public$35 = function($a) {
    var $post_args, self = this;

    
    
    $post_args = Opal.slice.call(arguments, 0, arguments.length);
    ;
    return nil;
  }, $public$35.$$arity = -1);
  return (Opal.defs(self, '$private', $private$36 = function($a) {
    var $post_args, self = this;

    
    
    $post_args = Opal.slice.call(arguments, 0, arguments.length);
    ;
    return nil;
  }, $private$36.$$arity = -1), nil) && 'private';
};

/* Generated by Opal 1.2.0 */
Opal.modules["opal"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("opal/mini");
  self.$require("corelib/kernel/format");
  self.$require("corelib/string/encoding");
  self.$require("corelib/math");
  self.$require("corelib/complex");
  self.$require("corelib/rational");
  self.$require("corelib/time");
  self.$require("corelib/struct");
  self.$require("corelib/io");
  self.$require("corelib/main");
  self.$require("corelib/dir");
  self.$require("corelib/file");
  self.$require("corelib/process");
  self.$require("corelib/random/formatter");
  self.$require("corelib/random");
  self.$require("corelib/random/mersenne_twister");
  return self.$require("corelib/unsupported");
};

/* Generated by Opal 1.2.0 */
Opal.modules["native"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $range = Opal.range, $klass = Opal.klass, $send2 = Opal.send2, $gvars = Opal.gvars;

  Opal.add_stubs(['$try_convert', '$native?', '$respond_to?', '$to_n', '$raise', '$inspect', '$Native', '$proc', '$map!', '$end_with?', '$define_method', '$[]', '$convert', '$call', '$to_proc', '$new', '$each', '$native_reader', '$native_writer', '$extend', '$warn', '$include', '$is_a?', '$map', '$to_a', '$_Array', '$method_missing', '$bind', '$instance_method', '$slice', '$-', '$length', '$[]=', '$enum_for', '$===', '$>=', '$<<', '$each_pair', '$_initialize', '$name', '$native_module']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Native');

    var $nesting = [self].concat($parent_nesting), $Native_is_a$ques$1, $Native_try_convert$2, $Native_convert$3, $Native_call$4, $Native_proc$5, $Native_included$22;

    
    Opal.defs(self, '$is_a?', $Native_is_a$ques$1 = function(object, klass) {
      var self = this;

      
      try {
        return object instanceof self.$try_convert(klass);
      }
      catch (e) {
        return false;
      }
    
    }, $Native_is_a$ques$1.$$arity = 2);
    Opal.defs(self, '$try_convert', $Native_try_convert$2 = function $$try_convert(value, default$) {
      var self = this;

      
      
      if (default$ == null) {
        default$ = nil;
      };
      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        return default$;
      }
    ;
    }, $Native_try_convert$2.$$arity = -2);
    Opal.defs(self, '$convert', $Native_convert$3 = function $$convert(value) {
      var self = this;

      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        self.$raise($$($nesting, 'ArgumentError'), "" + (value.$inspect()) + " isn't native");
      }
    
    }, $Native_convert$3.$$arity = 1);
    Opal.defs(self, '$call', $Native_call$4 = function $$call(obj, key, $a) {
      var $iter = $Native_call$4.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Native_call$4.$$p = null;
      
      
      if ($iter) $Native_call$4.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 2, arguments.length);
      
      args = $post_args;;
      
      var prop = obj[key];

      if (prop instanceof Function) {
        var converted = new Array(args.length);

        for (var i = 0, l = args.length; i < l; i++) {
          var item = args[i],
              conv = self.$try_convert(item);

          converted[i] = conv === nil ? item : conv;
        }

        if (block !== nil) {
          converted.push(block);
        }

        return self.$Native(prop.apply(obj, converted));
      }
      else {
        return self.$Native(prop);
      }
    ;
    }, $Native_call$4.$$arity = -3);
    Opal.defs(self, '$proc', $Native_proc$5 = function $$proc() {
      var $iter = $Native_proc$5.$$p, block = $iter || nil, $$6, self = this;

      if ($iter) $Native_proc$5.$$p = null;
      
      
      if ($iter) $Native_proc$5.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'LocalJumpError'), "no block given")
      };
      return $send($$$('::', 'Kernel'), 'proc', [], ($$6 = function($a){var self = $$6.$$s == null ? this : $$6.$$s, $post_args, args, $$7, instance = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        $send(args, 'map!', [], ($$7 = function(arg){var self = $$7.$$s == null ? this : $$7.$$s;

        
          
          if (arg == null) {
            arg = nil;
          };
          return self.$Native(arg);}, $$7.$$s = self, $$7.$$arity = 1, $$7));
        instance = self.$Native(this);
        
        // if global is current scope, run the block in the scope it was defined
        if (this === Opal.global) {
          return block.apply(self, args);
        }

        var self_ = block.$$s;
        block.$$s = null;

        try {
          return block.apply(instance, args);
        }
        finally {
          block.$$s = self_;
        }
      ;}, $$6.$$s = self, $$6.$$arity = -1, $$6));
    }, $Native_proc$5.$$arity = 0);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Helpers');

      var $nesting = [self].concat($parent_nesting), $Helpers_alias_native$8, $Helpers_native_reader$12, $Helpers_native_writer$15, $Helpers_native_accessor$18;

      
      
      Opal.def(self, '$alias_native', $Helpers_alias_native$8 = function $$alias_native(new$, $a, $b) {
        var $post_args, $kwargs, old, as, $$9, $$10, $$11, $iter = $Helpers_alias_native$8.$$p, $yield = $iter || nil, self = this;

        if ($iter) $Helpers_alias_native$8.$$p = null;
        
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        $kwargs = Opal.extract_kwargs($post_args);
        
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new('expected kwargs');
        };
        
        if ($post_args.length > 0) {
          old = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (old == null) {
          old = new$;
        };
        
        as = $kwargs.$$smap["as"];
        if (as == null) {
          as = nil
        };
        if ($truthy(old['$end_with?']("="))) {
          return $send(self, 'define_method', [new$], ($$9 = function(value){var self = $$9.$$s == null ? this : $$9.$$s;
            if (self["native"] == null) self["native"] = nil;

          
            
            if (value == null) {
              value = nil;
            };
            self["native"][old['$[]']($range(0, -2, false))] = $$($nesting, 'Native').$convert(value);
            return value;}, $$9.$$s = self, $$9.$$arity = 1, $$9))
        } else if ($truthy(as)) {
          return $send(self, 'define_method', [new$], ($$10 = function($c){var self = $$10.$$s == null ? this : $$10.$$s, $iter = $$10.$$p, block = $iter || nil, $post_args, args, value = nil;
            if (self["native"] == null) self["native"] = nil;

          
            
            if ($iter) $$10.$$p = null;;
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            value = $send($$($nesting, 'Native'), 'call', [self["native"], old].concat(Opal.to_a(args)), block.$to_proc());
            if ($truthy(value)) {
              return as.$new(value.$to_n())
            } else {
              return nil
            };}, $$10.$$s = self, $$10.$$arity = -1, $$10))
        } else {
          return $send(self, 'define_method', [new$], ($$11 = function($c){var self = $$11.$$s == null ? this : $$11.$$s, $iter = $$11.$$p, block = $iter || nil, $post_args, args;
            if (self["native"] == null) self["native"] = nil;

          
            
            if ($iter) $$11.$$p = null;;
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            return $send($$($nesting, 'Native'), 'call', [self["native"], old].concat(Opal.to_a(args)), block.$to_proc());}, $$11.$$s = self, $$11.$$arity = -1, $$11))
        };
      }, $Helpers_alias_native$8.$$arity = -2);
      
      Opal.def(self, '$native_reader', $Helpers_native_reader$12 = function $$native_reader($a) {
        var $post_args, names, $$13, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        names = $post_args;;
        return $send(names, 'each', [], ($$13 = function(name){var self = $$13.$$s == null ? this : $$13.$$s, $$14;

        
          
          if (name == null) {
            name = nil;
          };
          return $send(self, 'define_method', [name], ($$14 = function(){var self = $$14.$$s == null ? this : $$14.$$s;
            if (self["native"] == null) self["native"] = nil;

          return self.$Native(self["native"][name])}, $$14.$$s = self, $$14.$$arity = 0, $$14));}, $$13.$$s = self, $$13.$$arity = 1, $$13));
      }, $Helpers_native_reader$12.$$arity = -1);
      
      Opal.def(self, '$native_writer', $Helpers_native_writer$15 = function $$native_writer($a) {
        var $post_args, names, $$16, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        names = $post_args;;
        return $send(names, 'each', [], ($$16 = function(name){var self = $$16.$$s == null ? this : $$16.$$s, $$17;

        
          
          if (name == null) {
            name = nil;
          };
          return $send(self, 'define_method', ["" + (name) + "="], ($$17 = function(value){var self = $$17.$$s == null ? this : $$17.$$s;
            if (self["native"] == null) self["native"] = nil;

          
            
            if (value == null) {
              value = nil;
            };
            return self.$Native(self["native"][name] = value);}, $$17.$$s = self, $$17.$$arity = 1, $$17));}, $$16.$$s = self, $$16.$$arity = 1, $$16));
      }, $Helpers_native_writer$15.$$arity = -1);
      return (Opal.def(self, '$native_accessor', $Helpers_native_accessor$18 = function $$native_accessor($a) {
        var $post_args, names, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        names = $post_args;;
        $send(self, 'native_reader', Opal.to_a(names));
        return $send(self, 'native_writer', Opal.to_a(names));
      }, $Helpers_native_accessor$18.$$arity = -1), nil) && 'native_accessor';
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Wrapper');

      var $nesting = [self].concat($parent_nesting), $Wrapper_initialize$19, $Wrapper_to_n$20, $Wrapper_included$21;

      
      
      Opal.def(self, '$initialize', $Wrapper_initialize$19 = function $$initialize(native$) {
        var self = this;

        
        if ($truthy($$$('::', 'Kernel')['$native?'](native$))) {
        } else {
          $$$('::', 'Kernel').$raise($$($nesting, 'ArgumentError'), "" + (native$.$inspect()) + " isn't native")
        };
        return (self["native"] = native$);
      }, $Wrapper_initialize$19.$$arity = 1);
      
      Opal.def(self, '$to_n', $Wrapper_to_n$20 = function $$to_n() {
        var self = this;
        if (self["native"] == null) self["native"] = nil;

        return self["native"]
      }, $Wrapper_to_n$20.$$arity = 0);
      return (Opal.defs(self, '$included', $Wrapper_included$21 = function $$included(klass) {
        var self = this;

        return klass.$extend($$($nesting, 'Helpers'))
      }, $Wrapper_included$21.$$arity = 1), nil) && 'included';
    })($nesting[0], $nesting);
    return (Opal.defs(self, '$included', $Native_included$22 = function $$included(base) {
      var self = this;

      
      self.$warn("Including ::Native is deprecated. Please include Native::Wrapper instead.");
      return base.$include($$($nesting, 'Wrapper'));
    }, $Native_included$22.$$arity = 1), nil) && 'included';
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_native$ques$23, $Kernel_Native$24, $Kernel_Array$27;

    
    
    Opal.def(self, '$native?', $Kernel_native$ques$23 = function(value) {
      var self = this;

      return value == null || !value.$$class;
    }, $Kernel_native$ques$23.$$arity = 1);
    
    Opal.def(self, '$Native', $Kernel_Native$24 = function $$Native(obj) {
      var $$25, $$26, $iter = $Kernel_Native$24.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Kernel_Native$24.$$p = null;
      if ($truthy(obj == null)) {
        return nil
      } else if ($truthy(self['$native?'](obj))) {
        return $$$($$($nesting, 'Native'), 'Object').$new(obj)
      } else if ($truthy(obj['$is_a?']($$($nesting, 'Array')))) {
        return $send(obj, 'map', [], ($$25 = function(o){var self = $$25.$$s == null ? this : $$25.$$s;

        
          
          if (o == null) {
            o = nil;
          };
          return self.$Native(o);}, $$25.$$s = self, $$25.$$arity = 1, $$25))
      } else if ($truthy(obj['$is_a?']($$($nesting, 'Proc')))) {
        return $send(self, 'proc', [], ($$26 = function($a){var self = $$26.$$s == null ? this : $$26.$$s, $iter = $$26.$$p, block = $iter || nil, $post_args, args;

        
          
          if ($iter) $$26.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return self.$Native($send(obj, 'call', Opal.to_a(args), block.$to_proc()));}, $$26.$$s = self, $$26.$$arity = -1, $$26))
      } else {
        return obj
      }
    }, $Kernel_Native$24.$$arity = 1);
    Opal.alias(self, "_Array", "Array");
    return (Opal.def(self, '$Array', $Kernel_Array$27 = function $$Array(object, $a) {
      var $iter = $Kernel_Array$27.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_Array$27.$$p = null;
      
      
      if ($iter) $Kernel_Array$27.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      if ($truthy(self['$native?'](object))) {
        return $send($$$($$($nesting, 'Native'), 'Array'), 'new', [object].concat(Opal.to_a(args)), block.$to_proc()).$to_a()};
      return self.$_Array(object);
    }, $Kernel_Array$27.$$arity = -2), nil) && 'Array';
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting), $Object_$eq_eq$28, $Object_has_key$ques$29, $Object_each$30, $Object_$$$31, $Object_$$$eq$32, $Object_merge$excl$33, $Object_respond_to$ques$34, $Object_respond_to_missing$ques$35, $Object_method_missing$36, $Object_nil$ques$37, $Object_is_a$ques$38, $Object_instance_of$ques$39, $Object_class$40, $Object_to_a$41, $Object_inspect$42;

    self.$$prototype["native"] = nil;
    
    self.$include($$$($$$('::', 'Native'), 'Wrapper'));
    
    Opal.def(self, '$==', $Object_$eq_eq$28 = function(other) {
      var self = this;

      return self["native"] === $$$('::', 'Native').$try_convert(other)
    }, $Object_$eq_eq$28.$$arity = 1);
    
    Opal.def(self, '$has_key?', $Object_has_key$ques$29 = function(name) {
      var self = this;

      return Opal.hasOwnProperty.call(self["native"], name)
    }, $Object_has_key$ques$29.$$arity = 1);
    Opal.alias(self, "key?", "has_key?");
    Opal.alias(self, "include?", "has_key?");
    Opal.alias(self, "member?", "has_key?");
    
    Opal.def(self, '$each', $Object_each$30 = function $$each($a) {
      var $post_args, args, $iter = $Object_each$30.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Object_each$30.$$p = null;
      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if (($yield !== nil)) {
        
        
        for (var key in self["native"]) {
          Opal.yieldX($yield, [key, self["native"][key]])
        }
      ;
        return self;
      } else {
        return $send(self, 'method_missing', ["each"].concat(Opal.to_a(args)))
      };
    }, $Object_each$30.$$arity = -1);
    
    Opal.def(self, '$[]', $Object_$$$31 = function(key) {
      var self = this;

      
      var prop = self["native"][key];

      if (prop instanceof Function) {
        return prop;
      }
      else {
        return $$$('::', 'Native').$call(self["native"], key)
      }
    
    }, $Object_$$$31.$$arity = 1);
    
    Opal.def(self, '$[]=', $Object_$$$eq$32 = function(key, value) {
      var self = this, native$ = nil;

      
      native$ = $$$('::', 'Native').$try_convert(value);
      if ($truthy(native$ === nil)) {
        return self["native"][key] = value
      } else {
        return self["native"][key] = native$
      };
    }, $Object_$$$eq$32.$$arity = 2);
    
    Opal.def(self, '$merge!', $Object_merge$excl$33 = function(other) {
      var self = this;

      
      
      other = $$$('::', 'Native').$convert(other);

      for (var prop in other) {
        self["native"][prop] = other[prop];
      }
    ;
      return self;
    }, $Object_merge$excl$33.$$arity = 1);
    
    Opal.def(self, '$respond_to?', $Object_respond_to$ques$34 = function(name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return $$$('::', 'Kernel').$instance_method("respond_to?").$bind(self).$call(name, include_all);
    }, $Object_respond_to$ques$34.$$arity = -2);
    
    Opal.def(self, '$respond_to_missing?', $Object_respond_to_missing$ques$35 = function(name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return Opal.hasOwnProperty.call(self["native"], name);
    }, $Object_respond_to_missing$ques$35.$$arity = -2);
    
    Opal.def(self, '$method_missing', $Object_method_missing$36 = function $$method_missing(mid, $a) {
      var $iter = $Object_method_missing$36.$$p, block = $iter || nil, $post_args, args, self = this, $writer = nil;

      if ($iter) $Object_method_missing$36.$$p = null;
      
      
      if ($iter) $Object_method_missing$36.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      if (mid.charAt(mid.length - 1) === '=') {
        return (($writer = [mid.$slice(0, $rb_minus(mid.$length(), 1)), args['$[]'](0)]), $send(self, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
      }
      else {
        return $send($$$('::', 'Native'), 'call', [self["native"], mid].concat(Opal.to_a(args)), block.$to_proc());
      }
    ;
    }, $Object_method_missing$36.$$arity = -2);
    
    Opal.def(self, '$nil?', $Object_nil$ques$37 = function() {
      var self = this;

      return false
    }, $Object_nil$ques$37.$$arity = 0);
    
    Opal.def(self, '$is_a?', $Object_is_a$ques$38 = function(klass) {
      var self = this;

      return Opal.is_a(self, klass);
    }, $Object_is_a$ques$38.$$arity = 1);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$instance_of?', $Object_instance_of$ques$39 = function(klass) {
      var self = this;

      return self.$$class === klass;
    }, $Object_instance_of$ques$39.$$arity = 1);
    
    Opal.def(self, '$class', $Object_class$40 = function() {
      var self = this;

      return self.$$class;
    }, $Object_class$40.$$arity = 0);
    
    Opal.def(self, '$to_a', $Object_to_a$41 = function $$to_a(options) {
      var $iter = $Object_to_a$41.$$p, block = $iter || nil, self = this;

      if ($iter) $Object_to_a$41.$$p = null;
      
      
      if ($iter) $Object_to_a$41.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      return $send($$$($$$('::', 'Native'), 'Array'), 'new', [self["native"], options], block.$to_proc()).$to_a();
    }, $Object_to_a$41.$$arity = -1);
    return (Opal.def(self, '$inspect', $Object_inspect$42 = function $$inspect() {
      var self = this;

      return "" + "#<Native:" + (String(self["native"])) + ">"
    }, $Object_inspect$42.$$arity = 0), nil) && 'inspect';
  })($$($nesting, 'Native'), $$($nesting, 'BasicObject'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_initialize$43, $Array_each$44, $Array_$$$45, $Array_$$$eq$46, $Array_last$47, $Array_length$48, $Array_inspect$49;

    self.$$prototype.named = self.$$prototype["native"] = self.$$prototype.get = self.$$prototype.block = self.$$prototype.set = self.$$prototype.length = nil;
    
    self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
    self.$include($$($nesting, 'Enumerable'));
    
    Opal.def(self, '$initialize', $Array_initialize$43 = function $$initialize(native$, options) {
      var $iter = $Array_initialize$43.$$p, block = $iter || nil, self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

      if ($iter) $Array_initialize$43.$$p = null;
      
      
      if ($iter) $Array_initialize$43.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      $send2(self, Opal.find_super_dispatcher(self, 'initialize', $Array_initialize$43, false, true), 'initialize', [native$], null);
      self.get = (function() {if ($truthy(($ret_or_1 = options['$[]']("get")))) {
        return $ret_or_1
      } else {
        return options['$[]']("access")
      }; return nil; })();
      self.named = options['$[]']("named");
      self.set = (function() {if ($truthy(($ret_or_2 = options['$[]']("set")))) {
        return $ret_or_2
      } else {
        return options['$[]']("access")
      }; return nil; })();
      self.length = (function() {if ($truthy(($ret_or_3 = options['$[]']("length")))) {
        return $ret_or_3
      } else {
        return "length"
      }; return nil; })();
      self.block = block;
      if ($truthy(self.$length() == null)) {
        return self.$raise($$($nesting, 'ArgumentError'), "no length found on the array-like object")
      } else {
        return nil
      };
    }, $Array_initialize$43.$$arity = -2);
    
    Opal.def(self, '$each', $Array_each$44 = function $$each() {
      var $iter = $Array_each$44.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_each$44.$$p = null;
      
      
      if ($iter) $Array_each$44.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("each")
      };
      
      for (var i = 0, length = self.$length(); i < length; i++) {
        Opal.yield1(block, self['$[]'](i));
      }
    ;
      return self;
    }, $Array_each$44.$$arity = 0);
    
    Opal.def(self, '$[]', $Array_$$$45 = function(index) {
      var self = this, result = nil, $case = nil;

      
      result = (function() {$case = index;
      if ($$($nesting, 'String')['$===']($case) || $$($nesting, 'Symbol')['$===']($case)) {if ($truthy(self.named)) {
        return self["native"][self.named](index)
      } else {
        return self["native"][index]
      }}
      else if ($$($nesting, 'Integer')['$===']($case)) {if ($truthy(self.get)) {
        return self["native"][self.get](index)
      } else {
        return self["native"][index]
      }}
      else { return nil }})();
      if ($truthy(result)) {
        if ($truthy(self.block)) {
          return self.block.$call(result)
        } else {
          return self.$Native(result)
        }
      } else {
        return nil
      };
    }, $Array_$$$45.$$arity = 1);
    
    Opal.def(self, '$[]=', $Array_$$$eq$46 = function(index, value) {
      var self = this;

      if ($truthy(self.set)) {
        return self["native"][self.set](index, $$($nesting, 'Native').$convert(value))
      } else {
        return self["native"][index] = $$($nesting, 'Native').$convert(value)
      }
    }, $Array_$$$eq$46.$$arity = 2);
    
    Opal.def(self, '$last', $Array_last$47 = function $$last(count) {
      var $a, self = this, index = nil, result = nil;

      
      
      if (count == null) {
        count = nil;
      };
      if ($truthy(count)) {
        
        index = $rb_minus(self.$length(), 1);
        result = [];
        while ($truthy($rb_ge(index, 0))) {
          
          result['$<<'](self['$[]'](index));
          index = $rb_minus(index, 1);
        };
        return result;
      } else {
        return self['$[]']($rb_minus(self.$length(), 1))
      };
    }, $Array_last$47.$$arity = -1);
    
    Opal.def(self, '$length', $Array_length$48 = function $$length() {
      var self = this;

      return self["native"][self.length]
    }, $Array_length$48.$$arity = 0);
    Opal.alias(self, "to_ary", "to_a");
    return (Opal.def(self, '$inspect', $Array_inspect$49 = function $$inspect() {
      var self = this;

      return self.$to_a().$inspect()
    }, $Array_inspect$49.$$arity = 0), nil) && 'inspect';
  })($$($nesting, 'Native'), null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $Numeric_to_n$50;

    return (Opal.def(self, '$to_n', $Numeric_to_n$50 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $Numeric_to_n$50.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $Proc_to_n$51;

    return (Opal.def(self, '$to_n', $Proc_to_n$51 = function $$to_n() {
      var self = this;

      return self
    }, $Proc_to_n$51.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_n$52;

    return (Opal.def(self, '$to_n', $String_to_n$52 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $String_to_n$52.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $Regexp_to_n$53;

    return (Opal.def(self, '$to_n', $Regexp_to_n$53 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $Regexp_to_n$53.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $MatchData_to_n$54;

    self.$$prototype.matches = nil;
    return (Opal.def(self, '$to_n', $MatchData_to_n$54 = function $$to_n() {
      var self = this;

      return self.matches
    }, $MatchData_to_n$54.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $Struct_to_n$55;

    return (Opal.def(self, '$to_n', $Struct_to_n$55 = function $$to_n() {
      var $$56, self = this, result = nil;

      
      result = {};
      $send(self, 'each_pair', [], ($$56 = function(name, value){var self = $$56.$$s == null ? this : $$56.$$s;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (value == null) {
          value = nil;
        };
        return result[name] = $$($nesting, 'Native').$try_convert(value, value);}, $$56.$$s = self, $$56.$$arity = 2, $$56));
      return result;
    }, $Struct_to_n$55.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_to_n$57;

    return (Opal.def(self, '$to_n', $Array_to_n$57 = function $$to_n() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var obj = self[i];

        result.push($$($nesting, 'Native').$try_convert(obj, obj));
      }

      return result;
    
    }, $Array_to_n$57.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting), $Boolean_to_n$58;

    return (Opal.def(self, '$to_n', $Boolean_to_n$58 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $Boolean_to_n$58.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $Time_to_n$59;

    return (Opal.def(self, '$to_n', $Time_to_n$59 = function $$to_n() {
      var self = this;

      return self
    }, $Time_to_n$59.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting), $NilClass_to_n$60;

    return (Opal.def(self, '$to_n', $NilClass_to_n$60 = function $$to_n() {
      var self = this;

      return null;
    }, $NilClass_to_n$60.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $Hash_initialize$61, $Hash_to_n$62;

    
    Opal.alias(self, "_initialize", "initialize");
    
    Opal.def(self, '$initialize', $Hash_initialize$61 = function $$initialize(defaults) {
      var $iter = $Hash_initialize$61.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_initialize$61.$$p = null;
      
      
      if ($iter) $Hash_initialize$61.$$p = null;;
      ;
      
      if (defaults != null &&
           (defaults.constructor === undefined ||
             defaults.constructor === Object)) {
        var smap = self.$$smap,
            keys = self.$$keys,
            key, value;

        for (key in defaults) {
          value = defaults[key];

          if (value &&
               (value.constructor === undefined ||
                 value.constructor === Object)) {
            smap[key] = $$($nesting, 'Hash').$new(value);
          } else if (value && value.$$is_array) {
            value = value.map(function(item) {
              if (item &&
                   (item.constructor === undefined ||
                     item.constructor === Object)) {
                return $$($nesting, 'Hash').$new(item);
              }

              return self.$Native(item);
            });
            smap[key] = value
          } else {
            smap[key] = self.$Native(value);
          }

          keys.push(key);
        }

        return self;
      }

      return $send(self, '_initialize', [defaults], block.$to_proc());
    ;
    }, $Hash_initialize$61.$$arity = -1);
    return (Opal.def(self, '$to_n', $Hash_to_n$62 = function $$to_n() {
      var self = this;

      
      var result = {},
          keys = self.$$keys,
          smap = self.$$smap,
          key, value;

      for (var i = 0, length = keys.length; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = smap[key];
        } else {
          key = key.key;
          value = key.value;
        }

        result[key] = $$($nesting, 'Native').$try_convert(value, value);
      }

      return result;
    
    }, $Hash_to_n$62.$$arity = 0), nil) && 'to_n';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_native_module$63;

    return (Opal.def(self, '$native_module', $Module_native_module$63 = function $$native_module() {
      var self = this;

      return Opal.global[self.$name()] = self
    }, $Module_native_module$63.$$arity = 0), nil) && 'native_module'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $Class_native_alias$64, $Class_native_class$65;

    
    
    Opal.def(self, '$native_alias', $Class_native_alias$64 = function $$native_alias(new_jsid, existing_mid) {
      var self = this;

      
      var aliased = self.prototype['$' + existing_mid];
      if (!aliased) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (existing_mid) + "' for class `" + (self.$inspect()) + "'", existing_mid));
      }
      self.prototype[new_jsid] = aliased;
    
    }, $Class_native_alias$64.$$arity = 2);
    return (Opal.def(self, '$native_class', $Class_native_class$65 = function $$native_class() {
      var self = this;

      
      self.$native_module();
      return self["new"] = self.$new;;
    }, $Class_native_class$65.$$arity = 0), nil) && 'native_class';
  })($nesting[0], null, $nesting);
  return ($gvars.$ = ($gvars.global = self.$Native(Opal.global)));
};

/* Generated by Opal 1.2.0 */
Opal.modules["console"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$raise', '$==', '$arity', '$instance_exec', '$to_proc', '$new']);
  
  self.$require("native");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Console');

    var $nesting = [self].concat($parent_nesting), $Console_clear$1, $Console_trace$2, $Console_log$3, $Console_info$4, $Console_warn$5, $Console_error$6, $Console_time$7, $Console_group$8, $Console_group$excl$9;

    self.$$prototype["native"] = nil;
    
    self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
    
    Opal.def(self, '$clear', $Console_clear$1 = function $$clear() {
      var self = this;

      return self["native"].clear()
    }, $Console_clear$1.$$arity = 0);
    
    Opal.def(self, '$trace', $Console_trace$2 = function $$trace() {
      var self = this;

      return self["native"].trace()
    }, $Console_trace$2.$$arity = 0);
    
    Opal.def(self, '$log', $Console_log$3 = function $$log($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self["native"].log.apply(self["native"], args);
    }, $Console_log$3.$$arity = -1);
    
    Opal.def(self, '$info', $Console_info$4 = function $$info($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self["native"].info.apply(self["native"], args);
    }, $Console_info$4.$$arity = -1);
    
    Opal.def(self, '$warn', $Console_warn$5 = function $$warn($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self["native"].warn.apply(self["native"], args);
    }, $Console_warn$5.$$arity = -1);
    
    Opal.def(self, '$error', $Console_error$6 = function $$error($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self["native"].error.apply(self["native"], args);
    }, $Console_error$6.$$arity = -1);
    
    Opal.def(self, '$time', $Console_time$7 = function $$time(label) {
      var $iter = $Console_time$7.$$p, block = $iter || nil, self = this;

      if ($iter) $Console_time$7.$$p = null;
      
      
      if ($iter) $Console_time$7.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "no block given")
      };
      self["native"].time(label);
      
      return (function() { try {
      if (block.$arity()['$=='](0)) {
        return $send(self, 'instance_exec', [], block.$to_proc())
      } else {
        return Opal.yield1(block, self);
      }
      } finally {
        self["native"].timeEnd()
      }; })();;
    }, $Console_time$7.$$arity = 1);
    
    Opal.def(self, '$group', $Console_group$8 = function $$group($a) {
      var $iter = $Console_group$8.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Console_group$8.$$p = null;
      
      
      if ($iter) $Console_group$8.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "no block given")
      };
      self["native"].group.apply(self["native"], args);
      
      return (function() { try {
      if (block.$arity()['$=='](0)) {
        return $send(self, 'instance_exec', [], block.$to_proc())
      } else {
        return Opal.yield1(block, self);
      }
      } finally {
        self["native"].groupEnd()
      }; })();;
    }, $Console_group$8.$$arity = -1);
    return (Opal.def(self, '$group!', $Console_group$excl$9 = function($a) {
      var $iter = $Console_group$excl$9.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Console_group$excl$9.$$p = null;
      
      
      if ($iter) $Console_group$excl$9.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ((block !== nil)) {
      } else {
        return nil
      };
      self["native"].groupCollapsed.apply(self["native"], args);
      
      return (function() { try {
      if (block.$arity()['$=='](0)) {
        return $send(self, 'instance_exec', [], block.$to_proc())
      } else {
        return Opal.yield1(block, self);
      }
      } finally {
        self["native"].groupEnd()
      }; })();;
    }, $Console_group$excl$9.$$arity = -1), nil) && 'group!';
  })($nesting[0], null, $nesting);
  if ($truthy((typeof(Opal.global.console) !== "undefined"))) {
    return ($gvars.console = $$($nesting, 'Console').$new(Opal.global.console))
  } else {
    return nil
  };
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/constants/colors"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Constants');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Colors');

        var $nesting = [self].concat($parent_nesting);

        
        Opal.const_set($nesting[0], 'C_BLACK', [255, 0, 0, 0]);
        Opal.const_set($nesting[0], 'C_RED', [255, 255, 0, 0]);
        Opal.const_set($nesting[0], 'C_GREEN', [255, 0, 255, 0]);
        Opal.const_set($nesting[0], 'C_BLUE', [255, 0, 0, 255]);
        Opal.const_set($nesting[0], 'C_YELLOW', [255, 255, 255, 0]);
        Opal.const_set($nesting[0], 'C_CYAN', [255, 0, 255, 255]);
        Opal.const_set($nesting[0], 'C_MAGENTA', [255, 255, 0, 255]);
        Opal.const_set($nesting[0], 'C_WHITE', [255, 255, 255, 255]);
        return Opal.const_set($nesting[0], 'C_DEFAULT', [0, 0, 0, 0]);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/font"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $class_variable_set = Opal.class_variable_set, $truthy = Opal.truthy, $class_variable_get = Opal.class_variable_get, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new', '$Native', '$width', '$measureText', '$getContext']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Font');

      var $nesting = [self].concat($parent_nesting), $Font_default$1, $Font_default$eq$2, $Font_initialize$3, $Font_size$4, $Font_fontname$5, $Font_get_width$6, $Font__spec_str$7;

      self.$$prototype.size = self.$$prototype.orig_fontname = self.$$prototype.fontname = nil;
      
      Opal.defs(self, '$default', $Font_default$1 = function() {
        var $a, self = this, $ret_or_1 = nil;

        return $class_variable_set($nesting[0], '@@default', (function() {if ($truthy((($a = $nesting[0].$$cvars['@@default'], $a != null) ? 'class variable' : nil))) {
          
          if ($truthy(($ret_or_1 = $class_variable_get($nesting[0], '@@default', false)))) {
            return $ret_or_1
          } else {
            return $$($nesting, 'Font').$new(24)
          };
        } else {
          return $$($nesting, 'Font').$new(24)
        }; return nil; })())
      }, $Font_default$1.$$arity = 0);
      Opal.defs(self, '$default=', $Font_default$eq$2 = function(f) {
        var self = this;

        return $class_variable_set($nesting[0], '@@default', f)
      }, $Font_default$eq$2.$$arity = 1);
      
      Opal.def(self, '$initialize', $Font_initialize$3 = function $$initialize(size, fontname, option) {
        var self = this, $ret_or_2 = nil;

        
        
        if (fontname == null) {
          fontname = nil;
        };
        
        if (option == null) {
          option = $hash2([], {});
        };
        self.size = size;
        self.orig_fontname = fontname;
        return (self.fontname = (function() {if ($truthy(($ret_or_2 = fontname))) {
          return $ret_or_2
        } else {
          return "sans-serif"
        }; return nil; })());
      }, $Font_initialize$3.$$arity = -2);
      
      Opal.def(self, '$size', $Font_size$4 = function $$size() {
        var self = this;

        return self.size
      }, $Font_size$4.$$arity = 0);
      
      Opal.def(self, '$fontname', $Font_fontname$5 = function $$fontname() {
        var self = this;

        return self.orig_fontname
      }, $Font_fontname$5.$$arity = 0);
      
      Opal.def(self, '$get_width', $Font_get_width$6 = function $$get_width(string) {
        var self = this, canvas = nil;

        
        canvas = self.$Native(document.getElementById('dxopal-canvas'));
        return canvas.$getContext("2d").$measureText(string).$width();
      }, $Font_get_width$6.$$arity = 1);
      return (Opal.def(self, '$_spec_str', $Font__spec_str$7 = function $$_spec_str() {
        var self = this;

        return "" + (self.size) + "px " + (self.fontname)
      }, $Font__spec_str$7.$$arity = 0), nil) && '_spec_str';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/input"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $class_variable_get = Opal.class_variable_get, $class_variable_set = Opal.class_variable_set, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $klass = Opal.klass;

  Opal.add_stubs(['$_init_mouse_events', '$_init_touch_events', '$keyevent_target', '$keyevent_target=', '$-', '$+', '$_update_touch_info', '$key_down?', '$_pressing_keys', '$class_variable_defined?', '$raise', '$_move', '$[]', '$new', '$[]=', '$push', '$_released', '$delete_if', '$released?', '$<', '$_released_at', '$attr_reader', '$!', '$released_at', '$id', '$x', '$y', '$inspect', '$data', '$values']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Input');

      var $nesting = [self].concat($parent_nesting), $Input__pressing_keys$1, $Input__init$2, $Input__on_tick$3, $Input_x$4, $Input_y$5, $Input_key_down$ques$6, $Input_key_push$ques$7, $Input_key_release$ques$8, $Input_keyevent_target$eq$9, $Input_keyevent_target$10, $Input__init_mouse_events$11, $Input_mouse_x$12, $Input_mouse_y$13, $Input_mouse_down$ques$14, $Input_mouse_push$ques$15, $Input_mouse_release$ques$16, $Input__init_touch_events$17, $Input__update_touch_info$18, $Input_touch_x$20, $Input_touch_y$21, $Input_touch_down$ques$22, $Input_touch_push$ques$23, $Input_touch_release$ques$24, $Input_touches$30, $Input_new_touches$31;

      
      (function($base, $parent_nesting) {
        var self = $module($base, 'MouseCodes');

        var $nesting = [self].concat($parent_nesting);

        
        Opal.const_set($nesting[0], 'M_LBUTTON', 1);
        Opal.const_set($nesting[0], 'M_RBUTTON', 2);
        Opal.const_set($nesting[0], 'M_MBUTTON', 4);
        Opal.const_set($nesting[0], 'M_4TH_BUTTON', 8);
        return Opal.const_set($nesting[0], 'M_5TH_BUTTON', 16);
      })($nesting[0], $nesting);
      Opal.defs(self, '$_pressing_keys', $Input__pressing_keys$1 = function $$_pressing_keys() {
        var self = this;

        return $class_variable_get($nesting[0], '@@pressing_keys', false)
      }, $Input__pressing_keys$1.$$arity = 0);
      Opal.defs(self, '$_init', $Input__init$2 = function $$_init(canvas) {
        var self = this, rect = nil, $writer = nil;

        
        $class_variable_set($nesting[0], '@@tick', 0);
        $class_variable_set($nesting[0], '@@pressing_keys', new Object());
        $class_variable_set($nesting[0], '@@mouse_info', {x: 0, y: 0});
        $class_variable_set($nesting[0], '@@pressing_mouse_buttons', new Object());
        $class_variable_set($nesting[0], '@@touch_info', {x: 0, y: 0});
        $class_variable_set($nesting[0], '@@pressing_touch', new Object());
        $class_variable_set($nesting[0], '@@canvas', canvas);
        rect = canvas.getBoundingClientRect();
        $class_variable_set($nesting[0], '@@canvas_x', rect.left + window.pageXOffset);
        $class_variable_set($nesting[0], '@@canvas_y', rect.top  + window.pageYOffset);
        self.$_init_mouse_events();
        self.$_init_touch_events();
        if ($truthy($$($nesting, 'Input').$keyevent_target())) {
          return nil
        } else {
          
          $writer = [window];
          $send(self, 'keyevent_target=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        };
      }, $Input__init$2.$$arity = 1);
      Opal.defs(self, '$_on_tick', $Input__on_tick$3 = function $$_on_tick() {
        var self = this;

        
        $class_variable_set($nesting[0], '@@tick', $rb_plus($class_variable_get($nesting[0], '@@tick', false), 1));
        return self.$_update_touch_info();
      }, $Input__on_tick$3.$$arity = 0);
      Opal.defs(self, '$x', $Input_x$4 = function $$x(pad_number) {
        var self = this, ret = nil;

        
        
        if (pad_number == null) {
          pad_number = 0;
        };
        ret = 0;
        if ($truthy(self['$key_down?']($$($nesting, 'K_RIGHT')))) {
          ret = $rb_plus(ret, 1)};
        if ($truthy(self['$key_down?']($$($nesting, 'K_LEFT')))) {
          ret = $rb_minus(ret, 1)};
        return ret;
      }, $Input_x$4.$$arity = -1);
      Opal.defs(self, '$y', $Input_y$5 = function $$y(pad_number) {
        var self = this, ret = nil;

        
        
        if (pad_number == null) {
          pad_number = 0;
        };
        ret = 0;
        if ($truthy(self['$key_down?']($$($nesting, 'K_DOWN')))) {
          ret = $rb_plus(ret, 1)};
        if ($truthy(self['$key_down?']($$($nesting, 'K_UP')))) {
          ret = $rb_minus(ret, 1)};
        return ret;
      }, $Input_y$5.$$arity = -1);
      Opal.defs(self, '$key_down?', $Input_key_down$ques$6 = function(code) {
        var self = this;

        return $class_variable_get($nesting[0], '@@pressing_keys', false)[code] > 0
      }, $Input_key_down$ques$6.$$arity = 1);
      Opal.defs(self, '$key_push?', $Input_key_push$ques$7 = function(code) {
        var self = this;

        return $class_variable_get($nesting[0], '@@pressing_keys', false)[code] == $class_variable_get($nesting[0], '@@tick', false)-1
      }, $Input_key_push$ques$7.$$arity = 1);
      Opal.defs(self, '$key_release?', $Input_key_release$ques$8 = function(code) {
        var self = this;

        return $class_variable_get($nesting[0], '@@pressing_keys', false)[code] == -($class_variable_get($nesting[0], '@@tick', false)-1)
      }, $Input_key_release$ques$8.$$arity = 1);
      Opal.const_set($nesting[0], 'ON_KEYDOWN_', 
      function(ev){
        $$($nesting, 'Input').$_pressing_keys()[ev.code] = $class_variable_get($nesting[0], '@@tick', false);
        ev.preventDefault();
        ev.stopPropagation();
      }
    );
      Opal.const_set($nesting[0], 'ON_KEYUP_', 
      function(ev){
        $$($nesting, 'Input').$_pressing_keys()[ev.code] = -$class_variable_get($nesting[0], '@@tick', false);
        ev.preventDefault();
        ev.stopPropagation();
      }
    );
      Opal.defs(self, '$keyevent_target=', $Input_keyevent_target$eq$9 = function(target) {
        var self = this;

        
        if ($truthy(self.$keyevent_target())) {
          
          $class_variable_get($nesting[0], '@@keyevent_target', false).removeEventListener('keydown', $$($nesting, 'ON_KEYDOWN_'));
          $class_variable_get($nesting[0], '@@keyevent_target', false).removeEventListener('keyup', $$($nesting, 'ON_KEYUP_'));
        };
        $class_variable_set($nesting[0], '@@keyevent_target', target);
        
        if ($class_variable_get($nesting[0], '@@keyevent_target', false).tagName == "CANVAS") {
          $class_variable_get($nesting[0], '@@keyevent_target', false).setAttribute('tabindex', 0);
        }
        $class_variable_get($nesting[0], '@@keyevent_target', false).addEventListener('keydown', $$($nesting, 'ON_KEYDOWN_'));
        $class_variable_get($nesting[0], '@@keyevent_target', false).addEventListener('keyup', $$($nesting, 'ON_KEYUP_'));
      ;
      }, $Input_keyevent_target$eq$9.$$arity = 1);
      Opal.defs(self, '$keyevent_target', $Input_keyevent_target$10 = function $$keyevent_target() {
        var self = this;

        
        if ($truthy(self['$class_variable_defined?']("@@keyevent_target"))) {
        } else {
          return nil
        };
        return $class_variable_get($nesting[0], '@@keyevent_target', false);
      }, $Input_keyevent_target$10.$$arity = 0);
      Opal.defs(self, '$_init_mouse_events', $Input__init_mouse_events$11 = function $$_init_mouse_events() {
        var self = this;

        
        document.addEventListener('mousemove', function(ev){
          $class_variable_get($nesting[0], '@@mouse_info', false).x = ev.pageX - $class_variable_get($nesting[0], '@@canvas_x', false);
          $class_variable_get($nesting[0], '@@mouse_info', false).y = ev.pageY - $class_variable_get($nesting[0], '@@canvas_y', false);
        });
        document.addEventListener('mousedown', function(ev){
          $class_variable_get($nesting[0], '@@mouse_info', false).x = ev.pageX - $class_variable_get($nesting[0], '@@canvas_x', false);
          $class_variable_get($nesting[0], '@@mouse_info', false).y = ev.pageY - $class_variable_get($nesting[0], '@@canvas_y', false);
          for (var k=1; k<=16; k<<=1) {
            if (ev.buttons & k) {
              $class_variable_get($nesting[0], '@@pressing_mouse_buttons', false)[k] = $class_variable_get($nesting[0], '@@tick', false);
            }
          }
        });
        document.addEventListener('mouseup', function(ev){
          $class_variable_get($nesting[0], '@@mouse_info', false).x = ev.pageX - $class_variable_get($nesting[0], '@@canvas_x', false);
          $class_variable_get($nesting[0], '@@mouse_info', false).y = ev.pageY - $class_variable_get($nesting[0], '@@canvas_y', false);
          // ev.button => ev.buttons
          table = { 0: 1, 1: 4, 2: 2, 3: 8, 4: 16 };
          for (var k=1; k<=16; k<<=1) {
            if ($class_variable_get($nesting[0], '@@pressing_mouse_buttons', false)[k]) {
              $class_variable_get($nesting[0], '@@pressing_mouse_buttons', false)[table[ev.button]] = -$class_variable_get($nesting[0], '@@tick', false);
            }
          }
        });
      
      }, $Input__init_mouse_events$11.$$arity = 0);
      Opal.defs(self, '$mouse_x', $Input_mouse_x$12 = function $$mouse_x() {
        var self = this;

        return $class_variable_get($nesting[0], '@@mouse_info', false).x
      }, $Input_mouse_x$12.$$arity = 0);
      Opal.defs(self, '$mouse_y', $Input_mouse_y$13 = function $$mouse_y() {
        var self = this;

        return $class_variable_get($nesting[0], '@@mouse_info', false).y
      }, $Input_mouse_y$13.$$arity = 0);
      (function(self, $parent_nesting) {
        var $nesting = [self].concat($parent_nesting);

        
        Opal.alias(self, "mouse_pos_x", "mouse_x");
        return Opal.alias(self, "mouse_pos_y", "mouse_y");
      })(Opal.get_singleton_class(self), $nesting);
      Opal.defs(self, '$mouse_down?', $Input_mouse_down$ques$14 = function(mouse_code) {
        var self = this;

        
        if ($truthy(mouse_code)) {
        } else {
          self.$raise("missing argument of `mouse_down?'")
        };
        return $class_variable_get($nesting[0], '@@pressing_mouse_buttons', false)[mouse_code] > 0;
      }, $Input_mouse_down$ques$14.$$arity = 1);
      Opal.defs(self, '$mouse_push?', $Input_mouse_push$ques$15 = function(mouse_code) {
        var self = this;

        
        if ($truthy(mouse_code)) {
        } else {
          self.$raise("missing argument of `mouse_push?'")
        };
        return $class_variable_get($nesting[0], '@@pressing_mouse_buttons', false)[mouse_code] == -($class_variable_get($nesting[0], '@@tick', false)-1);
      }, $Input_mouse_push$ques$15.$$arity = 1);
      Opal.defs(self, '$mouse_release?', $Input_mouse_release$ques$16 = function(mouse_code) {
        var self = this;

        
        if ($truthy(mouse_code)) {
        } else {
          self.$raise("missing argument of `mouse_release?'")
        };
        return $class_variable_get($nesting[0], '@@pressing_mouse_buttons', false)[mouse_code] == -($class_variable_get($nesting[0], '@@tick', false)-1);
      }, $Input_mouse_release$ques$16.$$arity = 1);
      Opal.defs(self, '$_init_touch_events', $Input__init_touch_events$17 = function $$_init_touch_events() {
        var $a, $b, self = this, new_touch = nil, $writer = nil;

        
        $class_variable_set($nesting[0], '@@touches', $hash2([], {}));
        $class_variable_set($nesting[0], '@@new_touches', []);
        
        $class_variable_get($nesting[0], '@@canvas', false).addEventListener('touchmove', function(ev){
          ev.preventDefault();
          ev.stopPropagation();
          $class_variable_get($nesting[0], '@@touch_info', false).x = ev.changedTouches[0].pageX - $class_variable_get($nesting[0], '@@canvas_x', false);
          $class_variable_get($nesting[0], '@@touch_info', false).y = ev.changedTouches[0].pageY - $class_variable_get($nesting[0], '@@canvas_y', false);
          for (var touch of ev.changedTouches) {
            const id = touch.identifier;
            const x = touch.pageX - $class_variable_get($nesting[0], '@@canvas_x', false);
            const y = touch.pageY - $class_variable_get($nesting[0], '@@canvas_y', false);
            ($a = $class_variable_get($nesting[0], '@@touches', false)['$[]'](id), ($a === nil || $a == null) ? nil : $send($a, '_move', [x, y]))
          }
        });
        $class_variable_get($nesting[0], '@@canvas', false).addEventListener('touchstart', function(ev){
          ev.preventDefault();
          ev.stopPropagation();
          $class_variable_get($nesting[0], '@@touch_info', false).x = ev.changedTouches[0].pageX - $class_variable_get($nesting[0], '@@canvas_x', false);
          $class_variable_get($nesting[0], '@@touch_info', false).y = ev.changedTouches[0].pageY - $class_variable_get($nesting[0], '@@canvas_y', false);
          $class_variable_get($nesting[0], '@@pressing_touch', false)[0] = $class_variable_get($nesting[0], '@@tick', false);
          for (var touch of ev.changedTouches) {
            const id = touch.identifier;
            const x = touch.pageX - $class_variable_get($nesting[0], '@@canvas_x', false);
            const y = touch.pageY - $class_variable_get($nesting[0], '@@canvas_y', false);
            ((new_touch = $$($nesting, 'Touch').$new(id, x, y)), (($writer = [id, new_touch]), $send($class_variable_get($nesting[0], '@@touches', false), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]), $class_variable_get($nesting[0], '@@new_touches', false).$push(new_touch))
          }
        });
        $class_variable_get($nesting[0], '@@canvas', false).addEventListener('touchend', function(ev){
          ev.preventDefault();
          ev.stopPropagation();
          $class_variable_get($nesting[0], '@@touch_info', false).x = ev.changedTouches[0].pageX - $class_variable_get($nesting[0], '@@canvas_x', false);
          $class_variable_get($nesting[0], '@@touch_info', false).y = ev.changedTouches[0].pageY - $class_variable_get($nesting[0], '@@canvas_y', false);
          $class_variable_get($nesting[0], '@@pressing_touch', false)[0] = -$class_variable_get($nesting[0], '@@tick', false);
          for (var touch of ev.changedTouches) {
            const id = touch.identifier;
            ($b = $class_variable_get($nesting[0], '@@touches', false)['$[]'](id), ($b === nil || $b == null) ? nil : $send($b, '_released', [$class_variable_get($nesting[0], '@@tick', false)]))
          }
        });
      ;
      }, $Input__init_touch_events$17.$$arity = 0);
      Opal.defs(self, '$_update_touch_info', $Input__update_touch_info$18 = function $$_update_touch_info() {
        var $$19, self = this;

        return $send($class_variable_get($nesting[0], '@@touches', false), 'delete_if', [], ($$19 = function(id, t){var self = $$19.$$s == null ? this : $$19.$$s, $ret_or_1 = nil;

        
          
          if (id == null) {
            id = nil;
          };
          
          if (t == null) {
            t = nil;
          };
          if ($truthy(($ret_or_1 = t['$released?']()))) {
            return $rb_lt(t.$_released_at(), $rb_minus($class_variable_get($nesting[0], '@@tick', false), 1))
          } else {
            return $ret_or_1
          };}, $$19.$$s = self, $$19.$$arity = 2, $$19))
      }, $Input__update_touch_info$18.$$arity = 0);
      Opal.defs(self, '$touch_x', $Input_touch_x$20 = function $$touch_x() {
        var self = this;

        return $class_variable_get($nesting[0], '@@touch_info', false).x
      }, $Input_touch_x$20.$$arity = 0);
      Opal.defs(self, '$touch_y', $Input_touch_y$21 = function $$touch_y() {
        var self = this;

        return $class_variable_get($nesting[0], '@@touch_info', false).y
      }, $Input_touch_y$21.$$arity = 0);
      (function(self, $parent_nesting) {
        var $nesting = [self].concat($parent_nesting);

        
        Opal.alias(self, "touch_pos_x", "touch_x");
        return Opal.alias(self, "touch_pos_y", "touch_y");
      })(Opal.get_singleton_class(self), $nesting);
      Opal.defs(self, '$touch_down?', $Input_touch_down$ques$22 = function() {
        var self = this;

        return $class_variable_get($nesting[0], '@@pressing_touch', false)[0] > 0
      }, $Input_touch_down$ques$22.$$arity = 0);
      Opal.defs(self, '$touch_push?', $Input_touch_push$ques$23 = function() {
        var self = this;

        return $class_variable_get($nesting[0], '@@pressing_touch', false)[0] == -($class_variable_get($nesting[0], '@@tick', false)-1)
      }, $Input_touch_push$ques$23.$$arity = 0);
      Opal.defs(self, '$touch_release?', $Input_touch_release$ques$24 = function() {
        var self = this;

        return $class_variable_get($nesting[0], '@@pressing_touch', false)[0] == -($class_variable_get($nesting[0], '@@tick', false)-1)
      }, $Input_touch_release$ques$24.$$arity = 0);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Touch');

        var $nesting = [self].concat($parent_nesting), $Touch_initialize$25, $Touch_released$ques$26, $Touch_inspect$27, $Touch__move$28, $Touch__released$29;

        self.$$prototype._released_at = nil;
        
        
        Opal.def(self, '$initialize', $Touch_initialize$25 = function $$initialize(id, x, y) {
          var self = this;

          
          self.id = id;
          self.$_move(x, y);
          self._released_at = nil;
          return (self.data = $hash2([], {}));
        }, $Touch_initialize$25.$$arity = 3);
        self.$attr_reader("id", "x", "y", "data", "_released_at");
        
        Opal.def(self, '$released?', $Touch_released$ques$26 = function() {
          var self = this;

          return self._released_at['$!']()['$!']()
        }, $Touch_released$ques$26.$$arity = 0);
        
        Opal.def(self, '$inspect', $Touch_inspect$27 = function $$inspect() {
          var self = this, rel = nil;

          
          rel = (function() {if ($truthy(self.$released_at())) {
            return "" + " released_at=" + (self.$released_at())
          } else {
            return ""
          }; return nil; })();
          return "" + "#<DXOpal::Touch id=" + (self.$id()) + " x=" + (self.$x()) + " y=" + (self.$y()) + " data=" + (self.$data().$inspect()) + (rel) + ">";
        }, $Touch_inspect$27.$$arity = 0);
        
        Opal.def(self, '$_move', $Touch__move$28 = function $$_move(x, y) {
          var self = this;

          
          self.x = x;
          return (self.y = y);
        }, $Touch__move$28.$$arity = 2);
        return (Opal.def(self, '$_released', $Touch__released$29 = function $$_released(tick) {
          var self = this;

          return (self._released_at = tick)
        }, $Touch__released$29.$$arity = 1), nil) && '_released';
      })($nesting[0], null, $nesting);
      Opal.defs(self, '$touches', $Input_touches$30 = function $$touches() {
        var self = this;

        return $class_variable_get($nesting[0], '@@touches', false).$values()
      }, $Input_touches$30.$$arity = 0);
      return (Opal.defs(self, '$new_touches', $Input_new_touches$31 = function $$new_touches() {
        var self = this, ret = nil;

        
        ret = $class_variable_get($nesting[0], '@@new_touches', false);
        $class_variable_set($nesting[0], '@@new_touches', []);
        return ret;
      }, $Input_new_touches$31.$$arity = 0), nil) && 'new_touches';
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/input/key_codes"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Input');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'KeyCodes');

        var $nesting = [self].concat($parent_nesting);

        
        Opal.const_set($nesting[0], 'K_ESCAPE', "Escape");
        Opal.const_set($nesting[0], 'K_1', "Digit1");
        Opal.const_set($nesting[0], 'K_2', "Digit2");
        Opal.const_set($nesting[0], 'K_3', "Digit3");
        Opal.const_set($nesting[0], 'K_4', "Digit4");
        Opal.const_set($nesting[0], 'K_5', "Digit5");
        Opal.const_set($nesting[0], 'K_6', "Digit6");
        Opal.const_set($nesting[0], 'K_7', "Digit7");
        Opal.const_set($nesting[0], 'K_8', "Digit8");
        Opal.const_set($nesting[0], 'K_9', "Digit9");
        Opal.const_set($nesting[0], 'K_0', "Digit0");
        Opal.const_set($nesting[0], 'K_MINUS', "Minus");
        Opal.const_set($nesting[0], 'K_EQUALS', "Equal");
        Opal.const_set($nesting[0], 'K_BACK', "Backspace");
        Opal.const_set($nesting[0], 'K_TAB', "Tab");
        Opal.const_set($nesting[0], 'K_Q', "KeyQ");
        Opal.const_set($nesting[0], 'K_W', "KeyW");
        Opal.const_set($nesting[0], 'K_E', "KeyE");
        Opal.const_set($nesting[0], 'K_R', "KeyR");
        Opal.const_set($nesting[0], 'K_T', "KeyT");
        Opal.const_set($nesting[0], 'K_Y', "KeyY");
        Opal.const_set($nesting[0], 'K_U', "KeyU");
        Opal.const_set($nesting[0], 'K_I', "KeyI");
        Opal.const_set($nesting[0], 'K_O', "KeyO");
        Opal.const_set($nesting[0], 'K_P', "KeyP");
        Opal.const_set($nesting[0], 'K_LBRACKET', "BracketLeft");
        Opal.const_set($nesting[0], 'K_RBRACKET', "BracketRight");
        Opal.const_set($nesting[0], 'K_RETURN', "Enter");
        Opal.const_set($nesting[0], 'K_ENTER', "Enter");
        Opal.const_set($nesting[0], 'K_LCONTROL', "ControlLeft");
        Opal.const_set($nesting[0], 'K_A', "KeyA");
        Opal.const_set($nesting[0], 'K_S', "KeyS");
        Opal.const_set($nesting[0], 'K_D', "KeyD");
        Opal.const_set($nesting[0], 'K_F', "KeyF");
        Opal.const_set($nesting[0], 'K_G', "KeyG");
        Opal.const_set($nesting[0], 'K_H', "KeyH");
        Opal.const_set($nesting[0], 'K_J', "KeyJ");
        Opal.const_set($nesting[0], 'K_K', "KeyK");
        Opal.const_set($nesting[0], 'K_L', "KeyL");
        Opal.const_set($nesting[0], 'K_SEMICOLON', "Semicolon");
        Opal.const_set($nesting[0], 'K_APOSTROPHE', "Quote");
        Opal.const_set($nesting[0], 'K_GRAVE', "Backquote");
        Opal.const_set($nesting[0], 'K_LSHIFT', "ShiftLeft");
        Opal.const_set($nesting[0], 'K_BACKSLASH', "BackSlash");
        Opal.const_set($nesting[0], 'K_Z', "KeyZ");
        Opal.const_set($nesting[0], 'K_X', "KeyX");
        Opal.const_set($nesting[0], 'K_C', "KeyC");
        Opal.const_set($nesting[0], 'K_V', "KeyV");
        Opal.const_set($nesting[0], 'K_B', "KeyB");
        Opal.const_set($nesting[0], 'K_N', "KeyN");
        Opal.const_set($nesting[0], 'K_M', "KeyM");
        Opal.const_set($nesting[0], 'K_COMMA', "Comma");
        Opal.const_set($nesting[0], 'K_PERIOD', "Period");
        Opal.const_set($nesting[0], 'K_SLASH', "Slash");
        Opal.const_set($nesting[0], 'K_RSHIFT', "ShiftRight");
        Opal.const_set($nesting[0], 'K_MULTIPLY', "NumpadMultiply");
        Opal.const_set($nesting[0], 'K_SPACE', "Space");
        Opal.const_set($nesting[0], 'K_F1', "F1");
        Opal.const_set($nesting[0], 'K_F2', "F2");
        Opal.const_set($nesting[0], 'K_F3', "F3");
        Opal.const_set($nesting[0], 'K_F4', "F4");
        Opal.const_set($nesting[0], 'K_F5', "F5");
        Opal.const_set($nesting[0], 'K_F6', "F6");
        Opal.const_set($nesting[0], 'K_F7', "F7");
        Opal.const_set($nesting[0], 'K_F8', "F8");
        Opal.const_set($nesting[0], 'K_F9', "F9");
        Opal.const_set($nesting[0], 'K_F10', "F10");
        Opal.const_set($nesting[0], 'K_NUMLOCK', "NumLock");
        Opal.const_set($nesting[0], 'K_SCROLL', "ScrollLock");
        Opal.const_set($nesting[0], 'K_NUMPAD7', "Numpad7");
        Opal.const_set($nesting[0], 'K_NUMPAD8', "Numpad8");
        Opal.const_set($nesting[0], 'K_NUMPAD9', "Numpad9");
        Opal.const_set($nesting[0], 'K_SUBTRACT', "NumpadSubtract");
        Opal.const_set($nesting[0], 'K_NUMPAD4', "Numpad4");
        Opal.const_set($nesting[0], 'K_NUMPAD5', "Numpad5");
        Opal.const_set($nesting[0], 'K_NUMPAD6', "Numpad6");
        Opal.const_set($nesting[0], 'K_ADD', "NumpadAdd");
        Opal.const_set($nesting[0], 'K_NUMPAD1', "Numpad1");
        Opal.const_set($nesting[0], 'K_NUMPAD2', "Numpad2");
        Opal.const_set($nesting[0], 'K_NUMPAD3', "Numpad3");
        Opal.const_set($nesting[0], 'K_NUMPAD0', "Numpad0");
        Opal.const_set($nesting[0], 'K_DECIMAL', "NumpadDecimal");
        Opal.const_set($nesting[0], 'K_F11', "F11");
        Opal.const_set($nesting[0], 'K_F12', "F12");
        Opal.const_set($nesting[0], 'K_F13', "F13");
        Opal.const_set($nesting[0], 'K_F14', "F14");
        Opal.const_set($nesting[0], 'K_F15', "F15");
        Opal.const_set($nesting[0], 'K_KANA', "KanaMode");
        Opal.const_set($nesting[0], 'K_CONVERT', "Convert");
        Opal.const_set($nesting[0], 'K_NOCONVERT', "NonConvert");
        Opal.const_set($nesting[0], 'K_YEN', "IntlYen");
        Opal.const_set($nesting[0], 'K_COLON', "Colon");
        Opal.const_set($nesting[0], 'K_UNDERLINE', "IntlRo");
        Opal.const_set($nesting[0], 'K_NUMPADENTER', "NumpadEnter");
        Opal.const_set($nesting[0], 'K_RCONTROL', "ControlRight");
        Opal.const_set($nesting[0], 'K_MUTE', "VolumeMute");
        Opal.const_set($nesting[0], 'K_VOLUMEDOWN', "VolumeDown");
        Opal.const_set($nesting[0], 'K_VOLUMEUP', "VolumeUp");
        Opal.const_set($nesting[0], 'K_WEBHOME', "BrowserHome");
        Opal.const_set($nesting[0], 'K_DIVIDE', "NumpadDivide");
        Opal.const_set($nesting[0], 'K_PAUSE', "Pause");
        Opal.const_set($nesting[0], 'K_HOME', "Home");
        Opal.const_set($nesting[0], 'K_UP', "ArrowUp");
        Opal.const_set($nesting[0], 'K_LEFT', "ArrowLeft");
        Opal.const_set($nesting[0], 'K_RIGHT', "ArrowRight");
        Opal.const_set($nesting[0], 'K_END', "End");
        Opal.const_set($nesting[0], 'K_DOWN', "ArrowDown");
        Opal.const_set($nesting[0], 'K_INSERT', "Insert");
        Opal.const_set($nesting[0], 'K_DELETE', "Delete");
        Opal.const_set($nesting[0], 'K_WEBSEARCH', "BrowserSearch");
        Opal.const_set($nesting[0], 'K_WEBFAVORITES', "BrowserFavorites");
        Opal.const_set($nesting[0], 'K_WEBREFRESH', "BrowserRefresh");
        Opal.const_set($nesting[0], 'K_WEBSTOP', "BrowserStop");
        Opal.const_set($nesting[0], 'K_WEBFORWARD', "BrowserForward");
        Opal.const_set($nesting[0], 'K_WEBBACK', "BrowserBack");
        Opal.const_set($nesting[0], 'K_BACKSPACE', "Backspace");
        Opal.const_set($nesting[0], 'K_NUMPADSTAR', "NumpadMultiply");
        Opal.const_set($nesting[0], 'K_LALT', "AltLeft");
        Opal.const_set($nesting[0], 'K_CAPSLOCK', "CapsLock");
        Opal.const_set($nesting[0], 'K_NUMPADMINUS', "NumpadSubtract");
        Opal.const_set($nesting[0], 'K_NUMPADPLUS', "NumpadAdd");
        Opal.const_set($nesting[0], 'K_NUMPADPERIOD', "NumpadDecimal");
        Opal.const_set($nesting[0], 'K_NUMPADSLASH', "NumpadDivide");
        Opal.const_set($nesting[0], 'K_RALT', "AltRight");
        Opal.const_set($nesting[0], 'K_UPARROW', "ArrowUp");
        Opal.const_set($nesting[0], 'K_PGUP', "PageUp");
        Opal.const_set($nesting[0], 'K_LEFTARROW', "ArrowLeft");
        Opal.const_set($nesting[0], 'K_RIGHTARROW', "ArrowRight");
        Opal.const_set($nesting[0], 'K_DOWNARROW', "ArrowDown");
        return Opal.const_set($nesting[0], 'K_PGDN', "PageDown");
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/remote_resource"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $class_variable_set = Opal.class_variable_set, $send = Opal.send, $hash2 = Opal.hash2, $class_variable_get = Opal.class_variable_get, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$[]=', '$-', '$_klass_name', '$[]', '$raise', '$inspect', '$each', '$!', '$_load', '$to_proc', '$flat_map', '$values', '$call', '$last', '$split', '$name']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'RemoteResource');

      var $nesting = [self].concat($parent_nesting), $RemoteResource$1, $RemoteResource$2, $RemoteResource$3, $RemoteResource_add_class$4, $RemoteResource_register$5, $RemoteResource_$$$6, $RemoteResource__load_resources$7, $RemoteResource__load$10, $RemoteResource__klass_name$11;

      
      $class_variable_set($nesting[0], '@@resources', $send($$($nesting, 'Hash'), 'new', [], ($RemoteResource$1 = function(h, k){var self = $RemoteResource$1.$$s == null ? this : $RemoteResource$1.$$s, $writer = nil;

      
        
        if (h == null) {
          h = nil;
        };
        
        if (k == null) {
          k = nil;
        };
        $writer = [k, $hash2([], {})];
        $send(h, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, $RemoteResource$1.$$s = self, $RemoteResource$1.$$arity = 2, $RemoteResource$1)));
      $class_variable_set($nesting[0], '@@promises', $send($$($nesting, 'Hash'), 'new', [], ($RemoteResource$2 = function(h, k){var self = $RemoteResource$2.$$s == null ? this : $RemoteResource$2.$$s, $writer = nil;

      
        
        if (h == null) {
          h = nil;
        };
        
        if (k == null) {
          k = nil;
        };
        $writer = [k, $hash2([], {})];
        $send(h, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, $RemoteResource$2.$$s = self, $RemoteResource$2.$$arity = 2, $RemoteResource$2)));
      $class_variable_set($nesting[0], '@@instances', $send($$($nesting, 'Hash'), 'new', [], ($RemoteResource$3 = function(h, k){var self = $RemoteResource$3.$$s == null ? this : $RemoteResource$3.$$s, $writer = nil;

      
        
        if (h == null) {
          h = nil;
        };
        
        if (k == null) {
          k = nil;
        };
        $writer = [k, $hash2([], {})];
        $send(h, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, $RemoteResource$3.$$s = self, $RemoteResource$3.$$arity = 2, $RemoteResource$3)));
      $class_variable_set($nesting[0], '@@klasses', $hash2([], {}));
      Opal.defs(self, '$add_class', $RemoteResource_add_class$4 = function $$add_class(subklass) {
        var self = this, $writer = nil;

        
        $writer = [subklass.$_klass_name(), subklass];
        $send($class_variable_get($nesting[0], '@@klasses', false), '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }, $RemoteResource_add_class$4.$$arity = 1);
      Opal.defs(self, '$register', $RemoteResource_register$5 = function $$register(name, $a) {
        var $iter = $RemoteResource_register$5.$$p, block = $iter || nil, $post_args, args, self = this, $ret_or_1 = nil, $writer = nil;

        if ($iter) $RemoteResource_register$5.$$p = null;
        
        
        if ($iter) $RemoteResource_register$5.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        args = $post_args;;
        if ($truthy(($ret_or_1 = $class_variable_get($nesting[0], '@@resources', false)['$[]'](self.$_klass_name())))) {
          $ret_or_1
        } else {
          
          $writer = [self.$_klass_name(), $hash2([], {})];
          $send($class_variable_get($nesting[0], '@@resources', false), '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };
        
        $writer = [name, [block, args]];
        $send($class_variable_get($nesting[0], '@@resources', false)['$[]'](self.$_klass_name()), '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      }, $RemoteResource_register$5.$$arity = -2);
      Opal.defs(self, '$[]', $RemoteResource_$$$6 = function(name) {
        var self = this, ret = nil;

        if ($truthy((ret = $class_variable_get($nesting[0], '@@instances', false)['$[]'](self.$_klass_name())['$[]'](name)))) {
          return ret
        } else {
          return self.$raise("" + (self.$_klass_name()) + " " + (name.$inspect()) + " is not registered")
        }
      }, $RemoteResource_$$$6.$$arity = 1);
      Opal.defs(self, '$_load_resources', $RemoteResource__load_resources$7 = function $$_load_resources() {
        var $iter = $RemoteResource__load_resources$7.$$p, block = $iter || nil, $$8, self = this, promises = nil;

        if ($iter) $RemoteResource__load_resources$7.$$p = null;
        
        
        if ($iter) $RemoteResource__load_resources$7.$$p = null;;
        $send($class_variable_get($nesting[0], '@@resources', false), 'each', [], ($$8 = function(klass_name, items){var self = $$8.$$s == null ? this : $$8.$$s, $$9, klass = nil;

        
          
          if (klass_name == null) {
            klass_name = nil;
          };
          
          if (items == null) {
            items = nil;
          };
          klass = $class_variable_get($nesting[0], '@@klasses', false)['$[]'](klass_name);
          return $send(items, 'each', [], ($$9 = function(name, $mlhs_tmp1){var self = $$9.$$s == null ? this : $$9.$$s, $a, $b, block2 = nil, args = nil, instance = nil, promise = nil, $writer = nil;

          
            
            if (name == null) {
              name = nil;
            };
            
            if ($mlhs_tmp1 == null) {
              $mlhs_tmp1 = nil;
            };
            $b = $mlhs_tmp1, $a = Opal.to_ary($b), (block2 = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), $b;
            if ($truthy($class_variable_get($nesting[0], '@@promises', false)['$[]'](klass_name)['$[]'](name)['$!']())) {
              
              $b = $send(klass, '_load', Opal.to_a(args), block2.$to_proc()), $a = Opal.to_ary($b), (instance = ($a[0] == null ? nil : $a[0])), (promise = ($a[1] == null ? nil : $a[1])), $b;
              
              $writer = [name, instance];
              $send($class_variable_get($nesting[0], '@@instances', false)['$[]'](klass_name), '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              
              $writer = [name, promise];
              $send($class_variable_get($nesting[0], '@@promises', false)['$[]'](klass_name), '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];;
            } else {
              return nil
            };}, $$9.$$s = self, $$9.$$arity = 2, $$9.$$has_top_level_mlhs_arg = true, $$9));}, $$8.$$s = self, $$8.$$arity = 2, $$8));
        promises = $send($class_variable_get($nesting[0], '@@promises', false).$values(), 'flat_map', [], "values".$to_proc());
        
        Promise.all(promises).then(function() {
          block.$call()
        });
      ;
      }, $RemoteResource__load_resources$7.$$arity = 0);
      Opal.defs(self, '$_load', $RemoteResource__load$10 = function $$_load($a) {
        var $post_args, args, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        return self.$raise("override me");
      }, $RemoteResource__load$10.$$arity = -1);
      return (Opal.defs(self, '$_klass_name', $RemoteResource__klass_name$11 = function $$_klass_name() {
        var self = this;

        return self.$name().$split(/::/).$last()
      }, $RemoteResource__klass_name$11.$$arity = 0), nil) && '_klass_name';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/image"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$require', '$add_class', '$<', '$*', '$+', '$/', '$-', '$===', '$new', '$attr_accessor', '$loaded', '$load', '$call', '$_resize', '$box_fill', '$attr_reader', '$canvas', '$draw_ex', '$[]', '$width', '$height', '$_spec_str', '$_rgba', '$_rgba_ary', '$fill', '$_image_data', '$_put_image_data', '$flat_map', '$map', '$slice', '$length', '$raise', '$inspect', '$join']);
  
  self.$require("dxopal/remote_resource");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Image');

      var $nesting = [self].concat($parent_nesting), $Image_hsl2rgb$1, $Image__load$2, $Image_loaded$ques$3, $Image_load$4, $Image_load$5, $Image_onload$6, $Image_initialize$7, $Image__resize$8, $Image_draw$9, $Image_draw_scale$10, $Image_draw_rot$11, $Image_draw_ex$12, $Image_draw_font$13, $Image_$$$14, $Image_$$$eq$15, $Image_compare$16, $Image_line$17, $Image_box$18, $Image_box_fill$19, $Image_circle$20, $Image_circle_fill$21, $Image_triangle$22, $Image_triangle_fill$23, $Image_fill$24, $Image_clear$25, $Image_slice$26, $Image_slice_tiles$27, $Image_set_color_key$30, $Image__draw_raw_image$31, $Image__image_data$32, $Image__put_image_data$33, $Image__rgb$34, $Image__rgba$35, $Image__rgba_ary$36;

      self.$$prototype.promise = self.$$prototype.canvas = self.$$prototype.width = self.$$prototype.height = self.$$prototype.ctx = nil;
      
      $$($nesting, 'RemoteResource').$add_class($$($nesting, 'Image'));
      Opal.defs(self, '$hsl2rgb', $Image_hsl2rgb$1 = function $$hsl2rgb(h, s, l) {
        var self = this, max = nil, min = nil, $case = nil;

        
        if ($truthy($rb_lt(l, 50))) {
          
          max = $rb_times(2.55, $rb_plus(l, $rb_times(l, $rb_divide(s, 100.0))));
          min = $rb_times(2.55, $rb_minus(l, $rb_times(l, $rb_divide(s, 100.0))));
        } else {
          
          max = $rb_times(2.55, $rb_plus(l, $rb_times($rb_minus(100, l), $rb_divide(s, 100.0))));
          min = $rb_times(2.55, $rb_minus(l, $rb_times($rb_minus(100, l), $rb_divide(s, 100.0))));
        };
        return (function() {$case = h;
        if ($range(0, 60, true)['$===']($case)) {return [max, $rb_plus($rb_times($rb_divide(h, 60.0), $rb_minus(max, min)), min), min]}
        else if ($range(60, 120, true)['$===']($case)) {return [$rb_plus($rb_times($rb_divide($rb_minus(120, h), 60.0), $rb_minus(max, min)), min), max, min]}
        else if ($range(120, 180, true)['$===']($case)) {return [min, max, $rb_plus($rb_times($rb_divide($rb_minus(h, 120), 60.0), $rb_minus(max, min)), min)]}
        else if ($range(180, 240, true)['$===']($case)) {return [min, $rb_plus($rb_times($rb_divide($rb_minus(240, h), 60.0), $rb_minus(max, min)), min), max]}
        else if ($range(240, 300, true)['$===']($case)) {return [$rb_plus($rb_times($rb_divide($rb_minus(h, 240), 60.0), $rb_minus(max, min)), min), min, max]}
        else {return [max, min, $rb_plus($rb_times($rb_divide($rb_minus(360, h), 60.0), $rb_minus(max, min)), min)]}})();
      }, $Image_hsl2rgb$1.$$arity = 3);
      Opal.defs(self, '$_load', $Image__load$2 = function $$_load(path_or_url) {
        var self = this, raw_img = nil, img_promise = nil, img = nil;

        
        raw_img = new Image();
        img_promise = 
        new Promise(function(resolve, reject) {
          raw_img.onload = function() {
            resolve(raw_img);
          };
          raw_img.src = path_or_url;
        });
      ;
        img = self.$new(0, 0);
        
        img_promise.then(function(raw_img){
          img.$_resize(raw_img.width, raw_img.height);
          img.$_draw_raw_image(0, 0, raw_img);
        });
      ;
        return [img, img_promise];
      }, $Image__load$2.$$arity = 1);
      self.$attr_accessor("promise", "loaded");
      
      Opal.def(self, '$loaded?', $Image_loaded$ques$3 = function() {
        var self = this;

        return self.$loaded()
      }, $Image_loaded$ques$3.$$arity = 0);
      Opal.defs(self, '$load', $Image_load$4 = function $$load(path_or_url) {
        var self = this;

        return self.$new(1, 1).$load(path_or_url)
      }, $Image_load$4.$$arity = 1);
      
      Opal.def(self, '$load', $Image_load$5 = function $$load(path_or_url) {
        var self = this, raw_img = nil;

        
        raw_img = new Image();
        self.promise = 
        new Promise(function(resolve, reject) {
          raw_img.onload = function() {
            self.$_resize(raw_img.width, raw_img.height);
            self.$_draw_raw_image(0, 0, raw_img);
            self.loaded = true;
            resolve();
          };
          raw_img.src = path_or_url;
        });
      ;
        return self;
      }, $Image_load$5.$$arity = 1);
      
      Opal.def(self, '$onload', $Image_onload$6 = function $$onload() {
        var $iter = $Image_onload$6.$$p, block = $iter || nil, self = this;

        if ($iter) $Image_onload$6.$$p = null;
        
        
        if ($iter) $Image_onload$6.$$p = null;;
        
        self.promise.then(function(response){
          block.$call()
        });
      ;
      }, $Image_onload$6.$$arity = 0);
      
      Opal.def(self, '$initialize', $Image_initialize$7 = function $$initialize(width, height, $a, $b) {
        var $post_args, $kwargs, color, canvas, $c, self = this, $ret_or_1 = nil;

        
        
        $post_args = Opal.slice.call(arguments, 2, arguments.length);
        
        $kwargs = Opal.extract_kwargs($post_args);
        
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new('expected kwargs');
        };
        
        if ($post_args.length > 0) {
          color = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (color == null) {
          color = $$($nesting, 'C_DEFAULT');
        };
        
        canvas = $kwargs.$$smap["canvas"];
        if (canvas == null) {
          canvas = nil
        };
        $c = [width, height], (self.width = $c[0]), (self.height = $c[1]), $c;
        self.canvas = (function() {if ($truthy(($ret_or_1 = canvas))) {
          return $ret_or_1
        } else {
          return document.createElement("canvas");
        }; return nil; })();
        self.ctx = self.canvas.getContext('2d');
        self.$_resize(self.width, self.height);
        return self.$box_fill(0, 0, self.width, self.height, color);
      }, $Image_initialize$7.$$arity = -3);
      self.$attr_reader("ctx", "canvas", "width", "height");
      
      Opal.def(self, '$_resize', $Image__resize$8 = function $$_resize(w, h) {
        var $a, self = this;

        
        $a = [w, h], (self.width = $a[0]), (self.height = $a[1]), $a;
        
        self.canvas.width = w;
        self.canvas.height = h;
      ;
      }, $Image__resize$8.$$arity = 2);
      
      Opal.def(self, '$draw', $Image_draw$9 = function $$draw(x, y, image) {
        var self = this;

        
        
        self.ctx.drawImage(image.$canvas(), x, y);
      ;
        return self;
      }, $Image_draw$9.$$arity = 3);
      
      Opal.def(self, '$draw_scale', $Image_draw_scale$10 = function $$draw_scale(x, y, image, scale_x, scale_y, center_x, center_y) {
        var self = this;

        
        
        if (center_x == null) {
          center_x = nil;
        };
        
        if (center_y == null) {
          center_y = nil;
        };
        return self.$draw_ex(x, y, image, $hash2(["scale_x", "scale_y", "center_x", "center_y"], {"scale_x": scale_x, "scale_y": scale_y, "center_x": center_x, "center_y": center_y}));
      }, $Image_draw_scale$10.$$arity = -6);
      
      Opal.def(self, '$draw_rot', $Image_draw_rot$11 = function $$draw_rot(x, y, image, angle, center_x, center_y) {
        var self = this;

        
        
        if (center_x == null) {
          center_x = nil;
        };
        
        if (center_y == null) {
          center_y = nil;
        };
        return self.$draw_ex(x, y, image, $hash2(["angle", "center_x", "center_y"], {"angle": angle, "center_x": center_x, "center_y": center_y}));
      }, $Image_draw_rot$11.$$arity = -5);
      Opal.const_set($nesting[0], 'BLEND_TYPES', $hash2(["alpha", "add"], {"alpha": "source-over", "add": "lighter"}));
      
      Opal.def(self, '$draw_ex', $Image_draw_ex$12 = function $$draw_ex(x, y, image, options) {
        var self = this, scale_x = nil, $ret_or_2 = nil, scale_y = nil, $ret_or_3 = nil, center_x = nil, $ret_or_4 = nil, center_y = nil, $ret_or_5 = nil, alpha = nil, $ret_or_6 = nil, blend = nil, $ret_or_7 = nil, angle = nil, $ret_or_8 = nil, cx = nil, cy = nil;

        
        
        if (options == null) {
          options = $hash2([], {});
        };
        scale_x = (function() {if ($truthy(($ret_or_2 = options['$[]']("scale_x")))) {
          return $ret_or_2
        } else {
          return 1
        }; return nil; })();
        scale_y = (function() {if ($truthy(($ret_or_3 = options['$[]']("scale_y")))) {
          return $ret_or_3
        } else {
          return 1
        }; return nil; })();
        center_x = (function() {if ($truthy(($ret_or_4 = options['$[]']("center_x")))) {
          return $ret_or_4
        } else {
          return $rb_divide(image.$width(), 2)
        }; return nil; })();
        center_y = (function() {if ($truthy(($ret_or_5 = options['$[]']("center_y")))) {
          return $ret_or_5
        } else {
          return $rb_divide(image.$height(), 2)
        }; return nil; })();
        alpha = (function() {if ($truthy(($ret_or_6 = options['$[]']("alpha")))) {
          return $ret_or_6
        } else {
          return 255
        }; return nil; })();
        blend = (function() {if ($truthy(($ret_or_7 = options['$[]']("blend")))) {
          return $ret_or_7
        } else {
          return "alpha"
        }; return nil; })();
        angle = (function() {if ($truthy(($ret_or_8 = options['$[]']("angle")))) {
          return $ret_or_8
        } else {
          return 0
        }; return nil; })();
        cx = $rb_plus(x, center_x);
        cy = $rb_plus(y, center_y);
        
        self.ctx.translate(cx, cy);
        self.ctx.rotate(angle * Math.PI / 180.0);
        self.ctx.scale(scale_x, scale_y);
        self.ctx.save();
        self.ctx.globalAlpha = alpha / 255;
        self.ctx.globalCompositeOperation = $$($nesting, 'BLEND_TYPES')['$[]'](blend);
        self.ctx.drawImage(image.$canvas(), x-cx, y-cy);
        self.ctx.restore();
        self.ctx.setTransform(1, 0, 0, 1, 0, 0); // reset
      ;
        return self;
      }, $Image_draw_ex$12.$$arity = -4);
      
      Opal.def(self, '$draw_font', $Image_draw_font$13 = function $$draw_font(x, y, string, font, color) {
        var self = this, ctx = nil;

        
        
        if (color == null) {
          color = [255, 255, 255];
        };
        ctx = self.ctx;
        
        ctx.font = font.$_spec_str();
        ctx.textBaseline = 'top';
        ctx.fillStyle = self.$_rgba(color);
        ctx.fillText(string, x, y);
      ;
        return self;
      }, $Image_draw_font$13.$$arity = -5);
      
      Opal.def(self, '$[]', $Image_$$$14 = function(x, y) {
        var self = this, ctx = nil, ret = nil;

        
        ctx = self.ctx;
        ret = nil;
        
        var pixel = ctx.getImageData(x, y, 1, 1);
        var rgba = pixel.data;
        ret = [rgba[3], rgba[0], rgba[1], rgba[2]];
      ;
        return ret;
      }, $Image_$$$14.$$arity = 2);
      
      Opal.def(self, '$[]=', $Image_$$$eq$15 = function(x, y, color) {
        var self = this;

        return self.$box_fill(x, y, $rb_plus(x, 1), $rb_plus(y, 1), color)
      }, $Image_$$$eq$15.$$arity = 3);
      
      Opal.def(self, '$compare', $Image_compare$16 = function $$compare(x, y, color) {
        var self = this, ctx = nil, rgba1 = nil, rgba2 = nil, ret = nil;

        
        ctx = self.ctx;
        rgba1 = self.$_rgba_ary(color);
        rgba2 = nil;
        ret = nil;
        
        var pixel = ctx.getImageData(x, y, 1, 1);
        rgba2 = pixel.data;
        // TODO: what is the right way to compare an Array and an Uint8ClampedArray?
        ret = rgba1[0] == rgba2[0] &&
              rgba1[1] == rgba2[1] &&
              rgba1[2] == rgba2[2] &&
              rgba1[3] == rgba2[3]
      ;
        return ret;
      }, $Image_compare$16.$$arity = 3);
      
      Opal.def(self, '$line', $Image_line$17 = function $$line(x1, y1, x2, y2, color) {
        var self = this, ctx = nil;

        
        ctx = self.ctx;
        
        ctx.beginPath();
        ctx.strokeStyle = self.$_rgba(color);
        ctx.moveTo(x1+0.5, y1+0.5); 
        ctx.lineTo(x2+0.5, y2+0.5); 
        ctx.stroke(); 
      ;
        return self;
      }, $Image_line$17.$$arity = 5);
      
      Opal.def(self, '$box', $Image_box$18 = function $$box(x1, y1, x2, y2, color) {
        var self = this, ctx = nil;

        
        ctx = self.ctx;
        
        ctx.beginPath();
        ctx.strokeStyle = self.$_rgba(color);
        ctx.rect(x1+0.5, y1+0.5, x2-x1, y2-y1); 
        ctx.stroke(); 
      ;
        return self;
      }, $Image_box$18.$$arity = 5);
      
      Opal.def(self, '$box_fill', $Image_box_fill$19 = function $$box_fill(x1, y1, x2, y2, color) {
        var self = this, ctx = nil;

        
        ctx = self.ctx;
        
        ctx.beginPath();
        ctx.fillStyle = self.$_rgba(color);
        ctx.fillRect(x1, y1, x2-x1, y2-y1); 
      ;
        return self;
      }, $Image_box_fill$19.$$arity = 5);
      
      Opal.def(self, '$circle', $Image_circle$20 = function $$circle(x, y, r, color) {
        var self = this, ctx = nil;

        
        ctx = self.ctx;
        
        ctx.beginPath();
        ctx.strokeStyle = self.$_rgba(color);
        ctx.arc(x+0.5, y+0.5, r, 0, Math.PI*2, false)
        ctx.stroke();
      ;
        return self;
      }, $Image_circle$20.$$arity = 4);
      
      Opal.def(self, '$circle_fill', $Image_circle_fill$21 = function $$circle_fill(x, y, r, color) {
        var self = this, ctx = nil;

        
        ctx = self.ctx;
        
        ctx.beginPath();
        ctx.fillStyle = self.$_rgba(color);
        ctx.arc(x, y, r, 0, Math.PI*2, false)
        ctx.fill();
      ;
        return self;
      }, $Image_circle_fill$21.$$arity = 4);
      
      Opal.def(self, '$triangle', $Image_triangle$22 = function $$triangle(x1, y1, x2, y2, x3, y3, color) {
        var self = this, ctx = nil;

        
        ctx = self.ctx;
        
        ctx.beginPath();
        ctx.strokeStyle = self.$_rgba(color);
        ctx.moveTo(x1+0.5, y1+0.5);
        ctx.lineTo(x2+0.5, y2+0.5);
        ctx.lineTo(x3+0.5, y3+0.5);
        ctx.lineTo(x1+0.5, y1+0.5);
        ctx.stroke();
      ;
        return self;
      }, $Image_triangle$22.$$arity = 7);
      
      Opal.def(self, '$triangle_fill', $Image_triangle_fill$23 = function $$triangle_fill(x1, y1, x2, y2, x3, y3, color) {
        var self = this, ctx = nil;

        
        ctx = self.ctx;
        
        ctx.beginPath();
        ctx.fillStyle = self.$_rgba(color);
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.fill();
      ;
        return self;
      }, $Image_triangle_fill$23.$$arity = 7);
      
      Opal.def(self, '$fill', $Image_fill$24 = function $$fill(color) {
        var self = this;

        return self.$box_fill(0, 0, $rb_minus(self.width, 1), $rb_minus(self.height, 1), color)
      }, $Image_fill$24.$$arity = 1);
      
      Opal.def(self, '$clear', $Image_clear$25 = function $$clear() {
        var self = this;

        return self.$fill([0, 0, 0, 0])
      }, $Image_clear$25.$$arity = 0);
      
      Opal.def(self, '$slice', $Image_slice$26 = function $$slice(x, y, width, height) {
        var self = this, newimg = nil, data = nil;

        
        newimg = $$($nesting, 'Image').$new(width, height);
        data = self.$_image_data(x, y, width, height);
        newimg.$_put_image_data(data);
        return newimg;
      }, $Image_slice$26.$$arity = 4);
      
      Opal.def(self, '$slice_tiles', $Image_slice_tiles$27 = function $$slice_tiles(xcount, ycount) {
        var $$28, self = this, tile_w = nil, tile_h = nil;

        
        tile_w = $rb_divide(self.width, xcount);
        tile_h = $rb_divide(self.height, ycount);
        return $send(Opal.Range.$new(0,ycount, true), 'flat_map', [], ($$28 = function(v){var self = $$28.$$s == null ? this : $$28.$$s, $$29;

        
          
          if (v == null) {
            v = nil;
          };
          return $send(Opal.Range.$new(0,xcount, true), 'map', [], ($$29 = function(u){var self = $$29.$$s == null ? this : $$29.$$s;

          
            
            if (u == null) {
              u = nil;
            };
            return self.$slice($rb_times(tile_w, u), $rb_times(tile_h, v), tile_w, tile_h);}, $$29.$$s = self, $$29.$$arity = 1, $$29));}, $$28.$$s = self, $$28.$$arity = 1, $$28));
      }, $Image_slice_tiles$27.$$arity = 2);
      
      Opal.def(self, '$set_color_key', $Image_set_color_key$30 = function $$set_color_key(color) {
        var $a, $b, self = this, r = nil, g = nil, b = nil, _ = nil, data = nil;

        
        $b = self.$_rgba_ary(color), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (g = ($a[1] == null ? nil : $a[1])), (b = ($a[2] == null ? nil : $a[2])), (_ = ($a[3] == null ? nil : $a[3])), $b;
        data = self.$_image_data();
        
        var buf = data.data;

        for(var i = 0; i < buf.length; i += 4){
          if (buf[i] == r && buf[i+1] == g && buf[i+2] == b) {
            buf[i+3] = 0
          }
        }
      ;
        return self.$_put_image_data(data);
      }, $Image_set_color_key$30.$$arity = 1);
      
      Opal.def(self, '$_draw_raw_image', $Image__draw_raw_image$31 = function $$_draw_raw_image(x, y, raw_img) {
        var self = this;

        
        self.ctx.drawImage(raw_img, x, y);
      
      }, $Image__draw_raw_image$31.$$arity = 3);
      
      Opal.def(self, '$_image_data', $Image__image_data$32 = function $$_image_data(x, y, w, h) {
        var self = this;

        
        
        if (x == null) {
          x = 0;
        };
        
        if (y == null) {
          y = 0;
        };
        
        if (w == null) {
          w = self.width;
        };
        
        if (h == null) {
          h = self.height;
        };
        return self.ctx.getImageData(x, y, w, h);
      }, $Image__image_data$32.$$arity = -1);
      
      Opal.def(self, '$_put_image_data', $Image__put_image_data$33 = function $$_put_image_data(image_data, x, y) {
        var self = this;

        
        
        if (x == null) {
          x = 0;
        };
        
        if (y == null) {
          y = 0;
        };
        return self.ctx.putImageData(image_data, x, y);
      }, $Image__put_image_data$33.$$arity = -2);
      
      Opal.def(self, '$_rgb', $Image__rgb$34 = function $$_rgb(color) {
        var self = this, $case = nil, rgb = nil;

        
        $case = color.$length();
        if ((4)['$===']($case)) {rgb = color['$[]'](1, 3)}
        else if ((3)['$===']($case)) {rgb = color}
        else {self.$raise("" + "invalid color: " + (color.$inspect()))};
        return $rb_plus($rb_plus("rgb(", rgb.$join(", ")), ")");
      }, $Image__rgb$34.$$arity = 1);
      
      Opal.def(self, '$_rgba', $Image__rgba$35 = function $$_rgba(color) {
        var self = this;

        return $rb_plus($rb_plus("rgba(", self.$_rgba_ary(color).$join(", ")), ")")
      }, $Image__rgba$35.$$arity = 1);
      return (Opal.def(self, '$_rgba_ary', $Image__rgba_ary$36 = function $$_rgba_ary(color) {
        var self = this, $case = nil;

        return (function() {$case = color.$length();
        if ((4)['$===']($case)) {return $rb_plus(color['$[]'](1, 3), [$rb_divide(color['$[]'](0), 255.0)])}
        else if ((3)['$===']($case)) {return $rb_plus(color, [1.0])}
        else {return self.$raise("" + "invalid color: " + (color.$inspect()))}})()
      }, $Image__rgba_ary$36.$$arity = 1), nil) && '_rgba_ary';
    })($nesting[0], $$($nesting, 'RemoteResource'), $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/sound"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $class_variable_set = Opal.class_variable_set, $truthy = Opal.truthy, $class_variable_get = Opal.class_variable_get;

  Opal.add_stubs(['$require', '$add_class', '$new', '$audio_context', '$attr_accessor', '$raise', '$path_or_url']);
  
  self.$require("dxopal/remote_resource");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Sound');

      var $nesting = [self].concat($parent_nesting), $Sound_audio_context$1, $Sound__load$2, $Sound_initialize$3, $Sound_play$4, $Sound_stop$5;

      self.$$prototype.decoded = self.$$prototype.source = nil;
      
      $$($nesting, 'RemoteResource').$add_class($$($nesting, 'Sound'));
      Opal.defs(self, '$audio_context', $Sound_audio_context$1 = function $$audio_context() {
        var $a, self = this, $ret_or_1 = nil;

        return $class_variable_set($nesting[0], '@@audio_context', (function() {if ($truthy((($a = $nesting[0].$$cvars['@@audio_context'], $a != null) ? 'class variable' : nil))) {
          
          if ($truthy(($ret_or_1 = $class_variable_get($nesting[0], '@@audio_context', false)))) {
            return $ret_or_1
          } else {
            return         new (window.AudioContext||window.webkitAudioContext);
          };
        } else {
          return         new (window.AudioContext||window.webkitAudioContext);
        }; return nil; })())
      }, $Sound_audio_context$1.$$arity = 0);
      Opal.defs(self, '$_load', $Sound__load$2 = function $$_load(path_or_url) {
        var self = this, snd = nil, snd_promise = nil;

        
        snd = self.$new(path_or_url);
        snd_promise = 
        new Promise(function(resolve, reject) {
          var request = new XMLHttpRequest();
          request.open('GET', path_or_url, true);
          request.responseType = 'arraybuffer';
          request.onload = function() {
            var audioData = request.response;
            var context = $$($nesting, 'Sound').$audio_context();
            context.decodeAudioData(audioData, function(decoded) {
              snd['$decoded='](decoded);
              resolve();
            });
          };
          request.send();
        });
      ;
        return [snd, snd_promise];
      }, $Sound__load$2.$$arity = 1);
      
      Opal.def(self, '$initialize', $Sound_initialize$3 = function $$initialize(path_or_url) {
        var self = this;

        return (self.path_or_url = path_or_url)
      }, $Sound_initialize$3.$$arity = 1);
      self.$attr_accessor("decoded");
      
      Opal.def(self, '$play', $Sound_play$4 = function $$play() {
        var self = this, source = nil;

        
        if ($truthy(self.decoded)) {
        } else {
          self.$raise("" + "Sound " + (self.$path_or_url()) + " is not loaded yet")
        };
        source = nil;
        
        var context = $$($nesting, 'Sound').$audio_context();
        source = context.createBufferSource();
        source.buffer = self.decoded;
        source.connect(context.destination);
        source.start(0); 
      ;
        return (self.source = source);
      }, $Sound_play$4.$$arity = 0);
      return (Opal.def(self, '$stop', $Sound_stop$5 = function $$stop() {
        var self = this;

        
        if ($truthy(self.decoded)) {
        } else {
          return nil
        };
        if ($truthy(self.source)) {
        } else {
          return nil
        };
        return self.source.stop();
      }, $Sound_stop$5.$$arity = 0), nil) && 'stop';
    })($nesting[0], $$($nesting, 'RemoteResource'), $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/sound_effect"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass;

  Opal.add_stubs(['$add_class', '$new', '$audio_context', '$/', '$call', '$raise', '$+', '$inspect']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'SoundEffect');

      var $nesting = [self].concat($parent_nesting), $SoundEffect__load$1, $SoundEffect_add$2;

      
      $$($nesting, 'RemoteResource').$add_class($$($nesting, 'SoundEffect'));
      (function($base, $parent_nesting) {
        var self = $module($base, 'WaveTypes');

        var $nesting = [self].concat($parent_nesting);

        
        Opal.const_set($nesting[0], 'WAVE_SIN', "sine");
        Opal.const_set($nesting[0], 'WAVE_SAW', "sawtooth");
        Opal.const_set($nesting[0], 'WAVE_TRI', "triangle");
        return Opal.const_set($nesting[0], 'WAVE_RECT', "square");
      })($nesting[0], $nesting);
      Opal.defs(self, '$_load', $SoundEffect__load$1 = function $$_load(time, wave_type, resolution) {
        var $iter = $SoundEffect__load$1.$$p, block = $iter || nil, self = this, snd = nil, snd_promise = nil;

        if ($iter) $SoundEffect__load$1.$$p = null;
        
        
        if ($iter) $SoundEffect__load$1.$$p = null;;
        
        if (wave_type == null) {
          wave_type = $$($nesting, 'WAVE_RECT');
        };
        
        if (resolution == null) {
          resolution = 1000;
        };
        snd = self.$new("(soundeffect)");
        snd_promise = 
        new Promise(function(resolve, reject){
          var n_channels = 1;
          var context = $$($nesting, 'Sound').$audio_context();
          var n_ticks = time;
          var totalSeconds = $rb_divide(time, resolution);
          var valuesPerSecond = context.sampleRate;
          var n_values = totalSeconds * valuesPerSecond;
          var myArrayBuffer = context.createBuffer(n_channels, n_values, valuesPerSecond);
          var values = myArrayBuffer.getChannelData(0);
          var n = 0;
          for (var i = 0; i < n_ticks; i++) {
            var ret = block.$call();
            var freq = ret[0], volume = ret[1];
            if (freq < 0) freq = 0;
            if (freq > 44100) freq = 44100;
            if (volume < 0) volume = 0;
            if (volume > 255) volume = 255;
            var vol = volume / 255;   // 0.0~1.0

            var period = valuesPerSecond * 1 / freq;
            for (; n < ((i+1) / n_ticks * n_values); n++) {
              var phase = (n % period) / period; // 0.0~1.0
              var value; // -1.0~1.0
              switch(wave_type) {
              case "sine":
                value = Math.sin(2 * Math.PI * phase) * 2 - 1;
                break;
              case "sawtooth":
                value = phase * 2 - 1;
                break;
              case "triangle":
                value = phase < 0.25 ?  0+phase*4 :
                        phase < 0.5  ?  1-(phase-0.25)*4 :
                        phase < 0.75 ?  0-(phase-0.5)*4 :
                                       -1+(phase-0.75)*4;
                break;
              case "square":
                value = (phase < 0.5 ? 1 : -1);
                break;
              default:
                self.$raise($rb_plus("unknown wave_type: ", wave_type.$inspect()));
              }
              values[n] = value * vol;
            }
          }
          snd['$decoded='](myArrayBuffer);
          resolve();
        });
      ;
        return [snd, snd_promise];
      }, $SoundEffect__load$1.$$arity = -2);
      return (Opal.def(self, '$add', $SoundEffect_add$2 = function $$add(wave_type, resolution) {
        var self = this;

        
        
        if (wave_type == null) {
          wave_type = $$($nesting, 'WAVE_RECT');
        };
        
        if (resolution == null) {
          resolution = 1000;
        };
        return $$($nesting, 'TODO');
      }, $SoundEffect_add$2.$$arity = -1), nil) && 'add';
    })($nesting[0], $$($nesting, 'Sound'), $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/sprite/collision_checker"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

   (function(){

var intersect = function(x1, y1, x2, y2, x3, y3, x4, y4){
  return ((x1 - x2) * (y3 - y1) + (y1 - y2) * (x1 - x3)) *
         ((x1 - x2) * (y4 - y1) + (y1 - y2) * (x1 - x4));
};

var check_line_line = function(x1, y1, x2, y2, x3, y3, x4, y4){
  return !((((x1 - x2) * (y3 - y1) + (y1 - y2) * (x1 - x3)) *
            ((x1 - x2) * (y4 - y1) + (y1 - y2) * (x1 - x4)) > 0.0) ||
           (((x3 - x4) * (y1 - y3) + (y3 - y4) * (x3 - x1)) *
            ((x3 - x4) * (y2 - y3) + (y3 - y4) * (x3 - x2)) > 0.0 ));
};

var check_circle_line = function(x, y, r, x1, y1, x2, y2) {
  var vx = x2-x1, vy = y2-y1;
  var cx = x-x1, cy = y-y1;

  if (vx == 0 && vy == 0 )
    return CCk.check_point_circle(x, y, r, x1, y1);

  var n1 = vx * cx + vy * cy;
  if (n1 < 0)
    return cx*cx + cy*cy < r * r;

  var n2 = vx * vx + vy * vy;
  if (n1 > n2) {
    var len = (x2 - x)*(x2 - x) + (y2 - y)*(y2 - y);
    return len < r * r;
  }
  else
  {
    var n3 = cx * cx + cy * cy;
    return n3-(n1/n2)*n1 < r * r;
  }
};

var CCk = {
  check_point_circle: function(px, py, cx, cy, cr) {
    return (cr*cr) >= ((cx-px) * (cx-px) + (cy-py) * (cy-py));
  },

  check_point_straight_rect: function(x, y, x1, y1, x2, y2) {
    return ((x) >= (x1) &&
            (y) >= (y1) &&
            (x) < (x2) &&
            (y) < (y2));
  },

  check_point_triangle: function(x, y, x1, y1, x2, y2, x3, y3){
    if ((x1 - x3) * (y1 - y2) == (x1 - x2) * (y1 - y3))
      return false;

    var cx = (x1 + x2 + x3) / 3,
        cy = (y1 + y2 + y3) / 3;

    if (intersect( x1, y1, x2, y2, x, y, cx, cy ) < 0.0 ||
        intersect( x2, y2, x3, y3, x, y, cx, cy ) < 0.0 ||
        intersect( x3, y3, x1, y1, x, y, cx, cy ) < 0.0 ) {
      return false;
    }
    return true;
  },

  check_circle_circle: function(ox, oy, or, dx, dy, dr) {
    return ((or+dr) * (or+dr) >= (ox-dx) * (ox-dx) + (oy-dy) * (oy-dy));
  },

  check_ellipse_ellipse: function(E1, E2) {
     var DefAng = E1.fAngle-E2.fAngle;
     var Cos = Math.cos( DefAng );
     var Sin = Math.sin( DefAng );
     var nx = E2.fRad_X * Cos;
     var ny = -E2.fRad_X * Sin;
     var px = E2.fRad_Y * Sin;
     var py = E2.fRad_Y * Cos;
     var ox = Math.cos( E1.fAngle )*(E2.fCx-E1.fCx) + Math.sin(E1.fAngle)*(E2.fCy-E1.fCy);
     var oy = -Math.sin( E1.fAngle )*(E2.fCx-E1.fCx) + Math.cos(E1.fAngle)*(E2.fCy-E1.fCy);

     var rx_pow2 = 1/(E1.fRad_X*E1.fRad_X);
     var ry_pow2 = 1/(E1.fRad_Y*E1.fRad_Y);
     var A = rx_pow2*nx*nx + ry_pow2*ny*ny;
     var B = rx_pow2*px*px + ry_pow2*py*py;
     var D = 2*rx_pow2*nx*px + 2*ry_pow2*ny*py;
     var E = 2*rx_pow2*nx*ox + 2*ry_pow2*ny*oy;
     var F = 2*rx_pow2*px*ox + 2*ry_pow2*py*oy;
     var G = (ox/E1.fRad_X)*(ox/E1.fRad_X) + (oy/E1.fRad_Y)*(oy/E1.fRad_Y) - 1;

     var tmp1 = 1/(D*D-4*A*B);
     var h = (F*D-2*E*B)*tmp1;
     var k = (E*D-2*A*F)*tmp1;
     var Th = (B-A)==0 ? 0 : Math.atan( D/(B-A) ) * 0.5;

     var CosTh = Math.cos(Th);
     var SinTh = Math.sin(Th);
     var A_tt = A*CosTh*CosTh + B*SinTh*SinTh - D*CosTh*SinTh;
     var B_tt = A*SinTh*SinTh + B*CosTh*CosTh + D*CosTh*SinTh;
     var KK = A*h*h + B*k*k + D*h*k - E*h - F*k + G > 0 ? 0 : A*h*h + B*k*k + D*h*k - E*h - F*k + G;
     var Rx_tt = 1+Math.sqrt(-KK/A_tt);
     var Ry_tt = 1+Math.sqrt(-KK/B_tt);
     var x_tt = CosTh*h-SinTh*k;
     var y_tt = SinTh*h+CosTh*k;
     var JudgeValue = x_tt*x_tt/(Rx_tt*Rx_tt) + y_tt*y_tt/(Ry_tt*Ry_tt);

     return (JudgeValue <= 1);
  },

  check_circle_tilted_rect: function(cx, cy, cr, x1, y1, x2, y2, x3, y3, x4, y4){
    return CCk.check_point_triangle(cx, cy, x1, y1, x2, y2, x3, y3) || 
           CCk.check_point_triangle(cx, cy, x1, y1, x3, y3, x4, y4) || 
           check_circle_line(cx, cy, cr, x1, y1, x2, y2) ||
           check_circle_line(cx, cy, cr, x2, y2, x3, y3) ||
           check_circle_line(cx, cy, cr, x3, y3, x4, y4) ||
           check_circle_line(cx, cy, cr, x4, y4, x1, y1);
  },

  check_circle_triangle: function(cx, cy, cr, x1, y1, x2, y2, x3, y3) {
    return CCk.check_point_triangle(cx, cy, x1, y1, x2, y2, x3, y3) || 
           check_circle_line(cx, cy, cr, x1, y1, x2, y2) ||
           check_circle_line(cx, cy, cr, x2, y2, x3, y3) ||
           check_circle_line(cx, cy, cr, x3, y3, x1, y1);
  },

  check_rect_rect: function(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
    return ax1 < bx2 &&
           ay1 < by2 &&
           bx1 < ax2 &&
           by1 < ay2;
  },

  // Rect(may be tilted) vs Triangle
  check_tilted_rect_triangle: function(ox1, oy1, ox2, oy2, ox3, oy3, ox4, oy4,
                                       dx1, dy1, dx2, dy2, dx3, dy3) {
    return check_line_line(ox1, oy1, ox2, oy2, dx1, dy1, dx2, dy2) ||
           check_line_line(ox1, oy1, ox2, oy2, dx2, dy2, dx3, dy3) ||
           check_line_line(ox1, oy1, ox2, oy2, dx3, dy3, dx1, dy1) ||
           check_line_line(ox2, oy2, ox3, oy3, dx1, dy1, dx2, dy2) ||
           check_line_line(ox2, oy2, ox3, oy3, dx2, dy2, dx3, dy3) ||
           check_line_line(ox2, oy2, ox3, oy3, dx3, dy3, dx1, dy1) ||
           check_line_line(ox3, oy3, ox4, oy4, dx1, dy1, dx2, dy2) ||
           check_line_line(ox3, oy3, ox4, oy4, dx2, dy2, dx3, dy3) ||
           check_line_line(ox3, oy3, ox4, oy4, dx3, dy3, dx1, dy1) ||
           check_line_line(ox4, oy4, ox1, oy1, dx1, dy1, dx2, dy2) ||
           check_line_line(ox4, oy4, ox1, oy1, dx2, dy2, dx3, dy3) ||
           check_line_line(ox4, oy4, ox1, oy1, dx3, dy3, dx1, dy1) ||
           CCk.check_point_triangle(dx1, dy1, ox1, oy1, ox2, oy2, ox3, oy3) || 
           CCk.check_point_triangle(dx1, dy1, ox1, oy1, ox3, oy3, ox4, oy4) || 
           CCk.check_point_triangle(ox1, oy1, dx1, dy1, dx2, dy2, dx3, dy3);
  },

  // Triangle vs Triangle
  check_triangle_triangle: function(ox1, oy1, ox2, oy2, ox3, oy3,
                                    dx1, dy1, dx2, dy2, dx3, dy3) {
    return check_line_line(ox1, oy1, ox2, oy2, dx2, dy2, dx3, dy3) ||
           check_line_line(ox1, oy1, ox2, oy2, dx3, dy3, dx1, dy1) ||
           check_line_line(ox2, oy2, ox3, oy3, dx1, dy1, dx2, dy2) ||
           check_line_line(ox2, oy2, ox3, oy3, dx3, dy3, dx1, dy1) ||
           check_line_line(ox3, oy3, ox1, oy1, dx1, dy1, dx2, dy2) ||
           check_line_line(ox3, oy3, ox1, oy1, dx2, dy2, dx3, dy3) ||
           CCk.check_point_triangle(ox1, oy1, dx1, dy1, dx2, dy2, dx3, dy3) ||
           CCk.check_point_triangle(dx1, dy1, ox1, oy1, ox2, oy2, ox3, oy3);
  }
};

Opal.DXOpal.CollisionChecker = CCk;
Opal.DXOpal.CCk = CCk; // Alias

})(); 
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/sprite/collision_area"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $send2 = Opal.send2;

  Opal.add_stubs(['$require', '$attr_reader', '$raise', '$x', '$y', '$!', '$collision_sync', '$map', '$+', '$angle', '$center_x', '$center_y', '$scale_x', '$scale_y', '$first', '$absolute', '$transback', '$-@', '$type', '$===', '$==', '$absolute_pos', '$transback1', '$sprite', '$absolute_norot_pos', '$r', '$absolute_norot_poss', '$absolute_poss', '$absolute1', '$collides?', '$collides_circle?', '$private', '$circle?', '$/', '$*', '$aabb']);
  
  self.$require("dxopal/sprite/collision_checker");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Sprite');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'CollisionArea');

        var $nesting = [self].concat($parent_nesting);

        
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Base');

          var $nesting = [self].concat($parent_nesting), $Base_type$1, $Base_absolute$2, $Base_absolute1$4, $Base_transback$5, $Base_transback1$6, $Base_aabb$7;

          self.$$prototype.sprite = nil;
          
          self.$attr_reader("sprite");
          
          Opal.def(self, '$type', $Base_type$1 = function $$type() {
            var self = this;

            return self.$raise("override me")
          }, $Base_type$1.$$arity = 0);
          
          Opal.def(self, '$absolute', $Base_absolute$2 = function $$absolute(poss) {
            var $$3, self = this, ox = nil, oy = nil, angle = nil, cx = nil, cy = nil, sx = nil, sy = nil, ret = nil;

            
            ox = self.sprite.$x();
            oy = self.sprite.$y();
            if ($truthy(self.sprite.$collision_sync()['$!']())) {
              return $send(poss, 'map', [], ($$3 = function($mlhs_tmp1){var self = $$3.$$s == null ? this : $$3.$$s, $a, $b, x = nil, y = nil;

              
                
                if ($mlhs_tmp1 == null) {
                  $mlhs_tmp1 = nil;
                };
                $b = $mlhs_tmp1, $a = Opal.to_ary($b), (x = ($a[0] == null ? nil : $a[0])), (y = ($a[1] == null ? nil : $a[1])), $b;
                return [$rb_plus(x, ox), $rb_plus(y, oy)];}, $$3.$$s = self, $$3.$$arity = 1, $$3.$$has_top_level_mlhs_arg = true, $$3))};
            angle = self.sprite.$angle();
            cx = self.sprite.$center_x();
            cy = self.sprite.$center_y();
            sx = self.sprite.$scale_x();
            sy = self.sprite.$scale_y();
            ret = [];
            
            var rad = Math.PI / 180.0 * angle;
            var sin = Math.sin(rad);
            var cos = Math.cos(rad);
            poss.forEach(function(pos){
              var x = pos[0], y = pos[1];
              x2 = (x - cx) * sx * cos - (y - cy) * sy * sin + cx + ox;
              y2 = (x - cx) * sx * sin + (y - cy) * sy * cos + cy + oy;
              ret.push([x2, y2]);
            });
          ;
            return ret;
          }, $Base_absolute$2.$$arity = 1);
          
          Opal.def(self, '$absolute1', $Base_absolute1$4 = function $$absolute1(pos) {
            var self = this;

            return self.$absolute([pos]).$first()
          }, $Base_absolute1$4.$$arity = 1);
          
          Opal.def(self, '$transback', $Base_transback$5 = function $$transback(poss, sprite) {
            var self = this, angle = nil, cx = nil, cy = nil, sx = nil, sy = nil, ret = nil;

            
            if ($truthy(sprite.$collision_sync()['$!']())) {
              return poss};
            angle = sprite.$angle();
            cx = $rb_plus(sprite.$x(), sprite.$center_x());
            cy = $rb_plus(sprite.$y(), sprite.$center_y());
            sx = sprite.$scale_x();
            sy = sprite.$scale_y();
            ret = [];
            
            var rad = Math.PI / 180.0 * -angle;
            var sin = Math.sin(rad);
            var cos = Math.cos(rad);
            poss.forEach(function(pos){
              var x = pos[0], y = pos[1];
              x2 = ((x - cx) * cos - (y - cy) * sin) / sx + cx;
              y2 = ((x - cx) * sin + (y - cy) * cos) / sy + cy;
              ret.push([x2, y2]);
            });
          ;
            return ret;
          }, $Base_transback$5.$$arity = 2);
          
          Opal.def(self, '$transback1', $Base_transback1$6 = function $$transback1(pos, sprite) {
            var self = this;

            return self.$transback([pos], sprite).$first()
          }, $Base_transback1$6.$$arity = 2);
          return (Opal.def(self, '$aabb', $Base_aabb$7 = function $$aabb(poss) {
            var self = this, x1 = nil, y1 = nil, x2 = nil, y2 = nil;

            
            x1 = (y1 = $$$($$($nesting, 'Float'), 'INFINITY'));
            x2 = (y2 = $$$($$($nesting, 'Float'), 'INFINITY')['$-@']());
            
            for(var i=0; i<poss.length; i++) {
              if (poss[i][0] < x1) x1 = poss[i][0];
              if (poss[i][1] < y1) y1 = poss[i][1];
              if (poss[i][0] > x2) x2 = poss[i][0];
              if (poss[i][1] > y2) y2 = poss[i][1];
            }
          ;
            return [[x1, y1], [x2, y2]];
          }, $Base_aabb$7.$$arity = 1), nil) && 'aabb';
        })($nesting[0], null, $nesting);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Point');

          var $nesting = [self].concat($parent_nesting), $Point_initialize$8, $Point_type$9, $Point_collides$ques$10, $Point_absolute_pos$11;

          self.$$prototype.x = self.$$prototype.y = nil;
          
          
          Opal.def(self, '$initialize', $Point_initialize$8 = function $$initialize(sprite, x, y) {
            var $a, $iter = $Point_initialize$8.$$p, $yield = $iter || nil, self = this;

            if ($iter) $Point_initialize$8.$$p = null;
            
            $a = [sprite, x, y], (self.sprite = $a[0]), (self.x = $a[1]), (self.y = $a[2]), $a;
            return $send2(self, Opal.find_super_dispatcher(self, 'initialize', $Point_initialize$8, false, true), 'initialize', [], null);
          }, $Point_initialize$8.$$arity = 3);
          
          Opal.def(self, '$type', $Point_type$9 = function $$type() {
            var self = this;

            return "Point"
          }, $Point_type$9.$$arity = 0);
          
          Opal.def(self, '$collides?', $Point_collides$ques$10 = function(other) {
            var $a, $b, self = this, $case = nil, x = nil, y = nil, cx = nil, cy = nil, x1 = nil, y1 = nil, x2 = nil, y2 = nil, x3 = nil, y3 = nil;

            return (function() {$case = other.$type();
            if ("Point"['$===']($case)) {return self.$absolute_pos()['$=='](other.$absolute_pos())}
            else if ("Circle"['$===']($case)) {
            $a = [].concat(Opal.to_a(self.$transback1(self.$absolute_pos(), other.$sprite()))), (x = ($a[0] == null ? nil : $a[0])), (y = ($a[1] == null ? nil : $a[1])), $a;
            $a = [].concat(Opal.to_a(other.$absolute_norot_pos())), (cx = ($a[0] == null ? nil : $a[0])), (cy = ($a[1] == null ? nil : $a[1])), $a;
            return Opal.DXOpal.CCk.check_point_circle(x, y, cx, cy, other.$r());}
            else if ("Rect"['$===']($case)) {
            $a = [].concat(Opal.to_a(self.$transback1(self.$absolute_pos(), other.$sprite()))), (x = ($a[0] == null ? nil : $a[0])), (y = ($a[1] == null ? nil : $a[1])), $a;
            $a = [].concat(Opal.to_a(other.$absolute_norot_poss())), ($b = Opal.to_ary(($a[0] == null ? nil : $a[0])), (x1 = ($b[0] == null ? nil : $b[0])), (y1 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[1] == null ? nil : $a[1])), (x2 = ($b[0] == null ? nil : $b[0])), (y2 = ($b[1] == null ? nil : $b[1]))), $a;
            return Opal.DXOpal.CCk.check_point_straight_rect(x, y, x1, y1, x2, y2);;}
            else if ("Triangle"['$===']($case)) {
            $a = [].concat(Opal.to_a(self.$absolute_pos())), (x = ($a[0] == null ? nil : $a[0])), (y = ($a[1] == null ? nil : $a[1])), $a;
            $a = [].concat(Opal.to_a(other.$absolute_poss())), ($b = Opal.to_ary(($a[0] == null ? nil : $a[0])), (x1 = ($b[0] == null ? nil : $b[0])), (y1 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[1] == null ? nil : $a[1])), (x2 = ($b[0] == null ? nil : $b[0])), (y2 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[2] == null ? nil : $a[2])), (x3 = ($b[0] == null ? nil : $b[0])), (y3 = ($b[1] == null ? nil : $b[1]))), $a;
            return Opal.DXOpal.CCk.check_point_triangle(x, y, x1, y1, x2, y2, x3, y3);;}
            else {return self.$raise()}})()
          }, $Point_collides$ques$10.$$arity = 1);
          return (Opal.def(self, '$absolute_pos', $Point_absolute_pos$11 = function $$absolute_pos() {
            var self = this;

            return self.$absolute1([self.x, self.y])
          }, $Point_absolute_pos$11.$$arity = 0), nil) && 'absolute_pos';
        })($nesting[0], $$($nesting, 'Base'), $nesting);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Circle');

          var $nesting = [self].concat($parent_nesting), $Circle_initialize$12, $Circle_type$13, $Circle_circle$ques$14, $Circle_collides$ques$15, $Circle_absolute_pos$16, $Circle_absolute_norot_pos$17, $Circle_collides_circle$ques$18;

          self.$$prototype.sprite = self.$$prototype.r = self.$$prototype.x = self.$$prototype.y = nil;
          
          
          Opal.def(self, '$initialize', $Circle_initialize$12 = function $$initialize(sprite, x, y, r) {
            var $a, $iter = $Circle_initialize$12.$$p, $yield = $iter || nil, self = this;

            if ($iter) $Circle_initialize$12.$$p = null;
            
            $a = [sprite, x, y, r], (self.sprite = $a[0]), (self.x = $a[1]), (self.y = $a[2]), (self.r = $a[3]), $a;
            return $send2(self, Opal.find_super_dispatcher(self, 'initialize', $Circle_initialize$12, false, true), 'initialize', [], null);
          }, $Circle_initialize$12.$$arity = 4);
          self.$attr_reader("r");
          
          Opal.def(self, '$type', $Circle_type$13 = function $$type() {
            var self = this;

            return "Circle"
          }, $Circle_type$13.$$arity = 0);
          
          Opal.def(self, '$circle?', $Circle_circle$ques$14 = function() {
            var self = this;

            return self.sprite.$scale_x()['$=='](self.sprite.$scale_y())
          }, $Circle_circle$ques$14.$$arity = 0);
          
          Opal.def(self, '$collides?', $Circle_collides$ques$15 = function(other) {
            var $a, $b, self = this, $case = nil, cx = nil, cy = nil, x1 = nil, y1 = nil, x2 = nil, y2 = nil, x3 = nil, y3 = nil, x4 = nil, y4 = nil;

            return (function() {$case = other.$type();
            if ("Point"['$===']($case)) {return other['$collides?'](self)}
            else if ("Circle"['$===']($case)) {return self['$collides_circle?'](other)}
            else if ("Rect"['$===']($case)) {
            $a = [].concat(Opal.to_a(self.$absolute_norot_pos())), (cx = ($a[0] == null ? nil : $a[0])), (cy = ($a[1] == null ? nil : $a[1])), $a;
            $a = [].concat(Opal.to_a(self.$transback(other.$absolute_poss(), self.sprite))), ($b = Opal.to_ary(($a[0] == null ? nil : $a[0])), (x1 = ($b[0] == null ? nil : $b[0])), (y1 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[1] == null ? nil : $a[1])), (x2 = ($b[0] == null ? nil : $b[0])), (y2 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[2] == null ? nil : $a[2])), (x3 = ($b[0] == null ? nil : $b[0])), (y3 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[3] == null ? nil : $a[3])), (x4 = ($b[0] == null ? nil : $b[0])), (y4 = ($b[1] == null ? nil : $b[1]))), $a;
            return Opal.DXOpal.CCk.check_circle_tilted_rect(cx, cy, self.r, x1, y1, x2, y2, x3, y3, x4, y4);}
            else if ("Triangle"['$===']($case)) {
            $a = [].concat(Opal.to_a(self.$absolute_norot_pos())), (cx = ($a[0] == null ? nil : $a[0])), (cy = ($a[1] == null ? nil : $a[1])), $a;
            $a = [].concat(Opal.to_a(self.$transback(other.$absolute_poss(), self.sprite))), ($b = Opal.to_ary(($a[0] == null ? nil : $a[0])), (x1 = ($b[0] == null ? nil : $b[0])), (y1 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[1] == null ? nil : $a[1])), (x2 = ($b[0] == null ? nil : $b[0])), (y2 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[2] == null ? nil : $a[2])), (x3 = ($b[0] == null ? nil : $b[0])), (y3 = ($b[1] == null ? nil : $b[1]))), $a;
            return Opal.DXOpal.CCk.check_circle_triangle(cx, cy, self.r, x1, y1, x2, y2, x3, y3);}
            else {return self.$raise()}})()
          }, $Circle_collides$ques$15.$$arity = 1);
          
          Opal.def(self, '$absolute_pos', $Circle_absolute_pos$16 = function $$absolute_pos() {
            var self = this;

            return self.$absolute1([self.x, self.y])
          }, $Circle_absolute_pos$16.$$arity = 0);
          
          Opal.def(self, '$absolute_norot_pos', $Circle_absolute_norot_pos$17 = function $$absolute_norot_pos() {
            var self = this;

            return [$rb_plus(self.x, self.sprite.$x()), $rb_plus(self.y, self.sprite.$y())]
          }, $Circle_absolute_norot_pos$17.$$arity = 0);
          self.$private();
          return (Opal.def(self, '$collides_circle?', $Circle_collides_circle$ques$18 = function(other) {
            var $a, self = this, x1 = nil, y1 = nil, r1 = nil, x2 = nil, y2 = nil, r2 = nil, $ret_or_1 = nil, scale_x1 = nil, scale_y1 = nil, angle1 = nil, scale_x2 = nil, scale_y2 = nil, angle2 = nil, ret = nil;

            
            $a = [].concat(Opal.to_a(self.$absolute_pos())), (x1 = ($a[0] == null ? nil : $a[0])), (y1 = ($a[1] == null ? nil : $a[1])), $a;
            r1 = self.r;
            $a = [].concat(Opal.to_a(other.$absolute_pos())), (x2 = ($a[0] == null ? nil : $a[0])), (y2 = ($a[1] == null ? nil : $a[1])), $a;
            r2 = other.$r();
            if ($truthy((function() {if ($truthy(($ret_or_1 = self['$circle?']()))) {
              return other['$circle?']()
            } else {
              return $ret_or_1
            }; return nil; })())) {
              return Opal.DXOpal.CCk.check_circle_circle(x1, y1, self.r, x2, y2, other.$r())
            } else {
              
              if ($truthy(self.sprite.$collision_sync())) {
                
                scale_x1 = self.sprite.$scale_x();
                scale_y1 = self.sprite.$scale_y();
                angle1 = $rb_divide($rb_times(self.sprite.$angle(), $$$($$($nesting, 'Math'), 'PI')), 180);
              } else {
                
                scale_x1 = 1;
                scale_y1 = 1;
                angle1 = 0;
              };
              if ($truthy(other.$sprite().$collision_sync())) {
                
                scale_x2 = other.$sprite().$scale_x();
                scale_y2 = other.$sprite().$scale_y();
                angle2 = $rb_divide($rb_times(other.$sprite().$angle(), $$$($$($nesting, 'Math'), 'PI')), 180);
              } else {
                
                scale_x2 = 1;
                scale_y2 = 1;
                angle2 = 0;
              };
              ret = nil;
              
              var e1 = {
                fRad_X: scale_x1 * r1,
                fRad_Y: scale_y1 * r1,
                fAngle: angle1,
                fCx: x1,
                fCy: y1,
              }
              var e2 = {
                fRad_X: scale_x2 * r2,
                fRad_Y: scale_y2 * r2,
                fAngle: angle2,
                fCx: x2,
                fCy: y2,
              }
              ret = Opal.DXOpal.CCk.check_ellipse_ellipse(e1, e2);
            ;
              return ret;
            };
          }, $Circle_collides_circle$ques$18.$$arity = 1), nil) && 'collides_circle?';
        })($nesting[0], $$($nesting, 'Base'), $nesting);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Rect');

          var $nesting = [self].concat($parent_nesting), $Rect_initialize$19, $Rect_type$20, $Rect_inspect$21, $Rect_collides$ques$22, $Rect_absolute_poss$23, $Rect_absolute_norot_poss$24;

          self.$$prototype.x1 = self.$$prototype.y1 = self.$$prototype.x2 = self.$$prototype.y2 = self.$$prototype.sprite = self.$$prototype.poss = nil;
          
          
          Opal.def(self, '$initialize', $Rect_initialize$19 = function $$initialize(sprite, x1, y1, x2, y2) {
            var $a, $iter = $Rect_initialize$19.$$p, $yield = $iter || nil, self = this;

            if ($iter) $Rect_initialize$19.$$p = null;
            
            $a = [sprite, x1, y1, x2, y2], (self.sprite = $a[0]), (self.x1 = $a[1]), (self.y1 = $a[2]), (self.x2 = $a[3]), (self.y2 = $a[4]), $a;
            self.poss = [[x1, y1], [x2, y1], [x2, y2], [x1, y2]];
            return $send2(self, Opal.find_super_dispatcher(self, 'initialize', $Rect_initialize$19, false, true), 'initialize', [], null);
          }, $Rect_initialize$19.$$arity = 5);
          
          Opal.def(self, '$type', $Rect_type$20 = function $$type() {
            var self = this;

            return "Rect"
          }, $Rect_type$20.$$arity = 0);
          
          Opal.def(self, '$inspect', $Rect_inspect$21 = function $$inspect() {
            var self = this;

            return "" + "#<CollisionArea::Rect(" + (self.x1) + ", " + (self.y1) + ", " + (self.x2) + ", " + (self.y2) + ")>"
          }, $Rect_inspect$21.$$arity = 0);
          
          Opal.def(self, '$collides?', $Rect_collides$ques$22 = function(other) {
            var $a, $b, $c, self = this, $case = nil, ox1 = nil, oy1 = nil, ox2 = nil, oy2 = nil, dx1 = nil, dy1 = nil, dx2 = nil, dy2 = nil, ox3 = nil, oy3 = nil, ox4 = nil, oy4 = nil, dx3 = nil, dy3 = nil;

            return (function() {$case = other.$type();
            if ("Point"['$===']($case) || "Circle"['$===']($case)) {return other['$collides?'](self)}
            else if ("Rect"['$===']($case)) {
            $b = self.$absolute_norot_poss(), $a = Opal.to_ary($b), ($c = Opal.to_ary(($a[0] == null ? nil : $a[0])), (ox1 = ($c[0] == null ? nil : $c[0])), (oy1 = ($c[1] == null ? nil : $c[1]))), ($c = Opal.to_ary(($a[1] == null ? nil : $a[1])), (ox2 = ($c[0] == null ? nil : $c[0])), (oy2 = ($c[1] == null ? nil : $c[1]))), $b;
            $b = self.$aabb(self.$transback(other.$absolute_poss(), self.sprite)), $a = Opal.to_ary($b), ($c = Opal.to_ary(($a[0] == null ? nil : $a[0])), (dx1 = ($c[0] == null ? nil : $c[0])), (dy1 = ($c[1] == null ? nil : $c[1]))), ($c = Opal.to_ary(($a[1] == null ? nil : $a[1])), (dx2 = ($c[0] == null ? nil : $c[0])), (dy2 = ($c[1] == null ? nil : $c[1]))), $b;
            if ($truthy(Opal.DXOpal.CCk.check_rect_rect(ox1, oy1, ox2, oy2, dx1, dy1, dx2, dy2))) {
            } else {
              return false
            };
            $b = other.$absolute_norot_poss(), $a = Opal.to_ary($b), ($c = Opal.to_ary(($a[0] == null ? nil : $a[0])), (ox1 = ($c[0] == null ? nil : $c[0])), (oy1 = ($c[1] == null ? nil : $c[1]))), ($c = Opal.to_ary(($a[1] == null ? nil : $a[1])), (ox2 = ($c[0] == null ? nil : $c[0])), (oy2 = ($c[1] == null ? nil : $c[1]))), $b;
            $b = self.$aabb(self.$transback(self.$absolute_poss(), other.$sprite())), $a = Opal.to_ary($b), ($c = Opal.to_ary(($a[0] == null ? nil : $a[0])), (dx1 = ($c[0] == null ? nil : $c[0])), (dy1 = ($c[1] == null ? nil : $c[1]))), ($c = Opal.to_ary(($a[1] == null ? nil : $a[1])), (dx2 = ($c[0] == null ? nil : $c[0])), (dy2 = ($c[1] == null ? nil : $c[1]))), $b;
            if ($truthy(Opal.DXOpal.CCk.check_rect_rect(ox1, oy1, ox2, oy2, dx1, dy1, dx2, dy2))) {
            } else {
              return false
            };
            return true;}
            else if ("Triangle"['$===']($case)) {
            $a = [].concat(Opal.to_a(self.$absolute_poss())), ($b = Opal.to_ary(($a[0] == null ? nil : $a[0])), (ox1 = ($b[0] == null ? nil : $b[0])), (oy1 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[1] == null ? nil : $a[1])), (ox2 = ($b[0] == null ? nil : $b[0])), (oy2 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[2] == null ? nil : $a[2])), (ox3 = ($b[0] == null ? nil : $b[0])), (oy3 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[3] == null ? nil : $a[3])), (ox4 = ($b[0] == null ? nil : $b[0])), (oy4 = ($b[1] == null ? nil : $b[1]))), $a;
            $a = [].concat(Opal.to_a(other.$absolute_poss())), ($b = Opal.to_ary(($a[0] == null ? nil : $a[0])), (dx1 = ($b[0] == null ? nil : $b[0])), (dy1 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[1] == null ? nil : $a[1])), (dx2 = ($b[0] == null ? nil : $b[0])), (dy2 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[2] == null ? nil : $a[2])), (dx3 = ($b[0] == null ? nil : $b[0])), (dy3 = ($b[1] == null ? nil : $b[1]))), $a;
            Opal.DXOpal.CCk.check_tilted_rect_triangle(ox1, oy1, ox2, oy2, ox3, oy3, ox4, oy4,
                                                        dx1, dy1, dx2, dy2, dx3, dy3);}
            else {return self.$raise()}})()
          }, $Rect_collides$ques$22.$$arity = 1);
          
          Opal.def(self, '$absolute_poss', $Rect_absolute_poss$23 = function $$absolute_poss() {
            var self = this;

            return self.$absolute(self.poss)
          }, $Rect_absolute_poss$23.$$arity = 0);
          return (Opal.def(self, '$absolute_norot_poss', $Rect_absolute_norot_poss$24 = function $$absolute_norot_poss() {
            var self = this;

            return [[$rb_plus(self.x1, self.sprite.$x()), $rb_plus(self.y1, self.sprite.$y())], [$rb_plus(self.x2, self.sprite.$x()), $rb_plus(self.y2, self.sprite.$y())]]
          }, $Rect_absolute_norot_poss$24.$$arity = 0), nil) && 'absolute_norot_poss';
        })($nesting[0], $$($nesting, 'Base'), $nesting);
        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Triangle');

          var $nesting = [self].concat($parent_nesting), $Triangle_initialize$25, $Triangle_type$26, $Triangle_collides$ques$27, $Triangle_absolute_poss$28;

          self.$$prototype.poss = nil;
          
          
          Opal.def(self, '$initialize', $Triangle_initialize$25 = function $$initialize(sprite, x1, y1, x2, y2, x3, y3) {
            var $iter = $Triangle_initialize$25.$$p, $yield = $iter || nil, self = this;

            if ($iter) $Triangle_initialize$25.$$p = null;
            
            self.sprite = sprite;
            self.poss = [[x1, y1], [x2, y2], [x3, y3]];
            return $send2(self, Opal.find_super_dispatcher(self, 'initialize', $Triangle_initialize$25, false, true), 'initialize', [], null);
          }, $Triangle_initialize$25.$$arity = 7);
          
          Opal.def(self, '$type', $Triangle_type$26 = function $$type() {
            var self = this;

            return "Triangle"
          }, $Triangle_type$26.$$arity = 0);
          
          Opal.def(self, '$collides?', $Triangle_collides$ques$27 = function(other) {
            var $a, $b, self = this, $case = nil, ox1 = nil, oy1 = nil, ox2 = nil, oy2 = nil, ox3 = nil, oy3 = nil, dx1 = nil, dy1 = nil, dx2 = nil, dy2 = nil, dx3 = nil, dy3 = nil;

            return (function() {$case = other.$type();
            if ("Point"['$===']($case) || "Circle"['$===']($case) || "Rect"['$===']($case)) {return other['$collides?'](self)}
            else if ("Triangle"['$===']($case)) {
            $a = [].concat(Opal.to_a(self.$absolute_poss())), ($b = Opal.to_ary(($a[0] == null ? nil : $a[0])), (ox1 = ($b[0] == null ? nil : $b[0])), (oy1 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[1] == null ? nil : $a[1])), (ox2 = ($b[0] == null ? nil : $b[0])), (oy2 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[2] == null ? nil : $a[2])), (ox3 = ($b[0] == null ? nil : $b[0])), (oy3 = ($b[1] == null ? nil : $b[1]))), $a;
            $a = [].concat(Opal.to_a(other.$absolute_poss())), ($b = Opal.to_ary(($a[0] == null ? nil : $a[0])), (dx1 = ($b[0] == null ? nil : $b[0])), (dy1 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[1] == null ? nil : $a[1])), (dx2 = ($b[0] == null ? nil : $b[0])), (dy2 = ($b[1] == null ? nil : $b[1]))), ($b = Opal.to_ary(($a[2] == null ? nil : $a[2])), (dx3 = ($b[0] == null ? nil : $b[0])), (dy3 = ($b[1] == null ? nil : $b[1]))), $a;
            Opal.DXOpal.CCk.check_triangle_triangle(ox1, oy1, ox2, oy2, ox3, oy3,
                                                     dx1, dy1, dx2, dy2, dx3, dy3);}
            else {return self.$raise()}})()
          }, $Triangle_collides$ques$27.$$arity = 1);
          return (Opal.def(self, '$absolute_poss', $Triangle_absolute_poss$28 = function $$absolute_poss() {
            var self = this;

            return self.$absolute(self.poss)
          }, $Triangle_absolute_poss$28.$$arity = 0), nil) && 'absolute_poss';
        })($nesting[0], $$($nesting, 'Base'), $nesting);
      })($nesting[0], $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/sprite/collision_check"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$Array', '$equal?', '$select', '$is_a?', '$length', '$===', '$[]', '$__send__', '$nil?', '$new', '$width', '$height', '$attr_accessor', '$attr_reader', '$raise', '$inspect', '$x', '$any?', '$check', '$_collides?', '$_collision_area', '$!', '$_collidable?', '$collides?']);
  
  self.$require("dxopal/sprite/collision_area");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Sprite');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'CollisionCheck');

        var $nesting = [self].concat($parent_nesting), $CollisionCheck_shot$3, $CollisionCheck_hit$4, $CollisionCheck__init_collision_info$5, $CollisionCheck_collision$eq$6, $CollisionCheck_$eq_eq_eq$7, $CollisionCheck_check$8, $CollisionCheck__collides$ques$10, $CollisionCheck__collidable$ques$11;

        
        (function($base, $parent_nesting) {
          var self = $module($base, 'ClassMethods');

          var $nesting = [self].concat($parent_nesting), $ClassMethods_check$1;

          return (Opal.def(self, '$check', $ClassMethods_check$1 = function $$check(offences, defences, shot, hit) {
            var $$2, self = this, i = nil, j = nil, sprites = nil, n = nil;

            
            
            if (shot == null) {
              shot = "shot";
            };
            
            if (hit == null) {
              hit = "hit";
            };
            offences = self.$Array(offences);
            defences = self.$Array(defences);
            i = (j = 0);
            if ($truthy(offences['$equal?'](defences))) {
              
              sprites = $send(offences, 'select', [], ($$2 = function(x){var self = $$2.$$s == null ? this : $$2.$$s;

              
                
                if (x == null) {
                  x = nil;
                };
                return x['$is_a?']($$($nesting, 'Sprite'));}, $$2.$$s = self, $$2.$$arity = 1, $$2));
              n = sprites.$length();
              
              for (var i=0; i<n; i++) {
                for (var j=i+1; j<n; j++) {
                  if (sprites['$[]'](i)['$==='](sprites['$[]'](j))) {
                    sprites['$[]'](i).$__send__(hit);
                    sprites['$[]'](j).$__send__(hit);
                  }
                }
              }
            ;
            } else {
              
              for (var i=0; i<offences.length; i++) {
                for (var j=0; j<defences.length; j++) {
                  if (offences['$[]'](i)['$==='](defences['$[]'](j))) {
                    offences['$[]'](i).$__send__(shot, defences['$[]'](j));
                    defences['$[]'](j).$__send__(hit, offences['$[]'](i));
                  }
                }
              }
            
            };
          }, $ClassMethods_check$1.$$arity = -3), nil) && 'check'
        })($nesting[0], $nesting);
        
        Opal.def(self, '$shot', $CollisionCheck_shot$3 = function $$shot(other) {
          var self = this;

          return nil
        }, $CollisionCheck_shot$3.$$arity = 1);
        
        Opal.def(self, '$hit', $CollisionCheck_hit$4 = function $$hit(other) {
          var self = this;

          return nil
        }, $CollisionCheck_hit$4.$$arity = 1);
        
        Opal.def(self, '$_init_collision_info', $CollisionCheck__init_collision_info$5 = function $$_init_collision_info(image) {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil;
          if (self.collision == null) self.collision = nil;
          if (self.collision_enable == null) self.collision_enable = nil;
          if (self.collision_sync == null) self.collision_sync = nil;
          if (self._collision_area == null) self._collision_area = nil;

          
          self.collision = (function() {if ($truthy(($ret_or_1 = self.collision))) {
            return $ret_or_1
          } else {
            return nil
          }; return nil; })();
          if ($truthy(self.collision_enable['$nil?']())) {
            self.collision_enable = true};
          if ($truthy(self.collision_sync['$nil?']())) {
            self.collision_sync = true};
          return (self._collision_area = (function() {if ($truthy(($ret_or_2 = self._collision_area))) {
            return $ret_or_2
          } else if ($truthy(image)) {
            return $$$($$($nesting, 'CollisionArea'), 'Rect').$new(self, 0, 0, image.$width(), image.$height())
          } else {
            return nil
          }; return nil; })());
        }, $CollisionCheck__init_collision_info$5.$$arity = 1);
        self.$attr_accessor("collision_enable");
        self.$attr_accessor("collision_sync");
        self.$attr_reader("collision");
        self.$attr_reader("_collision_area");
        
        Opal.def(self, '$collision=', $CollisionCheck_collision$eq$6 = function(area_spec) {
          var self = this, $case = nil;

          
          self._collision_area = (function() {$case = area_spec.$length();
          if ((2)['$===']($case)) {return $send($$$($$($nesting, 'CollisionArea'), 'Point'), 'new', [self].concat(Opal.to_a(area_spec)))}
          else if ((3)['$===']($case)) {return $send($$$($$($nesting, 'CollisionArea'), 'Circle'), 'new', [self].concat(Opal.to_a(area_spec)))}
          else if ((4)['$===']($case)) {return $send($$$($$($nesting, 'CollisionArea'), 'Rect'), 'new', [self].concat(Opal.to_a(area_spec)))}
          else if ((6)['$===']($case)) {return $send($$$($$($nesting, 'CollisionArea'), 'Triangle'), 'new', [self].concat(Opal.to_a(area_spec)))}
          else {return self.$raise("" + "Inlivad area data: " + (self.$x().$inspect()))}})();
          return (self.collision = area_spec);
        }, $CollisionCheck_collision$eq$6.$$arity = 1);
        
        Opal.def(self, '$===', $CollisionCheck_$eq_eq_eq$7 = function(sprite_or_sprites) {
          var self = this;

          return self.$check(sprite_or_sprites)['$any?']()
        }, $CollisionCheck_$eq_eq_eq$7.$$arity = 1);
        
        Opal.def(self, '$check', $CollisionCheck_check$8 = function $$check(sprite_or_sprites) {
          var $$9, self = this, sprites = nil;

          
          sprites = self.$Array(sprite_or_sprites);
          return $send(sprites, 'select', [], ($$9 = function(sprite){var self = $$9.$$s == null ? this : $$9.$$s;

          
            
            if (sprite == null) {
              sprite = nil;
            };
            return self['$_collides?'](sprite);}, $$9.$$s = self, $$9.$$arity = 1, $$9));
        }, $CollisionCheck_check$8.$$arity = 1);
        
        Opal.def(self, '$_collides?', $CollisionCheck__collides$ques$10 = function(sprite) {
          var self = this, $ret_or_3 = nil, $ret_or_4 = nil;
          if (self._collision_area == null) self._collision_area = nil;

          
          if ($truthy((function() {if ($truthy(($ret_or_3 = self._collision_area['$nil?']()))) {
            return $ret_or_3
          } else {
            return sprite.$_collision_area()['$nil?']()
          }; return nil; })())) {
            self.$raise("Sprite image not set")};
          if ($truthy((function() {if ($truthy(($ret_or_4 = self['$_collidable?']()['$!']()))) {
            return $ret_or_4
          } else {
            return sprite['$_collidable?']()['$!']()
          }; return nil; })())) {
            return false};
          return self._collision_area['$collides?'](sprite.$_collision_area());
        }, $CollisionCheck__collides$ques$10.$$arity = 1);
        return (Opal.def(self, '$_collidable?', $CollisionCheck__collidable$ques$11 = function() {
          var self = this, $ret_or_5 = nil;
          if (self.vanished == null) self.vanished = nil;
          if (self.collision_enable == null) self.collision_enable = nil;

          return (function() {if ($truthy(($ret_or_5 = self.vanished['$!']()))) {
            return self.collision_enable
          } else {
            return $ret_or_5
          }; return nil; })()
        }, $CollisionCheck__collidable$ques$11.$$arity = 0), nil) && '_collidable?';
      })($nesting[0], $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/sprite/physics"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$nil?', '$x', '$raise', '$[]', '$===', '$+', '$/', '$y', '$*', '$angle', '$inspect', '$_add_matter_body', '$attr_reader', '$-', '$[]=', '$_matter_sprites', '$_matter_engine', '$_remove_matter_body', '$delete', '$_matter_runner', '$type']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Sprite');

      var $nesting = [self].concat($parent_nesting), $Sprite__matter_engine$4, $Sprite__matter_runner$5, $Sprite__matter_sprites$6, $Sprite__add_matter_body$7, $Sprite_remove_matter_body$8, $Sprite__remove_matter_body$9, $Sprite_matter_enabled$ques$10, $Sprite_matter_tick$11;

      self.$$prototype._matter_body = nil;
      
      (function($base, $parent_nesting) {
        var self = $module($base, 'Physics');

        var $nesting = [self].concat($parent_nesting), $Physics_physical_body$eq$1, $Physics__move_matter_body$2, $Physics__move_to_matter_body$3;

        
        
        Opal.def(self, '$physical_body=', $Physics_physical_body$eq$1 = function(ary) {
          var $a, self = this, type = nil, $case = nil, _ = nil, width = nil, height = nil, opts = nil, x = nil, y = nil, info = nil;
          if (self._matter_body == null) self._matter_body = nil;

          
          if ($truthy(self.$x()['$nil?']())) {
            self.$raise("Call Sprite#initialize before calling physical_body=")};
          type = ary['$[]'](0);
          $case = type;
          if ("rectangle"['$===']($case)) {
          $a = [].concat(Opal.to_a(ary)), (_ = ($a[0] == null ? nil : $a[0])), (width = ($a[1] == null ? nil : $a[1])), (height = ($a[2] == null ? nil : $a[2])), (opts = ($a[3] == null ? nil : $a[3])), $a;
          x = $rb_plus(self.$x(), $rb_divide(width, 2));
          y = $rb_plus(self.$y(), $rb_divide(height, 2));
          info = [width, height];
          opts.angle = opts.angle || $rb_divide($rb_times(self.$angle(), $$$($$($nesting, 'Math'), 'PI')), 180);
          self._matter_body = Matter.Bodies[type](x, y, width, height, opts);}
          else {self.$raise("" + "type " + (type.$inspect()) + " is unknown or not supported yet")};
          return $$($nesting, 'Sprite').$_add_matter_body(self._matter_body, type, self, info);
        }, $Physics_physical_body$eq$1.$$arity = 1);
        self.$attr_reader("_matter_body");
        
        Opal.def(self, '$_move_matter_body', $Physics__move_matter_body$2 = function $$_move_matter_body() {
          var self = this;
          if (self._matter_body == null) self._matter_body = nil;
          if (self.x == null) self.x = nil;
          if (self.center_x == null) self.center_x = nil;
          if (self.y == null) self.y = nil;
          if (self.center_y == null) self.center_y = nil;

          Matter.Body.setPosition(self._matter_body,
           Matter.Vector.create($rb_plus(self.x, self.center_x), $rb_plus(self.y, self.center_y)))
        }, $Physics__move_matter_body$2.$$arity = 0);
        return (Opal.def(self, '$_move_to_matter_body', $Physics__move_to_matter_body$3 = function $$_move_to_matter_body(mx, my) {
          var self = this;
          if (self.center_x == null) self.center_x = nil;
          if (self.center_y == null) self.center_y = nil;

          
          self.x = $rb_minus(mx, self.center_x);
          return (self.y = $rb_minus(my, self.center_y));
        }, $Physics__move_to_matter_body$3.$$arity = 2), nil) && '_move_to_matter_body';
      })($nesting[0], $nesting);
      Opal.defs(self, '$_matter_engine', $Sprite__matter_engine$4 = function $$_matter_engine() {
        var self = this, $ret_or_1 = nil;
        if (self.matter_engine == null) self.matter_engine = nil;

        return (self.matter_engine = (function() {if ($truthy(($ret_or_1 = self.matter_engine))) {
          return $ret_or_1
        } else {
          return Matter.Engine.create();
        }; return nil; })())
      }, $Sprite__matter_engine$4.$$arity = 0);
      Opal.defs(self, '$_matter_runner', $Sprite__matter_runner$5 = function $$_matter_runner() {
        var self = this, $ret_or_2 = nil;
        if (self.matter_runner == null) self.matter_runner = nil;

        return (self.matter_runner = (function() {if ($truthy(($ret_or_2 = self.matter_runner))) {
          return $ret_or_2
        } else {
          return Matter.Runner.create();
        }; return nil; })())
      }, $Sprite__matter_runner$5.$$arity = 0);
      Opal.defs(self, '$_matter_sprites', $Sprite__matter_sprites$6 = function $$_matter_sprites() {
        var self = this, $ret_or_3 = nil;
        if (self.matter_bodies == null) self.matter_bodies = nil;

        return (self.matter_bodies = (function() {if ($truthy(($ret_or_3 = self.matter_bodies))) {
          return $ret_or_3
        } else {
          return $hash2([], {})
        }; return nil; })())
      }, $Sprite__matter_sprites$6.$$arity = 0);
      Opal.defs(self, '$_add_matter_body', $Sprite__add_matter_body$7 = function $$_add_matter_body(body, type, sprite, info) {
        var self = this, $writer = nil;

        
        
        $writer = [body.id, [type, sprite, info]];
        $send(self.$_matter_sprites(), '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return Matter.World.addBody($$($nesting, 'Sprite').$_matter_engine().world, body);
      }, $Sprite__add_matter_body$7.$$arity = 4);
      
      Opal.def(self, '$remove_matter_body', $Sprite_remove_matter_body$8 = function $$remove_matter_body() {
        var self = this;

        return $$($nesting, 'Sprite').$_remove_matter_body(self._matter_body)
      }, $Sprite_remove_matter_body$8.$$arity = 0);
      Opal.defs(self, '$_remove_matter_body', $Sprite__remove_matter_body$9 = function $$_remove_matter_body(body) {
        var self = this;

        
        self.$_matter_sprites().$delete(body.id);
        return Matter.World.remove($$($nesting, 'Sprite').$_matter_engine().world, body, null);
      }, $Sprite__remove_matter_body$9.$$arity = 1);
      Opal.defs(self, '$matter_enabled?', $Sprite_matter_enabled$ques$10 = function() {
        var self = this;
        if (self.matter_engine == null) self.matter_engine = nil;

        if ($truthy(self.matter_engine)) {
          return true
        } else {
          return false
        }
      }, $Sprite_matter_enabled$ques$10.$$arity = 0);
      return (Opal.defs(self, '$matter_tick', $Sprite_matter_tick$11 = function $$matter_tick(time) {
        var self = this;

        
        Matter.Runner.tick($$($nesting, 'Sprite').$_matter_runner(), $$($nesting, 'Sprite').$_matter_engine(), time);
        Matter.Composite.allBodies($$($nesting, 'Sprite').$_matter_engine().world).forEach((body) => {
          var [type, sprite, info] = $$($nesting, 'Sprite').$_matter_sprites()['$[]'](body.id);
          switch(type) {
          case "rectangle":
            var [width, height] = info;
            sprite['$_move_to_matter_body'](body.position.x, body.position.y);
            sprite['$angle='](body.angle / Math.PI * 180);
            break;
          default:
            `self.$raise("" + "unknown type: " + (self.$type()))`
          }
        });
      
      }, $Sprite_matter_tick$11.$$arity = 1), nil) && 'matter_tick';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/sprite"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$extend', '$include', '$each', '$!', '$respond_to?', '$vanished?', '$update', '$reject!', '$nil?', '$sort_by', '$flatten', '$to_proc', '$draw', '$/', '$width', '$height', '$_init_collision_info', '$attr_accessor', '$attr_reader', '$_move_matter_body', '$-', '$collision=', '$raise', '$draw_ex']);
  
  self.$require("dxopal/sprite/collision_check");
  self.$require("dxopal/sprite/physics");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Sprite');

      var $nesting = [self].concat($parent_nesting), $Sprite_update$1, $Sprite_clean$3, $Sprite_draw$5, $Sprite_initialize$7, $Sprite_x$eq$8, $Sprite_y$eq$9, $Sprite_image$10, $Sprite_image$eq$11, $Sprite_vanish$12, $Sprite_vanished$ques$13, $Sprite_draw$14;

      self.$$prototype.image = self.$$prototype._matter_body = self.$$prototype.collision = self.$$prototype.center_x = self.$$prototype.vanished = self.$$prototype.visible = self.$$prototype.x = self.$$prototype.y = self.$$prototype.scale_x = self.$$prototype.scale_y = self.$$prototype.alpha = self.$$prototype.blend = self.$$prototype.angle = self.$$prototype.center_y = nil;
      
      self.$extend($$$($$$($$$($$($nesting, 'DXOpal'), 'Sprite'), 'CollisionCheck'), 'ClassMethods'));
      self.$include($$$($$$($$($nesting, 'DXOpal'), 'Sprite'), 'CollisionCheck'));
      self.$include($$$($$$($$($nesting, 'DXOpal'), 'Sprite'), 'Physics'));
      Opal.defs(self, '$update', $Sprite_update$1 = function $$update(sprites) {
        var $$2, self = this;

        return $send(sprites, 'each', [], ($$2 = function(sprite){var self = $$2.$$s == null ? this : $$2.$$s, $ret_or_1 = nil;

        
          
          if (sprite == null) {
            sprite = nil;
          };
          if ($truthy(sprite['$respond_to?']("update")['$!']())) {
            return nil;};
          if ($truthy((function() {if ($truthy(($ret_or_1 = sprite['$respond_to?']("vanished?")))) {
            return sprite['$vanished?']()
          } else {
            return $ret_or_1
          }; return nil; })())) {
            return nil;};
          return sprite.$update();}, $$2.$$s = self, $$2.$$arity = 1, $$2))
      }, $Sprite_update$1.$$arity = 1);
      Opal.defs(self, '$clean', $Sprite_clean$3 = function $$clean(sprites) {
        var $$4, self = this;

        return $send(sprites, 'reject!', [], ($$4 = function(sprite){var self = $$4.$$s == null ? this : $$4.$$s, $ret_or_2 = nil;

        
          
          if (sprite == null) {
            sprite = nil;
          };
          if ($truthy(($ret_or_2 = sprite['$nil?']()))) {
            return $ret_or_2
          } else {
            return sprite['$vanished?']()
          };}, $$4.$$s = self, $$4.$$arity = 1, $$4))
      }, $Sprite_clean$3.$$arity = 1);
      Opal.defs(self, '$draw', $Sprite_draw$5 = function $$draw(sprites) {
        var $$6, self = this;

        return $send($send(sprites.$flatten(), 'sort_by', [], "z".$to_proc()), 'each', [], ($$6 = function(sprite){var self = $$6.$$s == null ? this : $$6.$$s, $ret_or_3 = nil;

        
          
          if (sprite == null) {
            sprite = nil;
          };
          if ($truthy((function() {if ($truthy(($ret_or_3 = sprite['$respond_to?']("vanished?")))) {
            return sprite['$vanished?']()
          } else {
            return $ret_or_3
          }; return nil; })())) {
            return nil;};
          return sprite.$draw();}, $$6.$$s = self, $$6.$$arity = 1, $$6))
      }, $Sprite_draw$5.$$arity = 1);
      
      Opal.def(self, '$initialize', $Sprite_initialize$7 = function $$initialize(x, y, image) {
        var $a, self = this;

        
        
        if (x == null) {
          x = 0;
        };
        
        if (y == null) {
          y = 0;
        };
        
        if (image == null) {
          image = nil;
        };
        $a = [x, y, image], (self.x = $a[0]), (self.y = $a[1]), (self.image = $a[2]), $a;
        self.z = 0;
        self.angle = 0;
        self.scale_x = (self.scale_y = 1.0);
        if ($truthy(image)) {
          
          self.center_x = $rb_divide(image.$width(), 2);
          self.center_y = $rb_divide(image.$height(), 2);};
        self.visible = true;
        self.vanished = false;
        return self.$_init_collision_info(self.image);
      }, $Sprite_initialize$7.$$arity = -1);
      self.$attr_accessor("z", "visible");
      self.$attr_accessor("angle");
      self.$attr_accessor("scale_x", "scale_y");
      self.$attr_accessor("center_x", "center_y");
      self.$attr_accessor("alpha");
      self.$attr_accessor("blend");
      self.$attr_reader("x", "y");
      
      Opal.def(self, '$x=', $Sprite_x$eq$8 = function(newx) {
        var self = this;

        
        self.x = newx;
        if ($truthy(self._matter_body)) {
          return self.$_move_matter_body()
        } else {
          return nil
        };
      }, $Sprite_x$eq$8.$$arity = 1);
      
      Opal.def(self, '$y=', $Sprite_y$eq$9 = function(newy) {
        var self = this;

        
        self.y = newy;
        if ($truthy(self._matter_body)) {
          return self.$_move_matter_body()
        } else {
          return nil
        };
      }, $Sprite_y$eq$9.$$arity = 1);
      
      Opal.def(self, '$image', $Sprite_image$10 = function $$image() {
        var self = this;

        return self.image
      }, $Sprite_image$10.$$arity = 0);
      
      Opal.def(self, '$image=', $Sprite_image$eq$11 = function(img) {
        var self = this, $writer = nil;

        
        self.image = img;
        if ($truthy(self.collision['$nil?']())) {
          
          $writer = [[0, 0, $rb_minus(img.$width(), 1), $rb_minus(img.$height(), 1)]];
          $send(self, 'collision=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if ($truthy(self.center_x['$nil?']())) {
          
          self.center_x = $rb_divide(img.$width(), 2);
          return (self.center_y = $rb_divide(img.$height(), 2));
        } else {
          return nil
        };
      }, $Sprite_image$eq$11.$$arity = 1);
      
      Opal.def(self, '$vanish', $Sprite_vanish$12 = function $$vanish() {
        var self = this;

        return (self.vanished = true)
      }, $Sprite_vanish$12.$$arity = 0);
      
      Opal.def(self, '$vanished?', $Sprite_vanished$ques$13 = function() {
        var self = this;

        return self.vanished
      }, $Sprite_vanished$ques$13.$$arity = 0);
      return (Opal.def(self, '$draw', $Sprite_draw$14 = function $$draw() {
        var self = this;

        
        if ($truthy(self.image['$nil?']())) {
          self.$raise("image not set to Sprite")};
        if ($truthy(self.visible['$!']())) {
          return nil};
        return $$($nesting, 'Window').$draw_ex(self.x, self.y, self.image, $hash2(["scale_x", "scale_y", "alpha", "blend", "angle", "center_x", "center_y"], {"scale_x": self.scale_x, "scale_y": self.scale_y, "alpha": self.alpha, "blend": self.blend, "angle": self.angle, "center_x": self.center_x, "center_y": self.center_y}));
      }, $Sprite_draw$14.$$arity = 0), nil) && 'draw';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/window"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $class_variable_set = Opal.class_variable_set, $send = Opal.send, $class_variable_get = Opal.class_variable_get, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$now', '$_load_resources', '$dump_error', '$to_proc', '$!', '$_loop', '$clear', '$draw_pause_screen', '$nil?', '$raise', '$loop', '$draw_box_fill', '$width', '$height', '$draw_font', '$default', '$_init', '$/', '$-', '$+', '$>=', '$matter_enabled?', '$matter_tick', '$_on_tick', '$box_fill', '$sort', '$==', '$[]', '$<=>', '$each', '$===', '$draw', '$drop', '$draw_rot', '$draw_scale', '$draw_ex', '$[]=', '$line', '$box', '$circle', '$circle_fill', '$triangle', '$triangle_fill', '$width=', '$height=', '$new', '$enqueue_draw', '$push', '$length']);
  
  self.$require("dxopal/constants/colors");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Window');

      var $nesting = [self].concat($parent_nesting), $Window_load_resources$1, $Window_loop$3, $Window_pause$5, $Window_paused$ques$6, $Window_resume$7, $Window_draw_pause_screen$8, $Window__loop$9, $Window__init$14, $Window__img$15, $Window_fps$16, $Window_fps$eq$17, $Window_real_fps$18, $Window_width$19, $Window_width$eq$20, $Window_height$21, $Window_height$eq$22, $Window_bgcolor$23, $Window_bgcolor$eq$24, $Window_draw$25, $Window_draw_scale$26, $Window_draw_rot$27, $Window_draw_ex$28, $Window_draw_font$29, $Window_draw_pixel$30, $Window_draw_line$31, $Window_draw_box$32, $Window_draw_box_fill$33, $Window_draw_circle$34, $Window_draw_circle_fill$35, $Window_draw_triangle$36, $Window_draw_triangle_fill$37, $Window_enqueue_draw$38;

      
      $class_variable_set($nesting[0], '@@fps', 60);
      $class_variable_set($nesting[0], '@@fps_ts', nil);
      $class_variable_set($nesting[0], '@@fps_ct', 0);
      $class_variable_set($nesting[0], '@@real_fps', 0);
      $class_variable_set($nesting[0], '@@real_fps_ct', 1);
      $class_variable_set($nesting[0], '@@real_fps_t', $$($nesting, 'Time').$now());
      $class_variable_set($nesting[0], '@@width', 640);
      $class_variable_set($nesting[0], '@@height', 480);
      $class_variable_set($nesting[0], '@@block', nil);
      $class_variable_set($nesting[0], '@@paused', false);
      Opal.defs(self, '$load_resources', $Window_load_resources$1 = function $$load_resources() {
        var $iter = $Window_load_resources$1.$$p, block = $iter || nil, $$2, self = this;

        if ($iter) $Window_load_resources$1.$$p = null;
        
        
        if ($iter) $Window_load_resources$1.$$p = null;;
        return $send($$($nesting, 'RemoteResource'), '_load_resources', [], ($$2 = function(){var self = $$2.$$s == null ? this : $$2.$$s;

        return $send($$($nesting, 'DXOpal'), 'dump_error', [], block.$to_proc())}, $$2.$$s = self, $$2.$$arity = 0, $$2));
      }, $Window_load_resources$1.$$arity = 0);
      Opal.defs(self, '$loop', $Window_loop$3 = function $$loop() {
        var $iter = $Window_loop$3.$$p, block = $iter || nil, $$4, self = this, already_running = nil;

        if ($iter) $Window_loop$3.$$p = null;
        
        
        if ($iter) $Window_loop$3.$$p = null;;
        already_running = $class_variable_get($nesting[0], '@@block', false)['$!']()['$!']();
        $class_variable_set($nesting[0], '@@block', block);
        if ($truthy(already_running)) {
          return nil};
        return (window).requestAnimationFrame(($$4 = function(time){var self = $$4.$$s == null ? this : $$4.$$s;

        
          
          if (time == null) {
            time = nil;
          };
          return self.$_loop(time);}, $$4.$$s = self, $$4.$$arity = 1, $$4));
      }, $Window_loop$3.$$arity = 0);
      Opal.defs(self, '$pause', $Window_pause$5 = function $$pause() {
        var self = this;

        
        $class_variable_set($nesting[0], '@@paused', true);
        $class_variable_get($nesting[0], '@@draw_queue', false).$clear();
        return self.$draw_pause_screen();
      }, $Window_pause$5.$$arity = 0);
      Opal.defs(self, '$paused?', $Window_paused$ques$6 = function() {
        var self = this;

        return $class_variable_get($nesting[0], '@@paused', false)
      }, $Window_paused$ques$6.$$arity = 0);
      Opal.defs(self, '$resume', $Window_resume$7 = function $$resume() {
        var self = this;

        
        if ($truthy($class_variable_get($nesting[0], '@@block', false)['$nil?']())) {
          self.$raise("Window.resume is called before Window.loop")};
        $class_variable_set($nesting[0], '@@paused', false);
        return $send($$($nesting, 'Window'), 'loop', [], $class_variable_get($nesting[0], '@@block', false).$to_proc());
      }, $Window_resume$7.$$arity = 0);
      Opal.defs(self, '$draw_pause_screen', $Window_draw_pause_screen$8 = function $$draw_pause_screen() {
        var self = this;

        
        $$($nesting, 'Window').$draw_box_fill(0, 0, $$($nesting, 'Window').$width(), $$($nesting, 'Window').$height(), $$($nesting, 'C_BLACK'));
        return $$($nesting, 'Window').$draw_font(0, 0, "...PAUSE...", $$($nesting, 'Font').$default(), $hash2(["color"], {"color": $$($nesting, 'C_WHITE')}));
      }, $Window_draw_pause_screen$8.$$arity = 0);
      Opal.defs(self, '$_loop', $Window__loop$9 = function $$_loop(timestamp) {
        var $a, $b, $$10, $$11, $$12, $$13, self = this, $ret_or_1 = nil, frame_msec = nil, $ret_or_2 = nil, passed_msec = nil, t = nil, sorted = nil;

        
        $class_variable_set($nesting[0], '@@img', (function() {if ($truthy((($a = $nesting[0].$$cvars['@@img'], $a != null) ? 'class variable' : nil))) {
          
          if ($truthy(($ret_or_1 = $class_variable_get($nesting[0], '@@img', false)))) {
            return $ret_or_1
          } else {
            return self.$_init()
          };
        } else {
          return self.$_init()
        }; return nil; })());
        frame_msec = $rb_divide(1000.0, $class_variable_get($nesting[0], '@@fps', false));
        $class_variable_set($nesting[0], '@@fps_ts', (function() {if ($truthy((($b = $nesting[0].$$cvars['@@fps_ts'], $b != null) ? 'class variable' : nil))) {
          
          if ($truthy(($ret_or_2 = $class_variable_get($nesting[0], '@@fps_ts', false)))) {
            return $ret_or_2
          } else {
            return timestamp
          };
        } else {
          return timestamp
        }; return nil; })());
        passed_msec = $rb_minus(timestamp, $class_variable_get($nesting[0], '@@fps_ts', false));
        $class_variable_set($nesting[0], '@@fps_ts', timestamp);
        $class_variable_set($nesting[0], '@@fps_ct', $rb_plus($class_variable_get($nesting[0], '@@fps_ct', false), passed_msec));
        if ($truthy($rb_ge($class_variable_get($nesting[0], '@@fps_ct', false), frame_msec))) {
          $class_variable_set($nesting[0], '@@fps_ct', $rb_minus($class_variable_get($nesting[0], '@@fps_ct', false), frame_msec))
        } else {
          
          (window).requestAnimationFrame(($$10 = function(time){var self = $$10.$$s == null ? this : $$10.$$s;

          
            
            if (time == null) {
              time = nil;
            };
            return self.$_loop(time);}, $$10.$$s = self, $$10.$$arity = 1, $$10));
          return nil;
        };
        t = $$($nesting, 'Time').$now();
        if ($truthy($rb_ge($rb_minus(t, $class_variable_get($nesting[0], '@@real_fps_t', false)), 1.0))) {
          
          $class_variable_set($nesting[0], '@@real_fps', $class_variable_get($nesting[0], '@@real_fps_ct', false));
          $class_variable_set($nesting[0], '@@real_fps_ct', 1);
          $class_variable_set($nesting[0], '@@real_fps_t', t);
        } else {
          $class_variable_set($nesting[0], '@@real_fps_ct', $rb_plus($class_variable_get($nesting[0], '@@real_fps_ct', false), 1))
        };
        if ($truthy($$($nesting, 'Sprite')['$matter_enabled?']())) {
          $$($nesting, 'Sprite').$matter_tick(timestamp)};
        $$($nesting, 'Input').$_on_tick();
        $class_variable_set($nesting[0], '@@draw_queue', []);
        if ($truthy($class_variable_get($nesting[0], '@@paused', false))) {
          $$($nesting, 'Window').$draw_pause_screen()
        } else {
          $send($$($nesting, 'DXOpal'), 'dump_error', [], $class_variable_get($nesting[0], '@@block', false).$to_proc())
        };
        $class_variable_get($nesting[0], '@@img', false).$box_fill(0, 0, $class_variable_get($nesting[0], '@@width', false), $class_variable_get($nesting[0], '@@height', false), $class_variable_get($nesting[0], '@@bgcolor', false));
        sorted = $send($class_variable_get($nesting[0], '@@draw_queue', false), 'sort', [], ($$11 = function(a, b){var self = $$11.$$s == null ? this : $$11.$$s;

        
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          if (a['$[]'](0)['$=='](b['$[]'](0))) {
            return a['$[]'](1)['$<=>'](b['$[]'](1))
          } else {
            return a['$[]'](0)['$<=>'](b['$[]'](0))
          };}, $$11.$$s = self, $$11.$$arity = 2, $$11));
        $send(sorted, 'each', [], ($$12 = function(item){var self = $$12.$$s == null ? this : $$12.$$s, $case = nil, $writer = nil;

        
          
          if (item == null) {
            item = nil;
          };
          return (function() {$case = item['$[]'](2);
          if ("image"['$===']($case)) {return $send($class_variable_get($nesting[0], '@@img', false), 'draw', Opal.to_a(item.$drop(3)))}
          else if ("image_rot"['$===']($case)) {return $send($class_variable_get($nesting[0], '@@img', false), 'draw_rot', Opal.to_a(item.$drop(3)))}
          else if ("image_scale"['$===']($case)) {return $send($class_variable_get($nesting[0], '@@img', false), 'draw_scale', Opal.to_a(item.$drop(3)))}
          else if ("draw_ex"['$===']($case)) {return $send($class_variable_get($nesting[0], '@@img', false), 'draw_ex', Opal.to_a(item.$drop(3)))}
          else if ("font"['$===']($case)) {return $send($class_variable_get($nesting[0], '@@img', false), 'draw_font', Opal.to_a(item.$drop(3)))}
          else if ("pixel"['$===']($case)) {
          $writer = [].concat(Opal.to_a(item.$drop(3)));
          $send($class_variable_get($nesting[0], '@@img', false), '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}
          else if ("line"['$===']($case)) {return $send($class_variable_get($nesting[0], '@@img', false), 'line', Opal.to_a(item.$drop(3)))}
          else if ("box"['$===']($case)) {return $send($class_variable_get($nesting[0], '@@img', false), 'box', Opal.to_a(item.$drop(3)))}
          else if ("box_fill"['$===']($case)) {return $send($class_variable_get($nesting[0], '@@img', false), 'box_fill', Opal.to_a(item.$drop(3)))}
          else if ("circle"['$===']($case)) {return $send($class_variable_get($nesting[0], '@@img', false), 'circle', Opal.to_a(item.$drop(3)))}
          else if ("circle_fill"['$===']($case)) {return $send($class_variable_get($nesting[0], '@@img', false), 'circle_fill', Opal.to_a(item.$drop(3)))}
          else if ("triangle"['$===']($case)) {return $send($class_variable_get($nesting[0], '@@img', false), 'triangle', Opal.to_a(item.$drop(3)))}
          else if ("triangle_fill"['$===']($case)) {return $send($class_variable_get($nesting[0], '@@img', false), 'triangle_fill', Opal.to_a(item.$drop(3)))}
          else { return nil }})();}, $$12.$$s = self, $$12.$$arity = 1, $$12));
        return (window).requestAnimationFrame(($$13 = function(time){var self = $$13.$$s == null ? this : $$13.$$s;

        
          
          if (time == null) {
            time = nil;
          };
          return self.$_loop(time);}, $$13.$$s = self, $$13.$$arity = 1, $$13));
      }, $Window__loop$9.$$arity = 1);
      Opal.defs(self, '$_init', $Window__init$14 = function $$_init() {
        var self = this, canvas = nil, $writer = nil, img = nil;

        
        canvas = document.getElementById("dxopal-canvas");
        
        $writer = [$class_variable_get($nesting[0], '@@width', false)];
        $send(self, 'width=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = [$class_variable_get($nesting[0], '@@height', false)];
        $send(self, 'height=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        img = $$($nesting, 'Image').$new(self.$width(), self.$height(), $hash2(["canvas"], {"canvas": canvas}));
        $$($nesting, 'Input').$_init(canvas);
        return img;
      }, $Window__init$14.$$arity = 0);
      Opal.defs(self, '$_img', $Window__img$15 = function $$_img() {
        var self = this;

        return $class_variable_get($nesting[0], '@@img', false)
      }, $Window__img$15.$$arity = 0);
      Opal.defs(self, '$fps', $Window_fps$16 = function $$fps() {
        var self = this;

        return $class_variable_get($nesting[0], '@@fps', false)
      }, $Window_fps$16.$$arity = 0);
      Opal.defs(self, '$fps=', $Window_fps$eq$17 = function(w) {
        var self = this;

        return $class_variable_set($nesting[0], '@@fps', w)
      }, $Window_fps$eq$17.$$arity = 1);
      Opal.defs(self, '$real_fps', $Window_real_fps$18 = function $$real_fps() {
        var self = this;

        return $class_variable_get($nesting[0], '@@real_fps', false)
      }, $Window_real_fps$18.$$arity = 0);
      Opal.defs(self, '$width', $Window_width$19 = function $$width() {
        var self = this;

        return $class_variable_get($nesting[0], '@@width', false)
      }, $Window_width$19.$$arity = 0);
      Opal.defs(self, '$width=', $Window_width$eq$20 = function(w) {
        var self = this, canvas = nil, $ret_or_3 = nil;

        
        canvas = document.getElementById("dxopal-canvas");
        $class_variable_set($nesting[0], '@@width', (function() {if ($truthy(($ret_or_3 = w))) {
          return $ret_or_3
        } else {
          return window.innerWidth;
        }; return nil; })());
        canvas.width = $class_variable_get($nesting[0], '@@width', false);
        return canvas.style.width = $class_variable_get($nesting[0], '@@width', false);
      }, $Window_width$eq$20.$$arity = 1);
      Opal.defs(self, '$height', $Window_height$21 = function $$height() {
        var self = this;

        return $class_variable_get($nesting[0], '@@height', false)
      }, $Window_height$21.$$arity = 0);
      Opal.defs(self, '$height=', $Window_height$eq$22 = function(h) {
        var self = this, canvas = nil, $ret_or_4 = nil;

        
        canvas = document.getElementById("dxopal-canvas");
        $class_variable_set($nesting[0], '@@height', (function() {if ($truthy(($ret_or_4 = h))) {
          return $ret_or_4
        } else {
          return window.innerHeight;
        }; return nil; })());
        canvas.height = $class_variable_get($nesting[0], '@@height', false);
        return canvas.style.height = $class_variable_get($nesting[0], '@@height', false);
      }, $Window_height$eq$22.$$arity = 1);
      $class_variable_set($nesting[0], '@@bgcolor', $$$($$$($$($nesting, 'Constants'), 'Colors'), 'C_BLACK'));
      Opal.defs(self, '$bgcolor', $Window_bgcolor$23 = function $$bgcolor() {
        var self = this;

        return $class_variable_get($nesting[0], '@@bgcolor', false)
      }, $Window_bgcolor$23.$$arity = 0);
      Opal.defs(self, '$bgcolor=', $Window_bgcolor$eq$24 = function(col) {
        var self = this;

        return $class_variable_set($nesting[0], '@@bgcolor', col)
      }, $Window_bgcolor$eq$24.$$arity = 1);
      Opal.defs(self, '$draw', $Window_draw$25 = function $$draw(x, y, image, z) {
        var self = this;

        
        
        if (z == null) {
          z = 0;
        };
        return self.$enqueue_draw(z, "image", x, y, image);
      }, $Window_draw$25.$$arity = -4);
      Opal.defs(self, '$draw_scale', $Window_draw_scale$26 = function $$draw_scale(x, y, image, scale_x, scale_y, center_x, center_y, z) {
        var self = this;

        
        
        if (center_x == null) {
          center_x = nil;
        };
        
        if (center_y == null) {
          center_y = nil;
        };
        
        if (z == null) {
          z = 0;
        };
        return self.$enqueue_draw(z, "image_scale", x, y, image, scale_x, scale_y, center_x, center_y);
      }, $Window_draw_scale$26.$$arity = -6);
      Opal.defs(self, '$draw_rot', $Window_draw_rot$27 = function $$draw_rot(x, y, image, angle, center_x, center_y, z) {
        var self = this;

        
        
        if (center_x == null) {
          center_x = nil;
        };
        
        if (center_y == null) {
          center_y = nil;
        };
        
        if (z == null) {
          z = 0;
        };
        return self.$enqueue_draw(z, "image_rot", x, y, image, angle, center_x, center_y);
      }, $Window_draw_rot$27.$$arity = -5);
      Opal.defs(self, '$draw_ex', $Window_draw_ex$28 = function $$draw_ex(x, y, image, options) {
        var self = this, $ret_or_5 = nil;

        
        
        if (options == null) {
          options = $hash2([], {});
        };
        return self.$enqueue_draw((function() {if ($truthy(($ret_or_5 = options['$[]']("z")))) {
          return $ret_or_5
        } else {
          return 0
        }; return nil; })(), "draw_ex", x, y, image, options);
      }, $Window_draw_ex$28.$$arity = -4);
      Opal.defs(self, '$draw_font', $Window_draw_font$29 = function $$draw_font(x, y, string, font, option) {
        var self = this, z = nil, $ret_or_6 = nil, color = nil, $ret_or_7 = nil;

        
        
        if (option == null) {
          option = $hash2([], {});
        };
        z = (function() {if ($truthy(($ret_or_6 = option['$[]']("z")))) {
          return $ret_or_6
        } else {
          return 0
        }; return nil; })();
        color = (function() {if ($truthy(($ret_or_7 = option['$[]']("color")))) {
          return $ret_or_7
        } else {
          return [255, 255, 255]
        }; return nil; })();
        return self.$enqueue_draw(z, "font", x, y, string, font, color);
      }, $Window_draw_font$29.$$arity = -5);
      Opal.defs(self, '$draw_pixel', $Window_draw_pixel$30 = function $$draw_pixel(x, y, color, z) {
        var self = this;

        
        
        if (z == null) {
          z = 0;
        };
        return self.$enqueue_draw(z, "pixel", x, y, color);
      }, $Window_draw_pixel$30.$$arity = -4);
      Opal.defs(self, '$draw_line', $Window_draw_line$31 = function $$draw_line(x1, y1, x2, y2, color, z) {
        var self = this;

        
        
        if (z == null) {
          z = 0;
        };
        return self.$enqueue_draw(z, "line", x1, y1, x2, y2, color);
      }, $Window_draw_line$31.$$arity = -6);
      Opal.defs(self, '$draw_box', $Window_draw_box$32 = function $$draw_box(x1, y1, x2, y2, color, z) {
        var self = this;

        
        
        if (z == null) {
          z = 0;
        };
        return self.$enqueue_draw(z, "box", x1, y1, x2, y2, color);
      }, $Window_draw_box$32.$$arity = -6);
      Opal.defs(self, '$draw_box_fill', $Window_draw_box_fill$33 = function $$draw_box_fill(x1, y1, x2, y2, color, z) {
        var self = this;

        
        
        if (z == null) {
          z = 0;
        };
        return self.$enqueue_draw(z, "box_fill", x1, y1, x2, y2, color);
      }, $Window_draw_box_fill$33.$$arity = -6);
      Opal.defs(self, '$draw_circle', $Window_draw_circle$34 = function $$draw_circle(x, y, r, color, z) {
        var self = this;

        
        
        if (z == null) {
          z = 0;
        };
        return self.$enqueue_draw(z, "circle", x, y, r, color);
      }, $Window_draw_circle$34.$$arity = -5);
      Opal.defs(self, '$draw_circle_fill', $Window_draw_circle_fill$35 = function $$draw_circle_fill(x, y, r, color, z) {
        var self = this;

        
        
        if (z == null) {
          z = 0;
        };
        return self.$enqueue_draw(z, "circle_fill", x, y, r, color);
      }, $Window_draw_circle_fill$35.$$arity = -5);
      Opal.defs(self, '$draw_triangle', $Window_draw_triangle$36 = function $$draw_triangle(x1, y1, x2, y2, x3, y3, color, z) {
        var self = this;

        
        
        if (z == null) {
          z = 0;
        };
        return self.$enqueue_draw(z, "triangle", x1, y1, x2, y2, x3, y3, color);
      }, $Window_draw_triangle$36.$$arity = -8);
      Opal.defs(self, '$draw_triangle_fill', $Window_draw_triangle_fill$37 = function $$draw_triangle_fill(x1, y1, x2, y2, x3, y3, color, z) {
        var self = this;

        
        
        if (z == null) {
          z = 0;
        };
        return self.$enqueue_draw(z, "triangle_fill", x1, y1, x2, y2, x3, y3, color);
      }, $Window_draw_triangle_fill$37.$$arity = -8);
      return (Opal.defs(self, '$enqueue_draw', $Window_enqueue_draw$38 = function $$enqueue_draw(z, $a) {
        var $post_args, args, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        args = $post_args;;
        return $class_variable_get($nesting[0], '@@draw_queue', false).$push([z, $class_variable_get($nesting[0], '@@draw_queue', false).$length()].concat(Opal.to_a(args)));
      }, $Window_enqueue_draw$38.$$arity = -2), nil) && 'enqueue_draw';
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/version"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return Opal.const_set($nesting[0], 'VERSION', "1.5.2")
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["singleton"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $send2 = Opal.send2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$class', '$__init__', '$instance_eval', '$new', '$extend']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Singleton');

    var $nesting = [self].concat($parent_nesting), $Singleton_clone$1, $Singleton_dup$2;

    
    
    Opal.def(self, '$clone', $Singleton_clone$1 = function $$clone() {
      var self = this;

      return self.$raise($$($nesting, 'TypeError'), "" + "can't clone instance of singleton " + (self.$class()))
    }, $Singleton_clone$1.$$arity = 0);
    
    Opal.def(self, '$dup', $Singleton_dup$2 = function $$dup() {
      var self = this;

      return self.$raise($$($nesting, 'TypeError'), "" + "can't dup instance of singleton " + (self.$class()))
    }, $Singleton_dup$2.$$arity = 0);
    (function($base, $parent_nesting) {
      var self = $module($base, 'SingletonClassMethods');

      var $nesting = [self].concat($parent_nesting), $SingletonClassMethods_clone$3, $SingletonClassMethods_inherited$4;

      
      
      Opal.def(self, '$clone', $SingletonClassMethods_clone$3 = function $$clone() {
        var $iter = $SingletonClassMethods_clone$3.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $SingletonClassMethods_clone$3.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        return $$($nesting, 'Singleton').$__init__($send2(self, Opal.find_super_dispatcher(self, 'clone', $SingletonClassMethods_clone$3, false, true), 'clone', $zuper, $iter))
      }, $SingletonClassMethods_clone$3.$$arity = 0);
      return (Opal.def(self, '$inherited', $SingletonClassMethods_inherited$4 = function $$inherited(sub_klass) {
        var $iter = $SingletonClassMethods_inherited$4.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $SingletonClassMethods_inherited$4.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        $send2(self, Opal.find_super_dispatcher(self, 'inherited', $SingletonClassMethods_inherited$4, false, true), 'inherited', $zuper, $iter);
        return $$($nesting, 'Singleton').$__init__(sub_klass);
      }, $SingletonClassMethods_inherited$4.$$arity = 1), nil) && 'inherited';
    })($nesting[0], $nesting);
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $__init__$5, $included$8;

      
      
      Opal.def(self, '$__init__', $__init__$5 = function $$__init__(klass) {
        var $$6, $instance$7, self = this;

        
        $send(klass, 'instance_eval', [], ($$6 = function(){var self = $$6.$$s == null ? this : $$6.$$s;

        return (self.singleton__instance__ = nil)}, $$6.$$s = self, $$6.$$arity = 0, $$6));
        Opal.defs(klass, '$instance', $instance$7 = function $$instance() {
          var self = this;
          if (self.singleton__instance__ == null) self.singleton__instance__ = nil;

          
          if ($truthy(self.singleton__instance__)) {
            return self.singleton__instance__};
          return (self.singleton__instance__ = self.$new());
        }, $instance$7.$$arity = 0);
        return klass;
      }, $__init__$5.$$arity = 1);
      return (Opal.def(self, '$included', $included$8 = function $$included(klass) {
        var $iter = $included$8.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $included$8.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        $send2(self, Opal.find_super_dispatcher(self, 'included', $included$8, false, true), 'included', $zuper, $iter);
        klass.$extend($$($nesting, 'SingletonClassMethods'));
        return $$($nesting, 'Singleton').$__init__(klass);
      }, $included$8.$$arity = 1), nil) && 'included';
    })(Opal.get_singleton_class($$($nesting, 'Singleton')), $nesting);
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["delegate"] = function(Opal) {
  var $DelegateClass$6, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $send2 = Opal.send2;

  Opal.add_stubs(['$__setobj__', '$__getobj__', '$respond_to?', '$__send__', '$to_proc']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Delegator');

    var $nesting = [self].concat($parent_nesting), $Delegator_initialize$1, $Delegator_method_missing$2, $Delegator_respond_to_missing$ques$3;

    
    
    Opal.def(self, '$initialize', $Delegator_initialize$1 = function $$initialize(obj) {
      var self = this;

      return self.$__setobj__(obj)
    }, $Delegator_initialize$1.$$arity = 1);
    
    Opal.def(self, '$method_missing', $Delegator_method_missing$2 = function $$method_missing(m, $a) {
      var $iter = $Delegator_method_missing$2.$$p, block = $iter || nil, $post_args, args, self = this, target = nil;

      if ($iter) $Delegator_method_missing$2.$$p = null;
      
      
      if ($iter) $Delegator_method_missing$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      target = self.$__getobj__();
      if ($truthy(target['$respond_to?'](m))) {
        return $send(target, '__send__', [m].concat(Opal.to_a(args)), block.$to_proc())
      } else {
        return $send2(self, Opal.find_super_dispatcher(self, 'method_missing', $Delegator_method_missing$2, false, true), 'method_missing', [m].concat(Opal.to_a(args)), block.$to_proc())
      };
    }, $Delegator_method_missing$2.$$arity = -2);
    return (Opal.def(self, '$respond_to_missing?', $Delegator_respond_to_missing$ques$3 = function(m, include_private) {
      var self = this;

      return self.$__getobj__()['$respond_to?'](m, include_private)
    }, $Delegator_respond_to_missing$ques$3.$$arity = 2), nil) && 'respond_to_missing?';
  })($nesting[0], $$($nesting, 'BasicObject'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SimpleDelegator');

    var $nesting = [self].concat($parent_nesting), $SimpleDelegator___getobj__$4, $SimpleDelegator___setobj__$5;

    self.$$prototype.delegate_sd_obj = nil;
    
    
    Opal.def(self, '$__getobj__', $SimpleDelegator___getobj__$4 = function $$__getobj__() {
      var self = this;

      return self.delegate_sd_obj
    }, $SimpleDelegator___getobj__$4.$$arity = 0);
    return (Opal.def(self, '$__setobj__', $SimpleDelegator___setobj__$5 = function $$__setobj__(obj) {
      var self = this;

      return (self.delegate_sd_obj = obj)
    }, $SimpleDelegator___setobj__$5.$$arity = 1), nil) && '__setobj__';
  })($nesting[0], $$($nesting, 'Delegator'), $nesting);
  return (Opal.def(self, '$DelegateClass', $DelegateClass$6 = function $$DelegateClass(superklass) {
    var self = this;

    return $$($nesting, 'SimpleDelegator')
  }, $DelegateClass$6.$$arity = 1), nil) && 'DelegateClass';
};

/* Generated by Opal 1.2.0 */
Opal.modules["forwardable"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$each', '$respond_to?', '$def_instance_delegator', '$include?', '$start_with?', '$to_s', '$define_method', '$__send__', '$instance_variable_get', '$to_proc', '$def_single_delegator', '$define_singleton_method']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Forwardable');

    var $nesting = [self].concat($parent_nesting), $Forwardable_instance_delegate$1, $Forwardable_def_instance_delegators$4, $Forwardable_def_instance_delegator$6;

    
    
    Opal.def(self, '$instance_delegate', $Forwardable_instance_delegate$1 = function $$instance_delegate(hash) {
      var $$2, self = this;

      return $send(hash, 'each', [], ($$2 = function(methods, accessor){var self = $$2.$$s == null ? this : $$2.$$s, $$3;

      
        
        if (methods == null) {
          methods = nil;
        };
        
        if (accessor == null) {
          accessor = nil;
        };
        if ($truthy(methods['$respond_to?']("each"))) {
        } else {
          methods = [methods]
        };
        return $send(methods, 'each', [], ($$3 = function(method){var self = $$3.$$s == null ? this : $$3.$$s;

        
          
          if (method == null) {
            method = nil;
          };
          return self.$def_instance_delegator(accessor, method);}, $$3.$$s = self, $$3.$$arity = 1, $$3));}, $$2.$$s = self, $$2.$$arity = 2, $$2))
    }, $Forwardable_instance_delegate$1.$$arity = 1);
    
    Opal.def(self, '$def_instance_delegators', $Forwardable_def_instance_delegators$4 = function $$def_instance_delegators(accessor, $a) {
      var $post_args, methods, $$5, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      methods = $post_args;;
      return $send(methods, 'each', [], ($$5 = function(method){var self = $$5.$$s == null ? this : $$5.$$s;

      
        
        if (method == null) {
          method = nil;
        };
        if ($truthy(["__send__", "__id__"]['$include?'](method))) {
          return nil;};
        return self.$def_instance_delegator(accessor, method);}, $$5.$$s = self, $$5.$$arity = 1, $$5));
    }, $Forwardable_def_instance_delegators$4.$$arity = -2);
    
    Opal.def(self, '$def_instance_delegator', $Forwardable_def_instance_delegator$6 = function $$def_instance_delegator(accessor, method, ali) {
      var $$7, $$8, $iter = $Forwardable_def_instance_delegator$6.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Forwardable_def_instance_delegator$6.$$p = null;
      
      
      if (ali == null) {
        ali = method;
      };
      if ($truthy(accessor.$to_s()['$start_with?']("@"))) {
        return $send(self, 'define_method', [ali], ($$7 = function($a){var self = $$7.$$s == null ? this : $$7.$$s, $iter = $$7.$$p, block = $iter || nil, $post_args, args;

        
          
          if ($iter) $$7.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $send(self.$instance_variable_get(accessor), '__send__', [method].concat(Opal.to_a(args)), block.$to_proc());}, $$7.$$s = self, $$7.$$arity = -1, $$7))
      } else {
        return $send(self, 'define_method', [ali], ($$8 = function($a){var self = $$8.$$s == null ? this : $$8.$$s, $iter = $$8.$$p, block = $iter || nil, $post_args, args;

        
          
          if ($iter) $$8.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $send(self.$__send__(accessor), '__send__', [method].concat(Opal.to_a(args)), block.$to_proc());}, $$8.$$s = self, $$8.$$arity = -1, $$8))
      };
    }, $Forwardable_def_instance_delegator$6.$$arity = -3);
    Opal.alias(self, "delegate", "instance_delegate");
    Opal.alias(self, "def_delegators", "def_instance_delegators");
    return Opal.alias(self, "def_delegator", "def_instance_delegator");
  })($nesting[0], $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'SingleForwardable');

    var $nesting = [self].concat($parent_nesting), $SingleForwardable_single_delegate$9, $SingleForwardable_def_single_delegators$12, $SingleForwardable_def_single_delegator$14;

    
    
    Opal.def(self, '$single_delegate', $SingleForwardable_single_delegate$9 = function $$single_delegate(hash) {
      var $$10, self = this;

      return $send(hash, 'each', [], ($$10 = function(methods, accessor){var self = $$10.$$s == null ? this : $$10.$$s, $$11;

      
        
        if (methods == null) {
          methods = nil;
        };
        
        if (accessor == null) {
          accessor = nil;
        };
        if ($truthy(methods['$respond_to?']("each"))) {
        } else {
          methods = [methods]
        };
        return $send(methods, 'each', [], ($$11 = function(method){var self = $$11.$$s == null ? this : $$11.$$s;

        
          
          if (method == null) {
            method = nil;
          };
          return self.$def_single_delegator(accessor, method);}, $$11.$$s = self, $$11.$$arity = 1, $$11));}, $$10.$$s = self, $$10.$$arity = 2, $$10))
    }, $SingleForwardable_single_delegate$9.$$arity = 1);
    
    Opal.def(self, '$def_single_delegators', $SingleForwardable_def_single_delegators$12 = function $$def_single_delegators(accessor, $a) {
      var $post_args, methods, $$13, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      methods = $post_args;;
      return $send(methods, 'each', [], ($$13 = function(method){var self = $$13.$$s == null ? this : $$13.$$s;

      
        
        if (method == null) {
          method = nil;
        };
        if ($truthy(["__send__", "__id__"]['$include?'](method))) {
          return nil;};
        return self.$def_single_delegator(accessor, method);}, $$13.$$s = self, $$13.$$arity = 1, $$13));
    }, $SingleForwardable_def_single_delegators$12.$$arity = -2);
    
    Opal.def(self, '$def_single_delegator', $SingleForwardable_def_single_delegator$14 = function $$def_single_delegator(accessor, method, ali) {
      var $$15, $$16, $iter = $SingleForwardable_def_single_delegator$14.$$p, $yield = $iter || nil, self = this;

      if ($iter) $SingleForwardable_def_single_delegator$14.$$p = null;
      
      
      if (ali == null) {
        ali = method;
      };
      if ($truthy(accessor.$to_s()['$start_with?']("@"))) {
        return $send(self, 'define_singleton_method', [ali], ($$15 = function($a){var self = $$15.$$s == null ? this : $$15.$$s, $iter = $$15.$$p, block = $iter || nil, $post_args, args;

        
          
          if ($iter) $$15.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $send(self.$instance_variable_get(accessor), '__send__', [method].concat(Opal.to_a(args)), block.$to_proc());}, $$15.$$s = self, $$15.$$arity = -1, $$15))
      } else {
        return $send(self, 'define_singleton_method', [ali], ($$16 = function($a){var self = $$16.$$s == null ? this : $$16.$$s, $iter = $$16.$$p, block = $iter || nil, $post_args, args;

        
          
          if ($iter) $$16.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $send(self.$__send__(accessor), '__send__', [method].concat(Opal.to_a(args)), block.$to_proc());}, $$16.$$s = self, $$16.$$arity = -1, $$16))
      };
    }, $SingleForwardable_def_single_delegator$14.$$arity = -3);
    Opal.alias(self, "delegate", "single_delegate");
    Opal.alias(self, "def_delegators", "def_single_delegators");
    return Opal.alias(self, "def_delegator", "def_single_delegator");
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["thread"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$allocate', '$core_initialize!', '$current', '$raise', '$[]', '$coerce_key_name', '$[]=', '$-', '$key?', '$keys', '$private', '$coerce_to!', '$clear', '$empty?', '$size', '$shift', '$push', '$each', '$to_proc', '$locked?', '$lock', '$unlock']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ThreadError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Thread');

    var $nesting = [self].concat($parent_nesting), $Thread_current$1, $Thread_list$2, $Thread_initialize$3, $Thread_$$$4, $Thread_$$$eq$5, $Thread_key$ques$6, $Thread_keys$7, $Thread_thread_variable_get$8, $Thread_thread_variable_set$9, $Thread_thread_variable$ques$10, $Thread_thread_variables$11, $Thread_core_initialize$excl$12, $Thread_coerce_key_name$13;

    self.$$prototype.fiber_locals = self.$$prototype.thread_locals = nil;
    
    Opal.defs(self, '$current', $Thread_current$1 = function $$current() {
      var self = this;
      if (self.current == null) self.current = nil;

      
      if ($truthy(self.current)) {
      } else {
        
        self.current = self.$allocate();
        self.current['$core_initialize!']();
      };
      return self.current;
    }, $Thread_current$1.$$arity = 0);
    Opal.defs(self, '$list', $Thread_list$2 = function $$list() {
      var self = this;

      return [self.$current()]
    }, $Thread_list$2.$$arity = 0);
    
    Opal.def(self, '$initialize', $Thread_initialize$3 = function $$initialize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.$raise($$($nesting, 'NotImplementedError'), "Thread creation not available");
    }, $Thread_initialize$3.$$arity = -1);
    
    Opal.def(self, '$[]', $Thread_$$$4 = function(key) {
      var self = this;

      return self.fiber_locals['$[]'](self.$coerce_key_name(key))
    }, $Thread_$$$4.$$arity = 1);
    
    Opal.def(self, '$[]=', $Thread_$$$eq$5 = function(key, value) {
      var self = this, $writer = nil;

      
      $writer = [self.$coerce_key_name(key), value];
      $send(self.fiber_locals, '[]=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];
    }, $Thread_$$$eq$5.$$arity = 2);
    
    Opal.def(self, '$key?', $Thread_key$ques$6 = function(key) {
      var self = this;

      return self.fiber_locals['$key?'](self.$coerce_key_name(key))
    }, $Thread_key$ques$6.$$arity = 1);
    
    Opal.def(self, '$keys', $Thread_keys$7 = function $$keys() {
      var self = this;

      return self.fiber_locals.$keys()
    }, $Thread_keys$7.$$arity = 0);
    
    Opal.def(self, '$thread_variable_get', $Thread_thread_variable_get$8 = function $$thread_variable_get(key) {
      var self = this;

      return self.thread_locals['$[]'](self.$coerce_key_name(key))
    }, $Thread_thread_variable_get$8.$$arity = 1);
    
    Opal.def(self, '$thread_variable_set', $Thread_thread_variable_set$9 = function $$thread_variable_set(key, value) {
      var self = this, $writer = nil;

      
      $writer = [self.$coerce_key_name(key), value];
      $send(self.thread_locals, '[]=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];
    }, $Thread_thread_variable_set$9.$$arity = 2);
    
    Opal.def(self, '$thread_variable?', $Thread_thread_variable$ques$10 = function(key) {
      var self = this;

      return self.thread_locals['$key?'](self.$coerce_key_name(key))
    }, $Thread_thread_variable$ques$10.$$arity = 1);
    
    Opal.def(self, '$thread_variables', $Thread_thread_variables$11 = function $$thread_variables() {
      var self = this;

      return self.thread_locals.$keys()
    }, $Thread_thread_variables$11.$$arity = 0);
    self.$private();
    
    Opal.def(self, '$core_initialize!', $Thread_core_initialize$excl$12 = function() {
      var self = this;

      
      self.thread_locals = $hash2([], {});
      return (self.fiber_locals = $hash2([], {}));
    }, $Thread_core_initialize$excl$12.$$arity = 0);
    
    Opal.def(self, '$coerce_key_name', $Thread_coerce_key_name$13 = function $$coerce_key_name(key) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to!'](key, $$($nesting, 'String'), "to_s")
    }, $Thread_coerce_key_name$13.$$arity = 1);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Queue');

      var $nesting = [self].concat($parent_nesting), $Queue_initialize$14, $Queue_clear$15, $Queue_empty$ques$16, $Queue_size$17, $Queue_pop$18, $Queue_push$19, $Queue_each$20;

      self.$$prototype.storage = nil;
      
      
      Opal.def(self, '$initialize', $Queue_initialize$14 = function $$initialize() {
        var self = this;

        return self.$clear()
      }, $Queue_initialize$14.$$arity = 0);
      
      Opal.def(self, '$clear', $Queue_clear$15 = function $$clear() {
        var self = this;

        return (self.storage = [])
      }, $Queue_clear$15.$$arity = 0);
      
      Opal.def(self, '$empty?', $Queue_empty$ques$16 = function() {
        var self = this;

        return self.storage['$empty?']()
      }, $Queue_empty$ques$16.$$arity = 0);
      
      Opal.def(self, '$size', $Queue_size$17 = function $$size() {
        var self = this;

        return self.storage.$size()
      }, $Queue_size$17.$$arity = 0);
      Opal.alias(self, "length", "size");
      
      Opal.def(self, '$pop', $Queue_pop$18 = function $$pop(non_block) {
        var self = this;

        
        
        if (non_block == null) {
          non_block = false;
        };
        if ($truthy(self['$empty?']())) {
          
          if ($truthy(non_block)) {
            self.$raise($$($nesting, 'ThreadError'), "Queue empty")};
          self.$raise($$($nesting, 'ThreadError'), "Deadlock");};
        return self.storage.$shift();
      }, $Queue_pop$18.$$arity = -1);
      Opal.alias(self, "shift", "pop");
      Opal.alias(self, "deq", "pop");
      
      Opal.def(self, '$push', $Queue_push$19 = function $$push(value) {
        var self = this;

        return self.storage.$push(value)
      }, $Queue_push$19.$$arity = 1);
      Opal.alias(self, "<<", "push");
      Opal.alias(self, "enq", "push");
      return (Opal.def(self, '$each', $Queue_each$20 = function $$each() {
        var $iter = $Queue_each$20.$$p, block = $iter || nil, self = this;

        if ($iter) $Queue_each$20.$$p = null;
        
        
        if ($iter) $Queue_each$20.$$p = null;;
        return $send(self.storage, 'each', [], block.$to_proc());
      }, $Queue_each$20.$$arity = 0), nil) && 'each';
    })($nesting[0], null, $nesting);
  })($nesting[0], null, $nesting);
  Opal.const_set($nesting[0], 'Queue', $$$($$($nesting, 'Thread'), 'Queue'));
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Mutex');

    var $nesting = [self].concat($parent_nesting), $Mutex_initialize$21, $Mutex_lock$22, $Mutex_locked$ques$23, $Mutex_owned$ques$24, $Mutex_try_lock$25, $Mutex_unlock$26, $Mutex_synchronize$27;

    self.$$prototype.locked = nil;
    
    
    Opal.def(self, '$initialize', $Mutex_initialize$21 = function $$initialize() {
      var self = this;

      return (self.locked = false)
    }, $Mutex_initialize$21.$$arity = 0);
    
    Opal.def(self, '$lock', $Mutex_lock$22 = function $$lock() {
      var self = this;

      
      if ($truthy(self.locked)) {
        self.$raise($$($nesting, 'ThreadError'), "Deadlock")};
      self.locked = true;
      return self;
    }, $Mutex_lock$22.$$arity = 0);
    
    Opal.def(self, '$locked?', $Mutex_locked$ques$23 = function() {
      var self = this;

      return self.locked
    }, $Mutex_locked$ques$23.$$arity = 0);
    
    Opal.def(self, '$owned?', $Mutex_owned$ques$24 = function() {
      var self = this;

      return self.locked
    }, $Mutex_owned$ques$24.$$arity = 0);
    
    Opal.def(self, '$try_lock', $Mutex_try_lock$25 = function $$try_lock() {
      var self = this;

      if ($truthy(self['$locked?']())) {
        return false
      } else {
        
        self.$lock();
        return true;
      }
    }, $Mutex_try_lock$25.$$arity = 0);
    
    Opal.def(self, '$unlock', $Mutex_unlock$26 = function $$unlock() {
      var self = this;

      
      if ($truthy(self.locked)) {
      } else {
        self.$raise($$($nesting, 'ThreadError'), "Mutex not locked")
      };
      self.locked = false;
      return self;
    }, $Mutex_unlock$26.$$arity = 0);
    return (Opal.def(self, '$synchronize', $Mutex_synchronize$27 = function $$synchronize() {
      var $iter = $Mutex_synchronize$27.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Mutex_synchronize$27.$$p = null;
      
      self.$lock();
      
      return (function() { try {
      return Opal.yieldX($yield, []);
      } finally {
        self.$unlock()
      }; })();;
    }, $Mutex_synchronize$27.$$arity = 0), nil) && 'synchronize';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["stringio"] = function(Opal) {
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$include', '$new', '$call', '$close', '$attr_accessor', '$length', '$include?', '$!', '$check_readable', '$==', '$===', '$>=', '$raise', '$>', '$+', '$-', '$seek', '$enum_for', '$eof?', '$ord', '$[]', '$to_str', '$chomp', '$check_writable', '$String', '$write', '$closed_write?', '$closed_read?']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StringIO');

    var $nesting = [self].concat($parent_nesting), $StringIO_open$1, $StringIO_initialize$2, $StringIO_eof$ques$3, $StringIO_seek$4, $StringIO_tell$5, $StringIO_rewind$6, $StringIO_each_byte$7, $StringIO_each_char$8, $StringIO_each$9, $StringIO_write$10, $StringIO_read$11, $StringIO_close$12, $StringIO_close_read$13, $StringIO_close_write$14, $StringIO_closed$ques$15, $StringIO_closed_read$ques$16, $StringIO_closed_write$ques$17, $StringIO_check_writable$18, $StringIO_check_readable$19;

    self.$$prototype.position = self.$$prototype.string = self.$$prototype.closed = nil;
    
    self.$include($$$($$($nesting, 'IO'), 'Readable'));
    self.$include($$$($$($nesting, 'IO'), 'Writable'));
    Opal.defs(self, '$open', $StringIO_open$1 = function $$open(string, mode) {
      var $iter = $StringIO_open$1.$$p, block = $iter || nil, self = this, io = nil, res = nil;

      if ($iter) $StringIO_open$1.$$p = null;
      
      
      if ($iter) $StringIO_open$1.$$p = null;;
      
      if (string == null) {
        string = "";
      };
      
      if (mode == null) {
        mode = nil;
      };
      io = self.$new(string, mode);
      res = block.$call(io);
      io.$close();
      return res;
    }, $StringIO_open$1.$$arity = -1);
    self.$attr_accessor("string");
    
    Opal.def(self, '$initialize', $StringIO_initialize$2 = function $$initialize(string, mode) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      
      
      if (string == null) {
        string = "";
      };
      
      if (mode == null) {
        mode = "rw";
      };
      self.string = string;
      self.position = string.$length();
      if ($truthy((function() {if ($truthy(($ret_or_1 = mode['$include?']("r")))) {
        return mode['$include?']("w")['$!']()
      } else {
        return $ret_or_1
      }; return nil; })())) {
        return (self.closed = "write")
      } else if ($truthy((function() {if ($truthy(($ret_or_2 = mode['$include?']("w")))) {
        return mode['$include?']("r")['$!']()
      } else {
        return $ret_or_2
      }; return nil; })())) {
        return (self.closed = "read")
      } else {
        return nil
      };
    }, $StringIO_initialize$2.$$arity = -1);
    
    Opal.def(self, '$eof?', $StringIO_eof$ques$3 = function() {
      var self = this;

      
      self.$check_readable();
      return self.position['$=='](self.string.$length());
    }, $StringIO_eof$ques$3.$$arity = 0);
    Opal.alias(self, "eof", "eof?");
    
    Opal.def(self, '$seek', $StringIO_seek$4 = function $$seek(pos, whence) {
      var self = this, $case = nil;

      
      
      if (whence == null) {
        whence = $$$($$($nesting, 'IO'), 'SEEK_SET');
      };
      $case = whence;
      if ($$$($$($nesting, 'IO'), 'SEEK_SET')['$===']($case)) {
      if ($truthy($rb_ge(pos, 0))) {
      } else {
        self.$raise($$$($$($nesting, 'Errno'), 'EINVAL'))
      };
      self.position = pos;}
      else if ($$$($$($nesting, 'IO'), 'SEEK_CUR')['$===']($case)) {if ($truthy($rb_gt($rb_plus(self.position, pos), self.string.$length()))) {
        self.position = self.string.$length()
      } else {
        self.position = $rb_plus(self.position, pos)
      }}
      else if ($$$($$($nesting, 'IO'), 'SEEK_END')['$===']($case)) {if ($truthy($rb_gt(pos, self.string.$length()))) {
        self.position = 0
      } else {
        self.position = $rb_minus(self.position, pos)
      }};
      return 0;
    }, $StringIO_seek$4.$$arity = -2);
    
    Opal.def(self, '$tell', $StringIO_tell$5 = function $$tell() {
      var self = this;

      return self.position
    }, $StringIO_tell$5.$$arity = 0);
    Opal.alias(self, "pos", "tell");
    Opal.alias(self, "pos=", "seek");
    
    Opal.def(self, '$rewind', $StringIO_rewind$6 = function $$rewind() {
      var self = this;

      return self.$seek(0)
    }, $StringIO_rewind$6.$$arity = 0);
    
    Opal.def(self, '$each_byte', $StringIO_each_byte$7 = function $$each_byte() {
      var $iter = $StringIO_each_byte$7.$$p, block = $iter || nil, $a, self = this, i = nil;

      if ($iter) $StringIO_each_byte$7.$$p = null;
      
      
      if ($iter) $StringIO_each_byte$7.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("each_byte")
      };
      self.$check_readable();
      i = self.position;
      while (!($truthy(self['$eof?']()))) {
        
        block.$call(self.string['$[]'](i).$ord());
        i = $rb_plus(i, 1);
      };
      return self;
    }, $StringIO_each_byte$7.$$arity = 0);
    
    Opal.def(self, '$each_char', $StringIO_each_char$8 = function $$each_char() {
      var $iter = $StringIO_each_char$8.$$p, block = $iter || nil, $a, self = this, i = nil;

      if ($iter) $StringIO_each_char$8.$$p = null;
      
      
      if ($iter) $StringIO_each_char$8.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("each_char")
      };
      self.$check_readable();
      i = self.position;
      while (!($truthy(self['$eof?']()))) {
        
        block.$call(self.string['$[]'](i));
        i = $rb_plus(i, 1);
      };
      return self;
    }, $StringIO_each_char$8.$$arity = 0);
    
    Opal.def(self, '$each', $StringIO_each$9 = function $$each(separator) {
      var $iter = $StringIO_each$9.$$p, $yield = $iter || nil, self = this, chomp_lines = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $StringIO_each$9.$$p = null;
      
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if (($yield !== nil)) {
      } else {
        return self.$enum_for("each_line")
      };
      self.$check_readable();
      chomp_lines = false;
      if ($truthy($$$('::', 'Hash')['$==='](separator))) {
        separator = (function() {if ($truthy((chomp_lines = separator['$[]']("chomp")))) {
          return /\r?\n/
        } else {
          return $gvars["/"]
        }; return nil; })()
      } else if ($truthy(separator)) {
        separator = separator.$to_str()
      } else {
        separator = undefined
      };
      
      var str = self.string, stringLength = str.length;
      if (self.position < stringLength) str = str.substr(self.position);
      if (separator) {
        var chomped = (str).$chomp(), trailing = str.length !== chomped.length, splitted = chomped.split(separator);
        for (var i = 0, len = splitted.length; i < len; i++) {
          var line = chomp_lines ? splitted[i] : (i < len - 1 || trailing ? splitted[i] + separator : splitted[i]);
          Opal.yield1($yield, line);
        }
      } else if (separator === undefined) {
        Opal.yield1($yield, str);
      } else {
        var m, re = /(.+(?:\n\n|$))\n*/g;
        while ((m = re.exec(str))) Opal.yield1($yield, m[1]);
      }
      self.position = stringLength;
    ;
      return self;
    }, $StringIO_each$9.$$arity = -1);
    Opal.alias(self, "each_line", "each");
    
    Opal.def(self, '$write', $StringIO_write$10 = function $$write(string) {
      var self = this, before = nil, after = nil;

      
      self.$check_writable();
      string = self.$String(string);
      if (self.string.$length()['$=='](self.position)) {
        
        self.string = $rb_plus(self.string, string);
        return (self.position = $rb_plus(self.position, string.$length()));
      } else {
        
        before = self.string['$[]'](Opal.Range.$new(0, $rb_minus(self.position, 1), false));
        after = self.string['$[]'](Opal.Range.$new($rb_plus(self.position, string.$length()), -1, false));
        self.string = $rb_plus($rb_plus(before, string), after);
        return (self.position = $rb_plus(self.position, string.$length()));
      };
    }, $StringIO_write$10.$$arity = 1);
    
    Opal.def(self, '$read', $StringIO_read$11 = function $$read(length, outbuf) {
      var self = this, string = nil, str = nil;

      
      
      if (length == null) {
        length = nil;
      };
      
      if (outbuf == null) {
        outbuf = nil;
      };
      self.$check_readable();
      if ($truthy(self['$eof?']())) {
        return nil};
      string = (function() {if ($truthy(length)) {
        
        str = self.string['$[]'](self.position, length);
        self.position = $rb_plus(self.position, length);
        return str;
      } else {
        
        str = self.string['$[]'](Opal.Range.$new(self.position, -1, false));
        self.position = self.string.$length();
        return str;
      }; return nil; })();
      if ($truthy(outbuf)) {
        return outbuf.$write(string)
      } else {
        return string
      };
    }, $StringIO_read$11.$$arity = -1);
    
    Opal.def(self, '$close', $StringIO_close$12 = function $$close() {
      var self = this;

      return (self.closed = "both")
    }, $StringIO_close$12.$$arity = 0);
    
    Opal.def(self, '$close_read', $StringIO_close_read$13 = function $$close_read() {
      var self = this;

      if (self.closed['$==']("write")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "read")
      }
    }, $StringIO_close_read$13.$$arity = 0);
    
    Opal.def(self, '$close_write', $StringIO_close_write$14 = function $$close_write() {
      var self = this;

      if (self.closed['$==']("read")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "write")
      }
    }, $StringIO_close_write$14.$$arity = 0);
    
    Opal.def(self, '$closed?', $StringIO_closed$ques$15 = function() {
      var self = this;

      return self.closed['$==']("both")
    }, $StringIO_closed$ques$15.$$arity = 0);
    
    Opal.def(self, '$closed_read?', $StringIO_closed_read$ques$16 = function() {
      var self = this, $ret_or_3 = nil;

      if ($truthy(($ret_or_3 = self.closed['$==']("read")))) {
        return $ret_or_3
      } else {
        return self.closed['$==']("both")
      }
    }, $StringIO_closed_read$ques$16.$$arity = 0);
    
    Opal.def(self, '$closed_write?', $StringIO_closed_write$ques$17 = function() {
      var self = this, $ret_or_4 = nil;

      if ($truthy(($ret_or_4 = self.closed['$==']("write")))) {
        return $ret_or_4
      } else {
        return self.closed['$==']("both")
      }
    }, $StringIO_closed_write$ques$17.$$arity = 0);
    
    Opal.def(self, '$check_writable', $StringIO_check_writable$18 = function $$check_writable() {
      var self = this;

      if ($truthy(self['$closed_write?']())) {
        return self.$raise($$($nesting, 'IOError'), "not opened for writing")
      } else {
        return nil
      }
    }, $StringIO_check_writable$18.$$arity = 0);
    return (Opal.def(self, '$check_readable', $StringIO_check_readable$19 = function $$check_readable() {
      var self = this;

      if ($truthy(self['$closed_read?']())) {
        return self.$raise($$($nesting, 'IOError'), "not opened for reading")
      } else {
        return nil
      }
    }, $StringIO_check_readable$19.$$arity = 0), nil) && 'check_readable';
  })($nesting[0], $$($nesting, 'IO'), $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["prettyprint"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$dup', '$lambda', '$*', '$new', '$to_proc', '$flush', '$attr_reader', '$last', '$<', '$+', '$deq', '$empty?', '$breakables', '$shift', '$output', '$-', '$width', '$!', '$===', '$first', '$length', '$<<', '$add', '$break_outmost_groups', '$group', '$breakable', '$break?', '$call', '$text', '$group_sub', '$nest', '$depth', '$push', '$enq', '$pop', '$delete', '$each', '$clear', '$indent', '$current_group', '$newline', '$genspace', '$group_queue', '$[]', '$downto', '$slice!', '$break', '$[]=']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'PrettyPrint');

    var $nesting = [self].concat($parent_nesting), $PrettyPrint_format$1, $PrettyPrint_singleline_format$3, $PrettyPrint_initialize$4, $PrettyPrint_current_group$6, $PrettyPrint_break_outmost_groups$7, $PrettyPrint_text$8, $PrettyPrint_fill_breakable$9, $PrettyPrint_breakable$11, $PrettyPrint_group$12, $PrettyPrint_group_sub$15, $PrettyPrint_nest$16, $PrettyPrint_flush$17;

    self.$$prototype.group_stack = self.$$prototype.maxwidth = self.$$prototype.output_width = self.$$prototype.buffer_width = self.$$prototype.group_queue = self.$$prototype.buffer = self.$$prototype.output = self.$$prototype.newline = self.$$prototype.genspace = self.$$prototype.indent = nil;
    
    Opal.defs($$($nesting, 'PrettyPrint'), '$format', $PrettyPrint_format$1 = function $$format(output, maxwidth, newline, genspace) {
      var $$2, $iter = $PrettyPrint_format$1.$$p, $yield = $iter || nil, self = this, q = nil;

      if ($iter) $PrettyPrint_format$1.$$p = null;
      
      
      if (output == null) {
        output = "".$dup();
      };
      
      if (maxwidth == null) {
        maxwidth = 79;
      };
      
      if (newline == null) {
        newline = "\n";
      };
      
      if (genspace == null) {
        genspace = $send(self, 'lambda', [], ($$2 = function(n){var self = $$2.$$s == null ? this : $$2.$$s;

      
        
        if (n == null) {
          n = nil;
        };
        return $rb_times(" ", n);}, $$2.$$s = self, $$2.$$arity = 1, $$2));
      };
      q = $send($$($nesting, 'PrettyPrint'), 'new', [output, maxwidth, newline], genspace.$to_proc());
      Opal.yield1($yield, q);
      q.$flush();
      return output;
    }, $PrettyPrint_format$1.$$arity = -1);
    Opal.defs($$($nesting, 'PrettyPrint'), '$singleline_format', $PrettyPrint_singleline_format$3 = function $$singleline_format(output, maxwidth, newline, genspace) {
      var $iter = $PrettyPrint_singleline_format$3.$$p, $yield = $iter || nil, self = this, q = nil;

      if ($iter) $PrettyPrint_singleline_format$3.$$p = null;
      
      
      if (output == null) {
        output = "".$dup();
      };
      
      if (maxwidth == null) {
        maxwidth = nil;
      };
      
      if (newline == null) {
        newline = nil;
      };
      
      if (genspace == null) {
        genspace = nil;
      };
      q = $$($nesting, 'SingleLine').$new(output);
      Opal.yield1($yield, q);
      return output;
    }, $PrettyPrint_singleline_format$3.$$arity = -1);
    
    Opal.def(self, '$initialize', $PrettyPrint_initialize$4 = function $$initialize(output, maxwidth, newline) {
      var $iter = $PrettyPrint_initialize$4.$$p, genspace = $iter || nil, $$5, self = this, $ret_or_1 = nil, root_group = nil;

      if ($iter) $PrettyPrint_initialize$4.$$p = null;
      
      
      if ($iter) $PrettyPrint_initialize$4.$$p = null;;
      
      if (output == null) {
        output = "".$dup();
      };
      
      if (maxwidth == null) {
        maxwidth = 79;
      };
      
      if (newline == null) {
        newline = "\n";
      };
      self.output = output;
      self.maxwidth = maxwidth;
      self.newline = newline;
      self.genspace = (function() {if ($truthy(($ret_or_1 = genspace))) {
        return $ret_or_1
      } else {
        return $send(self, 'lambda', [], ($$5 = function(n){var self = $$5.$$s == null ? this : $$5.$$s;

        
          
          if (n == null) {
            n = nil;
          };
          return $rb_times(" ", n);}, $$5.$$s = self, $$5.$$arity = 1, $$5))
      }; return nil; })();
      self.output_width = 0;
      self.buffer_width = 0;
      self.buffer = [];
      root_group = $$($nesting, 'Group').$new(0);
      self.group_stack = [root_group];
      self.group_queue = $$($nesting, 'GroupQueue').$new(root_group);
      return (self.indent = 0);
    }, $PrettyPrint_initialize$4.$$arity = -1);
    self.$attr_reader("output");
    self.$attr_reader("maxwidth");
    self.$attr_reader("newline");
    self.$attr_reader("genspace");
    self.$attr_reader("indent");
    self.$attr_reader("group_queue");
    
    Opal.def(self, '$current_group', $PrettyPrint_current_group$6 = function $$current_group() {
      var self = this;

      return self.group_stack.$last()
    }, $PrettyPrint_current_group$6.$$arity = 0);
    
    Opal.def(self, '$break_outmost_groups', $PrettyPrint_break_outmost_groups$7 = function $$break_outmost_groups() {
      var $a, $b, self = this, group = nil, data = nil, $ret_or_2 = nil, text = nil;

      while ($truthy($rb_lt(self.maxwidth, $rb_plus(self.output_width, self.buffer_width)))) {
        
        if ($truthy((group = self.group_queue.$deq()))) {
        } else {
          return nil
        };
        while (!($truthy(group.$breakables()['$empty?']()))) {
          
          data = self.buffer.$shift();
          self.output_width = data.$output(self.output, self.output_width);
          self.buffer_width = $rb_minus(self.buffer_width, data.$width());
        };
        while ($truthy((function() {if ($truthy(($ret_or_2 = self.buffer['$empty?']()['$!']()))) {
          return $$($nesting, 'Text')['$==='](self.buffer.$first())
        } else {
          return $ret_or_2
        }; return nil; })())) {
          
          text = self.buffer.$shift();
          self.output_width = text.$output(self.output, self.output_width);
          self.buffer_width = $rb_minus(self.buffer_width, text.$width());
        };
      }
    }, $PrettyPrint_break_outmost_groups$7.$$arity = 0);
    
    Opal.def(self, '$text', $PrettyPrint_text$8 = function $$text(obj, width) {
      var self = this, text = nil;

      
      
      if (width == null) {
        width = obj.$length();
      };
      if ($truthy(self.buffer['$empty?']())) {
        
        self.output['$<<'](obj);
        return (self.output_width = $rb_plus(self.output_width, width));
      } else {
        
        text = self.buffer.$last();
        if ($truthy($$($nesting, 'Text')['$==='](text))) {
        } else {
          
          text = $$($nesting, 'Text').$new();
          self.buffer['$<<'](text);
        };
        text.$add(obj, width);
        self.buffer_width = $rb_plus(self.buffer_width, width);
        return self.$break_outmost_groups();
      };
    }, $PrettyPrint_text$8.$$arity = -2);
    
    Opal.def(self, '$fill_breakable', $PrettyPrint_fill_breakable$9 = function $$fill_breakable(sep, width) {
      var $$10, self = this;

      
      
      if (sep == null) {
        sep = " ";
      };
      
      if (width == null) {
        width = sep.$length();
      };
      return $send(self, 'group', [], ($$10 = function(){var self = $$10.$$s == null ? this : $$10.$$s;

      return self.$breakable(sep, width)}, $$10.$$s = self, $$10.$$arity = 0, $$10));
    }, $PrettyPrint_fill_breakable$9.$$arity = -1);
    
    Opal.def(self, '$breakable', $PrettyPrint_breakable$11 = function $$breakable(sep, width) {
      var self = this, group = nil;

      
      
      if (sep == null) {
        sep = " ";
      };
      
      if (width == null) {
        width = sep.$length();
      };
      group = self.group_stack.$last();
      if ($truthy(group['$break?']())) {
        
        self.$flush();
        self.output['$<<'](self.newline);
        self.output['$<<'](self.genspace.$call(self.indent));
        self.output_width = self.indent;
        return (self.buffer_width = 0);
      } else {
        
        self.buffer['$<<']($$($nesting, 'Breakable').$new(sep, width, self));
        self.buffer_width = $rb_plus(self.buffer_width, width);
        return self.$break_outmost_groups();
      };
    }, $PrettyPrint_breakable$11.$$arity = -1);
    
    Opal.def(self, '$group', $PrettyPrint_group$12 = function $$group(indent, open_obj, close_obj, open_width, close_width) {
      var $$13, $iter = $PrettyPrint_group$12.$$p, $yield = $iter || nil, self = this;

      if ($iter) $PrettyPrint_group$12.$$p = null;
      
      
      if (indent == null) {
        indent = 0;
      };
      
      if (open_obj == null) {
        open_obj = "";
      };
      
      if (close_obj == null) {
        close_obj = "";
      };
      
      if (open_width == null) {
        open_width = open_obj.$length();
      };
      
      if (close_width == null) {
        close_width = close_obj.$length();
      };
      self.$text(open_obj, open_width);
      $send(self, 'group_sub', [], ($$13 = function(){var self = $$13.$$s == null ? this : $$13.$$s, $$14;

      return $send(self, 'nest', [indent], ($$14 = function(){var self = $$14.$$s == null ? this : $$14.$$s;

        return Opal.yieldX($yield, []);}, $$14.$$s = self, $$14.$$arity = 0, $$14))}, $$13.$$s = self, $$13.$$arity = 0, $$13));
      return self.$text(close_obj, close_width);
    }, $PrettyPrint_group$12.$$arity = -1);
    
    Opal.def(self, '$group_sub', $PrettyPrint_group_sub$15 = function $$group_sub() {
      var $iter = $PrettyPrint_group_sub$15.$$p, $yield = $iter || nil, self = this, group = nil;

      if ($iter) $PrettyPrint_group_sub$15.$$p = null;
      
      group = $$($nesting, 'Group').$new($rb_plus(self.group_stack.$last().$depth(), 1));
      self.group_stack.$push(group);
      self.group_queue.$enq(group);
      
      return (function() { try {
      return Opal.yieldX($yield, []);
      } finally {
        (self.group_stack.$pop(), (function() {if ($truthy(group.$breakables()['$empty?']())) {
          return self.group_queue.$delete(group)
        } else {
          return nil
        }; return nil; })())
      }; })();;
    }, $PrettyPrint_group_sub$15.$$arity = 0);
    
    Opal.def(self, '$nest', $PrettyPrint_nest$16 = function $$nest(indent) {
      var $iter = $PrettyPrint_nest$16.$$p, $yield = $iter || nil, self = this;

      if ($iter) $PrettyPrint_nest$16.$$p = null;
      
      self.indent = $rb_plus(self.indent, indent);
      
      return (function() { try {
      return Opal.yieldX($yield, []);
      } finally {
        (self.indent = $rb_minus(self.indent, indent))
      }; })();;
    }, $PrettyPrint_nest$16.$$arity = 1);
    
    Opal.def(self, '$flush', $PrettyPrint_flush$17 = function $$flush() {
      var $$18, self = this;

      
      $send(self.buffer, 'each', [], ($$18 = function(data){var self = $$18.$$s == null ? this : $$18.$$s;
        if (self.output == null) self.output = nil;
        if (self.output_width == null) self.output_width = nil;

      
        
        if (data == null) {
          data = nil;
        };
        return (self.output_width = data.$output(self.output, self.output_width));}, $$18.$$s = self, $$18.$$arity = 1, $$18));
      self.buffer.$clear();
      return (self.buffer_width = 0);
    }, $PrettyPrint_flush$17.$$arity = 0);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Text');

      var $nesting = [self].concat($parent_nesting), $Text_initialize$19, $Text_output$20, $Text_add$22;

      self.$$prototype.objs = self.$$prototype.width = nil;
      
      
      Opal.def(self, '$initialize', $Text_initialize$19 = function $$initialize() {
        var self = this;

        
        self.objs = [];
        return (self.width = 0);
      }, $Text_initialize$19.$$arity = 0);
      self.$attr_reader("width");
      
      Opal.def(self, '$output', $Text_output$20 = function $$output(out, output_width) {
        var $$21, self = this;

        
        $send(self.objs, 'each', [], ($$21 = function(obj){var self = $$21.$$s == null ? this : $$21.$$s;

        
          
          if (obj == null) {
            obj = nil;
          };
          return out['$<<'](obj);}, $$21.$$s = self, $$21.$$arity = 1, $$21));
        return $rb_plus(output_width, self.width);
      }, $Text_output$20.$$arity = 2);
      return (Opal.def(self, '$add', $Text_add$22 = function $$add(obj, width) {
        var self = this;

        
        self.objs['$<<'](obj);
        return (self.width = $rb_plus(self.width, width));
      }, $Text_add$22.$$arity = 2), nil) && 'add';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Breakable');

      var $nesting = [self].concat($parent_nesting), $Breakable_initialize$23, $Breakable_output$24;

      self.$$prototype.group = self.$$prototype.pp = self.$$prototype.indent = self.$$prototype.obj = self.$$prototype.width = nil;
      
      
      Opal.def(self, '$initialize', $Breakable_initialize$23 = function $$initialize(sep, width, q) {
        var self = this;

        
        self.obj = sep;
        self.width = width;
        self.pp = q;
        self.indent = q.$indent();
        self.group = q.$current_group();
        return self.group.$breakables().$push(self);
      }, $Breakable_initialize$23.$$arity = 3);
      self.$attr_reader("obj");
      self.$attr_reader("width");
      self.$attr_reader("indent");
      return (Opal.def(self, '$output', $Breakable_output$24 = function $$output(out, output_width) {
        var self = this;

        
        self.group.$breakables().$shift();
        if ($truthy(self.group['$break?']())) {
          
          out['$<<'](self.pp.$newline());
          out['$<<'](self.pp.$genspace().$call(self.indent));
          return self.indent;
        } else {
          
          if ($truthy(self.group.$breakables()['$empty?']())) {
            self.pp.$group_queue().$delete(self.group)};
          out['$<<'](self.obj);
          return $rb_plus(output_width, self.width);
        };
      }, $Breakable_output$24.$$arity = 2), nil) && 'output';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Group');

      var $nesting = [self].concat($parent_nesting), $Group_initialize$25, $Group_break$26, $Group_break$ques$27, $Group_first$ques$28;

      self.$$prototype["break"] = nil;
      
      
      Opal.def(self, '$initialize', $Group_initialize$25 = function $$initialize(depth) {
        var self = this;

        
        self.depth = depth;
        self.breakables = [];
        return (self["break"] = false);
      }, $Group_initialize$25.$$arity = 1);
      self.$attr_reader("depth");
      self.$attr_reader("breakables");
      
      Opal.def(self, '$break', $Group_break$26 = function() {
        var self = this;

        return (self["break"] = true)
      }, $Group_break$26.$$arity = 0);
      
      Opal.def(self, '$break?', $Group_break$ques$27 = function() {
        var self = this;

        return self["break"]
      }, $Group_break$ques$27.$$arity = 0);
      return (Opal.def(self, '$first?', $Group_first$ques$28 = function() {
        var $a, self = this;

        if ($truthy((($a = self['first'], $a != null && $a !== nil) ? 'instance-variable' : nil))) {
          return false
        } else {
          
          self.first = false;
          return true;
        }
      }, $Group_first$ques$28.$$arity = 0), nil) && 'first?';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'GroupQueue');

      var $nesting = [self].concat($parent_nesting), $GroupQueue_initialize$29, $GroupQueue_enq$31, $GroupQueue_deq$32, $GroupQueue_delete$36;

      self.$$prototype.queue = nil;
      
      
      Opal.def(self, '$initialize', $GroupQueue_initialize$29 = function $$initialize($a) {
        var $post_args, groups, $$30, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        groups = $post_args;;
        self.queue = [];
        return $send(groups, 'each', [], ($$30 = function(g){var self = $$30.$$s == null ? this : $$30.$$s;

        
          
          if (g == null) {
            g = nil;
          };
          return self.$enq(g);}, $$30.$$s = self, $$30.$$arity = 1, $$30));
      }, $GroupQueue_initialize$29.$$arity = -1);
      
      Opal.def(self, '$enq', $GroupQueue_enq$31 = function $$enq(group) {
        var $a, self = this, depth = nil;

        
        depth = group.$depth();
        while (!($truthy($rb_lt(depth, self.queue.$length())))) {
          self.queue['$<<']([])
        };
        return self.queue['$[]'](depth)['$<<'](group);
      }, $GroupQueue_enq$31.$$arity = 1);
      
      Opal.def(self, '$deq', $GroupQueue_deq$32 = function $$deq() {try {

        var $$33, self = this;

        
        $send(self.queue, 'each', [], ($$33 = function(gs){var self = $$33.$$s == null ? this : $$33.$$s, $$34, $$35;

        
          
          if (gs == null) {
            gs = nil;
          };
          $send($rb_minus(gs.$length(), 1), 'downto', [0], ($$34 = function(i){var self = $$34.$$s == null ? this : $$34.$$s, group = nil;

          
            
            if (i == null) {
              i = nil;
            };
            if ($truthy(gs['$[]'](i).$breakables()['$empty?']())) {
              return nil
            } else {
              
              group = gs['$slice!'](i, 1).$first();
              group.$break();
              Opal.ret(group);
            };}, $$34.$$s = self, $$34.$$arity = 1, $$34));
          $send(gs, 'each', [], ($$35 = function(group){var self = $$35.$$s == null ? this : $$35.$$s;

          
            
            if (group == null) {
              group = nil;
            };
            return group.$break();}, $$35.$$s = self, $$35.$$arity = 1, $$35));
          return gs.$clear();}, $$33.$$s = self, $$33.$$arity = 1, $$33));
        return nil;
        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
      }, $GroupQueue_deq$32.$$arity = 0);
      return (Opal.def(self, '$delete', $GroupQueue_delete$36 = function(group) {
        var self = this;

        return self.queue['$[]'](group.$depth()).$delete(group)
      }, $GroupQueue_delete$36.$$arity = 1), nil) && 'delete';
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'SingleLine');

      var $nesting = [self].concat($parent_nesting), $SingleLine_initialize$37, $SingleLine_text$38, $SingleLine_breakable$39, $SingleLine_nest$40, $SingleLine_group$41, $SingleLine_flush$42, $SingleLine_first$ques$43;

      self.$$prototype.output = self.$$prototype.first = nil;
      
      
      Opal.def(self, '$initialize', $SingleLine_initialize$37 = function $$initialize(output, maxwidth, newline) {
        var self = this;

        
        
        if (maxwidth == null) {
          maxwidth = nil;
        };
        
        if (newline == null) {
          newline = nil;
        };
        self.output = output;
        return (self.first = [true]);
      }, $SingleLine_initialize$37.$$arity = -2);
      
      Opal.def(self, '$text', $SingleLine_text$38 = function $$text(obj, width) {
        var self = this;

        
        
        if (width == null) {
          width = nil;
        };
        return self.output['$<<'](obj);
      }, $SingleLine_text$38.$$arity = -2);
      
      Opal.def(self, '$breakable', $SingleLine_breakable$39 = function $$breakable(sep, width) {
        var self = this;

        
        
        if (sep == null) {
          sep = " ";
        };
        
        if (width == null) {
          width = nil;
        };
        return self.output['$<<'](sep);
      }, $SingleLine_breakable$39.$$arity = -1);
      
      Opal.def(self, '$nest', $SingleLine_nest$40 = function $$nest(indent) {
        var $iter = $SingleLine_nest$40.$$p, $yield = $iter || nil, self = this;

        if ($iter) $SingleLine_nest$40.$$p = null;
        return Opal.yieldX($yield, []);
      }, $SingleLine_nest$40.$$arity = 1);
      
      Opal.def(self, '$group', $SingleLine_group$41 = function $$group(indent, open_obj, close_obj, open_width, close_width) {
        var $iter = $SingleLine_group$41.$$p, $yield = $iter || nil, self = this;

        if ($iter) $SingleLine_group$41.$$p = null;
        
        
        if (indent == null) {
          indent = nil;
        };
        
        if (open_obj == null) {
          open_obj = "";
        };
        
        if (close_obj == null) {
          close_obj = "";
        };
        
        if (open_width == null) {
          open_width = nil;
        };
        
        if (close_width == null) {
          close_width = nil;
        };
        self.first.$push(true);
        self.output['$<<'](open_obj);
        Opal.yieldX($yield, []);
        self.output['$<<'](close_obj);
        return self.first.$pop();
      }, $SingleLine_group$41.$$arity = -1);
      
      Opal.def(self, '$flush', $SingleLine_flush$42 = function $$flush() {
        var self = this;

        return nil
      }, $SingleLine_flush$42.$$arity = 0);
      return (Opal.def(self, '$first?', $SingleLine_first$ques$43 = function() {
        var self = this, result = nil, $writer = nil;

        
        result = self.first['$[]'](-1);
        
        $writer = [-1, false];
        $send(self.first, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return result;
      }, $SingleLine_first$ques$43.$$arity = 0), nil) && 'first?';
    })($nesting[0], null, $nesting);
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["pp"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var $$59, $$62, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $gvars = Opal.gvars, $send = Opal.send, $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$new', '$guard_inspect_key', '$pp', '$flush', '$<<', '$bind_call', '$instance_method', '$to_proc', '$attr_accessor', '$==', '$[]', '$current', '$compare_by_identity', '$[]=', '$-', '$include?', '$delete', '$is_a?', '$__getobj__', '$check_inspect_key', '$group', '$pretty_print_cycle', '$push_inspect_key', '$pretty_print', '$sharing_detection', '$pop_inspect_key', '$+', '$name', '$class', '$chomp!', '$text', '$breakable', '$lambda', '$comma_breakable', '$__send__', '$call', '$object_address_group', '$seplist', '$pretty_print_instance_variables', '$===', '$to_s', '$instance_eval', '$include', '$!=', '$owner', '$inspect', '$!', '$respond_to?', '$pp_object', '$sort', '$instance_variables', '$raise', '$singleline_pp', '$dup', '$empty?', '$pp_hash', '$each', '$keys', '$sprintf', '$mcall', '$begin', '$exclude_end?', '$end', '$lines', '$>', '$size', '$named_captures', '$regexp', '$object_group', '$class_eval', '$string', '$<=', '$first', '$module_function']);
  
  self.$require("thread");
  self.$require("stringio");
  self.$require("prettyprint");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'PP');

    var $nesting = [self].concat($parent_nesting), $PP_pp$1, $PP_singleline_pp$3, $PP_mcall$5;

    
    Opal.defs($$($nesting, 'PP'), '$pp', $PP_pp$1 = function $$pp(obj, out, width) {
      var $$2, self = this, q = nil;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      if (out == null) {
        out = $gvars.stdout;
      };
      
      if (width == null) {
        width = 79;
      };
      q = $$($nesting, 'PP').$new(out, width);
      $send(q, 'guard_inspect_key', [], ($$2 = function(){var self = $$2.$$s == null ? this : $$2.$$s;

      return q.$pp(obj)}, $$2.$$s = self, $$2.$$arity = 0, $$2));
      q.$flush();
      return out['$<<']("\n");
    }, $PP_pp$1.$$arity = -2);
    Opal.defs($$($nesting, 'PP'), '$singleline_pp', $PP_singleline_pp$3 = function $$singleline_pp(obj, out) {
      var $$4, self = this, q = nil;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      if (out == null) {
        out = $gvars.stdout;
      };
      q = $$($nesting, 'SingleLine').$new(out);
      $send(q, 'guard_inspect_key', [], ($$4 = function(){var self = $$4.$$s == null ? this : $$4.$$s;

      return q.$pp(obj)}, $$4.$$s = self, $$4.$$arity = 0, $$4));
      q.$flush();
      return out;
    }, $PP_singleline_pp$3.$$arity = -2);
    Opal.defs($$($nesting, 'PP'), '$mcall', $PP_mcall$5 = function $$mcall(obj, mod, meth, $a) {
      var $iter = $PP_mcall$5.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $PP_mcall$5.$$p = null;
      
      
      if ($iter) $PP_mcall$5.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 3, arguments.length);
      
      args = $post_args;;
      return $send(mod.$instance_method(meth), 'bind_call', [obj].concat(Opal.to_a(args)), block.$to_proc());
    }, $PP_mcall$5.$$arity = -4);
    self.sharing_detection = false;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return self.$attr_accessor("sharing_detection")
    })(Opal.get_singleton_class(self), $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'PPMethods');

      var $nesting = [self].concat($parent_nesting), $PPMethods_guard_inspect_key$6, $PPMethods_check_inspect_key$7, $PPMethods_push_inspect_key$8, $PPMethods_pop_inspect_key$9, $PPMethods_pp$10, $PPMethods_object_group$13, $PPMethods_object_address_group$14, $PPMethods_comma_breakable$15, $PPMethods_seplist$16, $PPMethods_pp_object$19, $PPMethods_pp_hash$24;

      
      
      Opal.def(self, '$guard_inspect_key', $PPMethods_guard_inspect_key$6 = function $$guard_inspect_key() {
        var $iter = $PPMethods_guard_inspect_key$6.$$p, $yield = $iter || nil, self = this, $writer = nil, save = nil;

        if ($iter) $PPMethods_guard_inspect_key$6.$$p = null;
        
        if ($$($nesting, 'Thread').$current()['$[]']("__recursive_key__")['$=='](nil)) {
          
          $writer = ["__recursive_key__", $hash2([], {}).$compare_by_identity()];
          $send($$($nesting, 'Thread').$current(), '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if ($$($nesting, 'Thread').$current()['$[]']("__recursive_key__")['$[]']("inspect")['$=='](nil)) {
          
          $writer = ["inspect", $hash2([], {}).$compare_by_identity()];
          $send($$($nesting, 'Thread').$current()['$[]']("__recursive_key__"), '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        save = $$($nesting, 'Thread').$current()['$[]']("__recursive_key__")['$[]']("inspect");
        
        return (function() { try {
        
        
        $writer = ["inspect", $hash2([], {}).$compare_by_identity()];
        $send($$($nesting, 'Thread').$current()['$[]']("__recursive_key__"), '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return Opal.yieldX($yield, []);;
        } finally {
          (($writer = ["inspect", save]), $send($$($nesting, 'Thread').$current()['$[]']("__recursive_key__"), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])
        }; })();;
      }, $PPMethods_guard_inspect_key$6.$$arity = 0);
      
      Opal.def(self, '$check_inspect_key', $PPMethods_check_inspect_key$7 = function $$check_inspect_key(id) {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

        if ($truthy(($ret_or_1 = (function() {if ($truthy(($ret_or_2 = $$($nesting, 'Thread').$current()['$[]']("__recursive_key__")))) {
          return $$($nesting, 'Thread').$current()['$[]']("__recursive_key__")['$[]']("inspect")
        } else {
          return $ret_or_2
        }; return nil; })()))) {
          return $$($nesting, 'Thread').$current()['$[]']("__recursive_key__")['$[]']("inspect")['$include?'](id)
        } else {
          return $ret_or_1
        }
      }, $PPMethods_check_inspect_key$7.$$arity = 1);
      
      Opal.def(self, '$push_inspect_key', $PPMethods_push_inspect_key$8 = function $$push_inspect_key(id) {
        var self = this, $writer = nil;

        
        $writer = [id, true];
        $send($$($nesting, 'Thread').$current()['$[]']("__recursive_key__")['$[]']("inspect"), '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }, $PPMethods_push_inspect_key$8.$$arity = 1);
      
      Opal.def(self, '$pop_inspect_key', $PPMethods_pop_inspect_key$9 = function $$pop_inspect_key(id) {
        var self = this;

        return $$($nesting, 'Thread').$current()['$[]']("__recursive_key__")['$[]']("inspect").$delete(id)
      }, $PPMethods_pop_inspect_key$9.$$arity = 1);
      
      Opal.def(self, '$pp', $PPMethods_pp$10 = function $$pp(obj) {
        var $a, $$11, $$12, self = this, $ret_or_3 = nil;

        
        if ($truthy((function() {if ($truthy(($ret_or_3 = (($a = $$$('::', 'Delegator', 'skip_raise')) ? 'constant' : nil)))) {
          return obj['$is_a?']($$$('::', 'Delegator'))
        } else {
          return $ret_or_3
        }; return nil; })())) {
          obj = obj.$__getobj__()};
        if ($truthy(self.$check_inspect_key(obj))) {
          
          $send(self, 'group', [], ($$11 = function(){var self = $$11.$$s == null ? this : $$11.$$s;

          return obj.$pretty_print_cycle(self)}, $$11.$$s = self, $$11.$$arity = 0, $$11));
          return nil;};
        
        return (function() { try {
        
        self.$push_inspect_key(obj);
        return $send(self, 'group', [], ($$12 = function(){var self = $$12.$$s == null ? this : $$12.$$s;

        return obj.$pretty_print(self)}, $$12.$$s = self, $$12.$$arity = 0, $$12));
        } finally {
          (function() {if ($truthy($$($nesting, 'PP').$sharing_detection())) {
            return nil
          } else {
            return self.$pop_inspect_key(obj)
          }; return nil; })()
        }; })();;
      }, $PPMethods_pp$10.$$arity = 1);
      
      Opal.def(self, '$object_group', $PPMethods_object_group$13 = function $$object_group(obj) {
        var $iter = $PPMethods_object_group$13.$$p, block = $iter || nil, self = this;

        if ($iter) $PPMethods_object_group$13.$$p = null;
        
        
        if ($iter) $PPMethods_object_group$13.$$p = null;;
        return $send(self, 'group', [1, $rb_plus("#<", obj.$class().$name()), ">"], block.$to_proc());
      }, $PPMethods_object_group$13.$$arity = 1);
      
      Opal.def(self, '$object_address_group', $PPMethods_object_address_group$14 = function $$object_address_group(obj) {
        var $iter = $PPMethods_object_address_group$14.$$p, block = $iter || nil, self = this, str = nil;

        if ($iter) $PPMethods_object_address_group$14.$$p = null;
        
        
        if ($iter) $PPMethods_object_address_group$14.$$p = null;;
        str = $$($nesting, 'Kernel').$instance_method("to_s").$bind_call(obj);
        str['$chomp!'](">");
        return $send(self, 'group', [1, str, ">"], block.$to_proc());
      }, $PPMethods_object_address_group$14.$$arity = 1);
      
      Opal.def(self, '$comma_breakable', $PPMethods_comma_breakable$15 = function $$comma_breakable() {
        var self = this;

        
        self.$text(",");
        return self.$breakable();
      }, $PPMethods_comma_breakable$15.$$arity = 0);
      
      Opal.def(self, '$seplist', $PPMethods_seplist$16 = function $$seplist(list, sep, iter_method) {
        var $$17, $$18, $iter = $PPMethods_seplist$16.$$p, $yield = $iter || nil, self = this, $ret_or_4 = nil, first = nil;

        if ($iter) $PPMethods_seplist$16.$$p = null;
        
        
        if (sep == null) {
          sep = nil;
        };
        
        if (iter_method == null) {
          iter_method = "each";
        };
        sep = (function() {if ($truthy(($ret_or_4 = sep))) {
          return $ret_or_4
        } else {
          return $send(self, 'lambda', [], ($$17 = function(){var self = $$17.$$s == null ? this : $$17.$$s;

          return self.$comma_breakable()}, $$17.$$s = self, $$17.$$arity = 0, $$17))
        }; return nil; })();
        first = true;
        return $send(list, '__send__', [iter_method], ($$18 = function($a){var self = $$18.$$s == null ? this : $$18.$$s, $post_args, v;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          v = $post_args;;
          if ($truthy(first)) {
            first = false
          } else {
            sep.$call()
          };
          return Opal.yieldX($yield, Opal.to_a(v));;}, $$18.$$s = self, $$18.$$arity = -1, $$18));
      }, $PPMethods_seplist$16.$$arity = -2);
      
      Opal.def(self, '$pp_object', $PPMethods_pp_object$19 = function $$pp_object(obj) {
        var $$20, self = this;

        return $send(self, 'object_address_group', [obj], ($$20 = function(){var self = $$20.$$s == null ? this : $$20.$$s, $$21, $$22;

        return $send(self, 'seplist', [obj.$pretty_print_instance_variables(), $send(self, 'lambda', [], ($$21 = function(){var self = $$21.$$s == null ? this : $$21.$$s;

          return self.$text(",")}, $$21.$$s = self, $$21.$$arity = 0, $$21))], ($$22 = function(v){var self = $$22.$$s == null ? this : $$22.$$s, $$23;

          
            
            if (v == null) {
              v = nil;
            };
            self.$breakable();
            if ($truthy($$($nesting, 'Symbol')['$==='](v))) {
              v = v.$to_s()};
            self.$text(v);
            self.$text("=");
            return $send(self, 'group', [1], ($$23 = function(){var self = $$23.$$s == null ? this : $$23.$$s;

            
              self.$breakable("");
              return self.$pp(obj.$instance_eval(v));}, $$23.$$s = self, $$23.$$arity = 0, $$23));}, $$22.$$s = self, $$22.$$arity = 1, $$22))}, $$20.$$s = self, $$20.$$arity = 0, $$20))
      }, $PPMethods_pp_object$19.$$arity = 1);
      return (Opal.def(self, '$pp_hash', $PPMethods_pp_hash$24 = function $$pp_hash(obj) {
        var $$25, self = this;

        return $send(self, 'group', [1, "{", "}"], ($$25 = function(){var self = $$25.$$s == null ? this : $$25.$$s, $$26;

        return $send(self, 'seplist', [obj, nil, "each_pair"], ($$26 = function(k, v){var self = $$26.$$s == null ? this : $$26.$$s, $$27;

          
            
            if (k == null) {
              k = nil;
            };
            
            if (v == null) {
              v = nil;
            };
            return $send(self, 'group', [], ($$27 = function(){var self = $$27.$$s == null ? this : $$27.$$s, $$28;

            
              self.$pp(k);
              self.$text("=>");
              return $send(self, 'group', [1], ($$28 = function(){var self = $$28.$$s == null ? this : $$28.$$s;

              
                self.$breakable("");
                return self.$pp(v);}, $$28.$$s = self, $$28.$$arity = 0, $$28));}, $$27.$$s = self, $$27.$$arity = 0, $$27));}, $$26.$$s = self, $$26.$$arity = 2, $$26))}, $$25.$$s = self, $$25.$$arity = 0, $$25))
      }, $PPMethods_pp_hash$24.$$arity = 1), nil) && 'pp_hash';
    })($nesting[0], $nesting);
    self.$include($$($nesting, 'PPMethods'));
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'SingleLine');

      var $nesting = [self].concat($parent_nesting);

      return self.$include($$($nesting, 'PPMethods'))
    })($nesting[0], $$$($$($nesting, 'PrettyPrint'), 'SingleLine'), $nesting);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'ObjectMixin');

      var $nesting = [self].concat($parent_nesting), $ObjectMixin_pretty_print$29, $ObjectMixin_pretty_print_cycle$30, $ObjectMixin_pretty_print_instance_variables$32, $ObjectMixin_pretty_print_inspect$33;

      
      
      Opal.def(self, '$pretty_print', $ObjectMixin_pretty_print$29 = function $$pretty_print(q) {
        var self = this, umethod_method = nil, inspect_method = nil, $ret_or_5 = nil, $ret_or_6 = nil;

        
        umethod_method = $$($nesting, 'Object').$instance_method("method");
        
        try {
          inspect_method = umethod_method.$bind_call(self, "inspect")
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'NameError')])) {
            try {
              nil
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };;
        if ($truthy((function() {if ($truthy(($ret_or_5 = inspect_method))) {
          return inspect_method.$owner()['$!=']($$($nesting, 'Kernel'))
        } else {
          return $ret_or_5
        }; return nil; })())) {
          return q.$text(self.$inspect())
        } else if ($truthy((function() {if ($truthy(($ret_or_6 = inspect_method['$!']()))) {
          return self['$respond_to?']("inspect")
        } else {
          return $ret_or_6
        }; return nil; })())) {
          return q.$text(self.$inspect())
        } else {
          return q.$pp_object(self)
        };
      }, $ObjectMixin_pretty_print$29.$$arity = 1);
      
      Opal.def(self, '$pretty_print_cycle', $ObjectMixin_pretty_print_cycle$30 = function $$pretty_print_cycle(q) {
        var $$31, self = this;

        return $send(q, 'object_address_group', [self], ($$31 = function(){var self = $$31.$$s == null ? this : $$31.$$s;

        
          q.$breakable();
          return q.$text("...");}, $$31.$$s = self, $$31.$$arity = 0, $$31))
      }, $ObjectMixin_pretty_print_cycle$30.$$arity = 1);
      
      Opal.def(self, '$pretty_print_instance_variables', $ObjectMixin_pretty_print_instance_variables$32 = function $$pretty_print_instance_variables() {
        var self = this;

        return self.$instance_variables().$sort()
      }, $ObjectMixin_pretty_print_instance_variables$32.$$arity = 0);
      return (Opal.def(self, '$pretty_print_inspect', $ObjectMixin_pretty_print_inspect$33 = function $$pretty_print_inspect() {
        var self = this;

        
        if ($$($nesting, 'Object').$instance_method("method").$bind_call(self, "pretty_print").$owner()['$==']($$$($$($nesting, 'PP'), 'ObjectMixin'))) {
          self.$raise("" + "pretty_print is not overridden for " + (self.$class()))};
        return $$($nesting, 'PP').$singleline_pp(self, "".$dup());
      }, $ObjectMixin_pretty_print_inspect$33.$$arity = 0), nil) && 'pretty_print_inspect';
    })($nesting[0], $nesting);
  })($nesting[0], $$($nesting, 'PrettyPrint'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_pretty_print$34, $Array_pretty_print_cycle$37;

    
    
    Opal.def(self, '$pretty_print', $Array_pretty_print$34 = function $$pretty_print(q) {
      var $$35, self = this;

      return $send(q, 'group', [1, "[", "]"], ($$35 = function(){var self = $$35.$$s == null ? this : $$35.$$s, $$36;

      return $send(q, 'seplist', [self], ($$36 = function(v){var self = $$36.$$s == null ? this : $$36.$$s;

        
          
          if (v == null) {
            v = nil;
          };
          return q.$pp(v);}, $$36.$$s = self, $$36.$$arity = 1, $$36))}, $$35.$$s = self, $$35.$$arity = 0, $$35))
    }, $Array_pretty_print$34.$$arity = 1);
    return (Opal.def(self, '$pretty_print_cycle', $Array_pretty_print_cycle$37 = function $$pretty_print_cycle(q) {
      var self = this;

      return q.$text((function() {if ($truthy(self['$empty?']())) {
        return "[]"
      } else {
        return "[...]"
      }; return nil; })())
    }, $Array_pretty_print_cycle$37.$$arity = 1), nil) && 'pretty_print_cycle';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $Hash_pretty_print$38, $Hash_pretty_print_cycle$39;

    
    
    Opal.def(self, '$pretty_print', $Hash_pretty_print$38 = function $$pretty_print(q) {
      var self = this;

      return q.$pp_hash(self)
    }, $Hash_pretty_print$38.$$arity = 1);
    return (Opal.def(self, '$pretty_print_cycle', $Hash_pretty_print_cycle$39 = function $$pretty_print_cycle(q) {
      var self = this;

      return q.$text((function() {if ($truthy(self['$empty?']())) {
        return "{}"
      } else {
        return "{...}"
      }; return nil; })())
    }, $Hash_pretty_print_cycle$39.$$arity = 1), nil) && 'pretty_print_cycle';
  })($nesting[0], null, $nesting);
  (function(self, $parent_nesting) {
    var $nesting = [self].concat($parent_nesting), $pretty_print$40;

    return (Opal.def(self, '$pretty_print', $pretty_print$40 = function $$pretty_print(q) {
      var $$41, self = this, h = nil;

      
      h = $hash2([], {});
      $send($$($nesting, 'ENV').$keys().$sort(), 'each', [], ($$41 = function(k){var self = $$41.$$s == null ? this : $$41.$$s, $writer = nil;

      
        
        if (k == null) {
          k = nil;
        };
        $writer = [k, $$($nesting, 'ENV')['$[]'](k)];
        $send(h, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, $$41.$$s = self, $$41.$$arity = 1, $$41));
      return q.$pp_hash(h);
    }, $pretty_print$40.$$arity = 1), nil) && 'pretty_print'
  })(Opal.get_singleton_class($$($nesting, 'ENV')), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $Struct_pretty_print$42, $Struct_pretty_print_cycle$47;

    
    
    Opal.def(self, '$pretty_print', $Struct_pretty_print$42 = function $$pretty_print(q) {
      var $$43, self = this;

      return $send(q, 'group', [1, self.$sprintf("#<struct %s", $$($nesting, 'PP').$mcall(self, $$($nesting, 'Kernel'), "class").$name()), ">"], ($$43 = function(){var self = $$43.$$s == null ? this : $$43.$$s, $$44, $$45;

      return $send(q, 'seplist', [$$($nesting, 'PP').$mcall(self, $$($nesting, 'Struct'), "members"), $send(self, 'lambda', [], ($$44 = function(){var self = $$44.$$s == null ? this : $$44.$$s;

        return q.$text(",")}, $$44.$$s = self, $$44.$$arity = 0, $$44))], ($$45 = function(member){var self = $$45.$$s == null ? this : $$45.$$s, $$46;

        
          
          if (member == null) {
            member = nil;
          };
          q.$breakable();
          q.$text(member.$to_s());
          q.$text("=");
          return $send(q, 'group', [1], ($$46 = function(){var self = $$46.$$s == null ? this : $$46.$$s;

          
            q.$breakable("");
            return q.$pp(self['$[]'](member));}, $$46.$$s = self, $$46.$$arity = 0, $$46));}, $$45.$$s = self, $$45.$$arity = 1, $$45))}, $$43.$$s = self, $$43.$$arity = 0, $$43))
    }, $Struct_pretty_print$42.$$arity = 1);
    return (Opal.def(self, '$pretty_print_cycle', $Struct_pretty_print_cycle$47 = function $$pretty_print_cycle(q) {
      var self = this;

      return q.$text(self.$sprintf("#<struct %s:...>", $$($nesting, 'PP').$mcall(self, $$($nesting, 'Kernel'), "class").$name()))
    }, $Struct_pretty_print_cycle$47.$$arity = 1), nil) && 'pretty_print_cycle';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Range');

    var $nesting = [self].concat($parent_nesting), $Range_pretty_print$48;

    return (Opal.def(self, '$pretty_print', $Range_pretty_print$48 = function $$pretty_print(q) {
      var self = this;

      
      q.$pp(self.$begin());
      q.$breakable("");
      q.$text((function() {if ($truthy(self['$exclude_end?']())) {
        return "..."
      } else {
        return ".."
      }; return nil; })());
      q.$breakable("");
      if ($truthy(self.$end())) {
        return q.$pp(self.$end())
      } else {
        return nil
      };
    }, $Range_pretty_print$48.$$arity = 1), nil) && 'pretty_print'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_pretty_print$49;

    return (Opal.def(self, '$pretty_print', $String_pretty_print$49 = function $$pretty_print(q) {
      var $$50, self = this, lines = nil;

      
      lines = self.$lines();
      if ($truthy($rb_gt(lines.$size(), 1))) {
        return $send(q, 'group', [0, "", ""], ($$50 = function(){var self = $$50.$$s == null ? this : $$50.$$s, $$51, $$52;

        return $send(q, 'seplist', [lines, $send(self, 'lambda', [], ($$51 = function(){var self = $$51.$$s == null ? this : $$51.$$s;

          
            q.$text(" +");
            return q.$breakable();}, $$51.$$s = self, $$51.$$arity = 0, $$51))], ($$52 = function(v){var self = $$52.$$s == null ? this : $$52.$$s;

          
            
            if (v == null) {
              v = nil;
            };
            return q.$pp(v);}, $$52.$$s = self, $$52.$$arity = 1, $$52))}, $$50.$$s = self, $$50.$$arity = 0, $$50))
      } else {
        return q.$text(self.$inspect())
      };
    }, $String_pretty_print$49.$$arity = 1), nil) && 'pretty_print'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $MatchData_pretty_print$53;

    return (Opal.def(self, '$pretty_print', $MatchData_pretty_print$53 = function $$pretty_print(q) {
      var $$54, $$56, self = this, nc = nil;

      
      nc = [];
      $send(self.$regexp().$named_captures(), 'each', [], ($$54 = function(name, indexes){var self = $$54.$$s == null ? this : $$54.$$s, $$55;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (indexes == null) {
          indexes = nil;
        };
        return $send(indexes, 'each', [], ($$55 = function(i){var self = $$55.$$s == null ? this : $$55.$$s, $writer = nil;

        
          
          if (i == null) {
            i = nil;
          };
          $writer = [i, name];
          $send(nc, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$55.$$s = self, $$55.$$arity = 1, $$55));}, $$54.$$s = self, $$54.$$arity = 2, $$54));
      return $send(q, 'object_group', [self], ($$56 = function(){var self = $$56.$$s == null ? this : $$56.$$s, $$57, $$58;

      
        q.$breakable();
        return $send(q, 'seplist', [Opal.Range.$new(0,self.$size(), true), $send(self, 'lambda', [], ($$57 = function(){var self = $$57.$$s == null ? this : $$57.$$s;

        return q.$breakable()}, $$57.$$s = self, $$57.$$arity = 0, $$57))], ($$58 = function(i){var self = $$58.$$s == null ? this : $$58.$$s;

        
          
          if (i == null) {
            i = nil;
          };
          if (i['$=='](0)) {
            return q.$pp(self['$[]'](i))
          } else {
            
            if ($truthy(nc['$[]'](i))) {
              q.$text(nc['$[]'](i))
            } else {
              q.$pp(i)
            };
            q.$text(":");
            return q.$pp(self['$[]'](i));
          };}, $$58.$$s = self, $$58.$$arity = 1, $$58));}, $$56.$$s = self, $$56.$$arity = 0, $$56));
    }, $MatchData_pretty_print$53.$$arity = 1), nil) && 'pretty_print'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting);

    return self.$include($$$($$($nesting, 'PP'), 'ObjectMixin'))
  })($nesting[0], $$($nesting, 'BasicObject'), $nesting);
  $send([$$($nesting, 'Numeric'), $$($nesting, 'Symbol'), $$($nesting, 'FalseClass'), $$($nesting, 'TrueClass'), $$($nesting, 'NilClass'), $$($nesting, 'Module')], 'each', [], ($$59 = function(c){var self = $$59.$$s == null ? this : $$59.$$s, $$60;

  
    
    if (c == null) {
      c = nil;
    };
    return $send(c, 'class_eval', [], ($$60 = function(){var self = $$60.$$s == null ? this : $$60.$$s, $pretty_print_cycle$61;

    return (Opal.def(self, '$pretty_print_cycle', $pretty_print_cycle$61 = function $$pretty_print_cycle(q) {
        var self = this;

        return q.$text(self.$inspect())
      }, $pretty_print_cycle$61.$$arity = 1), nil) && 'pretty_print_cycle'}, $$60.$$s = self, $$60.$$arity = 0, $$60));}, $$59.$$s = self, $$59.$$arity = 1, $$59));
  $send([$$($nesting, 'Numeric'), $$($nesting, 'FalseClass'), $$($nesting, 'TrueClass'), $$($nesting, 'Module')], 'each', [], ($$62 = function(c){var self = $$62.$$s == null ? this : $$62.$$s, $$63;

  
    
    if (c == null) {
      c = nil;
    };
    return $send(c, 'class_eval', [], ($$63 = function(){var self = $$63.$$s == null ? this : $$63.$$s, $pretty_print$64;

    return (Opal.def(self, '$pretty_print', $pretty_print$64 = function $$pretty_print(q) {
        var self = this;

        return q.$text(self.$inspect())
      }, $pretty_print$64.$$arity = 1), nil) && 'pretty_print'}, $$63.$$s = self, $$63.$$arity = 0, $$63));}, $$62.$$s = self, $$62.$$arity = 1, $$62));
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_pretty_inspect$65, $Kernel_pp$66;

    
    
    Opal.def(self, '$pretty_inspect', $Kernel_pretty_inspect$65 = function $$pretty_inspect() {
      var self = this;

      return $$($nesting, 'PP').$pp(self, $$($nesting, 'StringIO').$new()).$string()
    }, $Kernel_pretty_inspect$65.$$arity = 0);
    
    Opal.def(self, '$pp', $Kernel_pp$66 = function $$pp($a) {
      var $post_args, objs, $$67, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objs = $post_args;;
      $send(objs, 'each', [], ($$67 = function(obj){var self = $$67.$$s == null ? this : $$67.$$s;

      
        
        if (obj == null) {
          obj = nil;
        };
        return $$($nesting, 'PP').$pp(obj);}, $$67.$$s = self, $$67.$$arity = 1, $$67));
      if ($truthy($rb_le(objs.$size(), 1))) {
        return objs.$first()
      } else {
        return objs
      };
    }, $Kernel_pp$66.$$arity = -1);
    return self.$module_function("pp");
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["promise"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $send2 = Opal.send2;

  Opal.add_stubs(['$resolve', '$new', '$reject', '$attr_reader', '$===', '$value', '$key?', '$keys', '$!=', '$==', '$<<', '$>>', '$exception?', '$[]', '$resolved?', '$rejected?', '$!', '$error', '$include?', '$action', '$realized?', '$raise', '$^', '$call', '$resolve!', '$exception!', '$any?', '$each', '$reject!', '$there_can_be_only_one!', '$then', '$to_proc', '$fail', '$always', '$trace', '$class', '$object_id', '$+', '$inspect', '$act?', '$nil?', '$prev', '$push', '$concat', '$it', '$proc', '$reverse', '$pop', '$<=', '$length', '$shift', '$-', '$wait', '$map', '$reduce', '$try', '$tap', '$all?', '$find']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Promise');

    var $nesting = [self].concat($parent_nesting), $Promise_value$1, $Promise_error$2, $Promise_when$3, $Promise_initialize$4, $Promise_value$5, $Promise_act$ques$6, $Promise_action$7, $Promise_exception$ques$8, $Promise_realized$ques$9, $Promise_resolved$ques$10, $Promise_rejected$ques$11, $Promise_$$12, $Promise_$lt$lt$13, $Promise_$gt$gt$14, $Promise_resolve$15, $Promise_resolve$excl$16, $Promise_reject$18, $Promise_reject$excl$19, $Promise_exception$excl$21, $Promise_then$22, $Promise_then$excl$23, $Promise_fail$24, $Promise_fail$excl$25, $Promise_always$26, $Promise_always$excl$27, $Promise_trace$28, $Promise_trace$excl$29, $Promise_there_can_be_only_one$excl$30, $Promise_inspect$31;

    self.$$prototype.value = self.$$prototype.action = self.$$prototype.exception = self.$$prototype.realized = self.$$prototype.next = self.$$prototype.delayed = self.$$prototype.error = self.$$prototype.prev = nil;
    
    Opal.defs(self, '$value', $Promise_value$1 = function $$value(value) {
      var self = this;

      return self.$new().$resolve(value)
    }, $Promise_value$1.$$arity = 1);
    Opal.defs(self, '$error', $Promise_error$2 = function $$error(value) {
      var self = this;

      return self.$new().$reject(value)
    }, $Promise_error$2.$$arity = 1);
    Opal.defs(self, '$when', $Promise_when$3 = function $$when($a) {
      var $post_args, promises, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      promises = $post_args;;
      return $$($nesting, 'When').$new(promises);
    }, $Promise_when$3.$$arity = -1);
    self.$attr_reader("error", "prev", "next");
    
    Opal.def(self, '$initialize', $Promise_initialize$4 = function $$initialize(action) {
      var self = this;

      
      
      if (action == null) {
        action = $hash2([], {});
      };
      self.action = action;
      self.realized = false;
      self.exception = false;
      self.value = nil;
      self.error = nil;
      self.delayed = false;
      self.prev = nil;
      return (self.next = []);
    }, $Promise_initialize$4.$$arity = -1);
    
    Opal.def(self, '$value', $Promise_value$5 = function $$value() {
      var self = this;

      if ($truthy($$($nesting, 'Promise')['$==='](self.value))) {
        return self.value.$value()
      } else {
        return self.value
      }
    }, $Promise_value$5.$$arity = 0);
    
    Opal.def(self, '$act?', $Promise_act$ques$6 = function() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.action['$key?']("success")))) {
        return $ret_or_1
      } else {
        return self.action['$key?']("always")
      }
    }, $Promise_act$ques$6.$$arity = 0);
    
    Opal.def(self, '$action', $Promise_action$7 = function $$action() {
      var self = this;

      return self.action.$keys()
    }, $Promise_action$7.$$arity = 0);
    
    Opal.def(self, '$exception?', $Promise_exception$ques$8 = function() {
      var self = this;

      return self.exception
    }, $Promise_exception$ques$8.$$arity = 0);
    
    Opal.def(self, '$realized?', $Promise_realized$ques$9 = function() {
      var self = this;

      return self.realized['$!='](false)
    }, $Promise_realized$ques$9.$$arity = 0);
    
    Opal.def(self, '$resolved?', $Promise_resolved$ques$10 = function() {
      var self = this;

      return self.realized['$==']("resolve")
    }, $Promise_resolved$ques$10.$$arity = 0);
    
    Opal.def(self, '$rejected?', $Promise_rejected$ques$11 = function() {
      var self = this;

      return self.realized['$==']("reject")
    }, $Promise_rejected$ques$11.$$arity = 0);
    
    Opal.def(self, '$^', $Promise_$$12 = function(promise) {
      var self = this;

      
      promise['$<<'](self);
      self['$>>'](promise);
      return promise;
    }, $Promise_$$12.$$arity = 1);
    
    Opal.def(self, '$<<', $Promise_$lt$lt$13 = function(promise) {
      var self = this;

      
      self.prev = promise;
      return self;
    }, $Promise_$lt$lt$13.$$arity = 1);
    
    Opal.def(self, '$>>', $Promise_$gt$gt$14 = function(promise) {
      var self = this, $ret_or_2 = nil;

      
      self.next['$<<'](promise);
      if ($truthy(self['$exception?']())) {
        promise.$reject(self.delayed['$[]'](0))
      } else if ($truthy(self['$resolved?']())) {
        promise.$resolve((function() {if ($truthy(self.delayed)) {
          return self.delayed['$[]'](0)
        } else {
          return self.$value()
        }; return nil; })())
      } else if ($truthy(self['$rejected?']())) {
        if ($truthy((function() {if ($truthy(($ret_or_2 = self.action['$key?']("failure")['$!']()))) {
          return $ret_or_2
        } else {
          return $$($nesting, 'Promise')['$===']((function() {if ($truthy(self.delayed)) {
            return self.delayed['$[]'](0)
          } else {
            return self.error
          }; return nil; })())
        }; return nil; })())) {
          promise.$reject((function() {if ($truthy(self.delayed)) {
            return self.delayed['$[]'](0)
          } else {
            return self.$error()
          }; return nil; })())
        } else if ($truthy(promise.$action()['$include?']("always"))) {
          promise.$reject((function() {if ($truthy(self.delayed)) {
            return self.delayed['$[]'](0)
          } else {
            return self.$error()
          }; return nil; })())}};
      return self;
    }, $Promise_$gt$gt$14.$$arity = 1);
    
    Opal.def(self, '$resolve', $Promise_resolve$15 = function $$resolve(value) {
      var self = this, block = nil, $ret_or_3 = nil, e = nil;

      
      
      if (value == null) {
        value = nil;
      };
      if ($truthy(self['$realized?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "the promise has already been realized")};
      if ($truthy($$($nesting, 'Promise')['$==='](value))) {
        return value['$<<'](self.prev)['$^'](self)};
      
      try {
        
        block = (function() {if ($truthy(($ret_or_3 = self.action['$[]']("success")))) {
          return $ret_or_3
        } else {
          return self.action['$[]']("always")
        }; return nil; })();
        if ($truthy(block)) {
          value = block.$call(value)};
        self['$resolve!'](value);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'Exception')])) {(e = $err)
          try {
            self['$exception!'](e)
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      };;
      return self;
    }, $Promise_resolve$15.$$arity = -1);
    
    Opal.def(self, '$resolve!', $Promise_resolve$excl$16 = function(value) {
      var $$17, self = this;

      
      self.realized = "resolve";
      self.value = value;
      if ($truthy(self.next['$any?']())) {
        return $send(self.next, 'each', [], ($$17 = function(p){var self = $$17.$$s == null ? this : $$17.$$s;

        
          
          if (p == null) {
            p = nil;
          };
          return p.$resolve(value);}, $$17.$$s = self, $$17.$$arity = 1, $$17))
      } else {
        return (self.delayed = [value])
      };
    }, $Promise_resolve$excl$16.$$arity = 1);
    
    Opal.def(self, '$reject', $Promise_reject$18 = function $$reject(value) {
      var self = this, block = nil, $ret_or_4 = nil, e = nil;

      
      
      if (value == null) {
        value = nil;
      };
      if ($truthy(self['$realized?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "the promise has already been realized")};
      if ($truthy($$($nesting, 'Promise')['$==='](value))) {
        return value['$<<'](self.prev)['$^'](self)};
      
      try {
        
        block = (function() {if ($truthy(($ret_or_4 = self.action['$[]']("failure")))) {
          return $ret_or_4
        } else {
          return self.action['$[]']("always")
        }; return nil; })();
        if ($truthy(block)) {
          value = block.$call(value)};
        if ($truthy(self.action['$key?']("always"))) {
          self['$resolve!'](value)
        } else {
          self['$reject!'](value)
        };
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'Exception')])) {(e = $err)
          try {
            self['$exception!'](e)
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      };;
      return self;
    }, $Promise_reject$18.$$arity = -1);
    
    Opal.def(self, '$reject!', $Promise_reject$excl$19 = function(value) {
      var $$20, self = this;

      
      self.realized = "reject";
      self.error = value;
      if ($truthy(self.next['$any?']())) {
        return $send(self.next, 'each', [], ($$20 = function(p){var self = $$20.$$s == null ? this : $$20.$$s;

        
          
          if (p == null) {
            p = nil;
          };
          return p.$reject(value);}, $$20.$$s = self, $$20.$$arity = 1, $$20))
      } else {
        return (self.delayed = [value])
      };
    }, $Promise_reject$excl$19.$$arity = 1);
    
    Opal.def(self, '$exception!', $Promise_exception$excl$21 = function(error) {
      var self = this;

      
      self.exception = true;
      return self['$reject!'](error);
    }, $Promise_exception$excl$21.$$arity = 1);
    
    Opal.def(self, '$then', $Promise_then$22 = function $$then() {
      var $iter = $Promise_then$22.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_then$22.$$p = null;
      
      
      if ($iter) $Promise_then$22.$$p = null;;
      return self['$^']($$($nesting, 'Promise').$new($hash2(["success"], {"success": block})));
    }, $Promise_then$22.$$arity = 0);
    
    Opal.def(self, '$then!', $Promise_then$excl$23 = function() {
      var $iter = $Promise_then$excl$23.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_then$excl$23.$$p = null;
      
      
      if ($iter) $Promise_then$excl$23.$$p = null;;
      self['$there_can_be_only_one!']();
      return $send(self, 'then', [], block.$to_proc());
    }, $Promise_then$excl$23.$$arity = 0);
    Opal.alias(self, "do", "then");
    Opal.alias(self, "do!", "then!");
    
    Opal.def(self, '$fail', $Promise_fail$24 = function $$fail() {
      var $iter = $Promise_fail$24.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_fail$24.$$p = null;
      
      
      if ($iter) $Promise_fail$24.$$p = null;;
      return self['$^']($$($nesting, 'Promise').$new($hash2(["failure"], {"failure": block})));
    }, $Promise_fail$24.$$arity = 0);
    
    Opal.def(self, '$fail!', $Promise_fail$excl$25 = function() {
      var $iter = $Promise_fail$excl$25.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_fail$excl$25.$$p = null;
      
      
      if ($iter) $Promise_fail$excl$25.$$p = null;;
      self['$there_can_be_only_one!']();
      return $send(self, 'fail', [], block.$to_proc());
    }, $Promise_fail$excl$25.$$arity = 0);
    Opal.alias(self, "rescue", "fail");
    Opal.alias(self, "catch", "fail");
    Opal.alias(self, "rescue!", "fail!");
    Opal.alias(self, "catch!", "fail!");
    
    Opal.def(self, '$always', $Promise_always$26 = function $$always() {
      var $iter = $Promise_always$26.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_always$26.$$p = null;
      
      
      if ($iter) $Promise_always$26.$$p = null;;
      return self['$^']($$($nesting, 'Promise').$new($hash2(["always"], {"always": block})));
    }, $Promise_always$26.$$arity = 0);
    
    Opal.def(self, '$always!', $Promise_always$excl$27 = function() {
      var $iter = $Promise_always$excl$27.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_always$excl$27.$$p = null;
      
      
      if ($iter) $Promise_always$excl$27.$$p = null;;
      self['$there_can_be_only_one!']();
      return $send(self, 'always', [], block.$to_proc());
    }, $Promise_always$excl$27.$$arity = 0);
    Opal.alias(self, "finally", "always");
    Opal.alias(self, "ensure", "always");
    Opal.alias(self, "finally!", "always!");
    Opal.alias(self, "ensure!", "always!");
    
    Opal.def(self, '$trace', $Promise_trace$28 = function $$trace(depth) {
      var $iter = $Promise_trace$28.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_trace$28.$$p = null;
      
      
      if ($iter) $Promise_trace$28.$$p = null;;
      
      if (depth == null) {
        depth = nil;
      };
      return self['$^']($$($nesting, 'Trace').$new(depth, block));
    }, $Promise_trace$28.$$arity = -1);
    
    Opal.def(self, '$trace!', $Promise_trace$excl$29 = function($a) {
      var $iter = $Promise_trace$excl$29.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Promise_trace$excl$29.$$p = null;
      
      
      if ($iter) $Promise_trace$excl$29.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      self['$there_can_be_only_one!']();
      return $send(self, 'trace', Opal.to_a(args), block.$to_proc());
    }, $Promise_trace$excl$29.$$arity = -1);
    
    Opal.def(self, '$there_can_be_only_one!', $Promise_there_can_be_only_one$excl$30 = function() {
      var self = this;

      if ($truthy(self.next['$any?']())) {
        return self.$raise($$($nesting, 'ArgumentError'), "a promise has already been chained")
      } else {
        return nil
      }
    }, $Promise_there_can_be_only_one$excl$30.$$arity = 0);
    
    Opal.def(self, '$inspect', $Promise_inspect$31 = function $$inspect() {
      var self = this, result = nil, $ret_or_5 = nil;

      
      result = "" + "#<" + (self.$class()) + "(" + (self.$object_id()) + ")";
      if ($truthy(self.next['$any?']())) {
        result = $rb_plus(result, "" + " >> " + (self.next.$inspect()))};
      result = $rb_plus(result, (function() {if ($truthy(self['$realized?']())) {
        return "" + ": " + ((function() {if ($truthy(($ret_or_5 = self.value))) {
          return $ret_or_5
        } else {
          return self.error
        }; return nil; })().$inspect()) + ">"
      } else {
        return ">"
      }; return nil; })());
      return result;
    }, $Promise_inspect$31.$$arity = 0);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Trace');

      var $nesting = [self].concat($parent_nesting), $Trace_it$32, $Trace_initialize$33;

      
      Opal.defs(self, '$it', $Trace_it$32 = function $$it(promise) {
        var self = this, current = nil, $ret_or_6 = nil, prev = nil;

        
        current = [];
        if ($truthy((function() {if ($truthy(($ret_or_6 = promise['$act?']()))) {
          return $ret_or_6
        } else {
          return promise.$prev()['$nil?']()
        }; return nil; })())) {
          current.$push(promise.$value())};
        prev = promise.$prev();
        if ($truthy(prev)) {
          return current.$concat(self.$it(prev))
        } else {
          return current
        };
      }, $Trace_it$32.$$arity = 1);
      return (Opal.def(self, '$initialize', $Trace_initialize$33 = function $$initialize(depth, block) {
        var $$34, $iter = $Trace_initialize$33.$$p, $yield = $iter || nil, self = this;

        if ($iter) $Trace_initialize$33.$$p = null;
        
        self.depth = depth;
        return $send2(self, Opal.find_super_dispatcher(self, 'initialize', $Trace_initialize$33, false, true), 'initialize', [$hash2(["success"], {"success": $send(self, 'proc', [], ($$34 = function(){var self = $$34.$$s == null ? this : $$34.$$s, trace = nil, $ret_or_7 = nil;

        
          trace = $$($nesting, 'Trace').$it(self).$reverse();
          trace.$pop();
          if ($truthy((function() {if ($truthy(($ret_or_7 = depth))) {
            return $rb_le(depth, trace.$length())
          } else {
            return $ret_or_7
          }; return nil; })())) {
            trace.$shift($rb_minus(trace.$length(), depth))};
          return $send(block, 'call', Opal.to_a(trace));}, $$34.$$s = self, $$34.$$arity = 0, $$34))})], null);
      }, $Trace_initialize$33.$$arity = 2), nil) && 'initialize';
    })($nesting[0], self, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'When');

      var $nesting = [self].concat($parent_nesting), $When_initialize$35, $When_each$37, $When_collect$39, $When_inject$41, $When_wait$43, $When_$gt$gt$45, $When_try$47;

      self.$$prototype.wait = nil;
      
      
      Opal.def(self, '$initialize', $When_initialize$35 = function $$initialize(promises) {
        var $$36, $iter = $When_initialize$35.$$p, $yield = $iter || nil, self = this;

        if ($iter) $When_initialize$35.$$p = null;
        
        
        if (promises == null) {
          promises = [];
        };
        $send2(self, Opal.find_super_dispatcher(self, 'initialize', $When_initialize$35, false, true), 'initialize', [], null);
        self.wait = [];
        return $send(promises, 'each', [], ($$36 = function(promise){var self = $$36.$$s == null ? this : $$36.$$s;

        
          
          if (promise == null) {
            promise = nil;
          };
          return self.$wait(promise);}, $$36.$$s = self, $$36.$$arity = 1, $$36));
      }, $When_initialize$35.$$arity = -1);
      
      Opal.def(self, '$each', $When_each$37 = function $$each() {
        var $iter = $When_each$37.$$p, block = $iter || nil, $$38, self = this;

        if ($iter) $When_each$37.$$p = null;
        
        
        if ($iter) $When_each$37.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "no block given")
        };
        return $send(self, 'then', [], ($$38 = function(values){var self = $$38.$$s == null ? this : $$38.$$s;

        
          
          if (values == null) {
            values = nil;
          };
          return $send(values, 'each', [], block.$to_proc());}, $$38.$$s = self, $$38.$$arity = 1, $$38));
      }, $When_each$37.$$arity = 0);
      
      Opal.def(self, '$collect', $When_collect$39 = function $$collect() {
        var $iter = $When_collect$39.$$p, block = $iter || nil, $$40, self = this;

        if ($iter) $When_collect$39.$$p = null;
        
        
        if ($iter) $When_collect$39.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "no block given")
        };
        return $send(self, 'then', [], ($$40 = function(values){var self = $$40.$$s == null ? this : $$40.$$s;

        
          
          if (values == null) {
            values = nil;
          };
          return $$($nesting, 'When').$new($send(values, 'map', [], block.$to_proc()));}, $$40.$$s = self, $$40.$$arity = 1, $$40));
      }, $When_collect$39.$$arity = 0);
      
      Opal.def(self, '$inject', $When_inject$41 = function $$inject($a) {
        var $iter = $When_inject$41.$$p, block = $iter || nil, $post_args, args, $$42, self = this;

        if ($iter) $When_inject$41.$$p = null;
        
        
        if ($iter) $When_inject$41.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        return $send(self, 'then', [], ($$42 = function(values){var self = $$42.$$s == null ? this : $$42.$$s;

        
          
          if (values == null) {
            values = nil;
          };
          return $send(values, 'reduce', Opal.to_a(args), block.$to_proc());}, $$42.$$s = self, $$42.$$arity = 1, $$42));
      }, $When_inject$41.$$arity = -1);
      Opal.alias(self, "map", "collect");
      Opal.alias(self, "reduce", "inject");
      
      Opal.def(self, '$wait', $When_wait$43 = function $$wait(promise) {
        var $$44, self = this;

        
        if ($truthy($$($nesting, 'Promise')['$==='](promise))) {
        } else {
          promise = $$($nesting, 'Promise').$value(promise)
        };
        if ($truthy(promise['$act?']())) {
          promise = promise.$then()};
        self.wait['$<<'](promise);
        $send(promise, 'always', [], ($$44 = function(){var self = $$44.$$s == null ? this : $$44.$$s;
          if (self.next == null) self.next = nil;

        if ($truthy(self.next['$any?']())) {
            return self.$try()
          } else {
            return nil
          }}, $$44.$$s = self, $$44.$$arity = 0, $$44));
        return self;
      }, $When_wait$43.$$arity = 1);
      Opal.alias(self, "and", "wait");
      
      Opal.def(self, '$>>', $When_$gt$gt$45 = function($a) {
        var $post_args, $$46, $iter = $When_$gt$gt$45.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $When_$gt$gt$45.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        ;
        return $send($send2(self, Opal.find_super_dispatcher(self, '>>', $When_$gt$gt$45, false, true), '>>', $zuper, $iter), 'tap', [], ($$46 = function(){var self = $$46.$$s == null ? this : $$46.$$s;

        return self.$try()}, $$46.$$s = self, $$46.$$arity = 0, $$46));
      }, $When_$gt$gt$45.$$arity = -1);
      return (Opal.def(self, '$try', $When_try$47 = function() {
        var self = this, promise = nil;

        if ($truthy($send(self.wait, 'all?', [], "realized?".$to_proc()))) {
          
          promise = $send(self.wait, 'find', [], "rejected?".$to_proc());
          if ($truthy(promise)) {
            return self.$reject(promise.$error())
          } else {
            return self.$resolve($send(self.wait, 'map', [], "value".$to_proc()))
          };
        } else {
          return nil
        }
      }, $When_try$47.$$arity = 0), nil) && 'try';
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["set"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $module = Opal.module;

  Opal.add_stubs(['$include', '$new', '$nil?', '$===', '$raise', '$each', '$add', '$merge', '$class', '$respond_to?', '$subtract', '$dup', '$join', '$to_a', '$equal?', '$instance_of?', '$==', '$instance_variable_get', '$is_a?', '$size', '$all?', '$include?', '$[]=', '$-', '$enum_for', '$[]', '$<<', '$replace', '$delete', '$select', '$reject', '$delete_if', '$to_proc', '$keep_if', '$each_key', '$empty?', '$eql?', '$instance_eval', '$clear', '$<', '$<=', '$any?', '$!', '$intersect?', '$keys']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Set');

    var $nesting = [self].concat($parent_nesting), $Set_$$$1, $Set_initialize$2, $Set_dup$4, $Set_$minus$5, $Set_inspect$6, $Set_$eq_eq$7, $Set_add$9, $Set_classify$10, $Set_collect$excl$13, $Set_delete$15, $Set_delete$ques$16, $Set_delete_if$17, $Set_keep_if$20, $Set_reject$excl$23, $Set_select$excl$24, $Set_add$ques$25, $Set_each$26, $Set_empty$ques$27, $Set_eql$ques$28, $Set_clear$30, $Set_include$ques$31, $Set_merge$32, $Set_replace$34, $Set_size$35, $Set_subtract$36, $Set_$$38, $Set_superset$ques$39, $Set_proper_superset$ques$41, $Set_subset$ques$43, $Set_proper_subset$ques$45, $Set_intersect$ques$47, $Set_disjoint$ques$50, $Set_to_a$51;

    self.$$prototype.hash = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defs(self, '$[]', $Set_$$$1 = function($a) {
      var $post_args, ary, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      ary = $post_args;;
      return self.$new(ary);
    }, $Set_$$$1.$$arity = -1);
    
    Opal.def(self, '$initialize', $Set_initialize$2 = function $$initialize(enum$) {
      var $iter = $Set_initialize$2.$$p, block = $iter || nil, $$3, self = this;

      if ($iter) $Set_initialize$2.$$p = null;
      
      
      if ($iter) $Set_initialize$2.$$p = null;;
      
      if (enum$ == null) {
        enum$ = nil;
      };
      self.hash = $hash2([], {});
      if ($truthy(enum$['$nil?']())) {
        return nil};
      if ($truthy($$($nesting, 'Enumerable')['$==='](enum$))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "value must be enumerable")
      };
      if ($truthy(block)) {
        return $send(enum$, 'each', [], ($$3 = function(item){var self = $$3.$$s == null ? this : $$3.$$s;

        
          
          if (item == null) {
            item = nil;
          };
          return self.$add(Opal.yield1(block, item));}, $$3.$$s = self, $$3.$$arity = 1, $$3))
      } else {
        return self.$merge(enum$)
      };
    }, $Set_initialize$2.$$arity = -1);
    
    Opal.def(self, '$dup', $Set_dup$4 = function $$dup() {
      var self = this, result = nil;

      
      result = self.$class().$new();
      return result.$merge(self);
    }, $Set_dup$4.$$arity = 0);
    
    Opal.def(self, '$-', $Set_$minus$5 = function(enum$) {
      var self = this;

      
      if ($truthy(enum$['$respond_to?']("each"))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "value must be enumerable")
      };
      return self.$dup().$subtract(enum$);
    }, $Set_$minus$5.$$arity = 1);
    Opal.alias(self, "difference", "-");
    
    Opal.def(self, '$inspect', $Set_inspect$6 = function $$inspect() {
      var self = this;

      return "" + "#<Set: {" + (self.$to_a().$join(",")) + "}>"
    }, $Set_inspect$6.$$arity = 0);
    
    Opal.def(self, '$==', $Set_$eq_eq$7 = function(other) {
      var $$8, self = this, $ret_or_1 = nil;

      if ($truthy(self['$equal?'](other))) {
        return true
      } else if ($truthy(other['$instance_of?'](self.$class()))) {
        return self.hash['$=='](other.$instance_variable_get("@hash"))
      } else if ($truthy((function() {if ($truthy(($ret_or_1 = other['$is_a?']($$($nesting, 'Set'))))) {
        return self.$size()['$=='](other.$size())
      } else {
        return $ret_or_1
      }; return nil; })())) {
        return $send(other, 'all?', [], ($$8 = function(o){var self = $$8.$$s == null ? this : $$8.$$s;
          if (self.hash == null) self.hash = nil;

        
          
          if (o == null) {
            o = nil;
          };
          return self.hash['$include?'](o);}, $$8.$$s = self, $$8.$$arity = 1, $$8))
      } else {
        return false
      }
    }, $Set_$eq_eq$7.$$arity = 1);
    
    Opal.def(self, '$add', $Set_add$9 = function $$add(o) {
      var self = this, $writer = nil;

      
      
      $writer = [o, true];
      $send(self.hash, '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return self;
    }, $Set_add$9.$$arity = 1);
    Opal.alias(self, "<<", "add");
    
    Opal.def(self, '$classify', $Set_classify$10 = function $$classify() {
      var $iter = $Set_classify$10.$$p, block = $iter || nil, $$11, $$12, self = this, result = nil;

      if ($iter) $Set_classify$10.$$p = null;
      
      
      if ($iter) $Set_classify$10.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("classify")
      };
      result = $send($$($nesting, 'Hash'), 'new', [], ($$11 = function(h, k){var self = $$11.$$s == null ? this : $$11.$$s, $writer = nil;

      
        
        if (h == null) {
          h = nil;
        };
        
        if (k == null) {
          k = nil;
        };
        $writer = [k, self.$class().$new()];
        $send(h, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, $$11.$$s = self, $$11.$$arity = 2, $$11));
      $send(self, 'each', [], ($$12 = function(item){var self = $$12.$$s == null ? this : $$12.$$s;

      
        
        if (item == null) {
          item = nil;
        };
        return result['$[]'](Opal.yield1(block, item)).$add(item);}, $$12.$$s = self, $$12.$$arity = 1, $$12));
      return result;
    }, $Set_classify$10.$$arity = 0);
    
    Opal.def(self, '$collect!', $Set_collect$excl$13 = function() {
      var $iter = $Set_collect$excl$13.$$p, block = $iter || nil, $$14, self = this, result = nil;

      if ($iter) $Set_collect$excl$13.$$p = null;
      
      
      if ($iter) $Set_collect$excl$13.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("collect!")
      };
      result = self.$class().$new();
      $send(self, 'each', [], ($$14 = function(item){var self = $$14.$$s == null ? this : $$14.$$s;

      
        
        if (item == null) {
          item = nil;
        };
        return result['$<<'](Opal.yield1(block, item));}, $$14.$$s = self, $$14.$$arity = 1, $$14));
      return self.$replace(result);
    }, $Set_collect$excl$13.$$arity = 0);
    Opal.alias(self, "map!", "collect!");
    
    Opal.def(self, '$delete', $Set_delete$15 = function(o) {
      var self = this;

      
      self.hash.$delete(o);
      return self;
    }, $Set_delete$15.$$arity = 1);
    
    Opal.def(self, '$delete?', $Set_delete$ques$16 = function(o) {
      var self = this;

      if ($truthy(self['$include?'](o))) {
        
        self.$delete(o);
        return self;
      } else {
        return nil
      }
    }, $Set_delete$ques$16.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Set_delete_if$17 = function $$delete_if() {
      var $$18, $$19, $iter = $Set_delete_if$17.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Set_delete_if$17.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return self.$enum_for("delete_if")
      };
      $send($send(self, 'select', [], ($$18 = function(o){var self = $$18.$$s == null ? this : $$18.$$s;

      
        
        if (o == null) {
          o = nil;
        };
        return Opal.yield1($yield, o);;}, $$18.$$s = self, $$18.$$arity = 1, $$18)), 'each', [], ($$19 = function(o){var self = $$19.$$s == null ? this : $$19.$$s;
        if (self.hash == null) self.hash = nil;

      
        
        if (o == null) {
          o = nil;
        };
        return self.hash.$delete(o);}, $$19.$$s = self, $$19.$$arity = 1, $$19));
      return self;
    }, $Set_delete_if$17.$$arity = 0);
    
    Opal.def(self, '$keep_if', $Set_keep_if$20 = function $$keep_if() {
      var $$21, $$22, $iter = $Set_keep_if$20.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Set_keep_if$20.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return self.$enum_for("keep_if")
      };
      $send($send(self, 'reject', [], ($$21 = function(o){var self = $$21.$$s == null ? this : $$21.$$s;

      
        
        if (o == null) {
          o = nil;
        };
        return Opal.yield1($yield, o);;}, $$21.$$s = self, $$21.$$arity = 1, $$21)), 'each', [], ($$22 = function(o){var self = $$22.$$s == null ? this : $$22.$$s;
        if (self.hash == null) self.hash = nil;

      
        
        if (o == null) {
          o = nil;
        };
        return self.hash.$delete(o);}, $$22.$$s = self, $$22.$$arity = 1, $$22));
      return self;
    }, $Set_keep_if$20.$$arity = 0);
    
    Opal.def(self, '$reject!', $Set_reject$excl$23 = function() {
      var $iter = $Set_reject$excl$23.$$p, block = $iter || nil, self = this, before = nil;

      if ($iter) $Set_reject$excl$23.$$p = null;
      
      
      if ($iter) $Set_reject$excl$23.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("reject!")
      };
      before = self.$size();
      $send(self, 'delete_if', [], block.$to_proc());
      if (self.$size()['$=='](before)) {
        return nil
      } else {
        return self
      };
    }, $Set_reject$excl$23.$$arity = 0);
    
    Opal.def(self, '$select!', $Set_select$excl$24 = function() {
      var $iter = $Set_select$excl$24.$$p, block = $iter || nil, self = this, before = nil;

      if ($iter) $Set_select$excl$24.$$p = null;
      
      
      if ($iter) $Set_select$excl$24.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("select!")
      };
      before = self.$size();
      $send(self, 'keep_if', [], block.$to_proc());
      if (self.$size()['$=='](before)) {
        return nil
      } else {
        return self
      };
    }, $Set_select$excl$24.$$arity = 0);
    Opal.alias(self, "filter!", "select!");
    
    Opal.def(self, '$add?', $Set_add$ques$25 = function(o) {
      var self = this;

      if ($truthy(self['$include?'](o))) {
        return nil
      } else {
        return self.$add(o)
      }
    }, $Set_add$ques$25.$$arity = 1);
    
    Opal.def(self, '$each', $Set_each$26 = function $$each() {
      var $iter = $Set_each$26.$$p, block = $iter || nil, self = this;

      if ($iter) $Set_each$26.$$p = null;
      
      
      if ($iter) $Set_each$26.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each")
      };
      $send(self.hash, 'each_key', [], block.$to_proc());
      return self;
    }, $Set_each$26.$$arity = 0);
    
    Opal.def(self, '$empty?', $Set_empty$ques$27 = function() {
      var self = this;

      return self.hash['$empty?']()
    }, $Set_empty$ques$27.$$arity = 0);
    
    Opal.def(self, '$eql?', $Set_eql$ques$28 = function(other) {
      var $$29, self = this;

      return self.hash['$eql?']($send(other, 'instance_eval', [], ($$29 = function(){var self = $$29.$$s == null ? this : $$29.$$s;
        if (self.hash == null) self.hash = nil;

      return self.hash}, $$29.$$s = self, $$29.$$arity = 0, $$29)))
    }, $Set_eql$ques$28.$$arity = 1);
    
    Opal.def(self, '$clear', $Set_clear$30 = function $$clear() {
      var self = this;

      
      self.hash.$clear();
      return self;
    }, $Set_clear$30.$$arity = 0);
    
    Opal.def(self, '$include?', $Set_include$ques$31 = function(o) {
      var self = this;

      return self.hash['$include?'](o)
    }, $Set_include$ques$31.$$arity = 1);
    Opal.alias(self, "member?", "include?");
    
    Opal.def(self, '$merge', $Set_merge$32 = function $$merge(enum$) {
      var $$33, self = this;

      
      $send(enum$, 'each', [], ($$33 = function(item){var self = $$33.$$s == null ? this : $$33.$$s;

      
        
        if (item == null) {
          item = nil;
        };
        return self.$add(item);}, $$33.$$s = self, $$33.$$arity = 1, $$33));
      return self;
    }, $Set_merge$32.$$arity = 1);
    
    Opal.def(self, '$replace', $Set_replace$34 = function $$replace(enum$) {
      var self = this;

      
      self.$clear();
      self.$merge(enum$);
      return self;
    }, $Set_replace$34.$$arity = 1);
    
    Opal.def(self, '$size', $Set_size$35 = function $$size() {
      var self = this;

      return self.hash.$size()
    }, $Set_size$35.$$arity = 0);
    Opal.alias(self, "length", "size");
    
    Opal.def(self, '$subtract', $Set_subtract$36 = function $$subtract(enum$) {
      var $$37, self = this;

      
      $send(enum$, 'each', [], ($$37 = function(item){var self = $$37.$$s == null ? this : $$37.$$s;

      
        
        if (item == null) {
          item = nil;
        };
        return self.$delete(item);}, $$37.$$s = self, $$37.$$arity = 1, $$37));
      return self;
    }, $Set_subtract$36.$$arity = 1);
    
    Opal.def(self, '$|', $Set_$$38 = function(enum$) {
      var self = this;

      
      if ($truthy(enum$['$respond_to?']("each"))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "value must be enumerable")
      };
      return self.$dup().$merge(enum$);
    }, $Set_$$38.$$arity = 1);
    
    Opal.def(self, '$superset?', $Set_superset$ques$39 = function(set) {
      var $$40, self = this, $ret_or_2 = nil;

      
      if ($truthy(($ret_or_2 = set['$is_a?']($$($nesting, 'Set'))))) {
        $ret_or_2
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "value must be a set")
      };
      if ($truthy($rb_lt(self.$size(), set.$size()))) {
        return false};
      return $send(set, 'all?', [], ($$40 = function(o){var self = $$40.$$s == null ? this : $$40.$$s;

      
        
        if (o == null) {
          o = nil;
        };
        return self['$include?'](o);}, $$40.$$s = self, $$40.$$arity = 1, $$40));
    }, $Set_superset$ques$39.$$arity = 1);
    Opal.alias(self, ">=", "superset?");
    
    Opal.def(self, '$proper_superset?', $Set_proper_superset$ques$41 = function(set) {
      var $$42, self = this, $ret_or_3 = nil;

      
      if ($truthy(($ret_or_3 = set['$is_a?']($$($nesting, 'Set'))))) {
        $ret_or_3
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "value must be a set")
      };
      if ($truthy($rb_le(self.$size(), set.$size()))) {
        return false};
      return $send(set, 'all?', [], ($$42 = function(o){var self = $$42.$$s == null ? this : $$42.$$s;

      
        
        if (o == null) {
          o = nil;
        };
        return self['$include?'](o);}, $$42.$$s = self, $$42.$$arity = 1, $$42));
    }, $Set_proper_superset$ques$41.$$arity = 1);
    Opal.alias(self, ">", "proper_superset?");
    
    Opal.def(self, '$subset?', $Set_subset$ques$43 = function(set) {
      var $$44, self = this, $ret_or_4 = nil;

      
      if ($truthy(($ret_or_4 = set['$is_a?']($$($nesting, 'Set'))))) {
        $ret_or_4
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "value must be a set")
      };
      if ($truthy($rb_lt(set.$size(), self.$size()))) {
        return false};
      return $send(self, 'all?', [], ($$44 = function(o){var self = $$44.$$s == null ? this : $$44.$$s;

      
        
        if (o == null) {
          o = nil;
        };
        return set['$include?'](o);}, $$44.$$s = self, $$44.$$arity = 1, $$44));
    }, $Set_subset$ques$43.$$arity = 1);
    Opal.alias(self, "<=", "subset?");
    
    Opal.def(self, '$proper_subset?', $Set_proper_subset$ques$45 = function(set) {
      var $$46, self = this, $ret_or_5 = nil;

      
      if ($truthy(($ret_or_5 = set['$is_a?']($$($nesting, 'Set'))))) {
        $ret_or_5
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "value must be a set")
      };
      if ($truthy($rb_le(set.$size(), self.$size()))) {
        return false};
      return $send(self, 'all?', [], ($$46 = function(o){var self = $$46.$$s == null ? this : $$46.$$s;

      
        
        if (o == null) {
          o = nil;
        };
        return set['$include?'](o);}, $$46.$$s = self, $$46.$$arity = 1, $$46));
    }, $Set_proper_subset$ques$45.$$arity = 1);
    Opal.alias(self, "<", "proper_subset?");
    
    Opal.def(self, '$intersect?', $Set_intersect$ques$47 = function(set) {
      var $$48, $$49, self = this;

      
      if ($truthy(set['$is_a?']($$($nesting, 'Set')))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "value must be a set")
      };
      if ($truthy($rb_lt(self.$size(), set.$size()))) {
        return $send(self, 'any?', [], ($$48 = function(o){var self = $$48.$$s == null ? this : $$48.$$s;

        
          
          if (o == null) {
            o = nil;
          };
          return set['$include?'](o);}, $$48.$$s = self, $$48.$$arity = 1, $$48))
      } else {
        return $send(set, 'any?', [], ($$49 = function(o){var self = $$49.$$s == null ? this : $$49.$$s;

        
          
          if (o == null) {
            o = nil;
          };
          return self['$include?'](o);}, $$49.$$s = self, $$49.$$arity = 1, $$49))
      };
    }, $Set_intersect$ques$47.$$arity = 1);
    
    Opal.def(self, '$disjoint?', $Set_disjoint$ques$50 = function(set) {
      var self = this;

      return self['$intersect?'](set)['$!']()
    }, $Set_disjoint$ques$50.$$arity = 1);
    Opal.alias(self, "+", "|");
    Opal.alias(self, "union", "|");
    return (Opal.def(self, '$to_a', $Set_to_a$51 = function $$to_a() {
      var self = this;

      return self.hash.$keys()
    }, $Set_to_a$51.$$arity = 0), nil) && 'to_a';
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $Enumerable_to_set$52;

    return (Opal.def(self, '$to_set', $Enumerable_to_set$52 = function $$to_set($a, $b) {
      var $iter = $Enumerable_to_set$52.$$p, block = $iter || nil, $post_args, klass, args, self = this;

      if ($iter) $Enumerable_to_set$52.$$p = null;
      
      
      if ($iter) $Enumerable_to_set$52.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      if ($post_args.length > 0) {
        klass = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (klass == null) {
        klass = $$($nesting, 'Set');
      };
      
      args = $post_args;;
      return $send(klass, 'new', [self].concat(Opal.to_a(args)), block.$to_proc());
    }, $Enumerable_to_set$52.$$arity = -1), nil) && 'to_set'
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["time"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass;

  Opal.add_stubs(['$strftime']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $Time_parse$1, $Time_iso8601$2;

    
    Opal.defs(self, '$parse', $Time_parse$1 = function $$parse(str) {
      var self = this;

      return new Date(Date.parse(str));
    }, $Time_parse$1.$$arity = 1);
    return (Opal.def(self, '$iso8601', $Time_iso8601$2 = function $$iso8601() {
      var self = this;

      return self.$strftime("%FT%T%z")
    }, $Time_iso8601$2.$$arity = 0), nil) && 'iso8601';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal/patches/require_dxopal"] = function(Opal) {
  var $require$1, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $send = Opal.send;

  Opal.add_stubs(['$==', '$dxopal_orig_require']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting);

    return Opal.alias(self, "dxopal_orig_require", "require")
  })($nesting[0], $nesting);
  return (Opal.def(self, '$require', $require$1 = function $$require($a) {
    var $post_args, args, self = this;

    
    
    $post_args = Opal.slice.call(arguments, 0, arguments.length);
    
    args = $post_args;;
    if (args['$=='](["dxopal"])) {
      return nil
    } else {
      return $send(self, 'dxopal_orig_require', Opal.to_a(args))
    };
  }, $require$1.$$arity = -1), nil) && 'require';
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var $console$1, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $gvars = Opal.gvars, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$call', '$name', '$class', '$Array', '$backtrace', '$raise', '$new', '$[]=', '$-', '$join', '$sort', '$keys', '$>=', '$[]', '$inspect', '$+']);
  
  self.$require("opal");
  self.$require("console");
  
  Opal.def(self, '$console', $console$1 = function $$console() {
    var self = this;
    if ($gvars.console == null) $gvars.console = nil;

    return $gvars.console
  }, $console$1.$$arity = 0);
  self.$require("dxopal/constants/colors");
  self.$require("dxopal/font");
  self.$require("dxopal/input");
  self.$require("dxopal/input/key_codes");
  self.$require("dxopal/image");
  self.$require("dxopal/sound");
  self.$require("dxopal/sound_effect");
  self.$require("dxopal/sprite");
  self.$require("dxopal/window");
  self.$require("dxopal/version");
  self.$require("singleton");
  self.$require("delegate");
  self.$require("forwardable");
  self.$require("pp");
  self.$require("promise");
  self.$require("set");
  self.$require("time");
  self.$require("dxopal/patches/require_dxopal");
  (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting), $DXOpal_dump_error$2, $DXOpal$3, $DXOpal_p_$4;

    
    self.$include($$$($$$($$($nesting, 'DXOpal'), 'Constants'), 'Colors'));
    self.$include($$$($$$($$($nesting, 'DXOpal'), 'Input'), 'KeyCodes'));
    self.$include($$$($$$($$($nesting, 'DXOpal'), 'Input'), 'MouseCodes'));
    self.$include($$$($$$($$($nesting, 'DXOpal'), 'SoundEffect'), 'WaveTypes'));
    Opal.defs(self, '$dump_error', $DXOpal_dump_error$2 = function $$dump_error() {
      var $iter = $DXOpal_dump_error$2.$$p, block = $iter || nil, self = this, ex = nil, div = nil;

      if ($iter) $DXOpal_dump_error$2.$$p = null;
      
      
      if ($iter) $DXOpal_dump_error$2.$$p = null;;
      try {
        return block.$call()
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'Exception')])) {(ex = $err)
          try {
            
            div = document.getElementById('dxopal-errors');
            if ($truthy(div && !ex.DXOpalPrinted)) {
              
        div.textContent = "ERROR: " + ex.$class().$name();
        var ul = document.createElement('ul');
        // Note: ex.backtrace may be an Array or a String
        self.$Array(ex.$backtrace()).forEach(function(line){
          var li = document.createElement('li');
          li.textContent = line;
          ul.appendChild(li);
        });
        div.appendChild(ul);
        ex.DXOpalPrinted = true;
      };
            return self.$raise(ex);
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      };
    }, $DXOpal_dump_error$2.$$arity = 0);
    Opal.const_set($nesting[0], 'P_CT', $send($$($nesting, 'Hash'), 'new', [], ($DXOpal$3 = function(h, k){var self = $DXOpal$3.$$s == null ? this : $DXOpal$3.$$s, $writer = nil;

    
      
      if (h == null) {
        h = nil;
      };
      
      if (k == null) {
        k = nil;
      };
      $writer = [k, 0];
      $send(h, '[]=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];}, $DXOpal$3.$$s = self, $DXOpal$3.$$arity = 2, $DXOpal$3)));
    return (Opal.def(self, '$p_', $DXOpal_p_$4 = function $$p_(hash, n) {
      var self = this, key = nil, $writer = nil;

      
      
      if (n == null) {
        n = 10;
      };
      key = hash.$keys().$sort().$join();
      if ($truthy($rb_ge($$($nesting, 'P_CT')['$[]'](key), n))) {
        return nil};
      console.log(hash.$inspect());
      
      $writer = [key, $rb_plus($$($nesting, 'P_CT')['$[]'](key), 1)];
      $send($$($nesting, 'P_CT'), '[]=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];;
    }, $DXOpal_p_$4.$$arity = -2), nil) && 'p_';
  })($nesting[0], $nesting);
  
  // Like `console.log`, but prints only limited times.
  // Example:
  //   Opal.DXOpal.p_("player", player)
  (function(){
    var P_CT = {};
    Opal.DXOpal.p_ = function(key, obj, n) {
      n = (n || 10);
      P_CT[key] = (P_CT[key] || 0);
      if (P_CT[key] < n) {
        console.log(key, obj);
        P_CT[key] += 1;
      }
    };
  })();
;
  return self.$include($$($nesting, 'DXOpal'));
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal_ext/sound2"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $class_variable_set = Opal.class_variable_set, $truthy = Opal.truthy, $class_variable_get = Opal.class_variable_get;

  Opal.add_stubs(['$require', '$add_class', '$new', '$audio_context', '$attr_accessor', '$/', '$**', '$*', '$raise', '$path_or_url', '$gain_value']);
  
  self.$require("dxopal/remote_resource");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Sound2');

      var $nesting = [self].concat($parent_nesting), $Sound2_audio_context$1, $Sound2__load$2, $Sound2_initialize$3, $Sound2_set_volume$4, $Sound2_master_volume$eq$5, $Sound2_gain_value$6, $Sound2_play$7, $Sound2_stop$8;

      self.$$prototype.volume = self.$$prototype.decoded = self.$$prototype.source = nil;
      
      $$($nesting, 'RemoteResource').$add_class($$($nesting, 'Sound2'));
      $class_variable_set($nesting[0], '@@master_volume', 230);
      Opal.defs(self, '$audio_context', $Sound2_audio_context$1 = function $$audio_context() {
        var $a, self = this, $ret_or_1 = nil;

        return $class_variable_set($nesting[0], '@@audio_context', (function() {if ($truthy((($a = $nesting[0].$$cvars['@@audio_context'], $a != null) ? 'class variable' : nil))) {
          
          if ($truthy(($ret_or_1 = $class_variable_get($nesting[0], '@@audio_context', false)))) {
            return $ret_or_1
          } else {
            return         new (window.AudioContext||window.webkitAudioContext);
          };
        } else {
          return         new (window.AudioContext||window.webkitAudioContext);
        }; return nil; })())
      }, $Sound2_audio_context$1.$$arity = 0);
      Opal.defs(self, '$_load', $Sound2__load$2 = function $$_load(path_or_url) {
        var self = this, snd = nil, snd_promise = nil;

        
        snd = self.$new(path_or_url);
        snd_promise = 
        new Promise(function(resolve, reject) {
          var request = new XMLHttpRequest();
          request.open('GET', path_or_url, true);
          request.responseType = 'arraybuffer';
          request.onload = function() {
            var audioData = request.response;
            var context = $$($nesting, 'Sound2').$audio_context();
            context.decodeAudioData(audioData, function(decoded) {
              snd['$decoded='](decoded);
              resolve();
            });
          };
          request.send();
        });
      ;
        return [snd, snd_promise];
      }, $Sound2__load$2.$$arity = 1);
      
      Opal.def(self, '$initialize', $Sound2_initialize$3 = function $$initialize(path_or_url) {
        var self = this;

        
        self.path_or_url = path_or_url;
        return (self.volume = 230);
      }, $Sound2_initialize$3.$$arity = 1);
      self.$attr_accessor("decoded");
      
      Opal.def(self, '$set_volume', $Sound2_set_volume$4 = function $$set_volume(volume, time) {
        var self = this;

        
        
        if (time == null) {
          time = 0;
        };
        return (self.volume = volume);
      }, $Sound2_set_volume$4.$$arity = -2);
      Opal.defs(self, '$master_volume=', $Sound2_master_volume$eq$5 = function(volume) {
        var self = this;

        return $class_variable_set($nesting[0], '@@master_volume', volume)
      }, $Sound2_master_volume$eq$5.$$arity = 1);
      
      Opal.def(self, '$gain_value', $Sound2_gain_value$6 = function $$gain_value() {
        var self = this, v_ratio = nil, mv_ratio = nil;

        
        v_ratio = $rb_divide(self.volume, 255.0);
        mv_ratio = $rb_divide($class_variable_get($nesting[0], '@@master_volume', false), 255.0);
        return $rb_times(v_ratio, mv_ratio)['$**'](10);
      }, $Sound2_gain_value$6.$$arity = 0);
      
      Opal.def(self, '$play', $Sound2_play$7 = function $$play() {
        var self = this, source = nil;

        
        if ($truthy(self.decoded)) {
        } else {
          self.$raise("" + "Sound2 " + (self.$path_or_url()) + " is not loaded yet")
        };
        source = nil;
        
        var context = $$($nesting, 'Sound2').$audio_context();
        source = context.createBufferSource();
        source.buffer = self.decoded;

        // source.connect(context.destination);

        var gain = context.createGain();
        gain.gain.value = self.$gain_value();
        source.connect(gain);
        gain.connect(context.destination);

        source.start(0); 
      ;
        return (self.source = source);
      }, $Sound2_play$7.$$arity = 0);
      return (Opal.def(self, '$stop', $Sound2_stop$8 = function $$stop() {
        var self = this;

        
        if ($truthy(self.decoded)) {
        } else {
          return nil
        };
        if ($truthy(self.source)) {
        } else {
          return nil
        };
        return self.source.stop();
      }, $Sound2_stop$8.$$arity = 0), nil) && 'stop';
    })($nesting[0], $$($nesting, 'RemoteResource'), $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["dxopal_ext/sound_effect2"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass;

  Opal.add_stubs(['$add_class', '$new', '$audio_context', '$/', '$call', '$raise', '$+', '$inspect']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'DXOpal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'SoundEffect2');

      var $nesting = [self].concat($parent_nesting), $SoundEffect2__load$1, $SoundEffect2_add$2;

      
      $$($nesting, 'RemoteResource').$add_class($$($nesting, 'SoundEffect2'));
      (function($base, $parent_nesting) {
        var self = $module($base, 'WaveTypes');

        var $nesting = [self].concat($parent_nesting);

        
        Opal.const_set($nesting[0], 'WAVE_SIN', "sine");
        Opal.const_set($nesting[0], 'WAVE_SAW', "sawtooth");
        Opal.const_set($nesting[0], 'WAVE_TRI', "triangle");
        return Opal.const_set($nesting[0], 'WAVE_RECT', "square");
      })($nesting[0], $nesting);
      Opal.defs(self, '$_load', $SoundEffect2__load$1 = function $$_load(time, wave_type, resolution) {
        var $iter = $SoundEffect2__load$1.$$p, block = $iter || nil, self = this, snd = nil, snd_promise = nil;

        if ($iter) $SoundEffect2__load$1.$$p = null;
        
        
        if ($iter) $SoundEffect2__load$1.$$p = null;;
        
        if (wave_type == null) {
          wave_type = $$($nesting, 'WAVE_RECT');
        };
        
        if (resolution == null) {
          resolution = 1000;
        };
        snd = self.$new("(soundeffect)");
        snd_promise = 
        new Promise(function(resolve, reject){
          var n_channels = 1;
          var context = $$($nesting, 'Sound2').$audio_context();
          var n_ticks = time;
          var totalSeconds = $rb_divide(time, resolution);
          var valuesPerSecond = context.sampleRate;
          var n_values = totalSeconds * valuesPerSecond;
          var myArrayBuffer = context.createBuffer(n_channels, n_values, valuesPerSecond);
          var values = myArrayBuffer.getChannelData(0);
          var n = 0;
          for (var i = 0; i < n_ticks; i++) {
            var ret = block.$call();
            var freq = ret[0], volume = ret[1];
            if (freq < 0) freq = 0;
            if (freq > 44100) freq = 44100;
            if (volume < 0) volume = 0;
            if (volume > 255) volume = 255;
            var vol = volume / 255;   // 0.0~1.0

            var period = valuesPerSecond * 1 / freq;
            for (; n < ((i+1) / n_ticks * n_values); n++) {
              var phase = (n % period) / period; // 0.0~1.0
              var value; // -1.0~1.0
              switch(wave_type) {
              case "sine":
                value = Math.sin(2 * Math.PI * phase) * 2 - 1;
                break;
              case "sawtooth":
                value = phase * 2 - 1;
                break;
              case "triangle":
                value = phase < 0.25 ?  0+phase*4 :
                        phase < 0.5  ?  1-(phase-0.25)*4 :
                        phase < 0.75 ?  0-(phase-0.5)*4 :
                                       -1+(phase-0.75)*4;
                break;
              case "square":
                value = (phase < 0.5 ? 1 : -1);
                break;
              default:
                self.$raise($rb_plus("unknown wave_type: ", wave_type.$inspect()));
              }
              values[n] = value * vol;
            }
          }
          snd['$decoded='](myArrayBuffer);
          resolve();
        });
      ;
        return [snd, snd_promise];
      }, $SoundEffect2__load$1.$$arity = -2);
      return (Opal.def(self, '$add', $SoundEffect2_add$2 = function $$add(wave_type, resolution) {
        var self = this;

        
        
        if (wave_type == null) {
          wave_type = $$($nesting, 'WAVE_RECT');
        };
        
        if (resolution == null) {
          resolution = 1000;
        };
        return $$($nesting, 'TODO');
      }, $SoundEffect2_add$2.$$arity = -1), nil) && 'add';
    })($nesting[0], $$($nesting, 'Sound2'), $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["ball"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send2 = Opal.send2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$*', '$create_image', '$new', '$angle=', '$-', '$physical_body=', '$lv_to_color', '$box', '$draw_font', '$[]', '$==', '$lv', '$<=', '$each', '$on_hit']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Ball');

    var $nesting = [self].concat($parent_nesting), $Ball_initialize$1, $Ball_create$2, $Ball_create_image$3, $Ball_lv_to_color$4, $Ball_hit$5;

    self.$$prototype.lv = self.$$prototype.observers = nil;
    
    Opal.const_set($nesting[0], 'COLORS', [[246, 255, 153], [159, 255, 239], [217, 164, 254], [254, 198, 170], [175, 253, 182], [180, 193, 253], [253, 186, 214], [232, 253, 191], [196, 248, 253], [255, 127, 127]]);
    self.$attr_reader("lv");
    
    Opal.def(self, '$initialize', $Ball_initialize$1 = function $$initialize(x, y, img, lv, observers) {
      var $iter = $Ball_initialize$1.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Ball_initialize$1.$$p = null;
      
      $send2(self, Opal.find_super_dispatcher(self, 'initialize', $Ball_initialize$1, false, true), 'initialize', [x, y, img], null);
      self.lv = lv;
      return (self.observers = observers);
    }, $Ball_initialize$1.$$arity = 5);
    Opal.defs(self, '$create', $Ball_create$2 = function $$create(x, y, radius, lv, angle, observers) {
      var self = this, w = nil, img = nil, ball = nil, $writer = nil;

      
      w = $rb_times(radius, 2);
      img = self.$create_image(lv, w);
      ball = $$($nesting, 'Ball').$new(x, y, img, lv, observers);
      
      $writer = [angle];
      $send(ball, 'angle=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      
      $writer = [["rectangle", w, w, {restitution: 0.9}]];
      $send(ball, 'physical_body=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return ball;
    }, $Ball_create$2.$$arity = 6);
    Opal.defs(self, '$create_image', $Ball_create_image$3 = function $$create_image(lv, w, opacity) {
      var self = this, color = nil, img = nil;

      
      
      if (opacity == null) {
        opacity = 255;
      };
      color = self.$lv_to_color(lv, opacity);
      img = $$($nesting, 'Image').$new(w, w, color);
      img.$box(0, 0, $rb_minus(w, 1), $rb_minus(w, 1), [opacity, 0, 0, 0]);
      img.$draw_font(2, 2, "" + (lv), $$($nesting, 'FONT_BALL'), [opacity, 0, 0, 0]);
      return img;
    }, $Ball_create_image$3.$$arity = -3);
    Opal.defs(self, '$lv_to_color', $Ball_lv_to_color$4 = function $$lv_to_color(lv, opacity) {
      var self = this, rgb = nil, $ret_or_1 = nil;

      
      
      if (opacity == null) {
        opacity = 255;
      };
      rgb = (function() {if ($truthy(($ret_or_1 = $$($nesting, 'COLORS')['$[]']($rb_minus(lv, 1))))) {
        return $ret_or_1
      } else {
        return [255, 255, 0]
      }; return nil; })();
      return [opacity].concat(Opal.to_a(rgb));
    }, $Ball_lv_to_color$4.$$arity = -2);
    return (Opal.def(self, '$hit', $Ball_hit$5 = function $$hit(offence) {
      var $$6, self = this;

      if (self.lv['$=='](offence.$lv())) {
        if ($truthy($rb_le(self.lv, $rb_minus($$$($$($nesting, 'Game'), 'LV_MAX'), 1)))) {
          return $send(self.observers, 'each', [], ($$6 = function(observer){var self = $$6.$$s == null ? this : $$6.$$s;

          
            
            if (observer == null) {
              observer = nil;
            };
            return observer.$on_hit(self, offence);}, $$6.$$s = self, $$6.$$arity = 1, $$6))
        } else {
          return nil
        }
      } else {
        return nil
      }
    }, $Ball_hit$5.$$arity = 1), nil) && 'hit';
  })($nesting[0], $$($nesting, 'Sprite'), $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["game"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash = Opal.hash, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy, $range = Opal.range;

  Opal.add_stubs(['$-', '$update_next_lv', '$*', '$rand', '$now', '$reset', '$each', '$vanish', '$clean_balls', '$+', '$make_wall', '$play', '$[]', '$select', '$vanished?', '$remove_matter_body', '$clean', '$draw_box_fill', '$draw_font', '$<', '$to_radius', '$sqrt', '$**', '$lv_to_color', '$create_image', '$draw_rot', '$cos', '$/', '$draw_line', '$each_with_index', '$size', '$format', '$draw', '$<<', '$create', '$next_radius', '$mouse_x', '$mouse_y', '$to_drop_x', '$mouse_push?', '$<=', '$===', '$drop_ball', '$==', '$check', '$!', '$x', '$y', '$lv', '$uniq', '$map', '$draw_basket', '$draw_score', '$draw_next_next', '$draw_next_cursor', '$draw_gameover', '$max', '$>', '$flatten', '$to_a', '$sample', '$new', '$physical_body=']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Game');

    var $nesting = [self].concat($parent_nesting), $Game_initialize$1, $Game_reset$2, $Game_init_basket$4, $Game_set_auto_drop$5, $Game_clean_balls$6, $Game_draw_gameover$9, $Game_draw_next_cursor$10, $Game_draw_debug_info$12, $Game_draw_basket$14, $Game_draw_score$15, $Game_draw_next_next$16, $Game_drop_ball$17, $Game_on_hit$18, $Game_tick$19, $Game_update_next_lv$29, $Game_next_radius$30, $Game_to_radius$31, $Game_to_drop_x$32, $Game_make_wall$33;

    self.$$prototype.balls = self.$$prototype.score = self.$$prototype.t_gameover_started_at = self.$$prototype.next_lv = self.$$prototype.next_angle = self.$$prototype.collision_list = self.$$prototype.next_next_lv = self.$$prototype.scene = self.$$prototype.basket_floor = self.$$prototype.basket_wall_l = self.$$prototype.basket_wall_r = self.$$prototype.auto_drop = self.$$prototype.t_next_auto_drop = nil;
    
    Opal.const_set($nesting[0], 'BASKET_X_MIN', 150);
    Opal.const_set($nesting[0], 'BASKET_X_MAX', $rb_minus($rb_minus(640, 150), 40));
    Opal.const_set($nesting[0], 'BASKET_W', $rb_minus($$($nesting, 'BASKET_X_MAX'), $$($nesting, 'BASKET_X_MIN')));
    Opal.const_set($nesting[0], 'BASKET_Y_MIN', 100);
    Opal.const_set($nesting[0], 'BASKET_Y_MAX', 440);
    Opal.const_set($nesting[0], 'BASKET_H', $rb_minus($$($nesting, 'BASKET_Y_MAX'), $$($nesting, 'BASKET_Y_MIN')));
    Opal.const_set($nesting[0], 'LV_MAX', 10);
    Opal.const_set($nesting[0], 'MAP_LV_SCORE', $hash(1, 1, 2, 2, 3, 5, 4, 10, 5, 15, 6, 20, 7, 50, 8, 100, 9, 200, 10, 500));
    
    Opal.def(self, '$initialize', $Game_initialize$1 = function $$initialize() {
      var self = this;

      
      self.basket_floor = nil;
      self.basket_wall_l = nil;
      self.basket_wall_r = nil;
      self.balls = [];
      self.collision_list = [];
      self.$update_next_lv();
      self.scene = "main";
      self.next_lv = 1;
      self.next_next_lv = 1;
      self.next_angle = $rb_times(self.$rand(), 90);
      self.t_gameover_started_at = $$($nesting, 'Time').$now();
      self.auto_drop = false;
      return self.$reset();
    }, $Game_initialize$1.$$arity = 0);
    
    Opal.def(self, '$reset', $Game_reset$2 = function $$reset() {
      var $$3, self = this;

      
      $send(self.balls, 'each', [], ($$3 = function(ball){var self = $$3.$$s == null ? this : $$3.$$s;

      
        
        if (ball == null) {
          ball = nil;
        };
        return ball.$vanish();}, $$3.$$s = self, $$3.$$arity = 1, $$3));
      self.$clean_balls(self.balls);
      self.score = 0;
      return (self.t_next_auto_drop = $rb_plus($$($nesting, 'Time').$now(), 1));
    }, $Game_reset$2.$$arity = 0);
    
    Opal.def(self, '$init_basket', $Game_init_basket$4 = function $$init_basket() {
      var self = this;

      
      self.basket_floor = self.$make_wall($$($nesting, 'BASKET_X_MIN'), $$($nesting, 'BASKET_Y_MAX'), 300, 40);
      self.basket_wall_l = self.$make_wall($rb_minus($$($nesting, 'BASKET_X_MIN'), 40), 100, 40, $rb_plus($$($nesting, 'BASKET_Y_MAX'), 40));
      return (self.basket_wall_r = self.$make_wall($$($nesting, 'BASKET_X_MAX'), 100, 40, $rb_plus($$($nesting, 'BASKET_Y_MAX'), 40)));
    }, $Game_init_basket$4.$$arity = 0);
    
    Opal.def(self, '$set_auto_drop', $Game_set_auto_drop$5 = function $$set_auto_drop(auto) {
      var self = this;

      
      self.t_next_auto_drop = $rb_plus($$($nesting, 'Time').$now(), 1);
      self.auto_drop = auto;
      return $$($nesting, 'SoundEffect2')['$[]']("s1").$play();
    }, $Game_set_auto_drop$5.$$arity = 1);
    
    Opal.def(self, '$clean_balls', $Game_clean_balls$6 = function $$clean_balls(balls) {
      var $$7, $$8, self = this;

      
      $send($send(balls, 'select', [], ($$7 = function(ball){var self = $$7.$$s == null ? this : $$7.$$s;

      
        
        if (ball == null) {
          ball = nil;
        };
        return ball['$vanished?']();}, $$7.$$s = self, $$7.$$arity = 1, $$7)), 'each', [], ($$8 = function(ball){var self = $$8.$$s == null ? this : $$8.$$s;

      
        
        if (ball == null) {
          ball = nil;
        };
        return ball.$remove_matter_body();}, $$8.$$s = self, $$8.$$arity = 1, $$8));
      return $$($nesting, 'Sprite').$clean(balls);
    }, $Game_clean_balls$6.$$arity = 1);
    
    Opal.def(self, '$draw_gameover', $Game_draw_gameover$9 = function $$draw_gameover() {
      var self = this, x = nil, y = nil;

      
      x = 130;
      y = 160;
      $$($nesting, 'Window').$draw_box_fill(0, 0, $$($nesting, 'WIN_W'), $$($nesting, 'WIN_H'), [80, 0, 0, 0]);
      $$($nesting, 'Window').$draw_font(x, y, "GAME OVER", $$($nesting, 'FONT_GAMEOVER'), $hash2(["color"], {"color": $$($nesting, 'C_WHITE')}));
      y = $rb_plus(y, 80);
      $$($nesting, 'Window').$draw_font(x, y, "" + "SCORE: " + (self.score), $$($nesting, 'FONT_GAMEOVER'), $hash2(["color"], {"color": $$($nesting, 'C_WHITE')}));
      y = $rb_plus(y, 100);
      if ($truthy($rb_lt($rb_plus(self.t_gameover_started_at, 2), $$($nesting, 'Time').$now()))) {
        return $$($nesting, 'Window').$draw_font(x, y, "click to start", $$($nesting, 'FONT_DEFAULT'), $hash2(["color"], {"color": $$($nesting, 'C_WHITE')}))
      } else {
        return nil
      };
    }, $Game_draw_gameover$9.$$arity = 0);
    
    Opal.def(self, '$draw_next_cursor', $Game_draw_next_cursor$10 = function $$draw_next_cursor(dx) {
      var $$11, self = this, next_rad = nil, circle_rad = nil, next_color = nil, next_img = nil, width = nil;

      
      next_rad = $$($nesting, 'Game').$to_radius(self.next_lv);
      circle_rad = $$($nesting, 'Math').$sqrt($rb_times(next_rad['$**'](2), 2));
      next_color = $$($nesting, 'Ball').$lv_to_color(self.next_lv, 100);
      next_img = $$($nesting, 'Ball').$create_image(self.next_lv, $rb_times(next_rad, 2), 100);
      $$($nesting, 'Window').$draw_rot($rb_minus(dx, next_rad), 40, next_img, self.next_angle, next_rad, next_rad);
      width = $rb_times(circle_rad, $$($nesting, 'Math').$cos($rb_times($rb_minus(90, $rb_plus(self.next_angle, 45)), $rb_divide($$$($$($nesting, 'Math'), 'PI'), 180.0))));
      return $send([$rb_minus(dx, width), $rb_plus(dx, width)], 'each', [], ($$11 = function(x){var self = $$11.$$s == null ? this : $$11.$$s;

      
        
        if (x == null) {
          x = nil;
        };
        return $$($nesting, 'Window').$draw_line(x, 0, x, $$($nesting, 'WIN_H'), [100, 0, 0, 0]);}, $$11.$$s = self, $$11.$$arity = 1, $$11));
    }, $Game_draw_next_cursor$10.$$arity = 1);
    
    Opal.def(self, '$draw_debug_info', $Game_draw_debug_info$12 = function $$draw_debug_info(y_max) {
      var $$13, self = this;

      return $send(["" + "@balls.size " + (self.balls.$size()), "" + "@collision_list.size " + (self.collision_list.$size()), "" + "@next_lv " + (self.next_lv), "" + "@next_next_lv " + (self.next_next_lv), self.$format("y max %.2f", y_max), "" + "@scene " + (self.scene)], 'each_with_index', [], ($$13 = function(line, i){var self = $$13.$$s == null ? this : $$13.$$s;

      
        
        if (line == null) {
          line = nil;
        };
        
        if (i == null) {
          i = nil;
        };
        return $$($nesting, 'Window').$draw_font(2, $rb_plus($rb_times(i, 20), 40), line, $$($nesting, 'FONT_DEBUG_INFO'), $hash2(["color"], {"color": [120, 0, 0, 0]}));}, $$13.$$s = self, $$13.$$arity = 2, $$13))
    }, $Game_draw_debug_info$12.$$arity = 1);
    
    Opal.def(self, '$draw_basket', $Game_draw_basket$14 = function $$draw_basket() {
      var self = this;

      
      self.basket_floor.$draw();
      self.basket_wall_l.$draw();
      return self.basket_wall_r.$draw();
    }, $Game_draw_basket$14.$$arity = 0);
    
    Opal.def(self, '$draw_score', $Game_draw_score$15 = function $$draw_score() {
      var self = this;

      return $$($nesting, 'Window').$draw_font(4, 2, "" + "score: " + (self.score), $$($nesting, 'FONT_DEFAULT'), $hash2(["color"], {"color": [200, 0, 0, 0]}))
    }, $Game_draw_score$15.$$arity = 0);
    
    Opal.def(self, '$draw_next_next', $Game_draw_next_next$16 = function $$draw_next_next() {
      var self = this, base_x = nil, next_next_rad = nil, next_next_peri = nil, next_next_img = nil;

      
      base_x = 540;
      $$($nesting, 'Window').$draw_font($rb_minus(base_x, 60), 2, "next:", $$($nesting, 'FONT_DEFAULT'), $hash2(["color"], {"color": [200, 0, 0, 0]}));
      next_next_rad = $$($nesting, 'Game').$to_radius(self.next_next_lv);
      next_next_peri = $rb_times(next_next_rad, 2);
      next_next_img = $$($nesting, 'Ball').$create_image(self.next_next_lv, next_next_peri, 200);
      return $$($nesting, 'Window').$draw(base_x, 4, next_next_img);
    }, $Game_draw_next_next$16.$$arity = 0);
    
    Opal.def(self, '$drop_ball', $Game_drop_ball$17 = function $$drop_ball(dx) {
      var self = this, lv = nil;

      
      lv = self.next_lv;
      self.balls['$<<']($$($nesting, 'Ball').$create($rb_minus(dx, self.$next_radius()), 40, self.$next_radius(), self.next_lv, self.next_angle, [self]));
      self.next_angle = $rb_times(self.$rand(), 90);
      self.$update_next_lv();
      return $$($nesting, 'SoundEffect2')['$[]']("" + "lv" + (lv)).$play();
    }, $Game_drop_ball$17.$$arity = 1);
    
    Opal.def(self, '$on_hit', $Game_on_hit$18 = function $$on_hit(b1, b2) {
      var self = this;

      return self.collision_list['$<<']([b1, b2])
    }, $Game_on_hit$18.$$arity = 2);
    
    Opal.def(self, '$tick', $Game_tick$19 = function $$tick() {
      var $$20, $$21, $$22, $$23, $$24, $$25, $$26, $$27, $$28, self = this, mx = nil, my = nil, dx = nil, $ret_or_1 = nil, $case = nil, new_balls = nil, lvs = nil, $ret_or_3 = nil, y_max = nil, $ret_or_4 = nil;

      
      mx = $$($nesting, 'Input').$mouse_x();
      my = $$($nesting, 'Input').$mouse_y();
      dx = self.$to_drop_x(mx);
      if ($truthy($$($nesting, 'Input')['$mouse_push?']($$($nesting, 'M_LBUTTON')))) {
        if ($truthy((function() {if ($truthy(($ret_or_1 = $rb_le(0, my)))) {
          return $rb_lt(my, $$($nesting, 'WIN_H'))
        } else {
          return $ret_or_1
        }; return nil; })())) {
          $case = self.scene;
          if ("main"['$===']($case)) {self.$drop_ball(dx)}
          else if ("gameover"['$===']($case)) {if ($truthy($rb_lt($rb_plus(self.t_gameover_started_at, 2), $$($nesting, 'Time').$now()))) {
            
            $$($nesting, 'SoundEffect2')['$[]']("s1").$play();
            self.$reset();
            self.scene = "main";}}}};
      if (self.scene['$==']("main")) {
        if ($truthy(self.auto_drop)) {
          if ($truthy($rb_lt(self.t_next_auto_drop, $$($nesting, 'Time').$now()))) {
            
            self.$drop_ball(dx);
            self.t_next_auto_drop = $rb_plus($rb_plus($$($nesting, 'Time').$now(), self.$rand(5)), 0.5);}}};
      self.collision_list = [];
      $send(self.balls, 'each', [], ($$20 = function(ball_self){var self = $$20.$$s == null ? this : $$20.$$s;
        if (self.balls == null) self.balls = nil;

      
        
        if (ball_self == null) {
          ball_self = nil;
        };
        return $$($nesting, 'Sprite').$check([ball_self], $rb_minus(self.balls, [ball_self]));}, $$20.$$s = self, $$20.$$arity = 1, $$20));
      new_balls = [];
      $send(self.collision_list, 'each', [], ($$21 = function(b1, b2){var self = $$21.$$s == null ? this : $$21.$$s, $ret_or_2 = nil, midx = nil, midy = nil, new_lv = nil;
        if (self.score == null) self.score = nil;

      
        
        if (b1 == null) {
          b1 = nil;
        };
        
        if (b2 == null) {
          b2 = nil;
        };
        if ($truthy((function() {if ($truthy(($ret_or_2 = b1['$vanished?']()['$!']()))) {
          
          return b2['$vanished?']()['$!']();
        } else {
          return $ret_or_2
        }; return nil; })())) {
          
          b1.$vanish();
          b2.$vanish();
          midx = $rb_divide($rb_plus(b1.$x(), b2.$x()), 2.0);
          midy = $rb_divide($rb_plus(b1.$y(), b2.$y()), 2.0);
          new_lv = $rb_plus(b1.$lv(), 1);
          new_balls['$<<']([new_lv, midx, midy]);
          return (self.score = $rb_plus(self.score, $$($nesting, 'MAP_LV_SCORE')['$[]'](new_lv)));
        } else {
          return nil
        };}, $$21.$$s = self, $$21.$$arity = 2, $$21));
      lvs = $send(new_balls, 'map', [], ($$22 = function(lv, _, $a){var self = $$22.$$s == null ? this : $$22.$$s;

      
        
        if (lv == null) {
          lv = nil;
        };
        
        if (_ == null) {
          _ = nil;
        };
        
        if (_ == null) {
          _ = nil;
        };
        return lv;}, $$22.$$s = self, $$22.$$arity = 3, $$22)).$uniq();
      $send(lvs, 'each', [], ($$23 = function(lv){var self = $$23.$$s == null ? this : $$23.$$s;

      
        
        if (lv == null) {
          lv = nil;
        };
        return $$($nesting, 'SoundEffect2')['$[]']("" + "lv" + (lv)).$play();}, $$23.$$s = self, $$23.$$arity = 1, $$23));
      self.$clean_balls(self.balls);
      self.balls = $rb_plus(self.balls, $send(new_balls, 'map', [], ($$24 = function(lv, x, y){var self = $$24.$$s == null ? this : $$24.$$s, rad = nil, angle = nil;

      
        
        if (lv == null) {
          lv = nil;
        };
        
        if (x == null) {
          x = nil;
        };
        
        if (y == null) {
          y = nil;
        };
        rad = $$($nesting, 'Game').$to_radius(lv);
        angle = $rb_times(self.$rand(), 90);
        return $$($nesting, 'Ball').$create(x, y, rad, lv, angle, [self]);}, $$24.$$s = self, $$24.$$arity = 3, $$24)));
      self.$draw_basket();
      self.$draw_score();
      self.$draw_next_next();
      $send(self.balls, 'each', [], ($$25 = function(ball){var self = $$25.$$s == null ? this : $$25.$$s;

      
        
        if (ball == null) {
          ball = nil;
        };
        return ball.$draw();}, $$25.$$s = self, $$25.$$arity = 1, $$25));
      if (self.scene['$==']("main")) {
        if ($truthy((function() {if ($truthy(($ret_or_3 = $rb_le(0, my)))) {
          return $rb_lt(my, $$($nesting, 'WIN_H'))
        } else {
          return $ret_or_3
        }; return nil; })())) {
          self.$draw_next_cursor(dx)}};
      if (self.scene['$==']("gameover")) {
        self.$draw_gameover()};
      y_max = (function() {if ($truthy(($ret_or_4 = $send(self.balls, 'map', [], ($$26 = function(ball){var self = $$26.$$s == null ? this : $$26.$$s;

      
        
        if (ball == null) {
          ball = nil;
        };
        return ball.$y();}, $$26.$$s = self, $$26.$$arity = 1, $$26)).$max()))) {
        return $ret_or_4
      } else {
        return 0
      }; return nil; })();
      if ($truthy($rb_gt(y_max, $rb_plus($$($nesting, 'WIN_H'), 100)))) {
        
        $send($send(self.balls, 'select', [], ($$27 = function(ball){var self = $$27.$$s == null ? this : $$27.$$s;

        
          
          if (ball == null) {
            ball = nil;
          };
          return $rb_gt(ball.$y(), $rb_plus($$($nesting, 'WIN_H'), 100));}, $$27.$$s = self, $$27.$$arity = 1, $$27)), 'each', [], ($$28 = function(ball){var self = $$28.$$s == null ? this : $$28.$$s;

        
          
          if (ball == null) {
            ball = nil;
          };
          return ball.$vanish();}, $$28.$$s = self, $$28.$$arity = 1, $$28));
        self.$clean_balls(self.balls);
        $$($nesting, 'SoundEffect2')['$[]']("hit3_long").$play();
        if (self.scene['$==']("main")) {
          
          self.t_gameover_started_at = $$($nesting, 'Time').$now();
          return (self.scene = "gameover");
        } else {
          return nil
        };
      } else {
        return nil
      };
    }, $Game_tick$19.$$arity = 0);
    Opal.const_set($nesting[0], 'NEXT_LVS', [$range(1, 3, false).$to_a(), $range(1, 3, false).$to_a(), 4].$flatten());
    
    Opal.def(self, '$update_next_lv', $Game_update_next_lv$29 = function $$update_next_lv() {
      var self = this;

      
      self.next_lv = self.next_next_lv;
      return (self.next_next_lv = $$($nesting, 'NEXT_LVS').$sample());
    }, $Game_update_next_lv$29.$$arity = 0);
    
    Opal.def(self, '$next_radius', $Game_next_radius$30 = function $$next_radius() {
      var self = this;

      return $$($nesting, 'Game').$to_radius(self.next_lv)
    }, $Game_next_radius$30.$$arity = 0);
    Opal.defs(self, '$to_radius', $Game_to_radius$31 = function $$to_radius(lv) {
      var self = this;

      return $rb_plus($rb_times(lv, 7.5), 4)
    }, $Game_to_radius$31.$$arity = 1);
    
    Opal.def(self, '$to_drop_x', $Game_to_drop_x$32 = function $$to_drop_x(x) {
      var self = this;

      if ($truthy($rb_lt(x, $rb_plus($$($nesting, 'BASKET_X_MIN'), 2)))) {
        return $rb_plus($$($nesting, 'BASKET_X_MIN'), 2)
      } else if ($truthy($rb_gt(x, $rb_minus($$($nesting, 'BASKET_X_MAX'), 2)))) {
        return $rb_minus($$($nesting, 'BASKET_X_MAX'), 2)
      } else {
        return x
      }
    }, $Game_to_drop_x$32.$$arity = 1);
    return (Opal.def(self, '$make_wall', $Game_make_wall$33 = function $$make_wall(x, y, w, h) {
      var self = this, wall = nil, $writer = nil;

      
      wall = $$($nesting, 'Sprite').$new(x, y, $$($nesting, 'Image').$new(w, h, [200, 200, 200]));
      
      $writer = [["rectangle", w, h, {isStatic: true}]];
      $send(wall, 'physical_body=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return wall;
    }, $Game_make_wall$33.$$arity = 4), nil) && 'make_wall';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.2.0 */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var $pre_tick$1, $set_master_volume$2, $$3, $$4, $create_sound_ball_new$5, $$7, $$8, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars, $writer = nil;
  if ($gvars.game == null) $gvars.game = nil;

  Opal.add_stubs(['$require', '$include', '$new', '$key_down?', '$key_push?', '$master_volume=', '$-', '$play', '$[]', '$register', '$to_f', '$*', '$**', '$/', '$<', '$+', '$each', '$create_sound_ball_new', '$width=', '$height=', '$fps=', '$bgcolor=', '$set_master_volume', '$init_basket', '$load_resources', '$puts', '$loop', '$pre_tick', '$tick']);
  
  self.$require("dxopal");
  self.$require("./main.rb"+ '/../' + "dxopal_ext/sound2");
  self.$require("./main.rb"+ '/../' + "dxopal_ext/sound_effect2");
  self.$include($$($nesting, 'DXOpal'));
  self.$require("./main.rb"+ '/../' + "ball");
  self.$require("./main.rb"+ '/../' + "game");
  Opal.const_set($nesting[0], 'WIN_W', 640);
  Opal.const_set($nesting[0], 'WIN_H', 480);
  Opal.const_set($nesting[0], 'FONT_DEFAULT', $$($nesting, 'Font').$new(20, "monospace"));
  Opal.const_set($nesting[0], 'FONT_BALL', $$($nesting, 'Font').$new(16, "monospace"));
  Opal.const_set($nesting[0], 'FONT_GAMEOVER', $$($nesting, 'Font').$new(80, "monospace"));
  Opal.const_set($nesting[0], 'FONT_DEBUG_INFO', $$($nesting, 'Font').$new(12, "monospace"));
  
  Opal.def(self, '$pre_tick', $pre_tick$1 = function $$pre_tick() {
    var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

    if ($truthy((function() {if ($truthy(($ret_or_1 = (function() {if ($truthy(($ret_or_2 = (function() {if ($truthy(($ret_or_3 = $$($nesting, 'Input')['$key_down?']($$($nesting, 'K_LCONTROL'))))) {
      return $$($nesting, 'Input')['$key_push?']($$($nesting, 'K_R'))
    } else {
      return $ret_or_3
    }; return nil; })()))) {
      return $ret_or_2
    } else {
      
      if ($truthy(($ret_or_4 = $$($nesting, 'Input')['$key_down?']($$($nesting, 'K_RCONTROL'))))) {
        return $$($nesting, 'Input')['$key_push?']($$($nesting, 'K_R'))
      } else {
        return $ret_or_4
      };
    }; return nil; })()))) {
      return $ret_or_1
    } else {
      return $$($nesting, 'Input')['$key_push?']($$($nesting, 'K_F5'))
    }; return nil; })())) {
      return location.reload();
    } else {
      return nil
    }
  }, $pre_tick$1.$$arity = 0);
  
  Opal.def(self, '$set_master_volume', $set_master_volume$2 = function $$set_master_volume(vol, play) {
    var self = this, $writer = nil;

    
    
    if (play == null) {
      play = false;
    };
    
    $writer = [vol];
    $send($$($nesting, 'Sound2'), 'master_volume=', Opal.to_a($writer));
    $writer[$rb_minus($writer["length"], 1)];;
    if ($truthy(play)) {
      return $$($nesting, 'SoundEffect2')['$[]']("lv1").$play()
    } else {
      return nil
    };
  }, $set_master_volume$2.$$arity = -2);
  $send($$($nesting, 'SoundEffect2'), 'register', ["s1", 50, $$($nesting, 'WAVE_TRI'), 1000], ($$3 = function(){var self = $$3.$$s == null ? this : $$3.$$s;

  return [1000, 120]}, $$3.$$s = self, $$3.$$arity = 0, $$3));
  $send($$($nesting, 'SoundEffect2'), 'register', ["hit3_long", 300, $$($nesting, 'WAVE_SAW'), 1000], ($$4 = function(){var self = $$4.$$s == null ? this : $$4.$$s;

  return [50, 100]}, $$4.$$s = self, $$4.$$arity = 0, $$4));
  Opal.const_set($nesting[0], 'NOTE_NOS', [0, 7, 11, 2, 5, 12, 19, 23, 14, 17]);
  
  Opal.def(self, '$create_sound_ball_new', $create_sound_ball_new$5 = function $$create_sound_ball_new(lv) {
    var $$6, self = this, duration_msec = nil, note_i = nil, note_no = nil, base_freq = nil, msec = nil;

    
    duration_msec = 500;
    note_i = $rb_minus(lv, 9);
    note_no = $$($nesting, 'NOTE_NOS')['$[]'](note_i);
    base_freq = $rb_times(440, (2)['$**']($rb_divide(note_no, 12.0))).$to_f();
    msec = 0;
    return $send($$($nesting, 'SoundEffect2'), 'register', ["" + "lv" + (lv), duration_msec, $$($nesting, 'WAVE_TRI')], ($$6 = function(){var self = $$6.$$s == null ? this : $$6.$$s, vol = nil, freq = nil;

    
      vol = (function() {if ($truthy($rb_lt(msec, 100))) {
        return 20
      } else if ($truthy($rb_lt(msec, 200))) {
        return 1
      } else if ($truthy($rb_lt(msec, 300))) {
        return 5
      } else if ($truthy($rb_lt(msec, 400))) {
        return 1
      } else {
        return 2
      }; return nil; })();
      vol = $rb_times(vol, $rb_divide(255.0, 20));
      freq = (function() {if ($truthy($rb_lt(msec, 20))) {
        return $rb_divide(base_freq, 2)
      } else {
        return base_freq
      }; return nil; })();
      msec = $rb_plus(msec, 1);
      return [freq, vol];}, $$6.$$s = self, $$6.$$arity = 0, $$6));
  }, $create_sound_ball_new$5.$$arity = 1);
  $send(Opal.Range.$new(1, $$$($$($nesting, 'Game'), 'LV_MAX'), false), 'each', [], ($$7 = function(lv){var self = $$7.$$s == null ? this : $$7.$$s;

  
    
    if (lv == null) {
      lv = nil;
    };
    return self.$create_sound_ball_new(lv);}, $$7.$$s = self, $$7.$$arity = 1, $$7));
  
  $writer = [$$($nesting, 'WIN_W')];
  $send($$($nesting, 'Window'), 'width=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [$$($nesting, 'WIN_H')];
  $send($$($nesting, 'Window'), 'height=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [60];
  $send($$($nesting, 'Window'), 'fps=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [[250, 250, 250]];
  $send($$($nesting, 'Window'), 'bgcolor=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  self.$set_master_volume(230);
  $gvars.game = $$($nesting, 'Game').$new();
  $gvars.game.$init_basket();
  return $send($$($nesting, 'Window'), 'load_resources', [], ($$8 = function(){var self = $$8.$$s == null ? this : $$8.$$s, $$9;

  
    self.$puts("load_resources ... done");
    return $send($$($nesting, 'Window'), 'loop', [], ($$9 = function(){var self = $$9.$$s == null ? this : $$9.$$s;
      if ($gvars.game == null) $gvars.game = nil;

    
      self.$pre_tick();
      return $gvars.game.$tick();}, $$9.$$s = self, $$9.$$arity = 0, $$9));}, $$8.$$s = self, $$8.$$arity = 0, $$8));
})(Opal);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGdsb2JhbF9vYmplY3QpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gQG5vdGVcbiAgLy8gICBBIGZldyBjb252ZW50aW9ucyBmb3IgdGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmaWxlOlxuICAvLyAgIDEuIEFsd2F5cyB1c2UgXCIvL1wiIChpbiBjb250cmFzdCB3aXRoIFwiLyoqL1wiKVxuICAvLyAgIDIuIFRoZSBzeW50YXggdXNlZCBpcyBZYXJkb2MgKHlhcmRvYy5vcmcpLCB3aGljaCBpcyBpbnRlbmRlZCBmb3IgUnVieSAoc2UgYmVsb3cpXG4gIC8vICAgMy4gYEBwYXJhbWAgYW5kIGBAcmV0dXJuYCB0eXBlcyBzaG91bGQgYmUgcHJlY2VkZWQgYnkgYEpTLmAgd2hlbiByZWZlcnJpbmcgdG9cbiAgLy8gICAgICBKYXZhU2NyaXB0IGNvbnN0cnVjdG9ycyAoZS5nLiBgSlMuRnVuY3Rpb25gKSBvdGhlcndpc2UgUnVieSBpcyBhc3N1bWVkLlxuICAvLyAgIDQuIGBuaWxgIGFuZCBgbnVsbGAgYmVpbmcgdW5hbWJpZ3VvdXMgcmVmZXIgdG8gdGhlIHJlc3BlY3RpdmVcbiAgLy8gICAgICBvYmplY3RzL3ZhbHVlcyBpbiBSdWJ5IGFuZCBKYXZhU2NyaXB0XG4gIC8vICAgNS4gVGhpcyBpcyBzdGlsbCBXSVAgOikgc28gcGxlYXNlIGdpdmUgZmVlZGJhY2sgYW5kIHN1Z2dlc3Rpb25zIG9uIGhvd1xuICAvLyAgICAgIHRvIGltcHJvdmUgb3IgZm9yIGFsdGVybmF0aXZlIHNvbHV0aW9uc1xuICAvL1xuICAvLyAgIFRoZSB3YXkgdGhlIGNvZGUgaXMgZGlnZXN0ZWQgYmVmb3JlIGdvaW5nIHRocm91Z2ggWWFyZG9jIGlzIGEgc2VjcmV0IGtlcHRcbiAgLy8gICBpbiB0aGUgZG9jcyByZXBvIChodHRwczovL2dpdGh1Yi5jb20vb3BhbC9kb2NzL3RyZWUvbWFzdGVyKS5cblxuICB2YXIgY29uc29sZTtcblxuICAvLyBEZXRlY3QgdGhlIGdsb2JhbCBvYmplY3RcbiAgaWYgKHR5cGVvZihnbG9iYWxUaGlzKSAhPT0gJ3VuZGVmaW5lZCcpIHsgZ2xvYmFsX29iamVjdCA9IGdsb2JhbFRoaXM7IH1cbiAgZWxzZSBpZiAodHlwZW9mKGdsb2JhbCkgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSBnbG9iYWw7IH1cbiAgZWxzZSBpZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSB3aW5kb3c7IH1cblxuICAvLyBTZXR1cCBhIGR1bW15IGNvbnNvbGUgb2JqZWN0IGlmIG1pc3NpbmdcbiAgaWYgKHR5cGVvZihnbG9iYWxfb2JqZWN0LmNvbnNvbGUpID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnNvbGUgPSBnbG9iYWxfb2JqZWN0LmNvbnNvbGU7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsX29iamVjdC5jb25zb2xlID09IG51bGwpIHtcbiAgICBjb25zb2xlID0gZ2xvYmFsX29iamVjdC5jb25zb2xlID0ge307XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZSA9IHt9O1xuICB9XG5cbiAgaWYgKCEoJ2xvZycgaW4gY29uc29sZSkpIHsgY29uc29sZS5sb2cgPSBmdW5jdGlvbiAoKSB7fTsgfVxuICBpZiAoISgnd2FybicgaW4gY29uc29sZSkpIHsgY29uc29sZS53YXJuID0gY29uc29sZS5sb2c7IH1cblxuICBpZiAodHlwZW9mKGdsb2JhbF9vYmplY3QuT3BhbCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS53YXJuKCdPcGFsIGFscmVhZHkgbG9hZGVkLiBMb2FkaW5nIHR3aWNlIGNhbiBjYXVzZSB0cm91YmxlcywgcGxlYXNlIGZpeCB5b3VyIHNldHVwLicpO1xuICAgIHJldHVybiBnbG9iYWxfb2JqZWN0Lk9wYWw7XG4gIH1cblxuICB2YXIgbmlsO1xuXG4gIC8vIFRoZSBhY3R1YWwgY2xhc3MgZm9yIEJhc2ljT2JqZWN0XG4gIHZhciBCYXNpY09iamVjdDtcblxuICAvLyBUaGUgYWN0dWFsIE9iamVjdCBjbGFzcy5cbiAgLy8gVGhlIGxlYWRpbmcgdW5kZXJzY29yZSBpcyB0byBhdm9pZCBjb25mdXNpb24gd2l0aCB3aW5kb3cuT2JqZWN0KClcbiAgdmFyIF9PYmplY3Q7XG5cbiAgLy8gVGhlIGFjdHVhbCBNb2R1bGUgY2xhc3NcbiAgdmFyIE1vZHVsZTtcblxuICAvLyBUaGUgYWN0dWFsIENsYXNzIGNsYXNzXG4gIHZhciBDbGFzcztcblxuICAvLyBUaGUgT3BhbCBvYmplY3QgdGhhdCBpcyBleHBvc2VkIGdsb2JhbGx5XG4gIHZhciBPcGFsID0gZ2xvYmFsX29iamVjdC5PcGFsID0ge307XG5cbiAgLy8gVGhpcyBpcyBhIHVzZWZ1bCByZWZlcmVuY2UgdG8gZ2xvYmFsIG9iamVjdCBpbnNpZGUgcnVieSBmaWxlc1xuICBPcGFsLmdsb2JhbCA9IGdsb2JhbF9vYmplY3Q7XG4gIGdsb2JhbF9vYmplY3QuT3BhbCA9IE9wYWw7XG5cbiAgLy8gQ29uZmlndXJlIHJ1bnRpbWUgYmVoYXZpb3Igd2l0aCByZWdhcmRzIHRvIHJlcXVpcmUgYW5kIHVuc3VwcG9ydGVkIGZlYXR1cmVzXG4gIE9wYWwuY29uZmlnID0ge1xuICAgIG1pc3NpbmdfcmVxdWlyZV9zZXZlcml0eTogJ2Vycm9yJywgICAgICAgIC8vIGVycm9yLCB3YXJuaW5nLCBpZ25vcmVcbiAgICB1bnN1cHBvcnRlZF9mZWF0dXJlc19zZXZlcml0eTogJ3dhcm5pbmcnLCAvLyBlcnJvciwgd2FybmluZywgaWdub3JlXG4gICAgZW5hYmxlX3N0YWNrX3RyYWNlOiB0cnVlICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSwgZmFsc2VcbiAgfTtcblxuICAvLyBNaW5pZnkgY29tbW9uIGZ1bmN0aW9uIGNhbGxzXG4gIHZhciAkaGFzX293biAgID0gT2JqZWN0Lmhhc093blByb3BlcnR5O1xuICB2YXIgJGJpbmQgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuICB2YXIgJHNldF9wcm90byA9IE9iamVjdC5zZXRQcm90b3R5cGVPZjtcbiAgdmFyICRzbGljZSAgICAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gIHZhciAkc3BsaWNlICAgID0gQXJyYXkucHJvdG90eXBlLnNwbGljZTtcblxuICAvLyBOaWwgb2JqZWN0IGlkIGlzIGFsd2F5cyA0XG4gIHZhciBuaWxfaWQgPSA0O1xuXG4gIC8vIEdlbmVyYXRlcyBldmVuIHNlcXVlbnRpYWwgbnVtYmVycyBncmVhdGVyIHRoYW4gNFxuICAvLyAobmlsX2lkKSB0byBzZXJ2ZSBhcyB1bmlxdWUgaWRzIGZvciBydWJ5IG9iamVjdHNcbiAgdmFyIHVuaXF1ZV9pZCA9IG5pbF9pZDtcblxuICAvLyBSZXR1cm4gbmV4dCB1bmlxdWUgaWRcbiAgT3BhbC51aWQgPSBmdW5jdGlvbigpIHtcbiAgICB1bmlxdWVfaWQgKz0gMjtcbiAgICByZXR1cm4gdW5pcXVlX2lkO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIG9yIGFzc2lnbiB0aGUgaWQgb2YgYW4gb2JqZWN0XG4gIE9wYWwuaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLiQkaXNfbnVtYmVyKSByZXR1cm4gKG9iaiAqIDIpKzE7XG4gICAgaWYgKG9iai4kJGlkICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBvYmouJCRpZDtcbiAgICB9XG4gICAgJGRlZmluZVByb3BlcnR5KG9iaiwgJyQkaWQnLCBPcGFsLnVpZCgpKTtcbiAgICByZXR1cm4gb2JqLiQkaWQ7XG4gIH07XG5cbiAgLy8gR2xvYmFscyB0YWJsZVxuICBPcGFsLmd2YXJzID0ge307XG5cbiAgLy8gRXhpdCBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgcmVwbGFjZWQgYnkgcGxhdGZvcm0gc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cbiAgLy8gKFNlZSBub2RlanMgYW5kIGNocm9tZSBmb3IgZXhhbXBsZXMpXG4gIE9wYWwuZXhpdCA9IGZ1bmN0aW9uKHN0YXR1cykgeyBpZiAoT3BhbC5ndmFycy5ERUJVRykgY29uc29sZS5sb2coJ0V4aXRlZCB3aXRoIHN0YXR1cyAnK3N0YXR1cyk7IH07XG5cbiAgLy8ga2VlcHMgdHJhY2sgb2YgZXhjZXB0aW9ucyBmb3IgJCFcbiAgT3BhbC5leGNlcHRpb25zID0gW107XG5cbiAgLy8gQHByaXZhdGVcbiAgLy8gUG9wcyBhbiBleGNlcHRpb24gZnJvbSB0aGUgc3RhY2sgYW5kIHVwZGF0ZXMgYCQhYC5cbiAgT3BhbC5wb3BfZXhjZXB0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgT3BhbC5ndmFyc1tcIiFcIl0gPSBPcGFsLmV4Y2VwdGlvbnMucG9wKCkgfHwgbmlsO1xuICB9O1xuXG4gIC8vIEluc3BlY3QgYW55IGtpbmQgb2Ygb2JqZWN0LCBpbmNsdWRpbmcgbm9uIFJ1Ynkgb25lc1xuICBPcGFsLmluc3BlY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoIW9iai4kJGNsYXNzKSB7XG4gICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG9iai4kaW5zcGVjdCgpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiAkZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBpbml0aWFsVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mKG9iamVjdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3I6XG4gICAgICAvLyAgIHMgPSBcInN0cmluZ1wiXG4gICAgICAvLyAgIGRlZiBzLm07IGVuZFxuICAgICAgLy8gU3RyaW5nIGNsYXNzIGlzIHRoZSBvbmx5IGNsYXNzIHRoYXQ6XG4gICAgICAvLyArIGNvbXBpbGVzIHRvIEpTIHByaW1pdGl2ZVxuICAgICAgLy8gKyBhbGxvd3MgbWV0aG9kIGRlZmluaXRpb24gZGlyZWN0bHkgb24gaW5zdGFuY2VzXG4gICAgICAvLyBudW1iZXJzLCB0cnVlLCBmYWxzZSBhbmQgbnVsbCBkbyBub3Qgc3VwcG9ydCBpdC5cbiAgICAgIG9iamVjdFtuYW1lXSA9IGluaXRpYWxWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICB2YWx1ZTogaW5pdGlhbFZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgT3BhbC5kZWZpbmVQcm9wZXJ0eSA9ICRkZWZpbmVQcm9wZXJ0eTtcblxuICBPcGFsLnNsaWNlID0gJHNsaWNlO1xuXG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLVxuXG4gIE9wYWwudHJ1dGh5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuICh2YWwgIT09IG5pbCAmJiB2YWwgIT0gbnVsbCAmJiAoIXZhbC4kJGlzX2Jvb2xlYW4gfHwgdmFsID09IHRydWUpKTtcbiAgfTtcblxuICBPcGFsLmZhbHN5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuICh2YWwgPT09IG5pbCB8fCB2YWwgPT0gbnVsbCB8fCAodmFsLiQkaXNfYm9vbGVhbiAmJiB2YWwgPT0gZmFsc2UpKVxuICB9O1xuXG4gIE9wYWwudHlwZV9lcnJvciA9IGZ1bmN0aW9uKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBjb2VyY2VkKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0LiQkY2xhc3M7XG5cbiAgICBpZiAoY29lcmNlZCAmJiBtZXRob2QpIHtcbiAgICAgIGNvZXJjZWQgPSBjb2VyY2VkLiQkY2xhc3M7XG4gICAgICByZXR1cm4gT3BhbC5UeXBlRXJyb3IuJG5ldyhcbiAgICAgICAgXCJjYW4ndCBjb252ZXJ0IFwiICsgb2JqZWN0ICsgXCIgaW50byBcIiArIHR5cGUgK1xuICAgICAgICBcIiAoXCIgKyBvYmplY3QgKyBcIiNcIiArIG1ldGhvZCArIFwiIGdpdmVzIFwiICsgY29lcmNlZCArIFwiKVwiXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLlR5cGVFcnJvci4kbmV3KFxuICAgICAgICBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgXCIgKyBvYmplY3QgKyBcIiBpbnRvIFwiICsgdHlwZVxuICAgICAgKVxuICAgIH1cbiAgfTtcblxuICBPcGFsLmNvZXJjZV90byA9IGZ1bmN0aW9uKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBhcmdzKSB7XG4gICAgaWYgKHR5cGVbJyQ9PT0nXShvYmplY3QpKSByZXR1cm4gb2JqZWN0O1xuXG4gICAgaWYgKCFvYmplY3RbJyRyZXNwb25kX3RvPyddKG1ldGhvZCkpIHtcbiAgICAgIHRocm93IE9wYWwudHlwZV9lcnJvcihvYmplY3QsIHR5cGUpO1xuICAgIH1cblxuICAgIGlmIChhcmdzID09IG51bGwpIGFyZ3MgPSBbXTtcbiAgICByZXR1cm4gT3BhbC5zZW5kKG9iamVjdCwgbWV0aG9kLCBhcmdzKTtcbiAgfVxuXG4gIE9wYWwucmVzcG9uZF90byA9IGZ1bmN0aW9uKG9iaiwganNpZCwgaW5jbHVkZV9hbGwpIHtcbiAgICBpZiAob2JqID09IG51bGwgfHwgIW9iai4kJGNsYXNzKSByZXR1cm4gZmFsc2U7XG4gICAgaW5jbHVkZV9hbGwgPSAhIWluY2x1ZGVfYWxsO1xuICAgIHZhciBib2R5ID0gb2JqW2pzaWRdO1xuXG4gICAgaWYgKG9ialsnJHJlc3BvbmRfdG8/J10uJCRwcmlzdGluZSkge1xuICAgICAgaWYgKG9ialsnJHJlc3BvbmRfdG9fbWlzc2luZz8nXS4kJHByaXN0aW5lKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YoYm9keSkgPT09IFwiZnVuY3Rpb25cIiAmJiAhYm9keS4kJHN0dWI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5zZW5kKG9iaiwgb2JqWyckcmVzcG9uZF90b19taXNzaW5nPyddLCBbanNpZC5zdWJzdHIoMSksIGluY2x1ZGVfYWxsXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLnNlbmQob2JqLCBvYmpbJyRyZXNwb25kX3RvPyddLCBbanNpZC5zdWJzdHIoMSksIGluY2x1ZGVfYWxsXSk7XG4gICAgfVxuICB9XG5cblxuICAvLyBDb25zdGFudHNcbiAgLy8gLS0tLS0tLS0tXG4gIC8vXG4gIC8vIEZvciBmdXR1cmUgcmVmZXJlbmNlOlxuICAvLyAtIFRoZSBSYWlscyBhdXRvbG9hZGluZyBndWlkZSAoaHR0cDovL2d1aWRlcy5ydWJ5b25yYWlscy5vcmcvdjUuMC9hdXRvbG9hZGluZ19hbmRfcmVsb2FkaW5nX2NvbnN0YW50cy5odG1sKVxuICAvLyAtIEBDb25yYWRJcndpbidzIDIwMTIgcG9zdCBvbiDigJxFdmVyeXRoaW5nIHlvdSBldmVyIHdhbnRlZCB0byBrbm93IGFib3V0IGNvbnN0YW50IGxvb2t1cCBpbiBSdWJ54oCdIChodHRwOi8vY2lydy5pbi9ibG9nL2NvbnN0YW50LWxvb2t1cC5odG1sKVxuICAvL1xuICAvLyBMZWdlbmQgb2YgTVJJIGNvbmNlcHRzL25hbWVzOlxuICAvLyAtIGNvbnN0YW50IHJlZmVyZW5jZSAoY3JlZik6IHRoZSBtb2R1bGUvY2xhc3MgdGhhdCBhY3RzIGFzIGEgbmFtZXNwYWNlXG4gIC8vIC0gbmVzdGluZzogdGhlIG5hbWVzcGFjZXMgd3JhcHBpbmcgdGhlIGN1cnJlbnQgc2NvcGUsIGUuZy4gbmVzdGluZyBpbnNpZGVcbiAgLy8gICAgICAgICAgICBgbW9kdWxlIEE7IG1vZHVsZSBCOjpDOyBlbmQ7IGVuZGAgaXMgYFtCOjpDLCBBXWBcblxuICAvLyBHZXQgdGhlIGNvbnN0YW50IGluIHRoZSBzY29wZSBvZiB0aGUgY3VycmVudCBjcmVmXG4gIGZ1bmN0aW9uIGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpIHtcbiAgICBpZiAoY3JlZikgcmV0dXJuIGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIG5lc3RpbmcgYXJyYXkgbG9va2luZyBmb3IgdGhlIGNvbnN0YW50XG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9uZXN0aW5nKG5lc3RpbmcsIG5hbWUpIHtcbiAgICB2YXIgaSwgaWksIGNvbnN0YW50O1xuXG4gICAgaWYgKG5lc3RpbmcubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAvLyBJZiB0aGUgbmVzdGluZyBpcyBub3QgZW1wdHkgdGhlIGNvbnN0YW50IGlzIGxvb2tlZCB1cCBpbiBpdHMgZWxlbWVudHNcbiAgICAvLyBhbmQgaW4gb3JkZXIuIFRoZSBhbmNlc3RvcnMgb2YgdGhvc2UgZWxlbWVudHMgYXJlIGlnbm9yZWQuXG4gICAgZm9yIChpID0gMCwgaWkgPSBuZXN0aW5nLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0YW50ID0gbmVzdGluZ1tpXS4kJGNvbnN0W25hbWVdO1xuICAgICAgaWYgKGNvbnN0YW50ICE9IG51bGwpIHJldHVybiBjb25zdGFudDtcbiAgICB9XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSBhbmNlc3RvcnMgY2hhaW4gbG9va2luZyBmb3IgdGhlIGNvbnN0YW50XG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoY3JlZiwgbmFtZSkge1xuICAgIHZhciBpLCBpaSwgYW5jZXN0b3JzO1xuXG4gICAgaWYgKGNyZWYgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMoY3JlZik7XG5cbiAgICBmb3IgKGkgPSAwLCBpaSA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZiAoYW5jZXN0b3JzW2ldLiQkY29uc3QgJiYgJGhhc19vd24uY2FsbChhbmNlc3RvcnNbaV0uJCRjb25zdCwgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9yc1tpXS4kJGNvbnN0W25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdhbGsgdXAgT2JqZWN0J3MgYW5jZXN0b3JzIGNoYWluIGxvb2tpbmcgZm9yIHRoZSBjb25zdGFudCxcbiAgLy8gYnV0IG9ubHkgaWYgY3JlZiBpcyBtaXNzaW5nIG9yIGEgbW9kdWxlLlxuICBmdW5jdGlvbiBjb25zdF9sb29rdXBfT2JqZWN0KGNyZWYsIG5hbWUpIHtcbiAgICBpZiAoY3JlZiA9PSBudWxsIHx8IGNyZWYuJCRpc19tb2R1bGUpIHtcbiAgICAgIHJldHVybiBjb25zdF9sb29rdXBfYW5jZXN0b3JzKF9PYmplY3QsIG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGwgY29uc3RfbWlzc2luZyBpZiBub3RoaW5nIGVsc2Ugd29ya2VkXG4gIGZ1bmN0aW9uIGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgaWYgKCFza2lwX21pc3NpbmcpIHtcbiAgICAgIHJldHVybiAoY3JlZiB8fCBfT2JqZWN0KS4kY29uc3RfbWlzc2luZyhuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQganVzdCBpbiB0aGUgY3VycmVudCBjcmVmIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYFxuICBPcGFsLmNvbnN0X2dldF9sb2NhbCA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAoY3JlZiA9PSBudWxsKSByZXR1cm47XG5cbiAgICBpZiAoY3JlZiA9PT0gJzo6JykgY3JlZiA9IF9PYmplY3Q7XG5cbiAgICBpZiAoIWNyZWYuJCRpc19tb2R1bGUgJiYgIWNyZWYuJCRpc19jbGFzcykge1xuICAgICAgdGhyb3cgbmV3IE9wYWwuVHlwZUVycm9yKGNyZWYudG9TdHJpbmcoKSArIFwiIGlzIG5vdCBhIGNsYXNzL21vZHVsZVwiKTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBjb25zdF9nZXRfbmFtZShjcmVmLCBuYW1lKTsgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXN1bHQgPSBjb25zdF9taXNzaW5nKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZyk7IGlmIChyZXN1bHQgIT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQgcmVsYXRpdmUgdG8gYSBjcmVmIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGVcbiAgLy8gY29uc3RhbnQgaXMgcHJlZml4ZWQgYnkgYDo6YCkuXG4gIE9wYWwuY29uc3RfZ2V0X3F1YWxpZmllZCA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIHZhciByZXN1bHQsIGNhY2hlLCBjYWNoZWQsIGN1cnJlbnRfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbjtcblxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcblxuICAgIGlmIChjcmVmID09PSAnOjonKSBjcmVmID0gX09iamVjdDtcblxuICAgIGlmICghY3JlZi4kJGlzX21vZHVsZSAmJiAhY3JlZi4kJGlzX2NsYXNzKSB7XG4gICAgICB0aHJvdyBuZXcgT3BhbC5UeXBlRXJyb3IoY3JlZi50b1N0cmluZygpICsgXCIgaXMgbm90IGEgY2xhc3MvbW9kdWxlXCIpO1xuICAgIH1cblxuICAgIGlmICgoY2FjaGUgPSBjcmVmLiQkY29uc3RfY2FjaGUpID09IG51bGwpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShjcmVmLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgY2FjaGUgPSBjcmVmLiQkY29uc3RfY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgaWYgKGNhY2hlZCA9PSBudWxsIHx8IGNhY2hlZFswXSAhPT0gY3VycmVudF92ZXJzaW9uKSB7XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhjcmVmLCBuYW1lKSkgICAgICAhPSBudWxsKTtcbiAgICAgIGNhY2hlW25hbWVdID0gW2N1cnJlbnRfdmVyc2lvbiwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY2FjaGVkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKTtcbiAgfTtcblxuICAvLyBJbml0aWFsaXplIHRoZSB0b3AgbGV2ZWwgY29uc3RhbnQgY2FjaGUgZ2VuZXJhdGlvbiBjb3VudGVyXG4gIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiA9IDE7XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IGluIHRoZSBvcGVuIHVzaW5nIHRoZSBjdXJyZW50IG5lc3RpbmcgYW5kIHRoZSBuZWFyZXN0XG4gIC8vIGNyZWYgYW5jZXN0b3JzIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGUgY29uc3RhbnQgaGFzIG5vIDo6IHByZWZpeCkuXG4gIE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlID0gZnVuY3Rpb24obmVzdGluZywgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgdmFyIGNyZWYgPSBuZXN0aW5nWzBdLCByZXN1bHQsIGN1cnJlbnRfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiwgY2FjaGUsIGNhY2hlZDtcblxuICAgIGlmICgoY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGUpID09IG51bGwpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShuZXN0aW5nLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgaWYgKGNhY2hlZCA9PSBudWxsIHx8IGNhY2hlZFswXSAhPT0gY3VycmVudF92ZXJzaW9uKSB7XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX25lc3RpbmcobmVzdGluZywgbmFtZSkpICAgICAhPSBudWxsKSB8fFxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfYW5jZXN0b3JzKGNyZWYsIG5hbWUpKSAgICAgICE9IG51bGwpIHx8XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9PYmplY3QoY3JlZiwgbmFtZSkpICAgICAgICAgIT0gbnVsbCk7XG5cbiAgICAgIGNhY2hlW25hbWVdID0gW2N1cnJlbnRfdmVyc2lvbiwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY2FjaGVkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKTtcbiAgfTtcblxuICAvLyBSZWdpc3RlciB0aGUgY29uc3RhbnQgb24gYSBjcmVmIGFuZCBvcHBvcnR1bmlzdGljYWxseSBzZXQgdGhlIG5hbWUgb2ZcbiAgLy8gdW5uYW1lZCBjbGFzc2VzL21vZHVsZXMuXG4gIE9wYWwuY29uc3Rfc2V0ID0gZnVuY3Rpb24oY3JlZiwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoY3JlZiA9PSBudWxsIHx8IGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKHZhbHVlLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgIGlmICh2YWx1ZS4kJG5hbWUgPT0gbnVsbCB8fCB2YWx1ZS4kJG5hbWUgPT09IG5pbCkgdmFsdWUuJCRuYW1lID0gbmFtZTtcbiAgICAgIGlmICh2YWx1ZS4kJGJhc2VfbW9kdWxlID09IG51bGwpIHZhbHVlLiQkYmFzZV9tb2R1bGUgPSBjcmVmO1xuICAgIH1cblxuICAgIGNyZWYuJCRjb25zdCA9IChjcmVmLiQkY29uc3QgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgY3JlZi4kJGNvbnN0W25hbWVdID0gdmFsdWU7XG5cbiAgICAvLyBBZGQgYSBzaG9ydCBoZWxwZXIgdG8gbmF2aWdhdGUgY29uc3RhbnRzIG1hbnVhbGx5LlxuICAgIC8vIEBleGFtcGxlXG4gICAgLy8gICBPcGFsLiQkLlJlZ2V4cC4kJC5JR05PUkVDQVNFXG4gICAgY3JlZi4kJCA9IGNyZWYuJCRjb25zdDtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuXG4gICAgLy8gRXhwb3NlIHRvcCBsZXZlbCBjb25zdGFudHMgb250byB0aGUgT3BhbCBvYmplY3RcbiAgICBpZiAoY3JlZiA9PT0gX09iamVjdCkgT3BhbFtuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gTmFtZSBuZXcgY2xhc3MgZGlyZWN0bHkgb250byBjdXJyZW50IHNjb3BlIChPcGFsLkZvby5CYXogPSBrbGFzcylcbiAgICAkZGVmaW5lUHJvcGVydHkoY3JlZiwgbmFtZSwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIEdldCBhbGwgdGhlIGNvbnN0YW50cyByZWFjaGFibGUgZnJvbSBhIGdpdmVuIGNyZWYsIGJ5IGRlZmF1bHQgd2lsbCBpbmNsdWRlXG4gIC8vIGluaGVyaXRlZCBjb25zdGFudHMuXG4gIE9wYWwuY29uc3RhbnRzID0gZnVuY3Rpb24oY3JlZiwgaW5oZXJpdCkge1xuICAgIGlmIChpbmhlcml0ID09IG51bGwpIGluaGVyaXQgPSB0cnVlO1xuXG4gICAgdmFyIG1vZHVsZSwgbW9kdWxlcyA9IFtjcmVmXSwgaSwgaWksIGNvbnN0YW50cyA9IHt9LCBjb25zdGFudDtcblxuICAgIGlmIChpbmhlcml0KSBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoT3BhbC5hbmNlc3RvcnMoY3JlZikpO1xuICAgIGlmIChpbmhlcml0ICYmIGNyZWYuJCRpc19tb2R1bGUpIG1vZHVsZXMgPSBtb2R1bGVzLmNvbmNhdChbT3BhbC5PYmplY3RdKS5jb25jYXQoT3BhbC5hbmNlc3RvcnMoT3BhbC5PYmplY3QpKTtcblxuICAgIGZvciAoaSA9IDAsIGlpID0gbW9kdWxlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBtb2R1bGUgPSBtb2R1bGVzW2ldO1xuXG4gICAgICAvLyBEbyBub3Qgc2hvdyBPYmplY3RzIGNvbnN0YW50cyB1bmxlc3Mgd2UncmUgcXVlcnlpbmcgT2JqZWN0IGl0c2VsZlxuICAgICAgaWYgKGNyZWYgIT09IF9PYmplY3QgJiYgbW9kdWxlID09IF9PYmplY3QpIGJyZWFrO1xuXG4gICAgICBmb3IgKGNvbnN0YW50IGluIG1vZHVsZS4kJGNvbnN0KSB7XG4gICAgICAgIGNvbnN0YW50c1tjb25zdGFudF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhjb25zdGFudHMpO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBhIGNvbnN0YW50IGZyb20gYSBjcmVmLlxuICBPcGFsLmNvbnN0X3JlbW92ZSA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUpIHtcbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcblxuICAgIGlmIChjcmVmLiQkY29uc3RbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgdmFyIG9sZCA9IGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgICAgIGRlbGV0ZSBjcmVmLiQkY29uc3RbbmFtZV07XG4gICAgICByZXR1cm4gb2xkO1xuICAgIH1cblxuICAgIGlmIChjcmVmLiQkYXV0b2xvYWQgIT0gbnVsbCAmJiBjcmVmLiQkYXV0b2xvYWRbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgZGVsZXRlIGNyZWYuJCRhdXRvbG9hZFtuYW1lXTtcbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuXG4gICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcImNvbnN0YW50IFwiK2NyZWYrXCI6OlwiK2NyZWYuJG5hbWUoKStcIiBub3QgZGVmaW5lZFwiKTtcbiAgfTtcblxuICAvLyBTZXR1cCBzb21lIHNob3J0Y3V0cyB0byByZWR1Y2UgY29tcGlsZWQgc2l6ZVxuICBPcGFsLiQkID0gT3BhbC5jb25zdF9nZXRfcmVsYXRpdmU7XG4gIE9wYWwuJCQkID0gT3BhbC5jb25zdF9nZXRfcXVhbGlmaWVkO1xuXG5cbiAgLy8gTW9kdWxlcyAmIENsYXNzZXNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBBIGBjbGFzcyBGb287IGVuZGAgZXhwcmVzc2lvbiBpbiBydWJ5IGlzIGNvbXBpbGVkIHRvIGNhbGwgdGhpcyBydW50aW1lXG4gIC8vIG1ldGhvZCB3aGljaCBlaXRoZXIgcmV0dXJucyBhbiBleGlzdGluZyBjbGFzcyBvZiB0aGUgZ2l2ZW4gbmFtZSwgb3IgY3JlYXRlc1xuICAvLyBhIG5ldyBjbGFzcyBpbiB0aGUgZ2l2ZW4gYGJhc2VgIHNjb3BlLlxuICAvL1xuICAvLyBJZiBhIGNvbnN0YW50IHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3RzLCB0aGVuIHdlIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0XG4gIC8vIGl0IGlzIGEgY2xhc3MgYW5kIGFsc28gdGhhdCB0aGUgc3VwZXJjbGFzc2VzIG1hdGNoLiBJZiBlaXRoZXIgb2YgdGhlc2VcbiAgLy8gZmFpbCwgdGhlbiB3ZSByYWlzZSBhIGBUeXBlRXJyb3JgLiBOb3RlLCBgc3VwZXJjbGFzc2AgbWF5IGJlIG51bGwgaWYgb25lXG4gIC8vIHdhcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBydWJ5IGNvZGUuXG4gIC8vXG4gIC8vIFdlIHBhc3MgYSBjb25zdHJ1Y3RvciB0byB0aGlzIG1ldGhvZCBvZiB0aGUgZm9ybSBgZnVuY3Rpb24gQ2xhc3NOYW1lKCkge31gXG4gIC8vIHNpbXBseSBzbyB0aGF0IGNsYXNzZXMgc2hvdyB1cCB3aXRoIG5pY2VseSBmb3JtYXR0ZWQgbmFtZXMgaW5zaWRlIGRlYnVnZ2Vyc1xuICAvLyBpbiB0aGUgd2ViIGJyb3dzZXIgKG9yIG5vZGUvc3Byb2NrZXRzKS5cbiAgLy9cbiAgLy8gVGhlIGBzY29wZWAgaXMgdGhlIGN1cnJlbnQgYHNlbGZgIHZhbHVlIHdoZXJlIHRoZSBjbGFzcyBpcyBiZWluZyBjcmVhdGVkXG4gIC8vIGZyb20uIFdlIHVzZSB0aGlzIHRvIGdldCB0aGUgc2NvcGUgZm9yIHdoZXJlIHRoZSBjbGFzcyBzaG91bGQgYmUgY3JlYXRlZC5cbiAgLy8gSWYgYHNjb3BlYCBpcyBhbiBvYmplY3QgKG5vdCBhIGNsYXNzL21vZHVsZSksIHdlIHNpbXBsZSBnZXQgaXRzIGNsYXNzIGFuZFxuICAvLyB1c2UgdGhhdCBhcyB0aGUgc2NvcGUgaW5zdGVhZC5cbiAgLy9cbiAgLy8gQHBhcmFtIHNjb3BlICAgICAgICBbT2JqZWN0XSB3aGVyZSB0aGUgY2xhc3MgaXMgYmVpbmcgY3JlYXRlZFxuICAvLyBAcGFyYW0gc3VwZXJjbGFzcyAgW0NsYXNzLG51bGxdIHN1cGVyY2xhc3Mgb2YgdGhlIG5ldyBjbGFzcyAobWF5IGJlIG51bGwpXG4gIC8vIEBwYXJhbSBpZCAgICAgICAgICBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgY2xhc3MgdG8gYmUgY3JlYXRlZFxuICAvLyBAcGFyYW0gY29uc3RydWN0b3IgW0pTLkZ1bmN0aW9uXSBmdW5jdGlvbiB0byB1c2UgYXMgY29uc3RydWN0b3JcbiAgLy9cbiAgLy8gQHJldHVybiBuZXcgW0NsYXNzXSAgb3IgZXhpc3RpbmcgcnVieSBjbGFzc1xuICAvL1xuICBPcGFsLmFsbG9jYXRlX2NsYXNzID0gZnVuY3Rpb24obmFtZSwgc3VwZXJjbGFzcykge1xuICAgIHZhciBrbGFzcywgY29uc3RydWN0b3I7XG5cbiAgICBpZiAoc3VwZXJjbGFzcyAhPSBudWxsICYmIHN1cGVyY2xhc3MuJCRicmlkZ2UpIHtcbiAgICAgIC8vIEluaGVyaXRhbmNlIGZyb20gYnJpZGdlZCBjbGFzc2VzIHJlcXVpcmVzXG4gICAgICAvLyBjYWxsaW5nIG9yaWdpbmFsIEpTIGNvbnN0cnVjdG9yc1xuICAgICAgY29uc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgc2VsZiA9IG5ldyAoJGJpbmQuYXBwbHkoc3VwZXJjbGFzcy4kJGNvbnN0cnVjdG9yLCBbbnVsbF0uY29uY2F0KGFyZ3MpKSkoKTtcblxuICAgICAgICAvLyBhbmQgcmVwbGFjaW5nIGEgX19wcm90b19fIG1hbnVhbGx5XG4gICAgICAgICRzZXRfcHJvdG8oc2VsZiwga2xhc3MuJCRwcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RydWN0b3IgPSBmdW5jdGlvbigpe307XG4gICAgfVxuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgJ2Rpc3BsYXlOYW1lJywgJzo6JytuYW1lKTtcbiAgICB9XG5cbiAgICBrbGFzcyA9IGNvbnN0cnVjdG9yO1xuXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRuYW1lJywgbmFtZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRjb25zdHJ1Y3RvcicsIGNvbnN0cnVjdG9yKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJHByb3RvdHlwZScsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRjb25zdCcsIHt9KTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGlzX2NsYXNzJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRpc19hX21vZHVsZScsIHRydWUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkc3VwZXInLCBzdXBlcmNsYXNzKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGN2YXJzJywge30pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkb3duX2luY2x1ZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRvd25fcHJlcGVuZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRhbmNlc3RvcnMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbicsIG51bGwpO1xuXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLiQkcHJvdG90eXBlLCAnJCRjbGFzcycsIGtsYXNzKTtcblxuICAgIC8vIEJ5IGRlZmF1bHQgaWYgdGhlcmUgYXJlIG5vIHNpbmdsZXRvbiBjbGFzcyBtZXRob2RzXG4gICAgLy8gX19wcm90b19fIGlzIENsYXNzLnByb3RvdHlwZVxuICAgIC8vIExhdGVyIHNpbmdsZXRvbiBtZXRob2RzIGdlbmVyYXRlIGEgc2luZ2xldG9uX2NsYXNzXG4gICAgLy8gYW5kIGluamVjdCBpdCBpbnRvIGFuY2VzdG9ycyBjaGFpblxuICAgIGlmIChPcGFsLkNsYXNzKSB7XG4gICAgICAkc2V0X3Byb3RvKGtsYXNzLCBPcGFsLkNsYXNzLnByb3RvdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHN1cGVyY2xhc3MgIT0gbnVsbCkge1xuICAgICAgJHNldF9wcm90byhrbGFzcy4kJHByb3RvdHlwZSwgc3VwZXJjbGFzcy4kJHByb3RvdHlwZSk7XG5cbiAgICAgIGlmIChzdXBlcmNsYXNzLiQkbWV0YSkge1xuICAgICAgICAvLyBJZiBzdXBlcmNsYXNzIGhhcyBtZXRhY2xhc3MgdGhlbiB3ZSBoYXZlIGV4cGxpY2l0ZWx5IGluaGVyaXQgaXQuXG4gICAgICAgIE9wYWwuYnVpbGRfY2xhc3Nfc2luZ2xldG9uX2NsYXNzKGtsYXNzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG5cblxuICBmdW5jdGlvbiBmaW5kX2V4aXN0aW5nX2NsYXNzKHNjb3BlLCBuYW1lKSB7XG4gICAgLy8gVHJ5IHRvIGZpbmQgdGhlIGNsYXNzIGluIHRoZSBjdXJyZW50IHNjb3BlXG4gICAgdmFyIGtsYXNzID0gY29uc3RfZ2V0X25hbWUoc2NvcGUsIG5hbWUpO1xuXG4gICAgLy8gSWYgdGhlIGNsYXNzIGV4aXN0cyBpbiB0aGUgc2NvcGUsIHRoZW4gd2UgbXVzdCB1c2UgdGhhdFxuICAgIGlmIChrbGFzcykge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBleGlzdGluZyBjb25zdGFudCBpcyBhIGNsYXNzLCBvciByYWlzZSBlcnJvclxuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzKSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcobmFtZSArIFwiIGlzIG5vdCBhIGNsYXNzXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlU3VwZXJjbGFzc01hdGNoKGtsYXNzLCBzdXBlcmNsYXNzKSB7XG4gICAgaWYgKGtsYXNzLiQkc3VwZXIgIT09IHN1cGVyY2xhc3MpIHtcbiAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG1pc21hdGNoIGZvciBjbGFzcyBcIiArIGtsYXNzLiQkbmFtZSk7XG4gICAgfVxuICB9XG5cbiAgT3BhbC5rbGFzcyA9IGZ1bmN0aW9uKHNjb3BlLCBzdXBlcmNsYXNzLCBuYW1lKSB7XG4gICAgdmFyIGJyaWRnZWQ7XG5cbiAgICBpZiAoc2NvcGUgPT0gbnVsbCB8fCBzY29wZSA9PSAnOjonKSB7XG4gICAgICAvLyBHbG9iYWwgc2NvcGVcbiAgICAgIHNjb3BlID0gX09iamVjdDtcbiAgICB9IGVsc2UgaWYgKCFzY29wZS4kJGlzX2NsYXNzICYmICFzY29wZS4kJGlzX21vZHVsZSkge1xuICAgICAgLy8gU2NvcGUgaXMgYW4gb2JqZWN0LCB1c2UgaXRzIGNsYXNzXG4gICAgICBzY29wZSA9IHNjb3BlLiQkY2xhc3M7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHN1cGVyY2xhc3MgaXMgbm90IGFuIE9wYWwtZ2VuZXJhdGVkIGNsYXNzIHRoZW4gd2UncmUgYnJpZGdpbmcgYSBuYXRpdmUgSlMgY2xhc3NcbiAgICBpZiAoXG4gICAgICBzdXBlcmNsYXNzICE9IG51bGwgJiYgKCFzdXBlcmNsYXNzLmhhc093blByb3BlcnR5IHx8IChcbiAgICAgICAgc3VwZXJjbGFzcy5oYXNPd25Qcm9wZXJ0eSAmJiAhc3VwZXJjbGFzcy5oYXNPd25Qcm9wZXJ0eSgnJCRpc19jbGFzcycpXG4gICAgICApKVxuICAgICkge1xuICAgICAgaWYgKHN1cGVyY2xhc3MuY29uc3RydWN0b3IgJiYgc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5uYW1lID09IFwiRnVuY3Rpb25cIikge1xuICAgICAgICBicmlkZ2VkID0gc3VwZXJjbGFzcztcbiAgICAgICAgc3VwZXJjbGFzcyA9IF9PYmplY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwic3VwZXJjbGFzcyBtdXN0IGJlIGEgQ2xhc3MgKFwiICsgKFxuICAgICAgICAgIChzdXBlcmNsYXNzLmNvbnN0cnVjdG9yICYmIChzdXBlcmNsYXNzLmNvbnN0cnVjdG9yLm5hbWUgfHwgc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci4kJG5hbWUpKSB8fFxuICAgICAgICAgIHR5cGVvZihzdXBlcmNsYXNzKVxuICAgICAgICApICsgXCIgZ2l2ZW4pXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrbGFzcyA9IGZpbmRfZXhpc3RpbmdfY2xhc3Moc2NvcGUsIG5hbWUpO1xuXG4gICAgaWYgKGtsYXNzKSB7XG4gICAgICBpZiAoc3VwZXJjbGFzcykge1xuICAgICAgICAvLyBNYWtlIHN1cmUgZXhpc3RpbmcgY2xhc3MgaGFzIHNhbWUgc3VwZXJjbGFzc1xuICAgICAgICBlbnN1cmVTdXBlcmNsYXNzTWF0Y2goa2xhc3MsIHN1cGVyY2xhc3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cblxuICAgIC8vIENsYXNzIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBhIG5ldyBvbmUgd2l0aCBnaXZlbiBzdXBlcmNsYXNzLi4uXG5cbiAgICAvLyBOb3Qgc3BlY2lmeWluZyBhIHN1cGVyY2xhc3MgbWVhbnMgd2UgY2FuIGFzc3VtZSBpdCB0byBiZSBPYmplY3RcbiAgICBpZiAoc3VwZXJjbGFzcyA9PSBudWxsKSB7XG4gICAgICBzdXBlcmNsYXNzID0gX09iamVjdDtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGhlIGNsYXNzIG9iamVjdCAoaW5zdGFuY2Ugb2YgQ2xhc3MpXG4gICAga2xhc3MgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG5hbWUsIHN1cGVyY2xhc3MpO1xuICAgIE9wYWwuY29uc3Rfc2V0KHNjb3BlLCBuYW1lLCBrbGFzcyk7XG5cbiAgICAvLyBDYWxsIC5pbmhlcml0ZWQoKSBob29rIHdpdGggbmV3IGNsYXNzIG9uIHRoZSBzdXBlcmNsYXNzXG4gICAgaWYgKHN1cGVyY2xhc3MuJGluaGVyaXRlZCkge1xuICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAoYnJpZGdlZCkge1xuICAgICAgT3BhbC5icmlkZ2UoYnJpZGdlZCwga2xhc3MpO1xuICAgIH1cblxuICAgIHJldHVybiBrbGFzcztcbiAgfTtcblxuICAvLyBEZWZpbmUgbmV3IG1vZHVsZSAob3IgcmV0dXJuIGV4aXN0aW5nIG1vZHVsZSkuIFRoZSBnaXZlbiBgc2NvcGVgIGlzIGJhc2ljYWxseVxuICAvLyB0aGUgY3VycmVudCBgc2VsZmAgdmFsdWUgdGhlIGBtb2R1bGVgIHN0YXRlbWVudCB3YXMgZGVmaW5lZCBpbi4gSWYgdGhpcyBpc1xuICAvLyBhIHJ1YnkgbW9kdWxlIG9yIGNsYXNzLCB0aGVuIGl0IGlzIHVzZWQsIG90aGVyd2lzZSBpZiB0aGUgc2NvcGUgaXMgYSBydWJ5XG4gIC8vIG9iamVjdCB0aGVuIHRoYXQgb2JqZWN0cyByZWFsIHJ1YnkgY2xhc3MgaXMgdXNlZCAoZS5nLiBpZiB0aGUgc2NvcGUgaXMgdGhlXG4gIC8vIG1haW4gb2JqZWN0LCB0aGVuIHRoZSB0b3AgbGV2ZWwgYE9iamVjdGAgY2xhc3MgaXMgdXNlZCBhcyB0aGUgc2NvcGUpLlxuICAvL1xuICAvLyBJZiBhIG1vZHVsZSBvZiB0aGUgZ2l2ZW4gbmFtZSBpcyBhbHJlYWR5IGRlZmluZWQgaW4gdGhlIHNjb3BlLCB0aGVuIHRoYXRcbiAgLy8gaW5zdGFuY2UgaXMganVzdCByZXR1cm5lZC5cbiAgLy9cbiAgLy8gSWYgdGhlcmUgaXMgYSBjbGFzcyBvZiB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGUgc2NvcGUsIHRoZW4gYW4gZXJyb3IgaXNcbiAgLy8gZ2VuZXJhdGVkIGluc3RlYWQgKGNhbm5vdCBoYXZlIGEgY2xhc3MgYW5kIG1vZHVsZSBvZiBzYW1lIG5hbWUgaW4gc2FtZSBzY29wZSkuXG4gIC8vXG4gIC8vIE90aGVyd2lzZSwgYSBuZXcgbW9kdWxlIGlzIGNyZWF0ZWQgaW4gdGhlIHNjb3BlIHdpdGggdGhlIGdpdmVuIG5hbWUsIGFuZCB0aGF0XG4gIC8vIG5ldyBpbnN0YW5jZSBpcyByZXR1cm5lZCBiYWNrICh0byBiZSByZWZlcmVuY2VkIGF0IHJ1bnRpbWUpLlxuICAvL1xuICAvLyBAcGFyYW0gIHNjb3BlIFtNb2R1bGUsIENsYXNzXSBjbGFzcyBvciBtb2R1bGUgdGhpcyBkZWZpbml0aW9uIGlzIGluc2lkZVxuICAvLyBAcGFyYW0gIGlkICAgW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG5ldyAob3IgZXhpc3RpbmcpIG1vZHVsZVxuICAvL1xuICAvLyBAcmV0dXJuIFtNb2R1bGVdXG4gIE9wYWwuYWxsb2NhdGVfbW9kdWxlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCl7fTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgJGRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCBuYW1lKycuJCRjb25zdHJ1Y3RvcicpO1xuICAgIH1cblxuICAgIHZhciBtb2R1bGUgPSBjb25zdHJ1Y3RvcjtcblxuICAgIGlmIChuYW1lKVxuICAgICAgJGRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCBuYW1lKycuY29uc3RydWN0b3InKTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJG5hbWUnLCBuYW1lKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRwcm90b3R5cGUnLCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGNvbnN0Jywge30pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGlzX21vZHVsZScsIHRydWUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkY3ZhcnMnLCB7fSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkaWNsYXNzZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkb3duX2luY2x1ZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkb3duX3ByZXBlbmRlZF9tb2R1bGVzJywgW10pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGFuY2VzdG9ycycsIFttb2R1bGVdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbicsIG51bGwpO1xuXG4gICAgJHNldF9wcm90byhtb2R1bGUsIE9wYWwuTW9kdWxlLnByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4gbW9kdWxlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZpbmRfZXhpc3RpbmdfbW9kdWxlKHNjb3BlLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZSA9IGNvbnN0X2dldF9uYW1lKHNjb3BlLCBuYW1lKTtcbiAgICBpZiAobW9kdWxlID09IG51bGwgJiYgc2NvcGUgPT09IF9PYmplY3QpIG1vZHVsZSA9IGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoX09iamVjdCwgbmFtZSk7XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICBpZiAoIW1vZHVsZS4kJGlzX21vZHVsZSAmJiBtb2R1bGUgIT09IF9PYmplY3QpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhuYW1lICsgXCIgaXMgbm90IGEgbW9kdWxlXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH1cblxuICBPcGFsLm1vZHVsZSA9IGZ1bmN0aW9uKHNjb3BlLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZTtcblxuICAgIGlmIChzY29wZSA9PSBudWxsIHx8IHNjb3BlID09ICc6OicpIHtcbiAgICAgIC8vIEdsb2JhbCBzY29wZVxuICAgICAgc2NvcGUgPSBfT2JqZWN0O1xuICAgIH0gZWxzZSBpZiAoIXNjb3BlLiQkaXNfY2xhc3MgJiYgIXNjb3BlLiQkaXNfbW9kdWxlKSB7XG4gICAgICAvLyBTY29wZSBpcyBhbiBvYmplY3QsIHVzZSBpdHMgY2xhc3NcbiAgICAgIHNjb3BlID0gc2NvcGUuJCRjbGFzcztcbiAgICB9XG5cbiAgICBtb2R1bGUgPSBmaW5kX2V4aXN0aW5nX21vZHVsZShzY29wZSwgbmFtZSk7XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cblxuICAgIC8vIE1vZHVsZSBkb2VzbnQgZXhpc3QsIGNyZWF0ZSBhIG5ldyBvbmUuLi5cbiAgICBtb2R1bGUgPSBPcGFsLmFsbG9jYXRlX21vZHVsZShuYW1lKTtcbiAgICBPcGFsLmNvbnN0X3NldChzY29wZSwgbmFtZSwgbW9kdWxlKTtcblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIHRoZSBwYXNzZWQgb2JqZWN0LlxuICAvL1xuICAvLyBJZiB0aGUgZ2l2ZW4gb2JqZWN0IGFscmVkeSBoYXMgYSBzaW5nbGV0b24gY2xhc3MsIHRoZW4gaXQgd2lsbCBiZSBzdG9yZWQgb25cbiAgLy8gdGhlIG9iamVjdCBhcyB0aGUgYCQkbWV0YWAgcHJvcGVydHkuIElmIHRoaXMgZXhpc3RzLCB0aGVuIGl0IGlzIHNpbXBseVxuICAvLyByZXR1cm5lZCBiYWNrLlxuICAvL1xuICAvLyBPdGhlcndpc2UsIGEgbmV3IHNpbmdsZXRvbiBvYmplY3QgZm9yIHRoZSBjbGFzcyBvciBvYmplY3QgaXMgY3JlYXRlZCwgc2V0IG9uXG4gIC8vIHRoZSBvYmplY3QgYXQgYCQkbWV0YWAgZm9yIGZ1dHVyZSB1c2UsIGFuZCB0aGVuIHJldHVybmVkLlxuICAvL1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdIHRoZSBydWJ5IG9iamVjdFxuICAvLyBAcmV0dXJuIFtDbGFzc10gdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3Igb2JqZWN0XG4gIE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuJCRtZXRhKSB7XG4gICAgICByZXR1cm4gb2JqZWN0LiQkbWV0YTtcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX2NsYXNzJykpIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX2NsYXNzX3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpO1xuICAgIH0gZWxzZSBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX21vZHVsZScpKSB7XG4gICAgICByZXR1cm4gT3BhbC5idWlsZF9tb2R1bGVfc2luZ2xldG9uX2NsYXNzKG9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX29iamVjdF9zaW5nbGV0b25fY2xhc3Mob2JqZWN0KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQnVpbGQgdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3IgYW4gZXhpc3RpbmcgY2xhc3MuIENsYXNzIG9iamVjdCBhcmUgYnVpbHRcbiAgLy8gd2l0aCB0aGVpciBzaW5nbGV0b24gY2xhc3MgYWxyZWFkeSBpbiB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBpbmhlcml0aW5nXG4gIC8vIGZyb20gdGhlaXIgc3VwZXJjbGFzcyBvYmplY3QgKHVwIHRvIGBDbGFzc2AgaXRzZWxmKS5cbiAgLy9cbiAgLy8gTk9URTogQWN0dWFsbHkgaW4gTVJJIGEgY2xhc3MnIHNpbmdsZXRvbiBjbGFzcyBpbmhlcml0cyBmcm9tIGl0c1xuICAvLyBzdXBlcmNsYXNzJyBzaW5nbGV0b24gY2xhc3Mgd2hpY2ggaW4gdHVybiBpbmhlcml0cyBmcm9tIENsYXNzLlxuICAvL1xuICAvLyBAcGFyYW0ga2xhc3MgW0NsYXNzXVxuICAvLyBAcmV0dXJuIFtDbGFzc11cbiAgT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihrbGFzcykge1xuICAgIHZhciBzdXBlcmNsYXNzLCBtZXRhO1xuXG4gICAgaWYgKGtsYXNzLiQkbWV0YSkge1xuICAgICAgcmV0dXJuIGtsYXNzLiQkbWV0YTtcbiAgICB9XG5cbiAgICAvLyBUaGUgc2luZ2xldG9uX2NsYXNzIHN1cGVyY2xhc3MgaXMgdGhlIHNpbmdsZXRvbl9jbGFzcyBvZiBpdHMgc3VwZXJjbGFzcztcbiAgICAvLyBidXQgQmFzaWNPYmplY3QgaGFzIG5vIHN1cGVyY2xhc3MgKGl0cyBgJCRzdXBlcmAgaXMgbnVsbCksIHRodXMgd2VcbiAgICAvLyBmYWxsYmFjayBvbiBgQ2xhc3NgLlxuICAgIHN1cGVyY2xhc3MgPSBrbGFzcyA9PT0gQmFzaWNPYmplY3QgPyBDbGFzcyA6IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhrbGFzcy4kJHN1cGVyKTtcblxuICAgIG1ldGEgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG51bGwsIHN1cGVyY2xhc3MsIGZ1bmN0aW9uKCl7fSk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkobWV0YSwgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1ldGEsICckJHNpbmdsZXRvbl9vZicsIGtsYXNzKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJG1ldGEnLCBtZXRhKTtcbiAgICAkc2V0X3Byb3RvKGtsYXNzLCBtZXRhLiQkcHJvdG90eXBlKTtcbiAgICAvLyBSZXN0b3JpbmcgQ2xhc3NOYW1lLmNsYXNzXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRjbGFzcycsIE9wYWwuQ2xhc3MpO1xuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH07XG5cbiAgT3BhbC5idWlsZF9tb2R1bGVfc2luZ2xldG9uX2NsYXNzID0gZnVuY3Rpb24obW9kKSB7XG4gICAgaWYgKG1vZC4kJG1ldGEpIHtcbiAgICAgIHJldHVybiBtb2QuJCRtZXRhO1xuICAgIH1cblxuICAgIHZhciBtZXRhID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhudWxsLCBPcGFsLk1vZHVsZSwgZnVuY3Rpb24oKXt9KTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShtZXRhLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobWV0YSwgJyQkc2luZ2xldG9uX29mJywgbW9kKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kLCAnJCRtZXRhJywgbWV0YSk7XG4gICAgJHNldF9wcm90byhtb2QsIG1ldGEuJCRwcm90b3R5cGUpO1xuICAgIC8vIFJlc3RvcmluZyBNb2R1bGVOYW1lLmNsYXNzXG4gICAgJGRlZmluZVByb3BlcnR5KG1vZCwgJyQkY2xhc3MnLCBPcGFsLk1vZHVsZSk7XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfTtcblxuICAvLyBCdWlsZCB0aGUgc2luZ2xldG9uIGNsYXNzIGZvciBhIFJ1YnkgKG5vbiBjbGFzcykgT2JqZWN0LlxuICAvL1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdXG4gIC8vIEByZXR1cm4gW0NsYXNzXVxuICBPcGFsLmJ1aWxkX29iamVjdF9zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgc3VwZXJjbGFzcyA9IG9iamVjdC4kJGNsYXNzLFxuICAgICAgICBrbGFzcyA9IE9wYWwuYWxsb2NhdGVfY2xhc3MobmlsLCBzdXBlcmNsYXNzLCBmdW5jdGlvbigpe30pO1xuXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJHNpbmdsZXRvbl9vZicsIG9iamVjdCk7XG5cbiAgICBkZWxldGUga2xhc3MuJCRwcm90b3R5cGUuJCRjbGFzcztcblxuICAgICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsICckJG1ldGEnLCBrbGFzcyk7XG5cbiAgICAkc2V0X3Byb3RvKG9iamVjdCwgb2JqZWN0LiQkbWV0YS4kJHByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG5cbiAgT3BhbC5pc19tZXRob2QgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIChwcm9wWzBdID09PSAnJCcgJiYgcHJvcFsxXSAhPT0gJyQnKTtcbiAgfTtcblxuICBPcGFsLmluc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgZXhjbHVkZSA9IFtdLCByZXN1bHRzID0gW10sIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXSxcbiAgICAgICAgICBwcm90byA9IGFuY2VzdG9yLiQkcHJvdG90eXBlO1xuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxsID0gcHJvcHMubGVuZ3RoOyBqIDwgbGw7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuXG4gICAgICAgIGlmIChPcGFsLmlzX21ldGhvZChwcm9wKSkge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSksXG4gICAgICAgICAgICAgIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgICAgaWYgKG1ldGhvZC4kJHN0dWIgJiYgZXhjbHVkZS5pbmRleE9mKG1ldGhvZF9uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGV4Y2x1ZGUucHVzaChtZXRob2RfbmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFtZXRob2QuJCRzdHViICYmIHJlc3VsdHMuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xICYmIGV4Y2x1ZGUuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobWV0aG9kX25hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgICBwcm90byA9IG1vZC4kJHByb3RvdHlwZTtcblxuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByb3BzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgIGlmICghbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG1ldGhvZF9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBPcGFsLmluc3RhbmNlX21ldGhvZHMoT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iaikpO1xuICB9O1xuXG4gIE9wYWwub3duX21ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gT3BhbC5vd25faW5zdGFuY2VfbWV0aG9kcyhPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSk7XG4gIH07XG5cbiAgT3BhbC5yZWNlaXZlcl9tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG1vZCA9IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopO1xuICAgIHZhciBzaW5nbGV0b25fbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kKTtcbiAgICB2YXIgaW5zdGFuY2VfbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kLiQkc3VwZXIpO1xuICAgIHJldHVybiBzaW5nbGV0b25fbWV0aG9kcy5jb25jYXQoaW5zdGFuY2VfbWV0aG9kcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgcGFpcnMgb2YgbmFtZXMvdmFsdWVzXG4gIC8vIGZvciBhbGwgY2xhc3MgdmFyaWFibGVzIGRlZmluZWQgaW4gcHJvdmlkZWQgK21vZHVsZStcbiAgLy8gYW5kIGl0cyBhbmNlc3RvcnMuXG4gIC8vXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV1cbiAgLy8gQHJldHVybiBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgICBpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGZvciAodmFyIGN2YXIgaW4gYW5jZXN0b3IuJCRjdmFycykge1xuICAgICAgICByZXN1bHRbY3Zhcl0gPSBhbmNlc3Rvci4kJGN2YXJzW2N2YXJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgdG8gK3ZhbHVlK1xuICAvLyBpbiBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIC8vIEBwYXJhbSB2YWx1ZSBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldCA9IGZ1bmN0aW9uKG1vZHVsZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMobW9kdWxlKSxcbiAgICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGlmICgkaGFzX293bi5jYWxsKGFuY2VzdG9yLiQkY3ZhcnMsIG5hbWUpKSB7XG4gICAgICAgIGFuY2VzdG9yLiQkY3ZhcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS4kJGN2YXJzW25hbWVdID0gdmFsdWU7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gR2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgZnJvbSBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIE9wYWwuY2xhc3NfdmFyaWFibGVfZ2V0ID0gZnVuY3Rpb24obW9kdWxlLCBuYW1lLCB0b2xlcmFudCkge1xuICAgIGlmICgkaGFzX293bi5jYWxsKG1vZHVsZS4kJGN2YXJzLCBuYW1lKSlcbiAgICAgIHJldHVybiBtb2R1bGUuJCRjdmFyc1tuYW1lXTtcblxuICAgIHZhciBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldO1xuXG4gICAgICBpZiAoJGhhc19vd24uY2FsbChhbmNlc3Rvci4kJGN2YXJzLCBuYW1lKSkge1xuICAgICAgICByZXR1cm4gYW5jZXN0b3IuJCRjdmFyc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRvbGVyYW50KVxuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldygndW5pbml0aWFsaXplZCBjbGFzcyB2YXJpYWJsZSAnK25hbWUrJyBpbiAnK21vZHVsZS4kbmFtZSgpKTtcblxuICAgIHJldHVybiBuaWw7XG4gIH1cblxuICBmdW5jdGlvbiBpc1Jvb3QocHJvdG8pIHtcbiAgICByZXR1cm4gcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykgJiYgcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkcm9vdCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX2luY2x1ZGVkX21vZHVsZXMobW9kdWxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBtb2QsIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZS4kJHByb3RvdHlwZSk7XG5cbiAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRjbGFzcycpKSB7XG4gICAgICAgIC8vIHN1cGVyY2xhc3NcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtb2QgPSBwcm90b1RvTW9kdWxlKHByb3RvKTtcbiAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobW9kKTtcbiAgICAgIH1cbiAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX3ByZXBlbmRlZF9tb2R1bGVzKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kLCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUuJCRwcm90b3R5cGUpO1xuXG4gICAgaWYgKG1vZHVsZS4kJHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgICAgaWYgKHByb3RvID09PSBtb2R1bGUuJCRwcm90b3R5cGUuJCRkZWZpbmVfbWV0aG9kc19vbikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kID0gcHJvdG9Ub01vZHVsZShwcm90byk7XG4gICAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuXG4gIC8vIFRoZSBhY3R1YWwgaW5jbHVzaW9uIG9mIGEgbW9kdWxlIGludG8gYSBjbGFzcy5cbiAgLy9cbiAgLy8gIyMgQ2xhc3MgYCQkcGFyZW50YCBhbmQgYGljbGFzc2BcbiAgLy9cbiAgLy8gVG8gaGFuZGxlIGBzdXBlcmAgY2FsbHMsIGV2ZXJ5IGNsYXNzIGhhcyBhIGAkJHBhcmVudGAuIFRoaXMgcGFyZW50IGlzXG4gIC8vIHVzZWQgdG8gcmVzb2x2ZSB0aGUgbmV4dCBjbGFzcyBmb3IgYSBzdXBlciBjYWxsLiBBIG5vcm1hbCBjbGFzcyB3b3VsZFxuICAvLyBoYXZlIHRoaXMgcG9pbnQgdG8gaXRzIHN1cGVyY2xhc3MuIEhvd2V2ZXIsIGlmIGEgY2xhc3MgaW5jbHVkZXMgYSBtb2R1bGVcbiAgLy8gdGhlbiB0aGlzIHdvdWxkIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlIG1vZHVsZS4gVGhlIG1vZHVsZSB3b3VsZFxuICAvLyBhbHNvIGhhdmUgdG8gdGhlbiBwb2ludCBpdHMgYCQkcGFyZW50YCB0byB0aGUgYWN0dWFsIHN1cGVyY2xhc3MuIFdlXG4gIC8vIGNhbm5vdCBtb2RpZnkgbW9kdWxlcyBsaWtlIHRoaXMsIGJlY2F1c2UgaXQgbWlnaHQgYmUgaW5jbHVkZWQgaW4gbW9yZVxuICAvLyB0aGVuIG9uZSBjbGFzcy4gVG8gZml4IHRoaXMsIHdlIGFjdHVhbGx5IGluc2VydCBhbiBgaWNsYXNzYCBhcyB0aGUgY2xhc3MnXG4gIC8vIGAkJHBhcmVudGAgd2hpY2ggY2FuIHRoZW4gcG9pbnQgdG8gdGhlIHN1cGVyY2xhc3MuIFRoZSBgaWNsYXNzYCBhY3RzIGFzXG4gIC8vIGEgcHJveHkgdG8gdGhlIGFjdHVhbCBtb2R1bGUsIHNvIHRoZSBgc3VwZXJgIGNoYWluIGNhbiB0aGVuIHNlYXJjaCBpdCBmb3JcbiAgLy8gdGhlIHJlcXVpcmVkIG1ldGhvZC5cbiAgLy9cbiAgLy8gQHBhcmFtIG1vZHVsZSBbTW9kdWxlXSB0aGUgbW9kdWxlIHRvIGluY2x1ZGVcbiAgLy8gQHBhcmFtIGluY2x1ZGVyIFtNb2R1bGVdIHRoZSB0YXJnZXQgY2xhc3MgdG8gaW5jbHVkZSBtb2R1bGUgaW50b1xuICAvLyBAcmV0dXJuIFtudWxsXVxuICBPcGFsLmFwcGVuZF9mZWF0dXJlcyA9IGZ1bmN0aW9uKG1vZHVsZSwgaW5jbHVkZXIpIHtcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKGluY2x1ZGVyKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdjeWNsaWMgaW5jbHVkZSBkZXRlY3RlZCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtb2R1bGVfYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBtb2R1bGVfYW5jZXN0b3JzW2ldLCBpY2xhc3MgPSBjcmVhdGVfaWNsYXNzKGFuY2VzdG9yKTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsICckJGluY2x1ZGVkJywgdHJ1ZSk7XG4gICAgICBpY2xhc3Nlcy5wdXNoKGljbGFzcyk7XG4gICAgfVxuICAgIHZhciBpbmNsdWRlcl9hbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhpbmNsdWRlciksXG4gICAgICAgIGNoYWluID0gY2hhaW5faWNsYXNzZXMoaWNsYXNzZXMpLFxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlcixcbiAgICAgICAgZW5kX2NoYWluX29uO1xuXG4gICAgaWYgKGluY2x1ZGVyX2FuY2VzdG9ycy5pbmRleE9mKG1vZHVsZSkgPT09IC0xKSB7XG4gICAgICAvLyBmaXJzdCB0aW1lIGluY2x1ZGVcblxuICAgICAgLy8gaW5jbHVkZXIgLT4gY2hhaW4uZmlyc3QgLT4gLi4uY2hhaW4uLi4gLT4gY2hhaW4ubGFzdCAtPiBpbmNsdWRlci5wYXJlbnRcbiAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gaW5jbHVkZXIuJCRwcm90b3R5cGU7XG4gICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5jbHVkZXIuJCRwcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgbW9kdWxlIGhhcyBiZWVuIGFscmVhZHkgaW5jbHVkZWQsXG4gICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHB1dCBpdCBpbnRvIHRoZSBhbmNlc3RvcnMgY2hhaW4gYWdhaW4sXG4gICAgICAvLyBidXQgdGhpcyBtb2R1bGUgbWF5IGhhdmUgbmV3IGluY2x1ZGVkIG1vZHVsZXMuXG4gICAgICAvLyBJZiBpdCdzIHRydWUgd2UgbmVlZCB0byBjb3B5IHRoZW0uXG4gICAgICAvL1xuICAgICAgLy8gVGhlIHNpbXBsZXN0IHdheSBpcyB0byByZXBsYWNlIGFuY2VzdG9ycyBjaGFpbiBmcm9tXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICBgbW9kdWxlYCBpY2xhc3MgKGhhcyBhICQkcm9vdCBmbGFnKVxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIC4uLnByZXZpb3MgY2hhaW4gb2YgbW9kdWxlLmluY2x1ZGVkX21vZHVsZXMgLi4uXG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICBcIm5leHQgYW5jZXN0b3JcIiAoaGFzIGEgJCRyb290IGZsYWcgb3IgaXMgYSByZWFsIGNsYXNzKVxuICAgICAgLy9cbiAgICAgIC8vIHRvXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAgYG1vZHVsZWAgaWNsYXNzIChoYXMgYSAkJHJvb3QgZmxhZylcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAuLi5yZWdlbmVyYXRlZCBjaGFpbiBvZiBtb2R1bGUuaW5jbHVkZWRfbW9kdWxlc1xuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIFwibmV4dCBhbmNlc3RvclwiIChoYXMgYSAkJHJvb3QgZmxhZyBvciBpcyBhIHJlYWwgY2xhc3MpXG4gICAgICAvL1xuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBhcmUgbm8gaW50ZXJtZWRpYXRlIGNsYXNzZXMgYmV0d2VlbiBgcGFyZW50YCBhbmQgYG5leHQgYW5jZXN0b3JgLlxuICAgICAgLy8gSXQgZG9lc24ndCBicmVhayBhbnkgcHJvdG90eXBlcyBvZiBvdGhlciBvYmplY3RzIGFzIHdlIGRvbid0IGNoYW5nZSBjbGFzcyByZWZlcmVuY2VzLlxuXG4gICAgICB2YXIgcGFyZW50ID0gaW5jbHVkZXIuJCRwcm90b3R5cGUsIG1vZHVsZV9pY2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTtcblxuICAgICAgd2hpbGUgKG1vZHVsZV9pY2xhc3MgIT0gbnVsbCkge1xuICAgICAgICBpZiAobW9kdWxlX2ljbGFzcy4kJG1vZHVsZSA9PT0gbW9kdWxlICYmIGlzUm9vdChtb2R1bGVfaWNsYXNzKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gbW9kdWxlX2ljbGFzcztcbiAgICAgICAgbW9kdWxlX2ljbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGVfaWNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZHVsZV9pY2xhc3MpIHtcbiAgICAgICAgLy8gbW9kdWxlIGhhcyBiZWVuIGRpcmVjdGx5IGluY2x1ZGVkXG4gICAgICAgIHZhciBuZXh0X2FuY2VzdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZV9pY2xhc3MpO1xuXG4gICAgICAgIC8vIHNraXAgbm9uLXJvb3QgaWNsYXNzZXMgKHRoYXQgd2VyZSByZWN1cnNpdmVseSBpbmNsdWRlZClcbiAgICAgICAgd2hpbGUgKG5leHRfYW5jZXN0b3IuaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykgJiYgIWlzUm9vdChuZXh0X2FuY2VzdG9yKSkge1xuICAgICAgICAgIG5leHRfYW5jZXN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV4dF9hbmNlc3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlciA9IHBhcmVudDtcbiAgICAgICAgZW5kX2NoYWluX29uID0gbmV4dF9hbmNlc3RvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vZHVsZSBoYXMgbm90IGJlZW4gZGlyZWN0bHkgaW5jbHVkZWQgYnV0IHdhcyBpbiBhbmNlc3RvciBjaGFpbiBiZWNhdXNlIGl0IHdhcyBpbmNsdWRlZCBieSBhbm90aGVyIG1vZHVsZVxuICAgICAgICAvLyBpbmNsdWRlIGl0IGRpcmVjdGx5XG4gICAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gaW5jbHVkZXIuJCRwcm90b3R5cGU7XG4gICAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbmNsdWRlci4kJHByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgJHNldF9wcm90byhzdGFydF9jaGFpbl9hZnRlciwgY2hhaW4uZmlyc3QpO1xuICAgICRzZXRfcHJvdG8oY2hhaW4ubGFzdCwgZW5kX2NoYWluX29uKTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIG93bl9pbmNsdWRlZF9tb2R1bGVzIGNhY2hlXG4gICAgaW5jbHVkZXIuJCRvd25faW5jbHVkZWRfbW9kdWxlcyA9IG93bl9pbmNsdWRlZF9tb2R1bGVzKGluY2x1ZGVyKTtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICB9O1xuXG4gIE9wYWwucHJlcGVuZF9mZWF0dXJlcyA9IGZ1bmN0aW9uKG1vZHVsZSwgcHJlcGVuZGVyKSB7XG4gICAgLy8gSGVyZSB3ZSBjaGFuZ2UgdGhlIGFuY2VzdG9ycyBjaGFpbiBmcm9tXG4gICAgLy9cbiAgICAvLyAgIHByZXBlbmRlclxuICAgIC8vICAgICAgfFxuICAgIC8vICAgIHBhcmVudFxuICAgIC8vXG4gICAgLy8gdG86XG4gICAgLy9cbiAgICAvLyBkdW1teShwcmVwZW5kZXIpXG4gICAgLy8gICAgICB8XG4gICAgLy8gIGljbGFzcyhtb2R1bGUpXG4gICAgLy8gICAgICB8XG4gICAgLy8gaWNsYXNzKHByZXBlbmRlcilcbiAgICAvLyAgICAgIHxcbiAgICAvLyAgICBwYXJlbnRcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKHByZXBlbmRlcikgIT09IC0xKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldygnY3ljbGljIHByZXBlbmQgZGV0ZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbW9kdWxlX2FuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gbW9kdWxlX2FuY2VzdG9yc1tpXSwgaWNsYXNzID0gY3JlYXRlX2ljbGFzcyhhbmNlc3Rvcik7XG4gICAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCAnJCRwcmVwZW5kZWQnLCB0cnVlKTtcbiAgICAgIGljbGFzc2VzLnB1c2goaWNsYXNzKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhaW4gPSBjaGFpbl9pY2xhc3NlcyhpY2xhc3NlcyksXG4gICAgICAgIGR1bW15X3ByZXBlbmRlciA9IHByZXBlbmRlci4kJHByb3RvdHlwZSxcbiAgICAgICAgcHJldmlvdXNfcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGR1bW15X3ByZXBlbmRlciksXG4gICAgICAgIHByZXBlbmRlcl9pY2xhc3MsXG4gICAgICAgIHN0YXJ0X2NoYWluX2FmdGVyLFxuICAgICAgICBlbmRfY2hhaW5fb247XG5cbiAgICBpZiAoZHVtbXlfcHJlcGVuZGVyLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIC8vIFRoZSBtb2R1bGUgYWxyZWFkeSBoYXMgc29tZSBwcmVwZW5kZWQgbW9kdWxlc1xuICAgICAgLy8gd2hpY2ggbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIHRvIG1ha2UgaXQgXCJkdW1teVwiXG4gICAgICBwcmVwZW5kZXJfaWNsYXNzID0gZHVtbXlfcHJlcGVuZGVyLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1ha2luZyB0aGUgbW9kdWxlIFwiZHVtbXlcIlxuICAgICAgcHJlcGVuZGVyX2ljbGFzcyA9IGNyZWF0ZV9kdW1teV9pY2xhc3MocHJlcGVuZGVyKTtcbiAgICAgIGZsdXNoX21ldGhvZHNfaW4ocHJlcGVuZGVyKTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShkdW1teV9wcmVwZW5kZXIsICckJGR1bW15JywgdHJ1ZSk7XG4gICAgICAkZGVmaW5lUHJvcGVydHkoZHVtbXlfcHJlcGVuZGVyLCAnJCRkZWZpbmVfbWV0aG9kc19vbicsIHByZXBlbmRlcl9pY2xhc3MpO1xuXG4gICAgICAvLyBDb252ZXJ0aW5nXG4gICAgICAvLyAgIGR1bW15KHByZXBlbmRlcikgLT4gcHJldmlvdXNfcGFyZW50XG4gICAgICAvLyB0b1xuICAgICAgLy8gICBkdW1teShwcmVwZW5kZXIpIC0+IGljbGFzcyhwcmVwZW5kZXIpIC0+IHByZXZpb3VzX3BhcmVudFxuICAgICAgJHNldF9wcm90byhkdW1teV9wcmVwZW5kZXIsIHByZXBlbmRlcl9pY2xhc3MpO1xuICAgICAgJHNldF9wcm90byhwcmVwZW5kZXJfaWNsYXNzLCBwcmV2aW91c19wYXJlbnQpO1xuICAgIH1cblxuICAgIHZhciBwcmVwZW5kZXJfYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMocHJlcGVuZGVyKTtcblxuICAgIGlmIChwcmVwZW5kZXJfYW5jZXN0b3JzLmluZGV4T2YobW9kdWxlKSA9PT0gLTEpIHtcbiAgICAgIC8vIGZpcnN0IHRpbWUgcHJlcGVuZFxuXG4gICAgICBzdGFydF9jaGFpbl9hZnRlciA9IGR1bW15X3ByZXBlbmRlcjtcblxuICAgICAgLy8gbmV4dCAkJHJvb3Qgb3IgcHJlcGVuZGVyX2ljbGFzcyBvciBub24tJCRpY2xhc3NcbiAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihkdW1teV9wcmVwZW5kZXIpO1xuICAgICAgd2hpbGUgKGVuZF9jaGFpbl9vbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBlbmRfY2hhaW5fb24uaGFzT3duUHJvcGVydHkoJyQkcm9vdCcpIHx8XG4gICAgICAgICAgZW5kX2NoYWluX29uID09PSBwcmVwZW5kZXJfaWNsYXNzIHx8XG4gICAgICAgICAgIWVuZF9jaGFpbl9vbi5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKVxuICAgICAgICApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihlbmRfY2hhaW5fb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBPcGFsLlJ1bnRpbWVFcnJvci4kbmV3KFwiUHJlcGVuZGluZyBhIG1vZHVsZSBtdWx0aXBsZSB0aW1lcyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cblxuICAgICRzZXRfcHJvdG8oc3RhcnRfY2hhaW5fYWZ0ZXIsIGNoYWluLmZpcnN0KTtcbiAgICAkc2V0X3Byb3RvKGNoYWluLmxhc3QsIGVuZF9jaGFpbl9vbik7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBvd25fcHJlcGVuZGVkX21vZHVsZXMgY2FjaGVcbiAgICBwcmVwZW5kZXIuJCRvd25fcHJlcGVuZGVkX21vZHVsZXMgPSBvd25fcHJlcGVuZGVkX21vZHVsZXMocHJlcGVuZGVyKTtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZsdXNoX21ldGhvZHNfaW4obW9kdWxlKSB7XG4gICAgdmFyIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlLFxuICAgICAgICBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgZGVsZXRlIHByb3RvW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZV9pY2xhc3MobW9kdWxlKSB7XG4gICAgdmFyIGljbGFzcyA9IGNyZWF0ZV9kdW1teV9pY2xhc3MobW9kdWxlKTtcblxuICAgIGlmIChtb2R1bGUuJCRpc19tb2R1bGUpIHtcbiAgICAgIG1vZHVsZS4kJGljbGFzc2VzLnB1c2goaWNsYXNzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWNsYXNzO1xuICB9XG5cbiAgLy8gRHVtbXkgaWNsYXNzIGRvZXNuJ3QgcmVjZWl2ZSB1cGRhdGVzIHdoZW4gdGhlIG1vZHVsZSBnZXRzIGEgbmV3IG1ldGhvZC5cbiAgZnVuY3Rpb24gY3JlYXRlX2R1bW15X2ljbGFzcyhtb2R1bGUpIHtcbiAgICB2YXIgaWNsYXNzID0ge30sXG4gICAgICAgIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlO1xuXG4gICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIHByb3RvID0gcHJvdG8uJCRkZWZpbmVfbWV0aG9kc19vbjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsIHByb3AsIHByb3RvW3Byb3BdKTtcbiAgICB9XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCAnJCRpY2xhc3MnLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCAnJCRtb2R1bGUnLCBtb2R1bGUpO1xuXG4gICAgcmV0dXJuIGljbGFzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYWluX2ljbGFzc2VzKGljbGFzc2VzKSB7XG4gICAgdmFyIGxlbmd0aCA9IGljbGFzc2VzLmxlbmd0aCwgZmlyc3QgPSBpY2xhc3Nlc1swXTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShmaXJzdCwgJyQkcm9vdCcsIHRydWUpO1xuXG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHsgZmlyc3Q6IGZpcnN0LCBsYXN0OiBmaXJzdCB9O1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91cyA9IGZpcnN0O1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBpY2xhc3Nlc1tpXTtcbiAgICAgICRzZXRfcHJvdG8ocHJldmlvdXMsIGN1cnJlbnQpO1xuICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIH1cblxuXG4gICAgcmV0dXJuIHsgZmlyc3Q6IGljbGFzc2VzWzBdLCBsYXN0OiBpY2xhc3Nlc1tsZW5ndGggLSAxXSB9O1xuICB9XG5cbiAgLy8gRm9yIHBlcmZvcm1hbmNlLCBzb21lIGNvcmUgUnVieSBjbGFzc2VzIGFyZSB0b2xsLWZyZWUgYnJpZGdlZCB0byB0aGVpclxuICAvLyBuYXRpdmUgSmF2YVNjcmlwdCBjb3VudGVycGFydHMgKGUuZy4gYSBSdWJ5IEFycmF5IGlzIGEgSmF2YVNjcmlwdCBBcnJheSkuXG4gIC8vXG4gIC8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2V0dXAgYSBuYXRpdmUgY29uc3RydWN0b3IgKGUuZy4gQXJyYXkpLCB0byBoYXZlXG4gIC8vIGl0cyBwcm90b3R5cGUgYWN0IGxpa2UgYSBub3JtYWwgUnVieSBjbGFzcy4gRmlyc3RseSwgYSBuZXcgUnVieSBjbGFzcyBpc1xuICAvLyBjcmVhdGVkIHVzaW5nIHRoZSBuYXRpdmUgY29uc3RydWN0b3Igc28gdGhhdCBpdHMgcHJvdG90eXBlIGlzIHNldCBhcyB0aGVcbiAgLy8gdGFyZ2V0IGZvciB0aGUgbmV3IGNsYXNzLiBOb3RlOiBhbGwgYnJpZGdlZCBjbGFzc2VzIGFyZSBzZXQgdG8gaW5oZXJpdFxuICAvLyBmcm9tIE9iamVjdC5cbiAgLy9cbiAgLy8gRXhhbXBsZTpcbiAgLy9cbiAgLy8gICAgT3BhbC5icmlkZ2Uoc2VsZiwgRnVuY3Rpb24pO1xuICAvL1xuICAvLyBAcGFyYW0ga2xhc3MgICAgICAgW0NsYXNzXSB0aGUgUnVieSBjbGFzcyB0byBicmlkZ2VcbiAgLy8gQHBhcmFtIGNvbnN0cnVjdG9yIFtKUy5GdW5jdGlvbl0gbmF0aXZlIEphdmFTY3JpcHQgY29uc3RydWN0b3IgdG8gdXNlXG4gIC8vIEByZXR1cm4gW0NsYXNzXSByZXR1cm5zIHRoZSBwYXNzZWQgUnVieSBjbGFzc1xuICAvL1xuICBPcGFsLmJyaWRnZSA9IGZ1bmN0aW9uKG5hdGl2ZV9rbGFzcywga2xhc3MpIHtcbiAgICBpZiAobmF0aXZlX2tsYXNzLmhhc093blByb3BlcnR5KCckJGJyaWRnZScpKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcImFscmVhZHkgYnJpZGdlZFwiKTtcbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3RvciBpcyBhIEpTIGZ1bmN0aW9uIHdpdGggYSBwcm90b3R5cGUgY2hhaW4gbGlrZTpcbiAgICAvLyAtIGNvbnN0cnVjdG9yXG4gICAgLy8gICAtIHN1cGVyXG4gICAgLy9cbiAgICAvLyBXaGF0IHdlIG5lZWQgdG8gZG8gaXMgdG8gaW5qZWN0IG91ciBjbGFzcyAod2l0aCBpdHMgcHJvdG90eXBlIGNoYWluKVxuICAgIC8vIGJldHdlZW4gY29uc3RydWN0b3IgYW5kIHN1cGVyLiBGb3IgZXhhbXBsZSwgYWZ0ZXIgaW5qZWN0aW5nIDo6T2JqZWN0XG4gICAgLy8gaW50byBKUyBTdHJpbmcgd2UgZ2V0OlxuICAgIC8vXG4gICAgLy8gLSBjb25zdHJ1Y3RvciAod2luZG93LlN0cmluZylcbiAgICAvLyAgIC0gT3BhbC5PYmplY3RcbiAgICAvLyAgICAgLSBPcGFsLktlcm5lbFxuICAgIC8vICAgICAgIC0gT3BhbC5CYXNpY09iamVjdFxuICAgIC8vICAgICAgICAgLSBzdXBlciAod2luZG93Lk9iamVjdClcbiAgICAvLyAgICAgICAgICAgLSBudWxsXG4gICAgLy9cbiAgICAkZGVmaW5lUHJvcGVydHkobmF0aXZlX2tsYXNzLCAnJCRicmlkZ2UnLCBrbGFzcyk7XG4gICAgJHNldF9wcm90byhuYXRpdmVfa2xhc3MucHJvdG90eXBlLCAoa2xhc3MuJCRzdXBlciB8fCBPcGFsLk9iamVjdCkuJCRwcm90b3R5cGUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkcHJvdG90eXBlJywgbmF0aXZlX2tsYXNzLnByb3RvdHlwZSk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MuJCRwcm90b3R5cGUsICckJGNsYXNzJywga2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkY29uc3RydWN0b3InLCBuYXRpdmVfa2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkYnJpZGdlJywgdHJ1ZSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHJvdG9Ub01vZHVsZShwcm90bykge1xuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIHByb3RvLiQkbW9kdWxlO1xuICAgIH0gZWxzZSBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIHByb3RvLiQkY2xhc3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb3duX2FuY2VzdG9ycyhtb2R1bGUpIHtcbiAgICByZXR1cm4gbW9kdWxlLiQkb3duX3ByZXBlbmRlZF9tb2R1bGVzLmNvbmNhdChbbW9kdWxlXSkuY29uY2F0KG1vZHVsZS4kJG93bl9pbmNsdWRlZF9tb2R1bGVzKTtcbiAgfVxuXG4gIC8vIFRoZSBBcnJheSBvZiBhbmNlc3RvcnMgZm9yIGEgZ2l2ZW4gbW9kdWxlL2NsYXNzXG4gIE9wYWwuYW5jZXN0b3JzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgaWYgKCFtb2R1bGUpIHsgcmV0dXJuIFtdOyB9XG5cbiAgICBpZiAobW9kdWxlLiQkYW5jZXN0b3JzX2NhY2hlX3ZlcnNpb24gPT09IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbikge1xuICAgICAgcmV0dXJuIG1vZHVsZS4kJGFuY2VzdG9ycztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW10sIGksIG1vZHMsIGxlbmd0aDtcblxuICAgIGZvciAoaSA9IDAsIG1vZHMgPSBvd25fYW5jZXN0b3JzKG1vZHVsZSksIGxlbmd0aCA9IG1vZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKG1vZHNbaV0pO1xuICAgIH1cblxuICAgIGlmIChtb2R1bGUuJCRzdXBlcikge1xuICAgICAgZm9yIChpID0gMCwgbW9kcyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZS4kJHN1cGVyKSwgbGVuZ3RoID0gbW9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChtb2RzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbjtcbiAgICBtb2R1bGUuJCRhbmNlc3RvcnMgPSByZXN1bHQ7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIE9wYWwuaW5jbHVkZWRfbW9kdWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kID0gbnVsbCwgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlLiQkcHJvdG90eXBlKTtcblxuICAgIGZvciAoOyBwcm90byAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pOyBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykpIHtcbiAgICAgIG1vZCA9IHByb3RvVG9Nb2R1bGUocHJvdG8pO1xuICAgICAgaWYgKG1vZCAmJiBtb2QuJCRpc19tb2R1bGUgJiYgcHJvdG8uJCRpY2xhc3MgJiYgcHJvdG8uJCRpbmNsdWRlZCkge1xuICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblxuICAvLyBNZXRob2QgTWlzc2luZ1xuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIE1ldGhvZHMgc3R1YnMgYXJlIHVzZWQgdG8gZmFjaWxpdGF0ZSBtZXRob2RfbWlzc2luZyBpbiBvcGFsLiBBIHN0dWIgaXMgYVxuICAvLyBwbGFjZWhvbGRlciBmdW5jdGlvbiB3aGljaCBqdXN0IGNhbGxzIGBtZXRob2RfbWlzc2luZ2Agb24gdGhlIHJlY2VpdmVyLlxuICAvLyBJZiBubyBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBhY3R1YWxseSBkZWZpbmVkIG9uIGFuIG9iamVjdCwgdGhlbiBpdFxuICAvLyBpcyBvYnZpb3VzIHRvIHNheSB0aGF0IHRoZSBzdHViIHdpbGwgYmUgY2FsbGVkIGluc3RlYWQsIGFuZCB0aGVuIGluIHR1cm5cbiAgLy8gbWV0aG9kX21pc3Npbmcgd2lsbCBiZSBjYWxsZWQuXG4gIC8vXG4gIC8vIFdoZW4gYSBmaWxlIGluIHJ1YnkgZ2V0cyBjb21waWxlZCB0byBqYXZhc2NyaXB0LCBpdCBpbmNsdWRlcyBhIGNhbGwgdG9cbiAgLy8gdGhpcyBmdW5jdGlvbiB3aGljaCBhZGRzIHN0dWJzIGZvciBldmVyeSBtZXRob2QgbmFtZSBpbiB0aGUgY29tcGlsZWQgZmlsZS5cbiAgLy8gSXQgc2hvdWxkIHRoZW4gYmUgc2FmZSB0byBhc3N1bWUgdGhhdCBtZXRob2RfbWlzc2luZyB3aWxsIHdvcmsgZm9yIGFueVxuICAvLyBtZXRob2QgY2FsbCBkZXRlY3RlZC5cbiAgLy9cbiAgLy8gTWV0aG9kIHN0dWJzIGFyZSBhZGRlZCB0byB0aGUgQmFzaWNPYmplY3QgcHJvdG90eXBlLCB3aGljaCBldmVyeSBvdGhlclxuICAvLyBydWJ5IG9iamVjdCBpbmhlcml0cywgc28gYWxsIG9iamVjdHMgc2hvdWxkIGhhbmRsZSBtZXRob2QgbWlzc2luZy4gQSBzdHViXG4gIC8vIGlzIG9ubHkgYWRkZWQgaWYgdGhlIGdpdmVuIHByb3BlcnR5IG5hbWUgKG1ldGhvZCBuYW1lKSBpcyBub3QgYWxyZWFkeVxuICAvLyBkZWZpbmVkLlxuICAvL1xuICAvLyBOb3RlOiBhbGwgcnVieSBtZXRob2RzIGhhdmUgYSBgJGAgcHJlZml4IGluIGphdmFzY3JpcHQsIHNvIGFsbCBzdHVicyB3aWxsXG4gIC8vIGhhdmUgdGhpcyBwcmVmaXggYXMgd2VsbCAodG8gbWFrZSB0aGlzIG1ldGhvZCBtb3JlIHBlcmZvcm1hbnQpLlxuICAvL1xuICAvLyAgICBPcGFsLmFkZF9zdHVicyhbXCIkZm9vXCIsIFwiJGJhclwiLCBcIiRiYXo9XCJdKTtcbiAgLy9cbiAgLy8gQWxsIHN0dWIgZnVuY3Rpb25zIHdpbGwgaGF2ZSBhIHByaXZhdGUgYCQkc3R1YmAgcHJvcGVydHkgc2V0IHRvIHRydWUgc29cbiAgLy8gdGhhdCBvdGhlciBpbnRlcm5hbCBtZXRob2RzIGNhbiBkZXRlY3QgaWYgYSBtZXRob2QgaXMganVzdCBhIHN0dWIgb3Igbm90LlxuICAvLyBgS2VybmVsI3Jlc3BvbmRfdG8/YCB1c2VzIHRoaXMgcHJvcGVydHkgdG8gZGV0ZWN0IGEgbWV0aG9kcyBwcmVzZW5jZS5cbiAgLy9cbiAgLy8gQHBhcmFtIHN0dWJzIFtBcnJheV0gYW4gYXJyYXkgb2YgbWV0aG9kIHN0dWJzIHRvIGFkZFxuICAvLyBAcmV0dXJuIFt1bmRlZmluZWRdXG4gIE9wYWwuYWRkX3N0dWJzID0gZnVuY3Rpb24oc3R1YnMpIHtcbiAgICB2YXIgcHJvdG8gPSBPcGFsLkJhc2ljT2JqZWN0LiQkcHJvdG90eXBlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0dWJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3R1YiA9IHN0dWJzW2ldLCBleGlzdGluZ19tZXRob2QgPSBwcm90b1tzdHViXTtcblxuICAgICAgaWYgKGV4aXN0aW5nX21ldGhvZCA9PSBudWxsIHx8IGV4aXN0aW5nX21ldGhvZC4kJHN0dWIpIHtcbiAgICAgICAgT3BhbC5hZGRfc3R1Yl9mb3IocHJvdG8sIHN0dWIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYSBtZXRob2RfbWlzc2luZyBzdHViIGZ1bmN0aW9uIHRvIHRoZSBnaXZlbiBwcm90b3R5cGUgZm9yIHRoZVxuICAvLyBnaXZlbiBuYW1lLlxuICAvL1xuICAvLyBAcGFyYW0gcHJvdG90eXBlIFtQcm90b3R5cGVdIHRoZSB0YXJnZXQgcHJvdG90eXBlXG4gIC8vIEBwYXJhbSBzdHViIFtTdHJpbmddIHN0dWIgbmFtZSB0byBhZGQgKGUuZy4gXCIkZm9vXCIpXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5hZGRfc3R1Yl9mb3IgPSBmdW5jdGlvbihwcm90b3R5cGUsIHN0dWIpIHtcbiAgICB2YXIgbWV0aG9kX21pc3Npbmdfc3R1YiA9IE9wYWwuc3R1Yl9mb3Ioc3R1Yik7XG4gICAgJGRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgc3R1YiwgbWV0aG9kX21pc3Npbmdfc3R1Yik7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgdGhlIG1ldGhvZF9taXNzaW5nIHN0dWIgZm9yIGEgZ2l2ZW4gbWV0aG9kIG5hbWUuXG4gIC8vXG4gIC8vIEBwYXJhbSBtZXRob2RfbmFtZSBbU3RyaW5nXSBUaGUganMtbmFtZSBvZiB0aGUgbWV0aG9kIHRvIHN0dWIgKGUuZy4gXCIkZm9vXCIpXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5zdHViX2ZvciA9IGZ1bmN0aW9uKG1ldGhvZF9uYW1lKSB7XG5cbiAgICBmdW5jdGlvbiBtZXRob2RfbWlzc2luZ19zdHViKCkge1xuICAgICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuXG4gICAgICAvLyBDb3B5IGFueSBnaXZlbiBibG9jayBvbnRvIHRoZSBtZXRob2RfbWlzc2luZyBkaXNwYXRjaGVyXG4gICAgICB0aGlzLiRtZXRob2RfbWlzc2luZy4kJHAgPSBtZXRob2RfbWlzc2luZ19zdHViLiQkcDtcblxuICAgICAgLy8gU2V0IGJsb2NrIHByb3BlcnR5IHRvIG51bGwgcmVhZHkgZm9yIHRoZSBuZXh0IGNhbGwgKHN0b3AgZmFsc2UtcG9zaXRpdmVzKVxuICAgICAgbWV0aG9kX21pc3Npbmdfc3R1Yi4kJHAgPSBudWxsO1xuXG4gICAgICAvLyBjYWxsIG1ldGhvZCBtaXNzaW5nIHdpdGggY29ycmVjdCBhcmdzIChyZW1vdmUgJyQnIHByZWZpeCBvbiBtZXRob2QgbmFtZSlcbiAgICAgIHZhciBhcmdzX2FyeSA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmd1bWVudHNbaV07IH1cblxuICAgICAgcmV0dXJuIHRoaXMuJG1ldGhvZF9taXNzaW5nLmFwcGx5KHRoaXMsIFttZXRob2RfbmFtZS5zbGljZSgxKV0uY29uY2F0KGFyZ3NfYXJ5KSk7XG4gICAgfVxuXG4gICAgbWV0aG9kX21pc3Npbmdfc3R1Yi4kJHN0dWIgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG1ldGhvZF9taXNzaW5nX3N0dWI7XG4gIH07XG5cblxuICAvLyBNZXRob2RzXG4gIC8vIC0tLS0tLS1cblxuICAvLyBBcml0eSBjb3VudCBlcnJvciBkaXNwYXRjaGVyIGZvciBtZXRob2RzXG4gIC8vXG4gIC8vIEBwYXJhbSBhY3R1YWwgW0ZpeG51bV0gbnVtYmVyIG9mIGFyZ3VtZW50cyBnaXZlbiB0byBtZXRob2RcbiAgLy8gQHBhcmFtIGV4cGVjdGVkIFtGaXhudW1dIGV4cGVjdGVkIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHBhcmFtIG9iamVjdCBbT2JqZWN0XSBvd25lciBvZiB0aGUgbWV0aG9kICttZXRoK1xuICAvLyBAcGFyYW0gbWV0aCBbU3RyaW5nXSBtZXRob2QgbmFtZSB0aGF0IGdvdCB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzXG4gIC8vIEByYWlzZSBbQXJndW1lbnRFcnJvcl1cbiAgT3BhbC5hYyA9IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIG9iamVjdCwgbWV0aCkge1xuICAgIHZhciBpbnNwZWN0ID0gJyc7XG4gICAgaWYgKG9iamVjdC4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICBpbnNwZWN0ICs9IG9iamVjdC4kJG5hbWUgKyAnLic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaW5zcGVjdCArPSBvYmplY3QuJCRjbGFzcy4kJG5hbWUgKyAnIyc7XG4gICAgfVxuICAgIGluc3BlY3QgKz0gbWV0aDtcblxuICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdbJyArIGluc3BlY3QgKyAnXSB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzKCcgKyBhY3R1YWwgKyAnIGZvciAnICsgZXhwZWN0ZWQgKyAnKScpO1xuICB9O1xuXG4gIC8vIEFyaXR5IGNvdW50IGVycm9yIGRpc3BhdGNoZXIgZm9yIGJsb2Nrc1xuICAvL1xuICAvLyBAcGFyYW0gYWN0dWFsIFtGaXhudW1dIG51bWJlciBvZiBhcmd1bWVudHMgZ2l2ZW4gdG8gYmxvY2tcbiAgLy8gQHBhcmFtIGV4cGVjdGVkIFtGaXhudW1dIGV4cGVjdGVkIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHBhcmFtIGNvbnRleHQgW09iamVjdF0gY29udGV4dCBvZiB0aGUgYmxvY2sgZGVmaW5pdGlvblxuICAvLyBAcmFpc2UgW0FyZ3VtZW50RXJyb3JdXG4gIE9wYWwuYmxvY2tfYWMgPSBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3BlY3QgPSBcImBibG9jayBpbiBcIiArIGNvbnRleHQgKyBcIidcIjtcblxuICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KGluc3BlY3QgKyAnOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgnICsgYWN0dWFsICsgJyBmb3IgJyArIGV4cGVjdGVkICsgJyknKTtcbiAgfTtcblxuICAvLyBTdXBlciBkaXNwYXRjaGVyXG4gIE9wYWwuZmluZF9zdXBlcl9kaXNwYXRjaGVyID0gZnVuY3Rpb24ob2JqLCBtaWQsIGN1cnJlbnRfZnVuYywgZGVmY2hlY2ssIGFsbG93X3N0dWJzKSB7XG4gICAgdmFyIGpzaWQgPSAnJCcgKyBtaWQsIGFuY2VzdG9ycywgc3VwZXJfbWV0aG9kO1xuXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSgnJCRtZXRhJykpIHtcbiAgICAgIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG9iai4kJG1ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhvYmouJCRjbGFzcyk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRfaW5kZXggPSBhbmNlc3RvcnMuaW5kZXhPZihjdXJyZW50X2Z1bmMuJCRvd25lcik7XG5cbiAgICBmb3IgKHZhciBpID0gY3VycmVudF9pbmRleCArIDE7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXSxcbiAgICAgICAgICBwcm90byA9IGFuY2VzdG9yLiQkcHJvdG90eXBlO1xuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eShqc2lkKSkge1xuICAgICAgICBzdXBlcl9tZXRob2QgPSBwcm90b1tqc2lkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkZWZjaGVjayAmJiBzdXBlcl9tZXRob2QgJiYgc3VwZXJfbWV0aG9kLiQkc3R1YiAmJiBvYmouJG1ldGhvZF9taXNzaW5nLiQkcHJpc3RpbmUpIHtcbiAgICAgIC8vIG1ldGhvZF9taXNzaW5nIGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgZGVmaW5lZFxuICAgICAgdGhyb3cgT3BhbC5Ob01ldGhvZEVycm9yLiRuZXcoJ3N1cGVyOiBubyBzdXBlcmNsYXNzIG1ldGhvZCBgJyttaWQrXCInIGZvciBcIitvYmosIG1pZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChzdXBlcl9tZXRob2QuJCRzdHViICYmICFhbGxvd19zdHVicykgPyBudWxsIDogc3VwZXJfbWV0aG9kO1xuICB9O1xuXG4gIC8vIEl0ZXIgZGlzcGF0Y2hlciBmb3Igc3VwZXIgaW4gYSBibG9ja1xuICBPcGFsLmZpbmRfaXRlcl9zdXBlcl9kaXNwYXRjaGVyID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrLCBpbXBsaWNpdCkge1xuICAgIHZhciBjYWxsX2pzaWQgPSBqc2lkO1xuXG4gICAgaWYgKCFjdXJyZW50X2Z1bmMpIHtcbiAgICAgIHRocm93IE9wYWwuUnVudGltZUVycm9yLiRuZXcoXCJzdXBlciBjYWxsZWQgb3V0c2lkZSBvZiBtZXRob2RcIik7XG4gICAgfVxuXG4gICAgaWYgKGltcGxpY2l0ICYmIGN1cnJlbnRfZnVuYy4kJGRlZmluZV9tZXRoKSB7XG4gICAgICB0aHJvdyBPcGFsLlJ1bnRpbWVFcnJvci4kbmV3KFwiaW1wbGljaXQgYXJndW1lbnQgcGFzc2luZyBvZiBzdXBlciBmcm9tIG1ldGhvZCBkZWZpbmVkIGJ5IGRlZmluZV9tZXRob2QoKSBpcyBub3Qgc3VwcG9ydGVkLiBTcGVjaWZ5IGFsbCBhcmd1bWVudHMgZXhwbGljaXRseVwiKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudF9mdW5jLiQkZGVmKSB7XG4gICAgICBjYWxsX2pzaWQgPSBjdXJyZW50X2Z1bmMuJCRqc2lkO1xuICAgIH1cblxuICAgIHJldHVybiBPcGFsLmZpbmRfc3VwZXJfZGlzcGF0Y2hlcihvYmosIGNhbGxfanNpZCwgY3VycmVudF9mdW5jLCBkZWZjaGVjayk7XG4gIH07XG5cbiAgLy8gVXNlZCB0byByZXR1cm4gYXMgYW4gZXhwcmVzc2lvbi4gU29tZXRpbWVzLCB3ZSBjYW4ndCBzaW1wbHkgcmV0dXJuIGZyb21cbiAgLy8gYSBqYXZhc2NyaXB0IGZ1bmN0aW9uIGFzIGlmIHdlIHdlcmUgYSBtZXRob2QsIGFzIHRoZSByZXR1cm4gaXMgdXNlZCBhc1xuICAvLyBhbiBleHByZXNzaW9uLCBvciBldmVuIGluc2lkZSBhIGJsb2NrIHdoaWNoIG11c3QgXCJyZXR1cm5cIiB0byB0aGUgb3V0ZXJcbiAgLy8gbWV0aG9kLiBUaGlzIGhlbHBlciBzaW1wbHkgdGhyb3dzIGFuIGVycm9yIHdoaWNoIGlzIHRoZW4gY2F1Z2h0IGJ5IHRoZVxuICAvLyBtZXRob2QuIFRoaXMgYXBwcm9hY2ggaXMgZXhwZW5zaXZlLCBzbyBpdCBpcyBvbmx5IHVzZWQgd2hlbiBhYnNvbHV0ZWx5XG4gIC8vIG5lZWRlZC5cbiAgLy9cbiAgT3BhbC5yZXQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICBPcGFsLnJldHVybmVyLiR2ID0gdmFsO1xuICAgIHRocm93IE9wYWwucmV0dXJuZXI7XG4gIH07XG5cbiAgLy8gVXNlZCB0byBicmVhayBvdXQgb2YgYSBibG9jay5cbiAgT3BhbC5icmsgPSBmdW5jdGlvbih2YWwsIGJyZWFrZXIpIHtcbiAgICBicmVha2VyLiR2ID0gdmFsO1xuICAgIHRocm93IGJyZWFrZXI7XG4gIH07XG5cbiAgLy8gQnVpbGRzIGEgbmV3IHVuaXF1ZSBicmVha2VyLCB0aGlzIGlzIHRvIGF2b2lkIG11bHRpcGxlIG5lc3RlZCBicmVha3MgdG8gZ2V0XG4gIC8vIGluIHRoZSB3YXkgb2YgZWFjaCBvdGhlci5cbiAgT3BhbC5uZXdfYnJrID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcigndW5leHBlY3RlZCBicmVhaycpO1xuICB9O1xuXG4gIC8vIGhhbmRsZXMgeWllbGQgY2FsbHMgZm9yIDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZDEgPSBmdW5jdGlvbihibG9jaywgYXJnKSB7XG4gICAgaWYgKHR5cGVvZihibG9jaykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgT3BhbC5Mb2NhbEp1bXBFcnJvci4kbmV3KFwibm8gYmxvY2sgZ2l2ZW5cIik7XG4gICAgfVxuXG4gICAgdmFyIGhhc19tbGhzID0gYmxvY2suJCRoYXNfdG9wX2xldmVsX21saHNfYXJnLFxuICAgICAgICBoYXNfdHJhaWxpbmdfY29tbWEgPSBibG9jay4kJGhhc190cmFpbGluZ19jb21tYV9pbl9hcmdzO1xuXG4gICAgaWYgKGJsb2NrLmxlbmd0aCA+IDEgfHwgKChoYXNfbWxocyB8fCBoYXNfdHJhaWxpbmdfY29tbWEpICYmIGJsb2NrLmxlbmd0aCA9PT0gMSkpIHtcbiAgICAgIGFyZyA9IE9wYWwudG9fYXJ5KGFyZyk7XG4gICAgfVxuXG4gICAgaWYgKChibG9jay5sZW5ndGggPiAxIHx8IChoYXNfdHJhaWxpbmdfY29tbWEgJiYgYmxvY2subGVuZ3RoID09PSAxKSkgJiYgYXJnLiQkaXNfYXJyYXkpIHtcbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBibG9jayhhcmcpO1xuICAgIH1cbiAgfTtcblxuICAvLyBoYW5kbGVzIHlpZWxkIGZvciA+IDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZFggPSBmdW5jdGlvbihibG9jaywgYXJncykge1xuICAgIGlmICh0eXBlb2YoYmxvY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IE9wYWwuTG9jYWxKdW1wRXJyb3IuJG5ldyhcIm5vIGJsb2NrIGdpdmVuXCIpO1xuICAgIH1cblxuICAgIGlmIChibG9jay5sZW5ndGggPiAxICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoYXJnc1swXS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFyZ3MuJCRpc19hcnJheSkge1xuICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmdzW2ldOyB9XG5cbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzX2FyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2NrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9O1xuXG4gIC8vIEZpbmRzIHRoZSBjb3JyZXNwb25kaW5nIGV4Y2VwdGlvbiBtYXRjaCBpbiBjYW5kaWRhdGVzLiAgRWFjaCBjYW5kaWRhdGUgY2FuXG4gIC8vIGJlIGEgdmFsdWUsIG9yIGFuIGFycmF5IG9mIHZhbHVlcy4gIFJldHVybnMgbnVsbCBpZiBub3QgZm91bmQuXG4gIE9wYWwucmVzY3VlID0gZnVuY3Rpb24oZXhjZXB0aW9uLCBjYW5kaWRhdGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tpXTtcblxuICAgICAgaWYgKGNhbmRpZGF0ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBPcGFsLnJlc2N1ZShleGNlcHRpb24sIGNhbmRpZGF0ZSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZSA9PT0gT3BhbC5KUy5FcnJvcikge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlWyckPT09J10oZXhjZXB0aW9uKSkge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIE9wYWwuaXNfYSA9IGZ1bmN0aW9uKG9iamVjdCwga2xhc3MpIHtcbiAgICBpZiAoa2xhc3MgIT0gbnVsbCAmJiBvYmplY3QuJCRtZXRhID09PSBrbGFzcyB8fCBvYmplY3QuJCRjbGFzcyA9PT0ga2xhc3MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvYmplY3QuJCRpc19udW1iZXIgJiYga2xhc3MuJCRpc19udW1iZXJfY2xhc3MpIHtcbiAgICAgIHJldHVybiAoa2xhc3MuJCRpc19pbnRlZ2VyX2NsYXNzKSA/IChvYmplY3QgJSAxKSA9PT0gMCA6IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGksIGxlbmd0aCwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMob2JqZWN0LiQkaXNfY2xhc3MgPyBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqZWN0KSA6IChvYmplY3QuJCRtZXRhIHx8IG9iamVjdC4kJGNsYXNzKSk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhbmNlc3RvcnNbaV0gPT09IGtsYXNzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBIZWxwZXJzIGZvciBleHRyYWN0aW5nIGt3c3BsYXRzXG4gIC8vIFVzZWQgZm9yOiB7ICoqaCB9XG4gIE9wYWwudG9faGFzaCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLiQkaXNfaGFzaCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVsnJHJlc3BvbmRfdG8/J10oJ3RvX2hhc2gnLCB0cnVlKSkge1xuICAgICAgdmFyIGhhc2ggPSB2YWx1ZS4kdG9faGFzaCgpO1xuICAgICAgaWYgKGhhc2guJCRpc19oYXNoKSB7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJDYW4ndCBjb252ZXJ0IFwiICsgdmFsdWUuJCRjbGFzcyArXG4gICAgICAgICAgXCIgdG8gSGFzaCAoXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIjdG9faGFzaCBnaXZlcyBcIiArIGhhc2guJCRjbGFzcyArIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiBcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiBpbnRvIEhhc2hcIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIEhlbHBlcnMgZm9yIGltcGxlbWVudGluZyBtdWx0aXBsZSBhc3NpZ25tZW50XG4gIC8vIE91ciBjb2RlIGZvciBleHRyYWN0aW5nIHRoZSB2YWx1ZXMgYW5kIGFzc2lnbmluZyB0aGVtIG9ubHkgd29ya3MgaWYgdGhlXG4gIC8vIHJldHVybiB2YWx1ZSBpcyBhIEpTIGFycmF5LlxuICAvLyBTbyBpZiB3ZSBnZXQgYW4gQXJyYXkgc3ViY2xhc3MsIGV4dHJhY3QgdGhlIHdyYXBwZWQgSlMgYXJyYXkgZnJvbSBpdFxuXG4gIC8vIFVzZWQgZm9yOiBhLCBiID0gc29tZXRoaW5nIChubyBzcGxhdClcbiAgT3BhbC50b19hcnkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlWyckcmVzcG9uZF90bz8nXSgndG9fYXJ5JywgdHJ1ZSkpIHtcbiAgICAgIHZhciBhcnkgPSB2YWx1ZS4kdG9fYXJ5KCk7XG4gICAgICBpZiAoYXJ5ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcnkuJCRpc19hcnJheSkge1xuICAgICAgICByZXR1cm4gYXJ5O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJDYW4ndCBjb252ZXJ0IFwiICsgdmFsdWUuJCRjbGFzcyArXG4gICAgICAgICAgXCIgdG8gQXJyYXkgKFwiICsgdmFsdWUuJCRjbGFzcyArIFwiI3RvX2FyeSBnaXZlcyBcIiArIGFyeS4kJGNsYXNzICsgXCIpXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgIH1cbiAgfTtcblxuICAvLyBVc2VkIGZvcjogYSwgYiA9ICpzb21ldGhpbmcgKHdpdGggc3BsYXQpXG4gIE9wYWwudG9fYSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpIHtcbiAgICAgIC8vIEEgc3BsYXR0ZWQgYXJyYXkgbXVzdCBiZSBjb3BpZWRcbiAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVsnJHJlc3BvbmRfdG8/J10oJ3RvX2EnLCB0cnVlKSkge1xuICAgICAgdmFyIGFyeSA9IHZhbHVlLiR0b19hKCk7XG4gICAgICBpZiAoYXJ5ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcnkuJCRpc19hcnJheSkge1xuICAgICAgICByZXR1cm4gYXJ5O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJDYW4ndCBjb252ZXJ0IFwiICsgdmFsdWUuJCRjbGFzcyArXG4gICAgICAgICAgXCIgdG8gQXJyYXkgKFwiICsgdmFsdWUuJCRjbGFzcyArIFwiI3RvX2EgZ2l2ZXMgXCIgKyBhcnkuJCRjbGFzcyArIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCBmb3IgZXh0cmFjdGluZyBrZXl3b3JkIGFyZ3VtZW50cyBmcm9tIGFyZ3VtZW50cyBwYXNzZWQgdG9cbiAgLy8gSlMgZnVuY3Rpb24uIElmIHByb3ZpZGVkICthcmd1bWVudHMrIGxpc3QgZG9lc24ndCBoYXZlIGEgSGFzaFxuICAvLyBhcyBhIGxhc3QgaXRlbSwgcmV0dXJucyBhIGJsYW5rIEhhc2guXG4gIC8vXG4gIC8vIEBwYXJhbSBwYXJhbWV0ZXJzIFtBcnJheV1cbiAgLy8gQHJldHVybiBbSGFzaF1cbiAgLy9cbiAgT3BhbC5leHRyYWN0X2t3YXJncyA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgICB2YXIga3dhcmdzID0gcGFyYW1ldGVyc1twYXJhbWV0ZXJzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChrd2FyZ3MgIT0gbnVsbCAmJiBPcGFsLnJlc3BvbmRfdG8oa3dhcmdzLCAnJHRvX2hhc2gnLCB0cnVlKSkge1xuICAgICAgJHNwbGljZS5jYWxsKHBhcmFtZXRlcnMsIHBhcmFtZXRlcnMubGVuZ3RoIC0gMSwgMSk7XG4gICAgICByZXR1cm4ga3dhcmdzLiR0b19oYXNoKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIE9wYWwuaGFzaDIoW10sIHt9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCB0byBnZXQgYSBsaXN0IG9mIHJlc3Qga2V5d29yZCBhcmd1bWVudHMuIE1ldGhvZCB0YWtlcyB0aGUgZ2l2ZW5cbiAgLy8ga2V5d29yZCBhcmdzLCBpLmUuIHRoZSBoYXNoIGxpdGVyYWwgcGFzc2VkIHRvIHRoZSBtZXRob2QgY29udGFpbmluZyBhbGxcbiAgLy8ga2V5d29yZCBhcmd1ZW1udHMgcGFzc2VkIHRvIG1ldGhvZCwgYXMgd2VsbCBhcyB0aGUgdXNlZCBhcmdzIHdoaWNoIGFyZVxuICAvLyB0aGUgbmFtZXMgb2YgcmVxdWlyZWQgYW5kIG9wdGlvbmFsIGFyZ3VtZW50cyBkZWZpbmVkLiBUaGlzIG1ldGhvZCB0aGVuXG4gIC8vIGp1c3QgcmV0dXJucyBhbGwga2V5L3ZhbHVlIHBhaXJzIHdoaWNoIGhhdmUgbm90IGJlZW4gdXNlZCwgaW4gYSBuZXdcbiAgLy8gaGFzaCBsaXRlcmFsLlxuICAvL1xuICAvLyBAcGFyYW0gZ2l2ZW5fYXJncyBbSGFzaF0gYWxsIGt3YXJncyBnaXZlbiB0byBtZXRob2RcbiAgLy8gQHBhcmFtIHVzZWRfYXJncyBbT2JqZWN0PFN0cmluZzogdHJ1ZT5dIGFsbCBrZXlzIHVzZWQgYXMgbmFtZWQga3dhcmdzXG4gIC8vIEByZXR1cm4gW0hhc2hdXG4gIC8vXG4gIE9wYWwua3dyZXN0YXJncyA9IGZ1bmN0aW9uKGdpdmVuX2FyZ3MsIHVzZWRfYXJncykge1xuICAgIHZhciBrZXlzICAgICAgPSBbXSxcbiAgICAgICAgbWFwICAgICAgID0ge30sXG4gICAgICAgIGtleSAgICAgICAgICAgLFxuICAgICAgICBnaXZlbl9tYXAgPSBnaXZlbl9hcmdzLiQkc21hcDtcblxuICAgIGZvciAoa2V5IGluIGdpdmVuX21hcCkge1xuICAgICAgaWYgKCF1c2VkX2FyZ3Nba2V5XSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgbWFwW2tleV0gPSBnaXZlbl9tYXBba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5oYXNoMihrZXlzLCBtYXApO1xuICB9O1xuXG4gIC8vIENhbGxzIHBhc3NlZCBtZXRob2Qgb24gYSBydWJ5IG9iamVjdCB3aXRoIGFyZ3VtZW50cyBhbmQgYmxvY2s6XG4gIC8vXG4gIC8vIENhbiB0YWtlIGEgbWV0aG9kIG9yIGEgbWV0aG9kIG5hbWUuXG4gIC8vXG4gIC8vIDEuIFdoZW4gbWV0aG9kIG5hbWUgZ2V0cyBwYXNzZWQgaXQgaW52b2tlcyBpdCBieSBpdHMgbmFtZVxuICAvLyAgICBhbmQgY2FsbHMgJ21ldGhvZF9taXNzaW5nJyB3aGVuIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2QuXG4gIC8vICAgIFVzZWQgaW50ZXJuYWxseSBieSBPcGFsIHRvIGludm9rZSBtZXRob2QgdGhhdCB0YWtlcyBhIGJsb2NrIG9yIGEgc3BsYXQuXG4gIC8vIDIuIFdoZW4gbWV0aG9kIChpLmUuIG1ldGhvZCBib2R5KSBnZXRzIHBhc3NlZCwgaXQgZG9lc24ndCB0cmlnZ2VyICdtZXRob2RfbWlzc2luZydcbiAgLy8gICAgYmVjYXVzZSBpdCBkb2Vzbid0IGtub3cgdGhlIG5hbWUgb2YgdGhlIGFjdHVhbCBtZXRob2QuXG4gIC8vICAgIFVzZWQgaW50ZXJuYWxseSBieSBPcGFsIHRvIGludm9rZSAnc3VwZXInLlxuICAvL1xuICAvLyBAZXhhbXBsZVxuICAvLyAgIHZhciBteV9hcnJheSA9IFsxLCAyLCAzLCA0XVxuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgJ2xlbmd0aCcpICAgICAgICAgICAgICAgICAgICAjID0+IDRcbiAgLy8gICBPcGFsLnNlbmQobXlfYXJyYXksIG15X2FycmF5LiRsZW5ndGgpICAgICAgICAgICAgIyA9PiA0XG4gIC8vXG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCAncmV2ZXJzZSEnKSAgICAgICAgICAgICAgICAgICMgPT4gWzQsIDMsIDIsIDFdXG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCBteV9hcnJheVsnJHJldmVyc2UhJ10nKSAgICAgICMgPT4gWzQsIDMsIDIsIDFdXG4gIC8vXG4gIC8vIEBwYXJhbSByZWN2IFtPYmplY3RdIHJ1Ynkgb2JqZWN0XG4gIC8vIEBwYXJhbSBtZXRob2QgW0Z1bmN0aW9uLCBTdHJpbmddIG1ldGhvZCBib2R5IG9yIG5hbWUgb2YgdGhlIG1ldGhvZFxuICAvLyBAcGFyYW0gYXJncyBbQXJyYXldIGFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBtZXRob2QgY2FsbFxuICAvLyBAcGFyYW0gYmxvY2sgW0Z1bmN0aW9uXSBydWJ5IGJsb2NrXG4gIC8vIEByZXR1cm4gW09iamVjdF0gcmV0dXJuaW5nIHZhbHVlIG9mIHRoZSBtZXRob2QgY2FsbFxuICBPcGFsLnNlbmQgPSBmdW5jdGlvbihyZWN2LCBtZXRob2QsIGFyZ3MsIGJsb2NrKSB7XG4gICAgdmFyIGJvZHk7XG5cbiAgICBpZiAodHlwZW9mKG1ldGhvZCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJvZHkgPSBtZXRob2Q7XG4gICAgICBtZXRob2QgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mKG1ldGhvZCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBib2R5ID0gcmVjdlsnJCcrbWV0aG9kXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIlBhc3NlZCBtZXRob2Qgc2hvdWxkIGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9wYWwuc2VuZDIocmVjdiwgYm9keSwgbWV0aG9kLCBhcmdzLCBibG9jayk7XG4gIH07XG5cbiAgT3BhbC5zZW5kMiA9IGZ1bmN0aW9uKHJlY3YsIGJvZHksIG1ldGhvZCwgYXJncywgYmxvY2spIHtcbiAgICBpZiAoYm9keSA9PSBudWxsICYmIG1ldGhvZCAhPSBudWxsICYmIHJlY3YuJG1ldGhvZF9taXNzaW5nKSB7XG4gICAgICBib2R5ID0gcmVjdi4kbWV0aG9kX21pc3Npbmc7XG4gICAgICBhcmdzID0gW21ldGhvZF0uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIGJvZHkuJCRwID0gYmxvY2s7XG4gICAgcmV0dXJuIGJvZHkuYXBwbHkocmVjdiwgYXJncyk7XG4gIH07XG5cbiAgT3BhbC5sYW1iZGEgPSBmdW5jdGlvbihibG9jaykge1xuICAgIGJsb2NrLiQkaXNfbGFtYmRhID0gdHJ1ZTtcbiAgICByZXR1cm4gYmxvY2s7XG4gIH07XG5cbiAgLy8gVXNlZCB0byBkZWZpbmUgbWV0aG9kcyBvbiBhbiBvYmplY3QuIFRoaXMgaXMgYSBoZWxwZXIgbWV0aG9kLCB1c2VkIGJ5IHRoZVxuICAvLyBjb21waWxlZCBzb3VyY2UgdG8gZGVmaW5lIG1ldGhvZHMgb24gc3BlY2lhbCBjYXNlIG9iamVjdHMgd2hlbiB0aGUgY29tcGlsZXJcbiAgLy8gY2FuIG5vdCBkZXRlcm1pbmUgdGhlIGRlc3RpbmF0aW9uIG9iamVjdCwgb3IgdGhlIG9iamVjdCBpcyBhIE1vZHVsZVxuICAvLyBpbnN0YW5jZS4gVGhpcyBjYW4gZ2V0IGNhbGxlZCBieSBgTW9kdWxlI2RlZmluZV9tZXRob2RgIGFzIHdlbGwuXG4gIC8vXG4gIC8vICMjIE1vZHVsZXNcbiAgLy9cbiAgLy8gQW55IG1ldGhvZCBkZWZpbmVkIG9uIGEgbW9kdWxlIHdpbGwgY29tZSB0aHJvdWdoIHRoaXMgcnVudGltZSBoZWxwZXIuXG4gIC8vIFRoZSBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIG1vZHVsZSBib2R5LCBhbmQgdGhlIG93bmVyIG9mIHRoZSBtZXRob2QgaXNcbiAgLy8gc2V0IHRvIGJlIHRoZSBtb2R1bGUgaXRzZWxmLiBUaGlzIGlzIHVzZWQgbGF0ZXIgd2hlbiBjaG9vc2luZyB3aGljaFxuICAvLyBtZXRob2Qgc2hvdWxkIHNob3cgb24gYSBjbGFzcyBpZiBtb3JlIHRoYW4gMSBpbmNsdWRlZCBtb2R1bGVzIGRlZmluZVxuICAvLyB0aGUgc2FtZSBtZXRob2QuIEZpbmFsbHksIGlmIHRoZSBtb2R1bGUgaXMgaW4gYG1vZHVsZV9mdW5jdGlvbmAgbW9kZSxcbiAgLy8gdGhlbiB0aGUgbWV0aG9kIGlzIGFsc28gZGVmaW5lZCBvbnRvIHRoZSBtb2R1bGUgaXRzZWxmLlxuICAvL1xuICAvLyAjIyBDbGFzc2VzXG4gIC8vXG4gIC8vIFRoaXMgaGVscGVyIHdpbGwgb25seSBiZSBjYWxsZWQgZm9yIGNsYXNzZXMgd2hlbiBhIG1ldGhvZCBpcyBiZWluZ1xuICAvLyBkZWZpbmVkIGluZGlyZWN0bHk7IGVpdGhlciB0aHJvdWdoIGBNb2R1bGUjZGVmaW5lX21ldGhvZGAsIG9yIGJ5IGFcbiAgLy8gbGl0ZXJhbCBgZGVmYCBtZXRob2QgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBvciBgY2xhc3NfZXZhbGAgYm9keS4gSW5cbiAgLy8gZWl0aGVyIGNhc2UsIHRoZSBtZXRob2QgaXMgc2ltcGx5IGFkZGVkIHRvIHRoZSBjbGFzcycgcHJvdG90eXBlLiBBIHNwZWNpYWxcbiAgLy8gZXhjZXB0aW9uIGV4aXN0cyBmb3IgYEJhc2ljT2JqZWN0YCBhbmQgYE9iamVjdGAuIFRoZXNlIHR3byBjbGFzc2VzIGFyZVxuICAvLyBzcGVjaWFsIGJlY2F1c2UgdGhleSBhcmUgdXNlZCBpbiB0b2xsLWZyZWUgYnJpZGdlZCBjbGFzc2VzLiBJbiBlYWNoIG9mXG4gIC8vIHRoZXNlIHR3byBjYXNlcywgZXh0cmEgd29yayBpcyByZXF1aXJlZCB0byBkZWZpbmUgdGhlIG1ldGhvZHMgb24gdG9sbC1mcmVlXG4gIC8vIGJyaWRnZWQgY2xhc3MnIHByb3RvdHlwZXMgYXMgd2VsbC5cbiAgLy9cbiAgLy8gIyMgT2JqZWN0c1xuICAvL1xuICAvLyBJZiBhIHNpbXBsZSBydWJ5IG9iamVjdCBpcyB0aGUgb2JqZWN0LCB0aGVuIHRoZSBtZXRob2QgaXMgc2ltcGx5IGp1c3RcbiAgLy8gZGVmaW5lZCBvbiB0aGUgb2JqZWN0IGFzIGEgc2luZ2xldG9uIG1ldGhvZC4gVGhpcyB3b3VsZCBiZSB0aGUgY2FzZSB3aGVuXG4gIC8vIGEgbWV0aG9kIGlzIGRlZmluZWQgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBibG9jay5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iaiAgW09iamVjdCwgQ2xhc3NdIHRoZSBhY3R1YWwgb2JqIHRvIGRlZmluZSBtZXRob2QgZm9yXG4gIC8vIEBwYXJhbSBqc2lkIFtTdHJpbmddIHRoZSBKYXZhU2NyaXB0IGZyaWVuZGx5IG1ldGhvZCBuYW1lIChlLmcuICckZm9vJylcbiAgLy8gQHBhcmFtIGJvZHkgW0pTLkZ1bmN0aW9uXSB0aGUgbGl0ZXJhbCBKYXZhU2NyaXB0IGZ1bmN0aW9uIHVzZWQgYXMgbWV0aG9kXG4gIC8vIEByZXR1cm4gW251bGxdXG4gIC8vXG4gIE9wYWwuZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBib2R5KSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIG1ldGhvZCBkZWZpbml0aW9uIGluIHRoZVxuICAgIC8vIHRvcC1sZXZlbCBuYW1lc3BhY2VcbiAgICBpZiAob2JqID09PSBPcGFsLnRvcCkge1xuICAgICAgT3BhbC5kZWZuKE9wYWwuT2JqZWN0LCBqc2lkLCBib2R5KVxuICAgIH1cbiAgICAvLyBpZiBpbnN0YW5jZV9ldmFsIGlzIGludm9rZWQgb24gYSBtb2R1bGUvY2xhc3MsIGl0IHNldHMgaW5zdF9ldmFsX21vZFxuICAgIGVsc2UgaWYgKCFvYmouJCRldmFsICYmIG9iai4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICBPcGFsLmRlZm4ob2JqLCBqc2lkLCBib2R5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBPcGFsLmRlZnMob2JqLCBqc2lkLCBib2R5KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRGVmaW5lIG1ldGhvZCBvbiBhIG1vZHVsZSBvciBjbGFzcyAoc2VlIE9wYWwuZGVmKS5cbiAgT3BhbC5kZWZuID0gZnVuY3Rpb24obW9kdWxlLCBqc2lkLCBib2R5KSB7XG4gICAgYm9keS5kaXNwbGF5TmFtZSA9IGpzaWQ7XG4gICAgYm9keS4kJG93bmVyID0gbW9kdWxlO1xuXG4gICAgdmFyIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlO1xuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuICAgICRkZWZpbmVQcm9wZXJ0eShwcm90bywganNpZCwgYm9keSk7XG5cbiAgICBpZiAobW9kdWxlLiQkaXNfbW9kdWxlKSB7XG4gICAgICBpZiAobW9kdWxlLiQkbW9kdWxlX2Z1bmN0aW9uKSB7XG4gICAgICAgIE9wYWwuZGVmcyhtb2R1bGUsIGpzaWQsIGJvZHkpXG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpY2xhc3NlcyA9IG1vZHVsZS4kJGljbGFzc2VzLCBsZW5ndGggPSBpY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWNsYXNzID0gaWNsYXNzZXNbaV07XG4gICAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsIGpzaWQsIGJvZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaW5nbGV0b25fb2YgPSBtb2R1bGUuJCRzaW5nbGV0b25fb2Y7XG4gICAgaWYgKG1vZHVsZS4kbWV0aG9kX2FkZGVkICYmICFtb2R1bGUuJG1ldGhvZF9hZGRlZC4kJHN0dWIgJiYgIXNpbmdsZXRvbl9vZikge1xuICAgICAgbW9kdWxlLiRtZXRob2RfYWRkZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzaW5nbGV0b25fb2YgJiYgc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkICYmICFzaW5nbGV0b25fb2YuJHNpbmdsZXRvbl9tZXRob2RfYWRkZWQuJCRzdHViKSB7XG4gICAgICBzaW5nbGV0b25fb2YuJHNpbmdsZXRvbl9tZXRob2RfYWRkZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEZWZpbmUgYSBzaW5nbGV0b24gbWV0aG9kIG9uIHRoZSBnaXZlbiBvYmplY3QgKHNlZSBPcGFsLmRlZikuXG4gIE9wYWwuZGVmcyA9IGZ1bmN0aW9uKG9iaiwganNpZCwgYm9keSkge1xuICAgIGlmIChvYmouJCRpc19zdHJpbmcgfHwgb2JqLiQkaXNfbnVtYmVyKSB7XG4gICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiY2FuJ3QgZGVmaW5lIHNpbmdsZXRvblwiKTtcbiAgICB9XG4gICAgT3BhbC5kZWZuKE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopLCBqc2lkLCBib2R5KVxuICB9O1xuXG4gIC8vIENhbGxlZCBmcm9tICNyZW1vdmVfbWV0aG9kLlxuICBPcGFsLnJkZWYgPSBmdW5jdGlvbihvYmosIGpzaWQpIHtcbiAgICBpZiAoISRoYXNfb3duLmNhbGwob2JqLiQkcHJvdG90eXBlLCBqc2lkKSkge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBkZWxldGUgb2JqLiQkcHJvdG90eXBlW2pzaWRdO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkICYmICFvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF9yZW1vdmVkICYmICFvYmouJG1ldGhvZF9yZW1vdmVkLiQkc3R1Yikge1xuICAgICAgICBvYmouJG1ldGhvZF9yZW1vdmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGZyb20gI3VuZGVmX21ldGhvZC5cbiAgT3BhbC51ZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkKSB7XG4gICAgaWYgKCFvYmouJCRwcm90b3R5cGVbanNpZF0gfHwgb2JqLiQkcHJvdG90eXBlW2pzaWRdLiQkc3R1Yikge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBPcGFsLmFkZF9zdHViX2ZvcihvYmouJCRwcm90b3R5cGUsIGpzaWQpO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQuJCRzdHViKSB7XG4gICAgICAgIG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kbWV0aG9kX3VuZGVmaW5lZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiRtZXRob2RfdW5kZWZpbmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfbWV0aG9kX2JvZHkoYm9keSkge1xuICAgIHJldHVybiAodHlwZW9mKGJvZHkpID09PSBcImZ1bmN0aW9uXCIgJiYgIWJvZHkuJCRzdHViKTtcbiAgfVxuXG4gIE9wYWwuYWxpYXMgPSBmdW5jdGlvbihvYmosIG5hbWUsIG9sZCkge1xuICAgIHZhciBpZCAgICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICBvbGRfaWQgPSAnJCcgKyBvbGQsXG4gICAgICAgIGJvZHkgICA9IG9iai4kJHByb3RvdHlwZVsnJCcgKyBvbGRdLFxuICAgICAgICBhbGlhcztcblxuICAgIC8vIFdoZW4gcnVubmluZyBpbnNpZGUgI2luc3RhbmNlX2V2YWwgdGhlIGFsaWFzIHJlZmVycyB0byBjbGFzcyBtZXRob2RzLlxuICAgIGlmIChvYmouJCRldmFsKSB7XG4gICAgICByZXR1cm4gT3BhbC5hbGlhcyhPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSwgbmFtZSwgb2xkKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBvYmouJCRzdXBlcjtcblxuICAgICAgd2hpbGUgKHR5cGVvZihib2R5KSAhPT0gXCJmdW5jdGlvblwiICYmIGFuY2VzdG9yKSB7XG4gICAgICAgIGJvZHkgICAgID0gYW5jZXN0b3Jbb2xkX2lkXTtcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci4kJHN1cGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpICYmIG9iai4kJGlzX21vZHVsZSkge1xuICAgICAgICAvLyB0cnkgdG8gbG9vayBpbnRvIE9iamVjdFxuICAgICAgICBib2R5ID0gT3BhbC5PYmplY3QuJCRwcm90b3R5cGVbb2xkX2lkXVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpKSB7XG4gICAgICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGBcIiArIG9sZCArIFwiJyBmb3IgY2xhc3MgYFwiICsgb2JqLiRuYW1lKCkgKyBcIidcIilcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYm9keSBpcyBpdHNlbGYgYW4gYWxpYXMgdXNlIHRoZSBvcmlnaW5hbCBib2R5XG4gICAgLy8gdG8ga2VlcCB0aGUgbWF4IGRlcHRoIGF0IDEuXG4gICAgaWYgKGJvZHkuJCRhbGlhc19vZikgYm9keSA9IGJvZHkuJCRhbGlhc19vZjtcblxuICAgIC8vIFdlIG5lZWQgYSB3cmFwcGVyIGJlY2F1c2Ugb3RoZXJ3aXNlIHByb3BlcnRpZXNcbiAgICAvLyB3b3VsZCBiZSBvdmVyd3JpdHRlbiBvbiB0aGUgb3JpZ2luYWwgYm9keS5cbiAgICBhbGlhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJsb2NrID0gYWxpYXMuJCRwLCBhcmdzLCBpLCBpaTtcblxuICAgICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIGZvcihpID0gMCwgaWkgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT0gbnVsbCkgeyBhbGlhcy4kJHAgPSBudWxsIH1cblxuICAgICAgcmV0dXJuIE9wYWwuc2VuZCh0aGlzLCBib2R5LCBhcmdzLCBibG9jayk7XG4gICAgfTtcblxuICAgIC8vIEFzc2lnbiB0aGUgJ2xlbmd0aCcgdmFsdWUgd2l0aCBkZWZpbmVQcm9wZXJ0eSBiZWNhdXNlXG4gICAgLy8gaW4gc3RyaWN0IG1vZGUgdGhlIHByb3BlcnR5IGlzIG5vdCB3cml0YWJsZS5cbiAgICAvLyBJdCBkb2Vzbid0IHdvcmsgaW4gb2xkZXIgYnJvd3NlcnMgKGxpa2UgQ2hyb21lIDM4KSwgd2hlcmVcbiAgICAvLyBhbiBleGNlcHRpb24gaXMgdGhyb3duIGJyZWFraW5nIE9wYWwgYWx0b2dldGhlci5cbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFsaWFzLCAnbGVuZ3RoJywgeyB2YWx1ZTogYm9keS5sZW5ndGggfSk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIFRyeSB0byBtYWtlIHRoZSBicm93c2VyIHBpY2sgdGhlIHJpZ2h0IG5hbWVcbiAgICBhbGlhcy5kaXNwbGF5TmFtZSAgICAgICA9IG5hbWU7XG5cbiAgICBhbGlhcy4kJGFyaXR5ICAgICAgICAgICA9IGJvZHkuJCRhcml0eTtcbiAgICBhbGlhcy4kJHBhcmFtZXRlcnMgICAgICA9IGJvZHkuJCRwYXJhbWV0ZXJzO1xuICAgIGFsaWFzLiQkc291cmNlX2xvY2F0aW9uID0gYm9keS4kJHNvdXJjZV9sb2NhdGlvbjtcbiAgICBhbGlhcy4kJGFsaWFzX29mICAgICAgICA9IGJvZHk7XG4gICAgYWxpYXMuJCRhbGlhc19uYW1lICAgICAgPSBuYW1lO1xuXG4gICAgT3BhbC5kZWZuKG9iaiwgaWQsIGFsaWFzKTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgT3BhbC5hbGlhc19uYXRpdmUgPSBmdW5jdGlvbihvYmosIG5hbWUsIG5hdGl2ZV9uYW1lKSB7XG4gICAgdmFyIGlkICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICBib2R5ID0gb2JqLiQkcHJvdG90eXBlW25hdGl2ZV9uYW1lXTtcblxuICAgIGlmICh0eXBlb2YoYm9keSkgIT09IFwiZnVuY3Rpb25cIiB8fCBib2R5LiQkc3R1Yikge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcInVuZGVmaW5lZCBuYXRpdmUgbWV0aG9kIGBcIiArIG5hdGl2ZV9uYW1lICsgXCInIGZvciBjbGFzcyBgXCIgKyBvYmouJG5hbWUoKSArIFwiJ1wiKVxuICAgIH1cblxuICAgIE9wYWwuZGVmbihvYmosIGlkLCBib2R5KTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cblxuICAvLyBIYXNoZXNcbiAgLy8gLS0tLS0tXG5cbiAgT3BhbC5oYXNoX2luaXQgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC4kJHNtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGhhc2guJCRtYXAgID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoLiQka2V5cyA9IFtdO1xuICB9O1xuXG4gIE9wYWwuaGFzaF9jbG9uZSA9IGZ1bmN0aW9uKGZyb21faGFzaCwgdG9faGFzaCkge1xuICAgIHRvX2hhc2guJCRub25lID0gZnJvbV9oYXNoLiQkbm9uZTtcbiAgICB0b19oYXNoLiQkcHJvYyA9IGZyb21faGFzaC4kJHByb2M7XG5cbiAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IGZyb21faGFzaC4kJGtleXMsIHNtYXAgPSBmcm9tX2hhc2guJCRzbWFwLCBsZW4gPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gc21hcFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICB9XG5cbiAgICAgIE9wYWwuaGFzaF9wdXQodG9faGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaF9wdXQgPSBmdW5jdGlvbihoYXNoLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaWYgKCEkaGFzX293bi5jYWxsKGhhc2guJCRzbWFwLCBrZXkpKSB7XG4gICAgICAgIGhhc2guJCRrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICAgIGhhc2guJCRzbWFwW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIga2V5X2hhc2gsIGJ1Y2tldCwgbGFzdF9idWNrZXQ7XG4gICAga2V5X2hhc2ggPSBoYXNoLiQkYnlfaWRlbnRpdHkgPyBPcGFsLmlkKGtleSkgOiBrZXkuJGhhc2goKTtcblxuICAgIGlmICghJGhhc19vd24uY2FsbChoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgIGJ1Y2tldCA9IHtrZXk6IGtleSwga2V5X2hhc2g6IGtleV9oYXNoLCB2YWx1ZTogdmFsdWV9O1xuICAgICAgaGFzaC4kJGtleXMucHVzaChidWNrZXQpO1xuICAgICAgaGFzaC4kJG1hcFtrZXlfaGFzaF0gPSBidWNrZXQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF07XG5cbiAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICBpZiAoa2V5ID09PSBidWNrZXQua2V5IHx8IGtleVsnJGVxbD8nXShidWNrZXQua2V5KSkge1xuICAgICAgICBsYXN0X2J1Y2tldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnVja2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGFzdF9idWNrZXQgPSBidWNrZXQ7XG4gICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICB9XG5cbiAgICBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgIGJ1Y2tldCA9IHtrZXk6IGtleSwga2V5X2hhc2g6IGtleV9oYXNoLCB2YWx1ZTogdmFsdWV9O1xuICAgICAgaGFzaC4kJGtleXMucHVzaChidWNrZXQpO1xuICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGJ1Y2tldDtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX2dldCA9IGZ1bmN0aW9uKGhhc2gsIGtleSkge1xuICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgIGlmICgkaGFzX293bi5jYWxsKGhhc2guJCRzbWFwLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCwgYnVja2V0O1xuICAgIGtleV9oYXNoID0gaGFzaC4kJGJ5X2lkZW50aXR5ID8gT3BhbC5pZChrZXkpIDoga2V5LiRoYXNoKCk7XG5cbiAgICBpZiAoJGhhc19vd24uY2FsbChoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdO1xuXG4gICAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICAgIGlmIChrZXkgPT09IGJ1Y2tldC5rZXkgfHwga2V5WyckZXFsPyddKGJ1Y2tldC5rZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGJ1Y2tldC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX2RlbGV0ZSA9IGZ1bmN0aW9uKGhhc2gsIGtleSkge1xuICAgIHZhciBpLCBrZXlzID0gaGFzaC4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCB2YWx1ZTtcblxuICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiKSBrZXkgPSBrZXkudmFsdWVPZigpO1xuXG4gICAgICBpZiAoISRoYXNfb3duLmNhbGwoaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGtleXNbaV0gPT09IGtleSkge1xuICAgICAgICAgIGtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gaGFzaC4kJHNtYXBba2V5XTtcbiAgICAgIGRlbGV0ZSBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCA9IGtleS4kaGFzaCgpO1xuXG4gICAgaWYgKCEkaGFzX293bi5jYWxsKGhhc2guJCRtYXAsIGtleV9oYXNoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBidWNrZXQgPSBoYXNoLiQkbWFwW2tleV9oYXNoXSwgbGFzdF9idWNrZXQ7XG5cbiAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICBpZiAoa2V5ID09PSBidWNrZXQua2V5IHx8IGtleVsnJGVxbD8nXShidWNrZXQua2V5KSkge1xuICAgICAgICB2YWx1ZSA9IGJ1Y2tldC52YWx1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoa2V5c1tpXSA9PT0gYnVja2V0KSB7XG4gICAgICAgICAgICBrZXlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0X2J1Y2tldCAmJiBidWNrZXQubmV4dCkge1xuICAgICAgICAgIGxhc3RfYnVja2V0Lm5leHQgPSBidWNrZXQubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXN0X2J1Y2tldCkge1xuICAgICAgICAgIGRlbGV0ZSBsYXN0X2J1Y2tldC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgaGFzaC4kJG1hcFtrZXlfaGFzaF0gPSBidWNrZXQubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgaGFzaC4kJG1hcFtrZXlfaGFzaF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBsYXN0X2J1Y2tldCA9IGJ1Y2tldDtcbiAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2hfcmVoYXNoID0gZnVuY3Rpb24oaGFzaCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBoYXNoLiQka2V5cy5sZW5ndGgsIGtleV9oYXNoLCBidWNrZXQsIGxhc3RfYnVja2V0OyBpIDwgbGVuZ3RoOyBpKyspIHtcblxuICAgICAgaWYgKGhhc2guJCRrZXlzW2ldLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBrZXlfaGFzaCA9IGhhc2guJCRrZXlzW2ldLmtleS4kaGFzaCgpO1xuXG4gICAgICBpZiAoa2V5X2hhc2ggPT09IGhhc2guJCRrZXlzW2ldLmtleV9oYXNoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBidWNrZXQgPSBoYXNoLiQkbWFwW2hhc2guJCRrZXlzW2ldLmtleV9oYXNoXTtcbiAgICAgIGxhc3RfYnVja2V0ID0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICAgIGlmIChidWNrZXQgPT09IGhhc2guJCRrZXlzW2ldKSB7XG4gICAgICAgICAgaWYgKGxhc3RfYnVja2V0ICYmIGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgICBsYXN0X2J1Y2tldC5uZXh0ID0gYnVja2V0Lm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGxhc3RfYnVja2V0KSB7XG4gICAgICAgICAgICBkZWxldGUgbGFzdF9idWNrZXQubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICAgIGhhc2guJCRtYXBbaGFzaC4kJGtleXNbaV0ua2V5X2hhc2hdID0gYnVja2V0Lm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGhhc2guJCRtYXBbaGFzaC4kJGtleXNbaV0ua2V5X2hhc2hdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsYXN0X2J1Y2tldCA9IGJ1Y2tldDtcbiAgICAgICAgYnVja2V0ID0gYnVja2V0Lm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGhhc2guJCRrZXlzW2ldLmtleV9oYXNoID0ga2V5X2hhc2g7XG5cbiAgICAgIGlmICghJGhhc19vd24uY2FsbChoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgICAgaGFzaC4kJG1hcFtrZXlfaGFzaF0gPSBoYXNoLiQka2V5c1tpXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdO1xuICAgICAgbGFzdF9idWNrZXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgICAgaWYgKGJ1Y2tldCA9PT0gaGFzaC4kJGtleXNbaV0pIHtcbiAgICAgICAgICBsYXN0X2J1Y2tldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsYXN0X2J1Y2tldCA9IGJ1Y2tldDtcbiAgICAgICAgYnVja2V0ID0gYnVja2V0Lm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsYXN0X2J1Y2tldCkge1xuICAgICAgICBsYXN0X2J1Y2tldC5uZXh0ID0gaGFzaC4kJGtleXNbaV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmd1bWVudHNfbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncywgaGFzaCwgaSwgbGVuZ3RoLCBrZXksIHZhbHVlO1xuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggPT09IDEgJiYgYXJndW1lbnRzWzBdLiQkaXNfaGFzaCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICB9XG5cbiAgICBoYXNoID0gbmV3IE9wYWwuSGFzaCgpO1xuICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggPT09IDEgJiYgYXJndW1lbnRzWzBdLiQkaXNfYXJyYXkpIHtcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHNbMF07XG4gICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcmdzW2ldLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KFwidmFsdWUgbm90IG9mIGxlbmd0aCAyOiBcIiArIGFyZ3NbaV0uJGluc3BlY3QoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSBhcmdzW2ldWzBdO1xuICAgICAgICB2YWx1ZSA9IGFyZ3NbaV1bMV07XG5cbiAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggPT09IDEpIHtcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHNbMF07XG4gICAgICBmb3IgKGtleSBpbiBhcmdzKSB7XG4gICAgICAgIGlmICgkaGFzX293bi5jYWxsKGFyZ3MsIGtleSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGFyZ3Nba2V5XTtcblxuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcIm9kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoXCIpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHNfbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzW2kgKyAxXTtcblxuICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvLyBBIGZhc3RlciBIYXNoIGNyZWF0b3IgZm9yIGhhc2hlcyB0aGF0IGp1c3QgdXNlIHN5bWJvbHMgYW5kXG4gIC8vIHN0cmluZ3MgYXMga2V5cy4gVGhlIG1hcCBhbmQga2V5cyBhcnJheSBjYW4gYmUgY29uc3RydWN0ZWQgYXRcbiAgLy8gY29tcGlsZSB0aW1lLCBzbyB0aGV5IGFyZSBqdXN0IGFkZGVkIGhlcmUgYnkgdGhlIGNvbnN0cnVjdG9yXG4gIC8vIGZ1bmN0aW9uLlxuICAvL1xuICBPcGFsLmhhc2gyID0gZnVuY3Rpb24oa2V5cywgc21hcCkge1xuICAgIHZhciBoYXNoID0gbmV3IE9wYWwuSGFzaCgpO1xuXG4gICAgaGFzaC4kJHNtYXAgPSBzbWFwO1xuICAgIGhhc2guJCRtYXAgID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoLiQka2V5cyA9IGtleXM7XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBuZXcgcmFuZ2UgaW5zdGFuY2Ugd2l0aCBmaXJzdCBhbmQgbGFzdCB2YWx1ZXMsIGFuZCB3aGV0aGVyIHRoZVxuICAvLyByYW5nZSBleGNsdWRlcyB0aGUgbGFzdCB2YWx1ZS5cbiAgLy9cbiAgT3BhbC5yYW5nZSA9IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCBleGMpIHtcbiAgICB2YXIgcmFuZ2UgICAgICAgICA9IG5ldyBPcGFsLlJhbmdlKCk7XG4gICAgICAgIHJhbmdlLmJlZ2luICAgPSBmaXJzdDtcbiAgICAgICAgcmFuZ2UuZW5kICAgICA9IGxhc3Q7XG4gICAgICAgIHJhbmdlLmV4Y2wgICAgPSBleGM7XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBpdmFyIG5hbWUgZm9yIGEgZ2l2ZW4gbmFtZS5cbiAgLy8gTW9zdGx5IGFkZHMgYSB0cmFpbGluZyAkIHRvIHJlc2VydmVkIG5hbWVzLlxuICAvL1xuICBPcGFsLml2YXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG4gICAgICAgIG5hbWUgPT09IFwiY29uc3RydWN0b3JcIiB8fFxuICAgICAgICBuYW1lID09PSBcImRpc3BsYXlOYW1lXCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJfX2NvdW50X19cIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fbm9TdWNoTWV0aG9kX19cIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fcGFyZW50X19cIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8XG5cbiAgICAgICAgLy8gbWV0aG9kc1xuICAgICAgICBuYW1lID09PSBcImhhc093blByb3BlcnR5XCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJ2YWx1ZU9mXCJcbiAgICAgICApXG4gICAge1xuICAgICAgcmV0dXJuIG5hbWUgKyBcIiRcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcblxuXG4gIC8vIFJlZ2V4cHNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEVzY2FwZSBSZWdleHAgc3BlY2lhbCBjaGFycyBsZXR0aW5nIHRoZSByZXN1bHRpbmcgc3RyaW5nIGJlIHVzZWQgdG8gYnVpbGRcbiAgLy8gYSBuZXcgUmVnZXhwLlxuICAvL1xuICBPcGFsLmVzY2FwZV9yZWdleHAgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLVtcXF1cXC97fSgpKis/Ll4kXFxcXHwgXSkvZywgJ1xcXFwkMScpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxuXS9nLCAnXFxcXG4nKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xccl0vZywgJ1xcXFxyJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXGZdL2csICdcXFxcZicpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx0XS9nLCAnXFxcXHQnKTtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBnbG9iYWwgUmVnZXhwIGZyb20gYSBSZWdFeHAgb2JqZWN0IGFuZCBjYWNoZSB0aGUgcmVzdWx0XG4gIC8vIG9uIHRoZSBvYmplY3QgaXRzZWxmICgkJGcgYXR0cmlidXRlKS5cbiAgLy9cbiAgT3BhbC5nbG9iYWxfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgIGlmIChwYXR0ZXJuLmdsb2JhbCkge1xuICAgICAgcmV0dXJuIHBhdHRlcm47IC8vIFJlZ0V4cCBhbHJlYWR5IGhhcyB0aGUgZ2xvYmFsIGZsYWdcbiAgICB9XG4gICAgaWYgKHBhdHRlcm4uJCRnID09IG51bGwpIHtcbiAgICAgIHBhdHRlcm4uJCRnID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgKHBhdHRlcm4ubXVsdGlsaW5lID8gJ2dtJyA6ICdnJykgKyAocGF0dGVybi5pZ25vcmVDYXNlID8gJ2knIDogJycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0dGVybi4kJGcubGFzdEluZGV4ID0gbnVsbDsgLy8gcmVzZXQgbGFzdEluZGV4IHByb3BlcnR5XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuLiQkZztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBnbG9iYWwgbXVsdGlsaW5lIFJlZ2V4cCBmcm9tIGEgUmVnRXhwIG9iamVjdCBhbmQgY2FjaGUgdGhlIHJlc3VsdFxuICAvLyBvbiB0aGUgb2JqZWN0IGl0c2VsZiAoJCRnbSBvciAkJGcgYXR0cmlidXRlKS5cbiAgLy9cbiAgT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChwYXR0ZXJuLm11bHRpbGluZSkge1xuICAgICAgaWYgKHBhdHRlcm4uZ2xvYmFsKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuOyAvLyBSZWdFeHAgYWxyZWFkeSBoYXMgdGhlIGdsb2JhbCBhbmQgbXVsdGlsaW5lIGZsYWdcbiAgICAgIH1cbiAgICAgIC8vIHdlIGFyZSB1c2luZyB0aGUgJCRnIGF0dHJpYnV0ZSBiZWNhdXNlIHRoZSBSZWdleHAgaXMgYWxyZWFkeSBtdWx0aWxpbmVcbiAgICAgIGlmIChwYXR0ZXJuLiQkZyAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IHBhdHRlcm4uJCRnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGcgPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCAnZ20nICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXR0ZXJuLiQkZ20gIT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGdtO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBwYXR0ZXJuLiQkZ20gPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCAnZ20nICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSk7XG4gICAgfVxuICAgIHJlc3VsdC5sYXN0SW5kZXggPSBudWxsOyAvLyByZXNldCBsYXN0SW5kZXggcHJvcGVydHlcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbWJpbmUgbXVsdGlwbGUgcmVnZXhwIHBhcnRzIHRvZ2V0aGVyXG4gIE9wYWwucmVnZXhwID0gZnVuY3Rpb24ocGFydHMsIGZsYWdzKSB7XG4gICAgdmFyIHBhcnQ7XG4gICAgdmFyIGlnbm9yZUNhc2UgPSB0eXBlb2YgZmxhZ3MgIT09ICd1bmRlZmluZWQnICYmIGZsYWdzICYmIGZsYWdzLmluZGV4T2YoJ2knKSA+PSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKHBhcnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgaWYgKHBhcnQuaWdub3JlQ2FzZSAhPT0gaWdub3JlQ2FzZSlcbiAgICAgICAgICBPcGFsLktlcm5lbC4kd2FybihcbiAgICAgICAgICAgIFwiaWdub3JlIGNhc2UgZG9lc24ndCBtYXRjaCBmb3IgXCIgKyBwYXJ0LnNvdXJjZS4kaW5zcGVjdCgpLFxuICAgICAgICAgICAgT3BhbC5oYXNoKHt1cGxldmVsOiAxfSlcbiAgICAgICAgICApXG5cbiAgICAgICAgcGFydCA9IHBhcnQuc291cmNlO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnQgPT09ICcnKSBwYXJ0ID0gJyg/OicgKyBwYXJ0ICsgJyknO1xuICAgICAgcGFydHNbaV0gPSBwYXJ0O1xuICAgIH1cblxuICAgIGlmIChmbGFncykge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGFydHMuam9pbignJyksIGZsYWdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGFydHMuam9pbignJykpO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXF1aXJlIHN5c3RlbVxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIE9wYWwubW9kdWxlcyAgICAgICAgID0ge307XG4gIE9wYWwubG9hZGVkX2ZlYXR1cmVzID0gWydjb3JlbGliL3J1bnRpbWUnXTtcbiAgT3BhbC5jdXJyZW50X2RpciAgICAgPSAnLic7XG4gIE9wYWwucmVxdWlyZV90YWJsZSAgID0geydjb3JlbGliL3J1bnRpbWUnOiB0cnVlfTtcblxuICBPcGFsLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICB2YXIgcGFydHMsIHBhcnQsIG5ld19wYXJ0cyA9IFtdLCBTRVBBUkFUT1IgPSAnLyc7XG5cbiAgICBpZiAoT3BhbC5jdXJyZW50X2RpciAhPT0gJy4nKSB7XG4gICAgICBwYXRoID0gT3BhbC5jdXJyZW50X2Rpci5yZXBsYWNlKC9cXC8qJC8sICcvJykgKyBwYXRoO1xuICAgIH1cblxuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC5cXC8vLCAnJyk7XG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwuKHJifG9wYWx8anMpJC8sICcnKTtcbiAgICBwYXJ0cyA9IHBhdGguc3BsaXQoU0VQQVJBVE9SKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0ID09PSAnJykgY29udGludWU7XG4gICAgICAocGFydCA9PT0gJy4uJykgPyBuZXdfcGFydHMucG9wKCkgOiBuZXdfcGFydHMucHVzaChwYXJ0KVxuICAgIH1cblxuICAgIHJldHVybiBuZXdfcGFydHMuam9pbihTRVBBUkFUT1IpO1xuICB9O1xuXG4gIE9wYWwubG9hZGVkID0gZnVuY3Rpb24ocGF0aHMpIHtcbiAgICB2YXIgaSwgbCwgcGF0aDtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBwYXRocy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoc1tpXSk7XG5cbiAgICAgIGlmIChPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIE9wYWwubG9hZGVkX2ZlYXR1cmVzLnB1c2gocGF0aCk7XG4gICAgICBPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0gPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBPcGFsLmxvYWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgcGF0aCA9IE9wYWwubm9ybWFsaXplKHBhdGgpO1xuXG4gICAgT3BhbC5sb2FkZWQoW3BhdGhdKTtcblxuICAgIHZhciBtb2R1bGUgPSBPcGFsLm1vZHVsZXNbcGF0aF07XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICBtb2R1bGUoT3BhbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNldmVyaXR5ID0gT3BhbC5jb25maWcubWlzc2luZ19yZXF1aXJlX3NldmVyaXR5O1xuICAgICAgdmFyIG1lc3NhZ2UgID0gJ2Nhbm5vdCBsb2FkIHN1Y2ggZmlsZSAtLSAnICsgcGF0aDtcblxuICAgICAgaWYgKHNldmVyaXR5ID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgaWYgKE9wYWwuTG9hZEVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgT3BhbC5Mb2FkRXJyb3IuJG5ldyhtZXNzYWdlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG1lc3NhZ2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2V2ZXJpdHkgPT09IFwid2FybmluZ1wiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogTG9hZEVycm9yOiAnICsgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgT3BhbC5yZXF1aXJlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcblxuICAgIGlmIChPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5sb2FkKHBhdGgpO1xuICB9O1xuXG5cbiAgLy8gU3RyaW5nc1xuICAvLyAtLS0tLS0tXG5cbiAgT3BhbC5lbmNvZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIFNldHMgdGhlIGVuY29kaW5nIG9uIGEgc3RyaW5nLCB3aWxsIHRyZWF0IHN0cmluZyBsaXRlcmFscyBhcyBmcm96ZW4gc3RyaW5nc1xuICAvLyByYWlzaW5nIGEgRnJvemVuRXJyb3IuXG4gIC8vXG4gIC8vIEBwYXJhbSBzdHIgW1N0cmluZ10gdGhlIHN0cmluZyBvbiB3aGljaCB0aGUgZW5jb2Rpbmcgc2hvdWxkIGJlIHNldFxuICAvLyBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgY2Fub25pY2FsIG5hbWUgb2YgdGhlIGVuY29kaW5nXG4gIC8vIEBwYXJhbSB0eXBlIFtTdHJpbmddIHBvc3NpYmxlIHZhbHVlcyBhcmUgZWl0aGVyIGBcImVuY29kaW5nXCJgLCBgXCJpbnRlcm5hbF9lbmNvZGluZ1wiYCwgb3IgYHVuZGVmaW5lZFxuICBPcGFsLnNldF9lbmNvZGluZyA9IGZ1bmN0aW9uKHN0ciwgbmFtZSwgdHlwZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJ1bmRlZmluZWRcIikgdHlwZSA9IFwiZW5jb2RpbmdcIjtcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyLiQkZnJvemVuID09PSB0cnVlKVxuICAgICAgdGhyb3cgT3BhbC5Gcm96ZW5FcnJvci4kbmV3KFwiY2FuJ3QgbW9kaWZ5IGZyb3plbiBTdHJpbmdcIik7XG5cbiAgICB2YXIgZW5jb2RpbmcgPSBPcGFsLmZpbmRfZW5jb2RpbmcobmFtZSk7XG5cbiAgICBpZiAoZW5jb2RpbmcgPT09IHN0clt0eXBlXSkgeyByZXR1cm4gc3RyOyB9XG5cbiAgICBzdHJbdHlwZV0gPSBlbmNvZGluZztcblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLy8gRmV0Y2hlcyB0aGUgZW5jb2RpbmcgZm9yIHRoZSBnaXZlbiBuYW1lIG9yIHJhaXNlcyBBcmd1bWVudEVycm9yLlxuICBPcGFsLmZpbmRfZW5jb2RpbmcgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHJlZ2lzdGVyID0gT3BhbC5lbmNvZGluZ3M7XG4gICAgdmFyIGVuY29kaW5nID0gcmVnaXN0ZXJbbmFtZV0gfHwgcmVnaXN0ZXJbbmFtZS50b1VwcGVyQ2FzZSgpXTtcbiAgICBpZiAoIWVuY29kaW5nKSB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcInVua25vd24gZW5jb2RpbmcgbmFtZSAtIFwiICsgbmFtZSk7XG4gICAgcmV0dXJuIGVuY29kaW5nO1xuICB9XG5cbiAgLy8gQHJldHVybnMgYSBTdHJpbmcgb2JqZWN0IHdpdGggdGhlIGVuY29kaW5nIHNldCBmcm9tIGEgc3RyaW5nIGxpdGVyYWxcbiAgT3BhbC5lbmMgPSBmdW5jdGlvbihzdHIsIG5hbWUpIHtcbiAgICB2YXIgZHVwID0gbmV3IFN0cmluZyhzdHIpO1xuICAgIGR1cCA9IE9wYWwuc2V0X2VuY29kaW5nKGR1cCwgbmFtZSk7XG4gICAgZHVwLmludGVybmFsX2VuY29kaW5nID0gZHVwLmVuY29kaW5nO1xuICAgIHJldHVybiBkdXBcbiAgfVxuXG4gIC8vIEByZXR1cm5zIGEgU3RyaW5nIG9iamVjdCB3aXRoIHRoZSBpbnRlcm5hbCBlbmNvZGluZyBzZXQgdG8gQmluYXJ5XG4gIE9wYWwuYmluYXJ5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIGR1cCA9IG5ldyBTdHJpbmcoc3RyKTtcbiAgICByZXR1cm4gT3BhbC5zZXRfZW5jb2RpbmcoZHVwLCBcImJpbmFyeVwiLCBcImludGVybmFsX2VuY29kaW5nXCIpO1xuICB9XG5cblxuICAvLyBJbml0aWFsaXphdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiAkQmFzaWNPYmplY3QoKSB7fVxuICBmdW5jdGlvbiAkT2JqZWN0KCkge31cbiAgZnVuY3Rpb24gJE1vZHVsZSgpIHt9XG4gIGZ1bmN0aW9uICRDbGFzcygpIHt9XG5cbiAgT3BhbC5CYXNpY09iamVjdCA9IEJhc2ljT2JqZWN0ID0gT3BhbC5hbGxvY2F0ZV9jbGFzcygnQmFzaWNPYmplY3QnLCBudWxsLCAkQmFzaWNPYmplY3QpO1xuICBPcGFsLk9iamVjdCAgICAgID0gX09iamVjdCAgICAgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKCdPYmplY3QnLCBPcGFsLkJhc2ljT2JqZWN0LCAkT2JqZWN0KTtcbiAgT3BhbC5Nb2R1bGUgICAgICA9IE1vZHVsZSAgICAgID0gT3BhbC5hbGxvY2F0ZV9jbGFzcygnTW9kdWxlJywgT3BhbC5PYmplY3QsICRNb2R1bGUpO1xuICBPcGFsLkNsYXNzICAgICAgID0gQ2xhc3MgICAgICAgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKCdDbGFzcycsIE9wYWwuTW9kdWxlLCAkQ2xhc3MpO1xuXG4gICRzZXRfcHJvdG8oT3BhbC5CYXNpY09iamVjdCwgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XG4gICRzZXRfcHJvdG8oT3BhbC5PYmplY3QsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuICAkc2V0X3Byb3RvKE9wYWwuTW9kdWxlLCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcbiAgJHNldF9wcm90byhPcGFsLkNsYXNzLCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcblxuICAvLyBCYXNpY09iamVjdCBjYW4gcmVhY2ggaXRzZWxmLCBhdm9pZCBjb25zdF9zZXQgdG8gc2tpcCB0aGUgJCRiYXNlX21vZHVsZSBsb2dpY1xuICBCYXNpY09iamVjdC4kJGNvbnN0W1wiQmFzaWNPYmplY3RcIl0gPSBCYXNpY09iamVjdDtcblxuICAvLyBBc3NpZ24gYmFzaWMgY29uc3RhbnRzXG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsIFwiQmFzaWNPYmplY3RcIiwgIEJhc2ljT2JqZWN0KTtcbiAgT3BhbC5jb25zdF9zZXQoX09iamVjdCwgXCJPYmplY3RcIiwgICAgICAgX09iamVjdCk7XG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsIFwiTW9kdWxlXCIsICAgICAgIE1vZHVsZSk7XG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsIFwiQ2xhc3NcIiwgICAgICAgIENsYXNzKTtcblxuICAvLyBGaXggYm9vdGVkIGNsYXNzZXMgdG8gaGF2ZSBjb3JyZWN0IC5jbGFzcyB2YWx1ZVxuICBCYXNpY09iamVjdC4kJGNsYXNzID0gQ2xhc3M7XG4gIF9PYmplY3QuJCRjbGFzcyAgICAgPSBDbGFzcztcbiAgTW9kdWxlLiQkY2xhc3MgICAgICA9IENsYXNzO1xuICBDbGFzcy4kJGNsYXNzICAgICAgID0gQ2xhc3M7XG5cbiAgLy8gRm9yd2FyZCAudG9TdHJpbmcoKSB0byAjdG9fc1xuICAkZGVmaW5lUHJvcGVydHkoX09iamVjdC4kJHByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvX3MgPSB0aGlzLiR0b19zKCk7XG4gICAgaWYgKHRvX3MuJCRpc19zdHJpbmcgJiYgdHlwZW9mKHRvX3MpID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gYSBzdHJpbmcgY3JlYXRlZCB1c2luZyBuZXcgU3RyaW5nKCdzdHJpbmcnKVxuICAgICAgcmV0dXJuIHRvX3MudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdG9fcztcbiAgICB9XG4gIH0pO1xuXG4gIC8vIE1ha2UgS2VybmVsI3JlcXVpcmUgaW1tZWRpYXRlbHkgYXZhaWxhYmxlIGFzIGl0J3MgbmVlZGVkIHRvIHJlcXVpcmUgYWxsIHRoZVxuICAvLyBvdGhlciBjb3JlbGliIGZpbGVzLlxuICAkZGVmaW5lUHJvcGVydHkoX09iamVjdC4kJHByb3RvdHlwZSwgJyRyZXF1aXJlJywgT3BhbC5yZXF1aXJlKTtcblxuICAvLyBJbnN0YW50aWF0ZSB0aGUgbWFpbiBvYmplY3RcbiAgT3BhbC50b3AgPSBuZXcgX09iamVjdCgpO1xuICBPcGFsLnRvcC4kdG9fcyA9IE9wYWwudG9wLiRpbnNwZWN0ID0gZnVuY3Rpb24oKSB7IHJldHVybiAnbWFpbicgfTtcbiAgT3BhbC50b3AuJGRlZmluZV9tZXRob2QgPSB0b3BfZGVmaW5lX21ldGhvZDtcblxuICAvLyBGb3dhcmQgY2FsbHMgdG8gZGVmaW5lX21ldGhvZCBvbiB0aGUgdG9wIG9iamVjdCB0byBPYmplY3RcbiAgZnVuY3Rpb24gdG9wX2RlZmluZV9tZXRob2QoKSB7XG4gICAgdmFyIGFyZ3MgPSBPcGFsLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICB2YXIgYmxvY2sgPSB0b3BfZGVmaW5lX21ldGhvZC4kJHA7XG4gICAgdG9wX2RlZmluZV9tZXRob2QuJCRwID0gbnVsbDtcbiAgICByZXR1cm4gT3BhbC5zZW5kKF9PYmplY3QsICdkZWZpbmVfbWV0aG9kJywgYXJncywgYmxvY2spXG4gIH07XG5cblxuICAvLyBOaWxcbiAgZnVuY3Rpb24gJE5pbENsYXNzKCkge31cbiAgT3BhbC5OaWxDbGFzcyA9IE9wYWwuYWxsb2NhdGVfY2xhc3MoJ05pbENsYXNzJywgT3BhbC5PYmplY3QsICROaWxDbGFzcyk7XG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsICdOaWxDbGFzcycsIE9wYWwuTmlsQ2xhc3MpO1xuICBuaWwgPSBPcGFsLm5pbCA9IG5ldyBPcGFsLk5pbENsYXNzKCk7XG4gIG5pbC4kJGlkID0gbmlsX2lkO1xuICBuaWwuY2FsbCA9IG5pbC5hcHBseSA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBPcGFsLkxvY2FsSnVtcEVycm9yLiRuZXcoJ25vIGJsb2NrIGdpdmVuJyk7IH07XG5cbiAgLy8gRXJyb3JzXG4gIE9wYWwuYnJlYWtlciAgPSBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgYnJlYWsgKG9sZCknKTtcbiAgT3BhbC5yZXR1cm5lciA9IG5ldyBFcnJvcigndW5leHBlY3RlZCByZXR1cm4nKTtcbiAgVHlwZUVycm9yLiQkc3VwZXIgPSBFcnJvcjtcbn0pLmNhbGwodGhpcyk7XG5PcGFsLmxvYWRlZChbXCJjb3JlbGliL3J1bnRpbWUuanNcIl0pOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGO0FBQ0U7QUFDRjtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDQTtBQUNBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJO0FBQ0E7O0FBRUo7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTs7QUFFRjtBQUNFOztBQUVGO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0k7QUFDQTtBQUNBOztBQUVKO0FBQ0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVKO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDSTs7QUFFSjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7O0FBR0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVFO0FBQ0U7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNKO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNKO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0k7QUFDQTtBQUNBOztBQUVKO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNFOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Q7QUFDSDtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ1U7QUFDQTtBQUNBO0FBQ0E7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFRjtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDQSJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjAxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9oZWxwZXJzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHlwZV9lcnJvciwgY29lcmNlX3RvXG5cbm1vZHVsZSBPcGFsXG4gIGRlZiBzZWxmLmJyaWRnZShjb25zdHJ1Y3Rvciwga2xhc3MpXG4gICAgYE9wYWwuYnJpZGdlKGNvbnN0cnVjdG9yLCBrbGFzcylgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvZXJjZV90byEob2JqZWN0LCB0eXBlLCBtZXRob2QsICphcmdzKVxuICAgIGNvZXJjZWQgPSBgJGNvZXJjZV90byhvYmplY3QsIHR5cGUsIG1ldGhvZCwgYXJncylgXG5cbiAgICB1bmxlc3MgdHlwZSA9PT0gY29lcmNlZFxuICAgICAgcmFpc2UgYCR0eXBlX2Vycm9yKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBjb2VyY2VkKWBcbiAgICBlbmRcblxuICAgIGNvZXJjZWRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29lcmNlX3RvPyhvYmplY3QsIHR5cGUsIG1ldGhvZCwgKmFyZ3MpXG4gICAgcmV0dXJuIHVubGVzcyBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG5cbiAgICBjb2VyY2VkID0gYCRjb2VyY2VfdG8ob2JqZWN0LCB0eXBlLCBtZXRob2QsIGFyZ3MpYFxuXG4gICAgcmV0dXJuIGlmIGNvZXJjZWQubmlsP1xuXG4gICAgdW5sZXNzIHR5cGUgPT09IGNvZXJjZWRcbiAgICAgIHJhaXNlIGAkdHlwZV9lcnJvcihvYmplY3QsIHR5cGUsIG1ldGhvZCwgY29lcmNlZClgXG4gICAgZW5kXG5cbiAgICBjb2VyY2VkXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iamVjdCwgdHlwZSwgbWV0aG9kKVxuICAgIHJldHVybiBvYmplY3QgaWYgdHlwZSA9PT0gb2JqZWN0XG5cbiAgICBpZiBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG4gICAgICBvYmplY3QuX19zZW5kX18gbWV0aG9kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbXBhcmUoYSwgYilcbiAgICBjb21wYXJlID0gYSA8PT4gYlxuXG4gICAgaWYgYGNvbXBhcmUgPT09IG5pbGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje2EuY2xhc3N9IHdpdGggI3tiLmNsYXNzfSBmYWlsZWRcIlxuICAgIGVuZFxuXG4gICAgY29tcGFyZVxuICBlbmRcblxuICBkZWYgc2VsZi5kZXN0cnVjdHVyZShhcmdzKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmdzLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3NfYXJ5Lmxlbmd0aDsgaSA8IGw7IGkrKykgeyBhcmdzX2FyeVtpXSA9IGFyZ3NbaV07IH1cblxuICAgICAgICByZXR1cm4gYXJnc19hcnk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5yZXNwb25kX3RvPyhvYmosIG1ldGhvZCwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICAleHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCB8fCAhb2JqLiQkY2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9iai5yZXNwb25kX3RvPyhtZXRob2QsIGluY2x1ZGVfYWxsKVxuICBlbmRcblxuICBkZWYgc2VsZi5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmNvZXJjZV90byEobmFtZSwgU3RyaW5nLCA6dG9fc3RyKVxuXG4gICAgdW5sZXNzIGAvXkBbYS16QS1aX11bYS16QS1aMC05X10qPyQvLnRlc3QobmFtZSlgXG4gICAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwiJyN7bmFtZX0nIGlzIG5vdCBhbGxvd2VkIGFzIGFuIGluc3RhbmNlIHZhcmlhYmxlIG5hbWVcIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIG5hbWVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcbiAgICBuYW1lID0gT3BhbC5jb2VyY2VfdG8hKG5hbWUsIFN0cmluZywgOnRvX3N0cilcblxuICAgIGlmIGBuYW1lLmxlbmd0aCA8IDMgfHwgbmFtZS5zbGljZSgwLDIpICE9PSAnQEAnYFxuICAgICAgcmFpc2UgTmFtZUVycm9yLm5ldyhcImAje25hbWV9JyBpcyBub3QgYWxsb3dlZCBhcyBhIGNsYXNzIHZhcmlhYmxlIG5hbWVcIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIG5hbWVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29uc3RfbmFtZSEoY29uc3RfbmFtZSlcbiAgICBjb25zdF9uYW1lID0gT3BhbC5jb2VyY2VfdG8hKGNvbnN0X25hbWUsIFN0cmluZywgOnRvX3N0cilcblxuICAgIGlmIGNvbnN0X25hbWVbMF0gIT0gY29uc3RfbmFtZVswXS51cGNhc2VcbiAgICAgIHJhaXNlIE5hbWVFcnJvciwgXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7Y29uc3RfbmFtZX1cIlxuICAgIGVuZFxuXG4gICAgY29uc3RfbmFtZVxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gICMgTWFyayBzb21lIG1ldGhvZHMgYXMgcHJpc3RpbmUgaW4gb3JkZXIgdG8gYXBwbHkgb3B0aW1pemF0aW9ucyB3aGVuIHRoZXlcbiAgIyBhcmUgc3RpbGwgaW4gdGhlaXIgb3JpZ2luYWwgZm9ybS4gVGhpcyBjb3VsZCBwcm9iYWJseSBiZSBtb3ZlZCB0b1xuICAjIHRoZSBgT3BhbC5kZWYoKWAgSlMgQVBJLCBidXQgZm9yIG5vdyBpdCB3aWxsIHN0YXkgbWFudWFsLlxuICAjXG4gICMgQGV4YW1wbGVcbiAgI1xuICAjICAgT3BhbC5wcmlzdGluZSBBcnJheSwgOmFsbG9jYXRlLCA6Y29weV9pbnN0YW5jZV92YXJpYWJsZXMsIDppbml0aWFsaXplX2R1cFxuICAjXG4gICMgICBjbGFzcyBBcnJheVxuICAjICAgICBkZWYgZHVwXG4gICMgICAgICAgJXh7XG4gICMgICAgICAgICBpZiAoXG4gICMgICAgICAgICAgIHNlbGYuJGFsbG9jYXRlLiQkcHJpc3RpbmUgJiZcbiAgIyAgICAgICAgICAgc2VsZi4kY29weV9pbnN0YW5jZV92YXJpYWJsZXMuJCRwcmlzdGluZSAmJlxuICAjICAgICAgICAgICBzZWxmLiRpbml0aWFsaXplX2R1cC4kJHByaXN0aW5lXG4gICMgICAgICAgICApIHJldHVybiBzZWxmLnNsaWNlKDApO1xuICAjICAgICAgIH1cbiAgI1xuICAjICAgICAgIHN1cGVyXG4gICMgICAgIGVuZFxuICAjICAgZW5kXG4gICNcbiAgIyBAcGFyYW0gb3duZXJfY2xhc3MgW0NsYXNzXSB0aGUgY2xhc3Mgb3duaW5nIHRoZSBtZXRob2RzXG4gICMgQHBhcmFtIG1ldGhvZF9uYW1lcyBbQXJyYXk8U3ltYm9sPl0gdGhlIGxpc3Qgb2YgbWV0aG9kcyBuYW1lcyB0byBtYXJrXG4gICMgQHJldHVybiBbbmlsXVxuICBkZWYgc2VsZi5wcmlzdGluZShvd25lcl9jbGFzcywgKm1ldGhvZF9uYW1lcylcbiAgICAleHtcbiAgICAgIHZhciBtZXRob2RfbmFtZSwgbWV0aG9kO1xuICAgICAgZm9yICh2YXIgaSA9IG1ldGhvZF9uYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBtZXRob2RfbmFtZSA9IG1ldGhvZF9uYW1lc1tpXTtcbiAgICAgICAgbWV0aG9kID0gb3duZXJfY2xhc3MuJCRwcm90b3R5cGVbJyQnK21ldGhvZF9uYW1lXTtcblxuICAgICAgICBpZiAobWV0aG9kICYmICFtZXRob2QuJCRzdHViKSB7XG4gICAgICAgICAgbWV0aG9kLiQkcHJpc3RpbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5pbFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImJyaWRnZSIsInNlbGYiLCJjb2VyY2VfdG8hIiwiY29lcmNlZCIsInR5cGUiLCI9PT0iLCJyYWlzZSIsImNvZXJjZV90bz8iLCJvYmplY3QiLCJyZXNwb25kX3RvPyIsIm1ldGhvZCIsIm5pbD8iLCJ0cnlfY29udmVydCIsIl9fc2VuZF9fIiwiY29tcGFyZSIsImEiLCI8PT4iLCJiIiwiY2xhc3MiLCJkZXN0cnVjdHVyZSIsIm9iaiIsImluY2x1ZGVfYWxsIiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJuYW1lIiwibmV3IiwiY2xhc3NfdmFyaWFibGVfbmFtZSEiLCJjb25zdF9uYW1lISIsImNvbnN0X25hbWUiLCJbXSIsIjAiLCIhPSIsInVwY2FzZSIsInByaXN0aW5lIl0sIm1hcHBpbmdzIjoiOzs7OztFQUVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFBQyxVQUFJQyxJQUFKRCxhQUFBQSxpQkFBQUEsa0JBQWdCLFdBQUQsRUFBYyxLQUE3QkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQywrQkFBRDtBQURGQSxJQUFBQSxDQUFBQSw0QkFBQUEsQ0FBQTtBQUFBLElBSUFFLFVBQUlELElBQUpDLGlCQUFBQSx5QkFBQUEsU0FBb0IsTUFBRCxFQUFTLElBQVQsRUFBZSxNQUFmLEVBUnJCLEVBUUVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQVJGO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBUTRDLE1BQUEsa0JBUjVDO0FBQUEsTUFTSUMsVUFBVyxzQ0FUZjtBQUFBLE1BV0ksSUFBQSxRQUFPQyxJQUFBQyxRQUFBQSxDQUFTRixPQUFURSxDQUFQLENBQUE7QUFBQSxNQUFBO0FBQUEsWUFDRUMsT0FBQUEsQ0FBTywwQ0FBUEE7QUFERixNQUFBLENBWEo7QUFBQSxNQWVJLE9BQUFILE9BZko7QUFRRUQsSUFBQUEsQ0FBQUEscUNBQUFBLENBSkE7QUFBQSxJQWNBSyxVQUFJTixJQUFKTSxpQkFBQUEseUJBQUFBLFNBQW9CLE1BQUQsRUFBUyxJQUFULEVBQWUsTUFBZixFQWxCckIsRUFrQkVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQWxCRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQWtCNEMsTUFBQSxrQkFsQjVDO0FBQUEsTUFtQkksSUFBQSxRQUFjQyxNQUFBQyxnQkFBQUEsQ0FBbUJDLE1BQW5CRCxDQUFkLENB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SkE7QUFBQSxNQWlKSSxPQUFBLEdBakpKO0FBcUlFQSxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FBQUEsb0JBaklBO0FBREZqQyxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3NjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL21vZHVsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgY29lcmNlX3RvXG5cbmNsYXNzIE1vZHVsZVxuICBkZWYgc2VsZi5hbGxvY2F0ZVxuICAgICV4e1xuICAgICAgdmFyIG1vZHVsZSA9IE9wYWwuYWxsb2NhdGVfbW9kdWxlKG5pbCwgZnVuY3Rpb24oKXt9KTtcbiAgICAgIC8vIExpbmsgdGhlIHByb3RvdHlwZSBvZiBNb2R1bGUgc3ViY2xhc3Nlc1xuICAgICAgaWYgKHNlbGYgIT09IE9wYWwuTW9kdWxlKSBPYmplY3Quc2V0UHJvdG90eXBlT2YobW9kdWxlLCBzZWxmLiQkcHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgmYmxvY2spXG4gICAgbW9kdWxlX2V2YWwoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cbiAgZW5kXG5cbiAgZGVmID09PShvYmplY3QpXG4gICAgcmV0dXJuIGZhbHNlIGlmIGBvYmplY3QgPT0gbnVsbGBcblxuICAgIGBPcGFsLmlzX2Eob2JqZWN0LCBzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgdW5sZXNzIE1vZHVsZSA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ2NvbXBhcmVkIHdpdGggbm9uIGNsYXNzL21vZHVsZSdcbiAgICBlbmRcblxuICAgICMgY2xhc3MgY2Fubm90IGJlIGEgZGVzY2VuZGFudCBvZiBpdHNlbGZcbiAgICAleHtcbiAgICAgIHZhciB3b3JraW5nID0gc2VsZixcbiAgICAgICAgICBhbmNlc3RvcnMsXG4gICAgICAgICAgaSwgbGVuZ3RoO1xuXG4gICAgICBpZiAod29ya2luZyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhzZWxmKSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhbmNlc3RvcnNbaV0gPT09IG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMob3RoZXIpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yc1tpXSA9PT0gc2VsZikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIGVxdWFsPyhvdGhlcikgfHwgc2VsZiA8IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA+KG90aGVyKVxuICAgIHVubGVzcyBNb2R1bGUgPT09IG90aGVyXG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdjb21wYXJlZCB3aXRoIG5vbiBjbGFzcy9tb2R1bGUnXG4gICAgZW5kXG5cbiAgICBvdGhlciA8IHNlbGZcbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgIGVxdWFsPyhvdGhlcikgfHwgc2VsZiA+IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIE1vZHVsZSA9PT0gb3RoZXJcbiAgICAgIHJldHVybiBuaWxcbiAgICBlbmRcblxuICAgIGx0ID0gc2VsZiA8IG90aGVyXG4gICAgcmV0dXJuIG5pbCBpZiBsdC5uaWw/XG4gICAgbHQgPyAtMSA6IDFcbiAgZW5kXG5cbiAgZGVmIGFsaWFzX21ldGhvZChuZXduYW1lLCBvbGRuYW1lKVxuICAgIG5ld25hbWUgPSBgJGNvZXJjZV90byhuZXduYW1lLCAje1N0cmluZ30sICd0b19zdHInKWBcbiAgICBvbGRuYW1lID0gYCRjb2VyY2VfdG8ob2xkbmFtZSwgI3tTdHJpbmd9LCAndG9fc3RyJylgXG4gICAgYE9wYWwuYWxpYXMoc2VsZiwgbmV3bmFtZSwgb2xkbmFtZSlgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhbGlhc19uYXRpdmUobWlkLCBqc2lkID0gbWlkKVxuICAgIGBPcGFsLmFsaWFzX25hdGl2ZShzZWxmLCBtaWQsIGpzaWQpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYW5jZXN0b3JzXG4gICAgYE9wYWwuYW5jZXN0b3JzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgYXBwZW5kX2ZlYXR1cmVzKGluY2x1ZGVyKVxuICAgIGBPcGFsLmFwcGVuZF9mZWF0dXJlcyhzZWxmLCBpbmNsdWRlcilgXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYXR0cl9hY2Nlc3NvcigqbmFtZXMpXG4gICAgYXR0cl9yZWFkZXIoKm5hbWVzKVxuICAgIGF0dHJfd3JpdGVyKCpuYW1lcylcbiAgZW5kXG5cbiAgZGVmIGF0dHIoKmFyZ3MpXG4gICAgJXh7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT0gMiAmJiAoYXJnc1sxXSA9PT0gdHJ1ZSB8fCBhcmdzWzFdID09PSBmYWxzZSkpIHtcbiAgICAgICAgI3t3YXJuICdvcHRpb25hbCBib29sZWFuIGFyZ3VtZW50IGlzIG9ic29sZXRlZCcsIHVwbGV2ZWw6IDF9XG5cbiAgICAgICAgYXJnc1sxXSA/ICN7YXR0cl9hY2Nlc3NvcihgYXJnc1swXWApfSA6ICN7YXR0cl9yZWFkZXIoYGFyZ3NbMF1gKX07XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cl9yZWFkZXIoKmFyZ3MpXG4gIGVuZFxuXG4gIGRlZiBhdHRyX3JlYWRlcigqbmFtZXMpXG4gICAgJXh7XG4gICAgICB2YXIgcHJvdG8gPSBzZWxmLiQkcHJvdG90eXBlO1xuXG4gICAgICBmb3IgKHZhciBpID0gbmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXSxcbiAgICAgICAgICAgIGlkICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICAgICAgaXZhciA9IE9wYWwuaXZhcihuYW1lKTtcblxuICAgICAgICAvLyB0aGUgY2xvc3VyZSBoZXJlIGlzIG5lZWRlZCBiZWNhdXNlIG5hbWUgd2lsbCBjaGFuZ2UgYXQgdGhlIG5leHRcbiAgICAgICAgLy8gY3ljbGUsIEkgd2lzaCB3ZSBjb3VsZCB1c2UgbGV0LlxuICAgICAgICB2YXIgYm9keSA9IChmdW5jdGlvbihpdmFyKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbaXZhcl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzW2l2YXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pKGl2YXIpO1xuXG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGluc3RhbmNlIHZhcmlhYmxlIGFzIG5pbFxuICAgICAgICBPcGFsLmRlZmluZVByb3BlcnR5KHByb3RvLCBpdmFyLCBuaWwpO1xuXG4gICAgICAgIGJvZHkuJCRwYXJhbWV0ZXJzID0gW107XG4gICAgICAgIGJvZHkuJCRhcml0eSA9IDA7XG5cbiAgICAgICAgT3BhbC5kZWZuKHNlbGYsIGlkLCBib2R5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGF0dHJfd3JpdGVyKCpuYW1lcylcbiAgICAleHtcbiAgICAgIHZhciBwcm90byA9IHNlbGYuJCRwcm90b3R5cGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSBuYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldLFxuICAgICAgICAgICAgaWQgICA9ICckJyArIG5hbWUgKyAnPScsXG4gICAgICAgICAgICBpdmFyID0gT3BhbC5pdmFyKG5hbWUpO1xuXG4gICAgICAgIC8vIHRoZSBjbG9zdXJlIGhlcmUgaXMgbmVlZGVkIGJlY2F1c2UgbmFtZSB3aWxsIGNoYW5nZSBhdCB0aGUgbmV4dFxuICAgICAgICAvLyBjeWNsZSwgSSB3aXNoIHdlIGNvdWxkIHVzZSBsZXQuXG4gICAgICAgIHZhciBib2R5ID0gKGZ1bmN0aW9uKGl2YXIpe1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbaXZhcl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKGl2YXIpO1xuXG4gICAgICAgIGJvZHkuJCRwYXJhbWV0ZXJzID0gW1sncmVxJ11dO1xuICAgICAgICBib2R5LiQkYXJpdHkgPSAxO1xuXG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGluc3RhbmNlIHZhcmlhYmxlIGFzIG5pbFxuICAgICAgICBPcGFsLmRlZmluZVByb3BlcnR5KHByb3RvLCBpdmFyLCBuaWwpO1xuXG4gICAgICAgIE9wYWwuZGVmbihzZWxmLCBpZCwgYm9keSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBhdXRvbG9hZChjb25zdCwgcGF0aClcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkYXV0b2xvYWQgPT0gbnVsbCkgc2VsZi4kJGF1dG9sb2FkID0ge307XG4gICAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcbiAgICAgIHNlbGYuJCRhdXRvbG9hZFsje2NvbnN0fV0gPSAje3BhdGh9O1xuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZXNcbiAgICBgT2JqZWN0LmtleXMoT3BhbC5jbGFzc192YXJpYWJsZXMoc2VsZikpYFxuICBlbmRcblxuICBkZWYgY2xhc3NfdmFyaWFibGVfZ2V0KG5hbWUpXG4gICAgbmFtZSA9IE9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmNsYXNzX3ZhcmlhYmxlX2dldChzZWxmLCBuYW1lLCBmYWxzZSlgXG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9zZXQobmFtZSwgdmFsdWUpXG4gICAgbmFtZSA9IE9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldChzZWxmLCBuYW1lLCB2YWx1ZSlgXG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9kZWZpbmVkPyhuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgT3BhbC5jbGFzc192YXJpYWJsZXMoc2VsZikuaGFzT3duUHJvcGVydHkobmFtZSlgXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfY2xhc3NfdmFyaWFibGUobmFtZSlcbiAgICBuYW1lID0gT3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICBpZiAoT3BhbC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGYuJCRjdmFycywgbmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc2VsZi4kJGN2YXJzW25hbWVdO1xuICAgICAgICBkZWxldGUgc2VsZi4kJGN2YXJzW25hbWVdO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAje3JhaXNlIE5hbWVFcnJvciwgXCJjYW5ub3QgcmVtb3ZlICN7bmFtZX0gZm9yICN7c2VsZn1cIn1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25zdGFudHMoaW5oZXJpdCA9IHRydWUpXG4gICAgYE9wYWwuY29uc3RhbnRzKHNlbGYsIGluaGVyaXQpYFxuICBlbmRcblxuICBkZWYgc2VsZi5jb25zdGFudHMoaW5oZXJpdCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChpbmhlcml0ID09IG51bGwpIHtcbiAgICAgICAgdmFyIG5lc3RpbmcgPSAoc2VsZi4kJG5lc3RpbmcgfHwgW10pLmNvbmNhdChPcGFsLk9iamVjdCksXG4gICAgICAgICAgICBjb25zdGFudCwgY29uc3RhbnRzID0ge30sXG4gICAgICAgICAgICBpLCBpaTtcblxuICAgICAgICBmb3IoaSA9IDAsIGlpID0gbmVzdGluZy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgZm9yIChjb25zdGFudCBpbiBuZXN0aW5nW2ldLiQkY29uc3QpIHtcbiAgICAgICAgICAgIGNvbnN0YW50c1tjb25zdGFudF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoY29uc3RhbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLmNvbnN0YW50cyhzZWxmLCBpbmhlcml0KVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYubmVzdGluZ1xuICAgIGBzZWxmLiQkbmVzdGluZyB8fCBbXWBcbiAgZW5kXG5cbiAgIyBjaGVjayBmb3IgY29uc3RhbnQgd2l0aGluIGN1cnJlbnQgc2NvcGVcbiAgIyBpZiBpbmhlcml0IGlzIHRydWUgb3Igc2VsZiBpcyBPYmplY3QsIHdpbGwgYWxzbyBjaGVjayBhbmNlc3RvcnNcbiAgZGVmIGNvbnN0X2RlZmluZWQ/KG5hbWUsIGluaGVyaXQgPSB0cnVlKVxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwid3JvbmcgY29uc3RhbnQgbmFtZSAje25hbWV9XCIsIG5hbWUpIHVubGVzcyBuYW1lID1+IE9wYWw6OkNPTlNUX05BTUVfUkVHRVhQXG5cbiAgICAleHtcbiAgICAgIHZhciBtb2R1bGUsIG1vZHVsZXMgPSBbc2VsZl0sIG1vZHVsZV9jb25zdGFudHMsIGksIGlpO1xuXG4gICAgICAvLyBBZGQgdXAgYW5jZXN0b3JzIGlmIGluaGVyaXQgaXMgdHJ1ZVxuICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KE9wYWwuYW5jZXN0b3JzKHNlbGYpKTtcblxuICAgICAgICAvLyBBZGQgT2JqZWN0J3MgYW5jZXN0b3JzIGlmIGl0J3MgYSBtb2R1bGUg4oCTIG1vZHVsZXMgaGF2ZSBubyBhbmNlc3RvcnMgb3RoZXJ3aXNlXG4gICAgICAgIGlmIChzZWxmLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KFtPcGFsLk9iamVjdF0pLmNvbmNhdChPcGFsLmFuY2VzdG9ycyhPcGFsLk9iamVjdCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGlpID0gbW9kdWxlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIG1vZHVsZSA9IG1vZHVsZXNbaV07XG4gICAgICAgIGlmIChtb2R1bGUuJCRjb25zdFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbnN0X2dldChuYW1lLCBpbmhlcml0ID0gdHJ1ZSlcbiAgICBuYW1lID0gT3BhbC5jb25zdF9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICBpZiAobmFtZS5pbmRleE9mKCc6OicpID09PSAwICYmIG5hbWUgIT09ICc6Oicpe1xuICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBgbmFtZS5pbmRleE9mKCc6OicpICE9IC0xICYmIG5hbWUgIT0gJzo6J2BcbiAgICAgIHJldHVybiBuYW1lLnNwbGl0KCc6OicpLmluamVjdChzZWxmKSB7IHxvLCBjfCBvLmNvbnN0X2dldChjKSB9XG4gICAgZW5kXG5cbiAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwid3JvbmcgY29uc3RhbnQgbmFtZSAje25hbWV9XCIsIG5hbWUpIHVubGVzcyBuYW1lID1+IE9wYWw6OkNPTlNUX05BTUVfUkVHRVhQXG5cbiAgICAleHtcbiAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgIHJldHVybiAkJChbc2VsZl0sIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuY29uc3RfZ2V0X2xvY2FsKHNlbGYsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbnN0X21pc3NpbmcobmFtZSlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkYXV0b2xvYWQpIHtcbiAgICAgICAgdmFyIGZpbGUgPSBzZWxmLiQkYXV0b2xvYWRbbmFtZV07XG5cbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICBzZWxmLiRyZXF1aXJlKGZpbGUpO1xuXG4gICAgICAgICAgcmV0dXJuICN7Y29uc3RfZ2V0IG5hbWV9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVsbF9jb25zdF9uYW1lID0gc2VsZiA9PSBPYmplY3QgPyBuYW1lIDogXCIje3NlbGZ9Ojoje25hbWV9XCJcblxuICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJ1bmluaXRpYWxpemVkIGNvbnN0YW50ICN7ZnVsbF9jb25zdF9uYW1lfVwiLCBuYW1lKVxuICBlbmRcblxuICBkZWYgY29uc3Rfc2V0KG5hbWUsIHZhbHVlKVxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICBpZiBuYW1lICF+IE9wYWw6OkNPTlNUX05BTUVfUkVHRVhQIHx8IG5hbWUuc3RhcnRfd2l0aD8oJzo6JylcbiAgICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIGBPcGFsLmNvbnN0X3NldChzZWxmLCBuYW1lLCB2YWx1ZSlgXG5cbiAgICB2YWx1ZVxuICBlbmRcblxuICBkZWYgcHVibGljX2NvbnN0YW50KGNvbnN0X25hbWUpXG4gIGVuZFxuXG4gIGRlZiBkZWZpbmVfbWV0aG9kKG5hbWUsIG1ldGhvZCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBtZXRob2QgPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNyZWF0ZSBhIFByb2Mgb2JqZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICBlbmRcblxuICAgIGJsb2NrIHx8PSBjYXNlIG1ldGhvZFxuICAgICAgICAgICAgICB3aGVuIFByb2NcbiAgICAgICAgICAgICAgICBtZXRob2RcblxuICAgICAgICAgICAgICB3aGVuIE1ldGhvZFxuICAgICAgICAgICAgICAgIGAje21ldGhvZC50b19wcm9jfS4kJHVuYm91bmRgXG5cbiAgICAgICAgICAgICAgd2hlbiBVbmJvdW5kTWV0aG9kXG4gICAgICAgICAgICAgICAgLT4oKmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgIGJvdW5kID0gbWV0aG9kLmJpbmQoc2VsZilcbiAgICAgICAgICAgICAgICAgIGJvdW5kLmNhbGwoKmFyZ3MpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Jsb2NrLmNsYXNzfSAoZXhwZWN0ZWQgUHJvYy9NZXRob2QpXCJcbiAgICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBpZCA9ICckJyArIG5hbWU7XG5cbiAgICAgIGJsb2NrLiQkanNpZCAgICAgICAgPSBuYW1lO1xuICAgICAgYmxvY2suJCRzICAgICAgICAgICA9IG51bGw7XG4gICAgICBibG9jay4kJGRlZiAgICAgICAgID0gYmxvY2s7XG4gICAgICBibG9jay4kJGRlZmluZV9tZXRoID0gdHJ1ZTtcblxuICAgICAgT3BhbC5kZWZuKHNlbGYsIGlkLCBibG9jayk7XG5cbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9tZXRob2QoKm5hbWVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwucmRlZihzZWxmLCBcIiRcIiArIG5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fY2xhc3M/XG4gICAgYCEhc2VsZi4kJGlzX3NpbmdsZXRvbmBcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGUoKm1vZHMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gbW9kcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbW9kID0gbW9kc1tpXTtcblxuICAgICAgICBpZiAoIW1vZC4kJGlzX21vZHVsZSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICAgIH1cblxuICAgICAgICAje2Btb2RgLmFwcGVuZF9mZWF0dXJlcyBzZWxmfTtcbiAgICAgICAgI3tgbW9kYC5pbmNsdWRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlZF9tb2R1bGVzXG4gICAgYE9wYWwuaW5jbHVkZWRfbW9kdWxlcyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG1vZClcbiAgICAleHtcbiAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBpaSwgbW9kMiwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMoc2VsZik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGlpID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgbW9kMiA9IGFuY2VzdG9yc1tpXTtcbiAgICAgICAgaWYgKG1vZDIgPT09IG1vZCAmJiBtb2QyICE9PSBzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX21ldGhvZChuYW1lKVxuICAgICV4e1xuICAgICAgdmFyIG1ldGggPSBzZWxmLiQkcHJvdG90eXBlWyckJyArIG5hbWVdO1xuXG4gICAgICBpZiAoIW1ldGggfHwgbWV0aC4kJHN0dWIpIHtcbiAgICAgICAgI3tyYWlzZSBOYW1lRXJyb3IubmV3KFwidW5kZWZpbmVkIG1ldGhvZCBgI3tuYW1lfScgZm9yIGNsYXNzIGAje3NlbGYubmFtZX0nXCIsIG5hbWUpfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7VW5ib3VuZE1ldGhvZC5uZXcoc2VsZiwgYG1ldGguJCRvd25lciB8fCAje3NlbGZ9YCwgYG1ldGhgLCBuYW1lKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfbWV0aG9kcyhpbmNsdWRlX3N1cGVyID0gdHJ1ZSlcbiAgICAleHtcbiAgICAgIGlmICgkdHJ1dGh5KCN7aW5jbHVkZV9zdXBlcn0pKSB7XG4gICAgICAgIHJldHVybiBPcGFsLmluc3RhbmNlX21ldGhvZHMoc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5vd25faW5zdGFuY2VfbWV0aG9kcyhzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlZChtb2QpXG4gIGVuZFxuXG4gIGRlZiBleHRlbmRlZChtb2QpXG4gIGVuZFxuXG4gIGRlZiBleHRlbmRfb2JqZWN0KG9iamVjdClcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9hZGRlZCgqKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX3JlbW92ZWQoKilcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF91bmRlZmluZWQoKilcbiAgZW5kXG5cbiAgZGVmIG1vZHVsZV9ldmFsKCphcmdzLCAmYmxvY2spXG4gICAgaWYgYmxvY2submlsPyAmJiBgISFPcGFsLmNvbXBpbGVgXG4gICAgICBLZXJuZWwucmFpc2UgQXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDEuLjMpJyB1bmxlc3MgKDEuLjMpLmNvdmVyPyBhcmdzLnNpemVcblxuICAgICAgc3RyaW5nLCBmaWxlLCBfbGluZW5vID0gKmFyZ3NcbiAgICAgIGRlZmF1bHRfZXZhbF9vcHRpb25zID0geyBmaWxlOiAoZmlsZSB8fCAnKGV2YWwpJyksIGV2YWw6IHRydWUgfVxuICAgICAgY29tcGlsaW5nX29wdGlvbnMgPSBfX09QQUxfQ09NUElMRVJfQ09ORklHX18ubWVyZ2UoZGVmYXVsdF9ldmFsX29wdGlvbnMpXG4gICAgICBjb21waWxlZCA9IE9wYWwuY29tcGlsZSBzdHJpbmcsIGNvbXBpbGluZ19vcHRpb25zXG4gICAgICBibG9jayA9IEtlcm5lbC5wcm9jIGRvXG4gICAgICAgICV4e1xuICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIGV2YWwoY29tcGlsZWQpO1xuICAgICAgICAgIH0pKHNlbGYpXG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVsc2lmIGFyZ3MuYW55P1xuICAgICAgS2VybmVsLnJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLnNpemV9IGZvciAwKVwiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG5cXG4gIE5PVEU6SWYgeW91IHdhbnQgdG8gZW5hYmxlIHBhc3NpbmcgYSBTdHJpbmcgYXJndW1lbnQgcGxlYXNlIGFkZCBcXFwicmVxdWlyZSAnb3BhbC1wYXJzZXInXFxcIiB0byB5b3VyIHNjcmlwdFxcblwiXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBvbGQgPSBibG9jay4kJHMsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gYmxvY2suYXBwbHkoc2VsZiwgW3NlbGZdKTtcbiAgICAgIGJsb2NrLiQkcyA9IG9sZDtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGNsYXNzX2V2YWwgbW9kdWxlX2V2YWxcblxuICBkZWYgbW9kdWxlX2V4ZWMoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICN7cmFpc2UgTG9jYWxKdW1wRXJyb3IsICdubyBibG9jayBnaXZlbid9XG4gICAgICB9XG5cbiAgICAgIHZhciBibG9ja19zZWxmID0gYmxvY2suJCRzLCByZXN1bHQ7XG5cbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XG4gICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIGJsb2NrLiQkcyA9IGJsb2NrX3NlbGY7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBjbGFzc19leGVjIG1vZHVsZV9leGVjXG5cbiAgZGVmIG1ldGhvZF9kZWZpbmVkPyhtZXRob2QpXG4gICAgJXh7XG4gICAgICB2YXIgYm9keSA9IHNlbGYuJCRwcm90b3R5cGVbJyQnICsgbWV0aG9kXTtcbiAgICAgIHJldHVybiAoISFib2R5KSAmJiAhYm9keS4kJHN0dWI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbW9kdWxlX2Z1bmN0aW9uKCptZXRob2RzKVxuICAgICV4e1xuICAgICAgaWYgKG1ldGhvZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlbGYuJCRtb2R1bGVfZnVuY3Rpb24gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtZXRob2RzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG1ldGggPSBtZXRob2RzW2ldLFxuICAgICAgICAgICAgICBpZCAgID0gJyQnICsgbWV0aCxcbiAgICAgICAgICAgICAgZnVuYyA9IHNlbGYuJCRwcm90b3R5cGVbaWRdO1xuXG4gICAgICAgICAgT3BhbC5kZWZzKHNlbGYsIGlkLCBmdW5jKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBuYW1lXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGZ1bGxfbmFtZSkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGZ1bGxfbmFtZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBiYXNlID0gc2VsZjtcblxuICAgICAgd2hpbGUgKGJhc2UpIHtcbiAgICAgICAgLy8gR2l2ZSB1cCBpZiBhbnkgb2YgdGhlIGFuY2VzdG9ycyBpcyB1bm5hbWVkXG4gICAgICAgIGlmIChiYXNlLiQkbmFtZSA9PT0gbmlsIHx8IGJhc2UuJCRuYW1lID09IG51bGwpIHJldHVybiBuaWw7XG5cbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoYmFzZS4kJG5hbWUpO1xuXG4gICAgICAgIGJhc2UgPSBiYXNlLiQkYmFzZV9tb2R1bGU7XG5cbiAgICAgICAgaWYgKGJhc2UgPT09IE9wYWwuT2JqZWN0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJCRmdWxsX25hbWUgPSByZXN1bHQuam9pbignOjonKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwcmVwZW5kKCptb2RzKVxuICAgICV4e1xuICAgICAgaWYgKG1vZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuIDAsIGV4cGVjdGVkIDErKSd9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBtb2RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBtb2QgPSBtb2RzW2ldO1xuXG4gICAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7YG1vZGAucHJlcGVuZF9mZWF0dXJlcyBzZWxmfTtcbiAgICAgICAgI3tgbW9kYC5wcmVwZW5kZWQgc2VsZn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcHJlcGVuZF9mZWF0dXJlcyhwcmVwZW5kZXIpXG4gICAgJXh7XG4gICAgICBpZiAoIXNlbGYuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje3NlbGYuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgfVxuXG4gICAgICBPcGFsLnByZXBlbmRfZmVhdHVyZXMoc2VsZiwgcHJlcGVuZGVyKVxuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwcmVwZW5kZWQobW9kKVxuICBlbmRcblxuICBkZWYgcmVtb3ZlX2NvbnN0KG5hbWUpXG4gICAgYE9wYWwuY29uc3RfcmVtb3ZlKHNlbGYsIG5hbWUpYFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGBPcGFsLk1vZHVsZS4kbmFtZS5jYWxsKHNlbGYpYCB8fCBcIiM8I3tgc2VsZi4kJGlzX21vZHVsZSA/ICdNb2R1bGUnIDogJ0NsYXNzJ2B9OjB4I3tfX2lkX18udG9fcygxNil9PlwiXG4gIGVuZFxuXG4gIGRlZiB1bmRlZl9tZXRob2QoKm5hbWVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwudWRlZihzZWxmLCBcIiRcIiArIG5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBjb25zdHMgPSBjb25zdGFudHNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KG5hbWUpICYmIG5hbWUuY2hhckF0KDApICE9PSAnJCcgJiYgbmFtZSAhPT0gJ2NvbnN0cnVjdG9yJyAmJiAhI3tjb25zdHMuaW5jbHVkZT8oYG5hbWVgKX0pIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgnQCcgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBzdXBlclxuICAgIGNvcHkuY29weV9jbGFzc192YXJpYWJsZXMoc2VsZilcbiAgICBjb3B5LmNvcHlfY29uc3RhbnRzKHNlbGYpXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgY29weV9jbGFzc192YXJpYWJsZXMob3RoZXIpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIG90aGVyLiQkY3ZhcnMpIHtcbiAgICAgICAgc2VsZi4kJGN2YXJzW25hbWVdID0gb3RoZXIuJCRjdmFyc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb3B5X2NvbnN0YW50cyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBuYW1lLCBvdGhlcl9jb25zdGFudHMgPSBvdGhlci4kJGNvbnN0O1xuXG4gICAgICBmb3IgKG5hbWUgaW4gb3RoZXJfY29uc3RhbnRzKSB7XG4gICAgICAgIE9wYWwuY29uc3Rfc2V0KHNlbGYsIG5hbWUsIG90aGVyX2NvbnN0YW50c1tuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiYWxsb2NhdGUiLCJzZWxmIiwiaW5pdGlhbGl6ZSIsImJsb2NrX2dpdmVuPyIsIm1vZHVsZV9ldmFsIiwiYmxvY2siLCI9PT0iLCI8Iiwib3RoZXIiLCJyYWlzZSIsIjw9IiwiJHJldF9vcl8xIiwiZXF1YWw/IiwiPiIsIj49IiwiJHJldF9vcl8yIiwiPD0+IiwibHQiLCJuaWw/IiwiLTEiLCIxIiwiYWxpYXNfbWV0aG9kIiwibmV3bmFtZSIsIm9sZG5hbWUiLCJhbGlhc19uYXRpdmUiLCJtaWQiLCJhbmNlc3RvcnMiLCJhcHBlbmRfZmVhdHVyZXMiLCJhdHRyX2FjY2Vzc29yIiwiYXR0cl9yZWFkZXIiLCJuYW1lcyIsImF0dHJfd3JpdGVyIiwiYXR0ciIsIndhcm4iLCJhcmdzIiwiYXV0b2xvYWQiLCJjb25zdCQiLCJwYXRoIiwiY2xhc3NfdmFyaWFibGVzIiwiY2xhc3NfdmFyaWFibGVfZ2V0IiwibmFtZSIsImNsYXNzX3ZhcmlhYmxlX25hbWUhIiwiY2xhc3NfdmFyaWFibGVfc2V0IiwiY2xhc3NfdmFyaWFibGVfZGVmaW5lZD8iLCJyZW1vdmVfY2xhc3NfdmFyaWFibGUiLCJjb25zdGFudHMiLCJuZXN0aW5nIiwiY29uc3RfZGVmaW5lZD8iLCJjb25zdF9uYW1lISIsIj1+IiwibmV3IiwiY29uc3RfZ2V0IiwiaW5qZWN0Iiwic3BsaXQiLCJvIiwiYyIsImNvbnN0X21pc3NpbmciLCJmdWxsX2NvbnN0X25hbWUiLCI9PSIsImNvbnN0X3NldCIsIiRyZXRfb3JfMyIsIiF+Iiwic3RhcnRfd2l0aD8iLCJ2YWx1ZSIsInB1YmxpY19jb25zdGFudCIsImRlZmluZV9tZXRob2QiLCIkcmV0X29yXzQiLCJtZXRob2QiLCJ0b19wcm9jIiwiYm91bmQiLCJiaW5kIiwiY2FsbCIsInJlbW92ZV9tZXRob2QiLCJzaW5nbGV0b25fY2xhc3M/IiwiaW5jbHVkZSIsImluY2x1ZGVkIiwiaW5jbHVkZWRfbW9kdWxlcyIsImluY2x1ZGU/IiwiaW5zdGFuY2VfbWV0aG9kIiwiaW5zdGFuY2VfbWV0aG9kcyIsImluY2x1ZGVfc3VwZXIiLCJleHRlbmRlZCIsImV4dGVuZF9vYmplY3QiLCJtZXRob2RfYWRkZWQiLCJtZXRob2RfcmVtb3ZlZCIsIm1ldGhvZF91bmRlZmluZWQiLCIkcmV0X29yXzUiLCIzIiwiY292ZXI/Iiwic2l6ZSIsInN0cmluZyIsImZpbGUiLCJfbGluZW5vIiwiZGVmYXVsdF9ldmFsX29wdGlvbnMiLCIkcmV0X29yXzYiLCJjb21waWxpbmdfb3B0aW9ucyIsIl9fT1BBTF9DT01QSUxFUl9DT05GSUdfXyIsIm1lcmdlIiwiY29tcGlsZWQiLCJjb21waWxlIiwicHJvYyIsImFueT8iLCJtb2R1bGVfZXhlYyIsIm1ldGhvZF9kZWZpbmVkPyIsIm1vZHVsZV9mdW5jdGlvbiIsInByZXBlbmQiLCJwcmVwZW5kX2ZlYXR1cmVzIiwicHJlcGVuZGVkIiwicmVtb3ZlX2NvbnN0IiwidG9fcyIsIiRyZXRfb3JfNyIsIl9faWRfXyIsIjE2IiwidW5kZWZfbWV0aG9kIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiY29uc3RzIiwiZHVwIiwiY29weSIsImNvcHlfY2xhc3NfdmFyaWFibGVzIiwiY29weV9jb25zdGFudHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0VBRUEsT0FBQUE7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LENBQVA7QUFBQSxNQUNBQSxJQUFBQyxzQkFBQUEsQ0FBMEJySCxJQUExQnFILENBREE7QUFBQSxNQUVBRCxJQUFBRSxnQkFBQUEsQ0FBb0J0SCxJQUFwQnNILENBRkE7QUFBQSxNQUdBLE9BQUFGLElBSEE7QUFERkQsSUFBQUEsQ0FBQUEsNEJBQUFBLENBN29CQTtBQUFBO0FBb3BCQUUsSUFBQUEsd0NBQUFBLGtDQUFBQSxnQ0FBeUIsS0FBekJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBTEVBLElBQUFBLENBQUFBLDZDQUFBQSxDQXBwQkE7QUFBQSxJQTRwQkEsT0FBQUMsQ0FBQUEsa0NBQUFBLDRCQUFBQSwwQkFBbUIsS0FBbkJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBUEVBLElBQUFBLENBQUFBLHVDQUFBQSxDQUFBQSwwQkE1cEJBO0FBREZ4SCxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM3MjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NsYXNzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvbW9kdWxlJ1xuXG5jbGFzcyBDbGFzc1xuICBkZWYgc2VsZi5uZXcoc3VwZXJjbGFzcyA9IE9iamVjdCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKCFzdXBlcmNsYXNzLiQkaXNfY2xhc3MpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcInN1cGVyY2xhc3MgbXVzdCBiZSBhIENsYXNzXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIga2xhc3MgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG5pbCwgc3VwZXJjbGFzcyk7XG4gICAgICBzdXBlcmNsYXNzLiRpbmhlcml0ZWQoa2xhc3MpO1xuICAgICAgI3tga2xhc3NgLmNsYXNzX2V2YWwoJmJsb2NrKSBpZiBibG9ja19naXZlbj99XG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYWxsb2NhdGVcbiAgICAleHtcbiAgICAgIHZhciBvYmogPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKCk7XG4gICAgICBvYmouJCRpZCA9IE9wYWwudWlkKCk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluaGVyaXRlZChjbHMpXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2R1cChvcmlnaW5hbClcbiAgICBpbml0aWFsaXplX2NvcHkob3JpZ2luYWwpXG4gICAgJXh7XG4gICAgICBzZWxmLiQkbmFtZSA9IG51bGw7XG4gICAgICBzZWxmLiQkZnVsbF9uYW1lID0gbnVsbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBuZXcoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBvYmplY3QgPSAje2FsbG9jYXRlfTtcbiAgICAgIE9wYWwuc2VuZChvYmplY3QsIG9iamVjdC4kaW5pdGlhbGl6ZSwgYXJncywgYmxvY2spO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzdXBlcmNsYXNzXG4gICAgYHNlbGYuJCRzdXBlciB8fCBuaWxgXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgJXh7XG4gICAgICB2YXIgc2luZ2xldG9uX29mID0gc2VsZi4kJHNpbmdsZXRvbl9vZjtcblxuICAgICAgaWYgKHNpbmdsZXRvbl9vZiAmJiBzaW5nbGV0b25fb2YuJCRpc19hX21vZHVsZSkge1xuICAgICAgICByZXR1cm4gI3tcIiM8Q2xhc3M6I3tgc2luZ2xldG9uX29mYC5uYW1lfT5cIn07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzaW5nbGV0b25fb2YpIHtcbiAgICAgICAgLy8gYSBzaW5nbGV0b24gY2xhc3MgY3JlYXRlZCBmcm9tIGFuIG9iamVjdFxuICAgICAgICByZXR1cm4gI3tcIiM8Q2xhc3M6Izwje2BzaW5nbGV0b25fb2YuJCRjbGFzc2AubmFtZX06MHgje2BPcGFsLmlkKHNpbmdsZXRvbl9vZilgLnRvX3MoMTYpfT4+XCJ9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tzdXBlcigpfTtcbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwibmV3Iiwic2VsZiIsImJsb2NrX2dpdmVuPyIsImNsYXNzX2V2YWwiLCJibG9jayIsImFsbG9jYXRlIiwiaW5oZXJpdGVkIiwiaW5pdGlhbGl6ZV9kdXAiLCJpbml0aWFsaXplX2NvcHkiLCJvcmlnaW5hbCIsInN1cGVyY2xhc3MiLCJ0b19zIiwibmFtZSIsIjE2Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQUFBO0FBQUEsRUFFQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQUMsVUFBSUMsSUFBSkQsVUFBQUEsZUFBQUEsU0FBYSxVQUFiQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFKRjtBQUlvQyxNQUFBLG1DQUpwQztBQUFBO0FBSWUsTUFBQTtBQUFBLE1BQUEsZUFBYSxzQkFBYjtBQUFBLE1BQUEsQ0FKZjtBQUFBO0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFRLGFBQUEsSUFBOEJFLGVBQTlCO0FBQUEsUUFBQSxPQUFBQyxNQUFBLENBQUMsS0FBRCxDQUFBQSxjQUFBQSxFQUFBQSxFQUFBQSxFQUFvQkMsZ0JBQXBCRDtBQUFBLE1BQUE7QUFBQTtBQUFBLE1BQUEsQ0FBQTtBQUNSO0FBQ0EsSUFkQTtBQUlFSCxJQUFBQSxDQUFBQSwyQkFBQUEsQ0FBQTtBQUFBO0FBYUFLLElBQUFBLDRCQUFBQSxvQkFBQUEsb0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBTEVBLElBQUFBLENBQUFBLCtCQUFBQSxDQWJBO0FBQUE7QUFxQkFDLElBQUFBLDZCQUFBQSxxQkFBQUEscUJBQWMsR0FBZEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BekJGLE9BQUE7QUF5QkVBLElBQUFBLENBQUFBLGdDQUFBQSxDQXJCQTtBQUFBO0FBd0JBQyxJQUFBQSxrQ0FBQUEsMEJBQUFBLDBCQUFtQixRQUFuQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsVUFBQUMsaUJBQUFBLENBQWdCQyxRQUFoQkQsQ0FBQTtBQUFBO0FBRUo7QUFDQTtBQUNBLElBSkk7QUFERkQsSUFBQUEsQ0FBQUEscUNBQUFBLENBeEJBO0FBQUE7QUFnQ0FQLElBQUFBLHVCQUFBQSxlQUFBQSxTQXBDRixFQW9DRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBcENGO0FBb0NpQixNQUFBLG1DQXBDakI7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQW9DVSxNQUFBLGtCQXBDVjtBQUFBO0FBc0NBLHVCQUFxQkssVUFBQUEsQ0FBQUEsQ0FBUztBQUM5QjtBQUNBO0FBQ0EsSUF6Q0E7QUFvQ0VMLElBQUFBLENBQUFBLDJCQUFBQSxDQWhDQTtBQUFBO0FBd0NBVSxJQUFBQSw4QkFBQUEsc0JBQUFBLHNCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLG1CQUFEO0FBREZBLElBQUFBLENBQUFBLGlDQUFBQSxDQXhDQTtBQUFBLElBNENBLE9BQUFDLENBQUFBLHdCQUFBQSxnQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQUVGOztBQUVBO0FBQ0EsZUFBaUIsRUFBQSxHQUFBLFVBQUEsR0FBQSxDQUFXLENBQUMsWUFBRCxDQUFBQyxNQUFBQSxDQUFBQSxDQUFYLENBQUEsR0FBQSxHQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxlQUFpQixFQUFBLEdBQUEsWUFBQSxHQUFBLENBQWEsQ0FBQyxvQkFBRCxDQUFBQSxNQUFBQSxDQUFBQSxDQUFiLENBQUEsR0FBQSxLQUFBLEdBQUEsQ0FBOEMsQ0FBQyxxQkFBRCxDQUFBRCxNQUFBQSxDQUE2QkUsRUFBN0JGLENBQTlDLENBQUEsR0FBQSxJQUFtRjtBQUNwRzs7QUFFQSxhQUFlLFdBQUEsRUFBQSxvRUFBQSxRQUFBLEVBQUEsRUFBQSxNQUFBLENBQVE7QUFDdkI7QUFiRUEsSUFBQUEsQ0FBQUEsMkJBQUFBLENBQUFBLGdCQTVDQTtBQURGWixFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQUZBOzsifX0seyJvZmZzZXQiOnsibGluZSI6Mzg0MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvYmFzaWNfb2JqZWN0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEJhc2ljT2JqZWN0XG4gIGRlZiBpbml0aWFsaXplKCopXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgc2VsZiA9PT0gb3RoZXJgXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHNlbGYgPT0gb3RoZXJcbiAgZW5kXG5cbiAgYWxpYXMgZXF1YWw/ID09XG5cbiAgZGVmIF9faWRfX1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkaWQ7XG4gICAgICB9XG4gICAgICBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYsICckJGlkJywgT3BhbC51aWQoKSk7XG4gICAgICByZXR1cm4gc2VsZi4kJGlkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIF9fc2VuZF9fKHN5bWJvbCwgKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBmdW5jID0gc2VsZlsnJCcgKyBzeW1ib2xdXG5cbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgZnVuYy4kJHAgPSBibG9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBzZWxmLiRtZXRob2RfbWlzc2luZy4kJHAgPSBibG9jaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJG1ldGhvZF9taXNzaW5nLmFwcGx5KHNlbGYsIFtzeW1ib2xdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgIVxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiAhPShvdGhlcilcbiAgICAhKHNlbGYgPT0gb3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9ldmFsKCphcmdzLCAmYmxvY2spXG4gICAgaWYgYmxvY2submlsPyAmJiBgISFPcGFsLmNvbXBpbGVgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxLi4zKScgdW5sZXNzICgxLi4zKS5jb3Zlcj8gYXJncy5zaXplXG5cbiAgICAgIHN0cmluZywgZmlsZSwgX2xpbmVubyA9ICphcmdzXG4gICAgICBkZWZhdWx0X2V2YWxfb3B0aW9ucyA9IHsgZmlsZTogKGZpbGUgfHwgJyhldmFsKScpLCBldmFsOiB0cnVlIH1cbiAgICAgIGNvbXBpbGluZ19vcHRpb25zID0gX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fLm1lcmdlKGRlZmF1bHRfZXZhbF9vcHRpb25zKVxuICAgICAgY29tcGlsZWQgPSA6Ok9wYWwuY29tcGlsZSBzdHJpbmcsIGNvbXBpbGluZ19vcHRpb25zXG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgZG9cbiAgICAgICAgJXh7XG4gICAgICAgICAgcmV0dXJuIChmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZhbChjb21waWxlZCk7XG4gICAgICAgICAgfSkoc2VsZilcbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZWxzaWYgYXJncy5hbnk/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLnNpemV9IGZvciAwKVwiXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBvbGQgPSBibG9jay4kJHMsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xuXG4gICAgICAvLyBOZWVkIHRvIHBhc3MgJCRldmFsIHNvIHRoYXQgbWV0aG9kIGRlZmluaXRpb25zIGtub3cgaWYgdGhpcyBpc1xuICAgICAgLy8gYmVpbmcgZG9uZSBvbiBhIGNsYXNzL21vZHVsZS4gQ2Fubm90IGJlIGNvbXBpbGVyIGRyaXZlbiBzaW5jZVxuICAgICAgLy8gc2VuZCg6aW5zdGFuY2VfZXZhbCkgbmVlZHMgdG8gd29yay5cbiAgICAgIGlmIChzZWxmLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgICAgc2VsZi4kJGV2YWwgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGJsb2NrLmNhbGwoc2VsZiwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgc2VsZi4kJGV2YWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGJsb2NrLmNhbGwoc2VsZiwgc2VsZik7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrLiQkcyA9IG9sZDtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9leGVjKCphcmdzLCAmYmxvY2spXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgYmxvY2tfc2VsZiA9IGJsb2NrLiQkcyxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XG5cbiAgICAgIGlmIChzZWxmLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgICAgc2VsZi4kJGV2YWwgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgIHNlbGYuJCRldmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgYmxvY2suJCRzID0gYmxvY2tfc2VsZjtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX2FkZGVkKCopXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQoKilcbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9tZXRob2RfdW5kZWZpbmVkKCopXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfbWlzc2luZyhzeW1ib2wsICphcmdzLCAmYmxvY2spXG4gICAgbWVzc2FnZSA9IGlmIGBzZWxmLiRpbnNwZWN0ICYmICFzZWxmLiRpbnNwZWN0LiQkc3R1YmBcbiAgICAgICAgICAgICAgICBcInVuZGVmaW5lZCBtZXRob2QgYCN7c3ltYm9sfScgZm9yICN7aW5zcGVjdH06I3tgc2VsZi4kJGNsYXNzYH1cIlxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgXCJ1bmRlZmluZWQgbWV0aG9kIGAje3N5bWJvbH0nIGZvciAje2BzZWxmLiQkY2xhc3NgfVwiXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOb01ldGhvZEVycm9yLm5ldyhtZXNzYWdlLCBzeW1ib2wpXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1ldGhvZF9uYW1lLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxuICAgIGZhbHNlXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJpbml0aWFsaXplIiwiPT0iLCJlcWw/Iiwic2VsZiIsIm90aGVyIiwiX19pZF9fIiwiX19zZW5kX18iLCIhIiwiIT0iLCJpbnN0YW5jZV9ldmFsIiwiJHJldF9vcl8xIiwiYmxvY2siLCJuaWw/IiwiMSIsIjMiLCJjb3Zlcj8iLCJhcmdzIiwic2l6ZSIsInJhaXNlIiwic3RyaW5nIiwiZmlsZSIsIl9saW5lbm8iLCJkZWZhdWx0X2V2YWxfb3B0aW9ucyIsIiRyZXRfb3JfMiIsImNvbXBpbGluZ19vcHRpb25zIiwiX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fIiwibWVyZ2UiLCJjb21waWxlZCIsImNvbXBpbGUiLCJwcm9jIiwiYW55PyIsImluc3RhbmNlX2V4ZWMiLCJzaW5nbGV0b25fbWV0aG9kX2FkZGVkIiwic2luZ2xldG9uX21ldGhvZF9yZW1vdmVkIiwic2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQiLCJtZXRob2RfbWlzc2luZyIsIm1lc3NhZ2UiLCJzeW1ib2wiLCJpbnNwZWN0IiwibmV3IiwicmVzcG9uZF90b19taXNzaW5nPyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0U7QUFBQUMsSUFBQUEsOEJBQUFBLDRCQUFBQSxzQkFGRixFQUVFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFGRjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxPQUFBLEdBQUE7QUFFRUEsSUFBQUEsQ0FBQUEsd0NBQUFBLENBQUE7QUFBQTtBQUdBQyxJQUFBQSxzQkFBQUEsd0JBQUFBLFNBQU8sS0FBUEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxjQUFEO0FBREZBLElBQUFBLENBQUFBLG1DQUFBQSxDQUhBO0FBQUE7QUFPQUMsSUFBQUEsd0JBQUFBLDBCQUFBQSxTQUFTLEtBQVRBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFDLElBQUFGLE9BQUFBLENBQVFHLEtBQVJIO0FBREZDLElBQUFBLENBQUFBLHFDQUFBQSxDQVBBO0FBQUEs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SnZDO0FBQUEsTUFvSkksT0FBQSxLQXBKSjtBQW1KRUEsSUFBQUEsQ0FBQUEsc0RBQUFBLENBQUFBLCtCQWpKQTtBQURGekMsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MDk2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9rZXJuZWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHksIGNvZXJjZV90bywgcmVzcG9uZF90b1xuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBtZXRob2RfbWlzc2luZyhzeW1ib2wsICphcmdzLCAmYmxvY2spXG4gICAgcmFpc2UgTm9NZXRob2RFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje3N5bWJvbH0nIGZvciAje2luc3BlY3R9XCIsIHN5bWJvbCwgYXJncylcbiAgZW5kXG5cbiAgZGVmID1+KG9iailcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgIX4ob2JqKVxuICAgICEoc2VsZiA9fiBvYmopXG4gIGVuZFxuXG4gIGRlZiA9PT0ob3RoZXIpXG4gICAgb2JqZWN0X2lkID09IG90aGVyLm9iamVjdF9pZCB8fCBzZWxmID09IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgJXh7XG4gICAgICAvLyBzZXQgZ3VhcmQgZm9yIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgc2VsZi4kJGNvbXBhcmFibGUgPSB0cnVlO1xuXG4gICAgICB2YXIgeCA9ICN7c2VsZiA9PSBvdGhlcn07XG5cbiAgICAgIGlmICh4ICYmIHggIT09IG5pbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtZXRob2QobmFtZSlcbiAgICAleHtcbiAgICAgIHZhciBtZXRoID0gc2VsZlsnJCcgKyBuYW1lXTtcblxuICAgICAgaWYgKCFtZXRoIHx8IG1ldGguJCRzdHViKSB7XG4gICAgICAgICN7cmFpc2UgTmFtZUVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7bmFtZX0nIGZvciBjbGFzcyBgI3tzZWxmLmNsYXNzfSdcIiwgbmFtZSl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tNZXRob2QubmV3KHNlbGYsIGBtZXRoLiQkb3duZXIgfHwgI3tzZWxmLmNsYXNzfWAsIGBtZXRoYCwgbmFtZSl9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1ldGhvZHMoYWxsID0gdHJ1ZSlcbiAgICAleHtcbiAgICAgIGlmICgkdHJ1dGh5KCN7YWxsfSkpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwubWV0aG9kcyhzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLm93bl9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHB1YmxpY19tZXRob2RzKGFsbCA9IHRydWUpXG4gICAgJXh7XG4gICAgICBpZiAoJHRydXRoeSgje2FsbH0pKSB7XG4gICAgICAgIHJldHVybiBPcGFsLm1ldGhvZHMoc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5yZWNlaXZlcl9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEFycmF5KG9iamVjdClcbiAgICAleHtcbiAgICAgIHZhciBjb2VyY2VkO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgY29lcmNlZCA9ICN7T3BhbC5jb2VyY2VfdG8/KG9iamVjdCwgQXJyYXksIDp0b19hcnkpfTtcbiAgICAgIGlmIChjb2VyY2VkICE9PSBuaWwpIHsgcmV0dXJuIGNvZXJjZWQ7IH1cblxuICAgICAgY29lcmNlZCA9ICN7T3BhbC5jb2VyY2VfdG8/KG9iamVjdCwgQXJyYXksIDp0b19hKX07XG4gICAgICBpZiAoY29lcmNlZCAhPT0gbmlsKSB7IHJldHVybiBjb2VyY2VkOyB9XG5cbiAgICAgIHJldHVybiBbb2JqZWN0XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhdF9leGl0KCZibG9jaylcbiAgICAkX19hdF9leGl0X18gfHw9IFtdXG4gICAgJF9fYXRfZXhpdF9fIDw8IGJsb2NrXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIGNhbGxlcihzdGFydCA9IDEsIGxlbmd0aCA9IG5pbClcbiAgICAleHtcbiAgICAgIHZhciBzdGFjaywgcmVzdWx0XG5cbiAgICAgIHN0YWNrID0gKG5ldyBFcnJvcigpLnN0YWNrIHx8IFwiXCIpLnNwbGl0KFwiXFxuXCIpXG4gICAgICByZXN1bHQgPSBbXVxuXG4gICAgICAvLyBTa2lwIHRoZSBpbml0aWFsIGxpbmUgKFwiRXJyb3I6XCIpIGFuZCBLZXJuZWwjY2FsbGVyIHdpdGggaT0zXG4gICAgICBmb3IgKHZhciBpID0gMywgaWkgPSBzdGFjay5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGlmICghc3RhY2tbaV0ubWF0Y2goXCJydW50aW1lLmpzXCIpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RhY2tbaV0ucmVwbGFjZSgvXiAqXFx3KyArLywgJycpKVxuICAgICAgICAgIGlmIChsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA9PSBsZW5ndGgpIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbGFzc1xuICAgIGBzZWxmLiQkY2xhc3NgXG4gIGVuZFxuXG4gIGRlZiBjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3RoZXIpLCBpLCBpaSwgbmFtZTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0ga2V5cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBrZXlzW2ldO1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgIT09ICckJyAmJiBvdGhlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHNlbGZbbmFtZV0gPSBvdGhlcltuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvcHlfc2luZ2xldG9uX21ldGhvZHMob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbmFtZSwgbmFtZXMsIGxlbmd0aDtcblxuICAgICAgaWYgKG90aGVyLmhhc093blByb3BlcnR5KCckJG1ldGEnKSkge1xuICAgICAgICB2YXIgb3RoZXJfc2luZ2xldG9uX2NsYXNzID0gT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG90aGVyKTtcbiAgICAgICAgdmFyIHNlbGZfc2luZ2xldG9uX2NsYXNzID0gT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKHNlbGYpO1xuICAgICAgICBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG90aGVyX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZSk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgaWYgKE9wYWwuaXNfbWV0aG9kKG5hbWUpKSB7XG4gICAgICAgICAgICBzZWxmX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZVtuYW1lXSA9IG90aGVyX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZVtuYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmX3NpbmdsZXRvbl9jbGFzcy4kJGNvbnN0ID0gT2JqZWN0LmFzc2lnbih7fSwgb3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkY29uc3QpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoXG4gICAgICAgICAgc2VsZl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGUsXG4gICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKG90aGVyX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvdGhlciksIGxlbmd0aCA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSAnJCcgJiYgbmFtZS5jaGFyQXQoMSkgIT09ICckJyAmJiBvdGhlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHNlbGZbbmFtZV0gPSBvdGhlcltuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNsb25lKGZyZWV6ZTogdHJ1ZSlcbiAgICBjb3B5ID0gc2VsZi5jbGFzcy5hbGxvY2F0ZVxuXG4gICAgY29weS5jb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyhzZWxmKVxuICAgIGNvcHkuY29weV9zaW5nbGV0b25fbWV0aG9kcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9jbG9uZShzZWxmKVxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9jbG9uZShvdGhlcilcbiAgICBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBkZWZpbmVfc2luZ2xldG9uX21ldGhvZChuYW1lLCBtZXRob2QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBzaW5nbGV0b25fY2xhc3MuZGVmaW5lX21ldGhvZChuYW1lLCBtZXRob2QsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBzZWxmLmNsYXNzLmFsbG9jYXRlXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2R1cChzZWxmKVxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9kdXAob3RoZXIpXG4gICAgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxuICBlbmRcblxuICBkZWYgZW51bV9mb3IobWV0aG9kID0gOmVhY2gsICphcmdzLCAmYmxvY2spXG4gICAgRW51bWVyYXRvci5mb3Ioc2VsZiwgbWV0aG9kLCAqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICBhbGlhcyB0b19lbnVtIGVudW1fZm9yXG5cbiAgZGVmIGVxdWFsPyhvdGhlcilcbiAgICBgc2VsZiA9PT0gb3RoZXJgXG4gIGVuZFxuXG4gIGRlZiBleGl0KHN0YXR1cyA9IHRydWUpXG4gICAgJF9fYXRfZXhpdF9fIHx8PSBbXVxuXG4gICAgdW50aWwgJF9fYXRfZXhpdF9fLmVtcHR5P1xuICAgICAgYmxvY2sgPSAkX19hdF9leGl0X18ucG9wXG4gICAgICBibG9jay5jYWxsXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzdGF0dXMuJCRpc19ib29sZWFuKSB7XG4gICAgICAgIHN0YXR1cyA9IHN0YXR1cyA/IDAgOiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gJGNvZXJjZV90byhzdGF0dXMsICN7SW50ZWdlcn0sICd0b19pbnQnKVxuICAgICAgfVxuXG4gICAgICBPcGFsLmV4aXQoc3RhdHVzKTtcbiAgICB9XG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBleHRlbmQoKm1vZHMpXG4gICAgJXh7XG4gICAgICB2YXIgc2luZ2xldG9uID0gI3tzaW5nbGV0b25fY2xhc3N9O1xuXG4gICAgICBmb3IgKHZhciBpID0gbW9kcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbW9kID0gbW9kc1tpXTtcblxuICAgICAgICBpZiAoIW1vZC4kJGlzX21vZHVsZSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICAgIH1cblxuICAgICAgICAje2Btb2RgLmFwcGVuZF9mZWF0dXJlcyBgc2luZ2xldG9uYH07XG4gICAgICAgICN7YG1vZGAuZXh0ZW5kX29iamVjdCBzZWxmfTtcbiAgICAgICAgI3tgbW9kYC5leHRlbmRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgX19pZF9fXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgdG9fc1xuICBlbmRcblxuICBkZWYgaW5zdGFuY2Vfb2Y/KGtsYXNzKVxuICAgICV4e1xuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzICYmICFrbGFzcy4kJGlzX21vZHVsZSkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ2NsYXNzIG9yIG1vZHVsZSByZXF1aXJlZCd9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNsYXNzID09PSBrbGFzcztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZV9kZWZpbmVkPyhuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgT3BhbC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGYsIG5hbWUuc3Vic3RyKDEpKWBcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlX2dldChuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIHZhciBpdmFyID0gc2VsZltPcGFsLml2YXIobmFtZS5zdWJzdHIoMSkpXTtcblxuICAgICAgcmV0dXJuIGl2YXIgPT0gbnVsbCA/IG5pbCA6IGl2YXI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVfc2V0KG5hbWUsIHZhbHVlKVxuICAgIG5hbWUgPSBPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgc2VsZltPcGFsLml2YXIobmFtZS5zdWJzdHIoMSkpXSA9IHZhbHVlYFxuICBlbmRcblxuICBkZWYgcmVtb3ZlX2luc3RhbmNlX3ZhcmlhYmxlKG5hbWUpXG4gICAgbmFtZSA9IE9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgICV4e1xuICAgICAgdmFyIGtleSA9IE9wYWwuaXZhcihuYW1lLnN1YnN0cigxKSksXG4gICAgICAgICAgdmFsO1xuICAgICAgaWYgKHNlbGYuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YWwgPSBzZWxmW2tleV07XG4gICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmFpc2UgTmFtZUVycm9yLCBcImluc3RhbmNlIHZhcmlhYmxlICN7bmFtZX0gbm90IGRlZmluZWRcIlxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGl2YXI7XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gc2VsZikge1xuICAgICAgICBpZiAoc2VsZi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBuYW1lLmNoYXJBdCgwKSAhPT0gJyQnKSB7XG4gICAgICAgICAgaWYgKG5hbWUuc3Vic3RyKC0xKSA9PT0gJyQnKSB7XG4gICAgICAgICAgICBpdmFyID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdmFyID0gbmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2goJ0AnICsgaXZhcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBJbnRlZ2VyKHZhbHVlLCBiYXNlID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGksIHN0ciwgYmFzZV9kaWdpdHM7XG5cbiAgICAgIGlmICghdmFsdWUuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKGJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2Jhc2Ugc3BlY2lmaWVkIGZvciBub24gc3RyaW5nIHZhbHVlJ31cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgbmlsIGludG8gSW50ZWdlclwifVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS4kJGlzX251bWJlcikge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkgfHwgdmFsdWUgPT09IC1JbmZpbml0eSB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7cmFpc2UgRmxvYXREb21haW5FcnJvciwgdmFsdWV9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyg6dG9faW50KX0pIHtcbiAgICAgICAgICBpID0gI3t2YWx1ZS50b19pbnR9O1xuICAgICAgICAgIGlmIChpICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gI3tPcGFsLmNvZXJjZV90byEodmFsdWUsIEludGVnZXIsIDp0b19pKX07XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gXCIwXCIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYmFzZSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlID0gJGNvZXJjZV90byhiYXNlLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGlmIChiYXNlID09PSAxIHx8IGJhc2UgPCAwIHx8IGJhc2UgPiAzNikge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YmFzZX1cIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHIgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFxcZClfKD89XFxkKS9nLCAnJDEnKTtcblxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL14oXFxzKlsrLV0/KSgwW2JvZHhdPykvLCBmdW5jdGlvbiAoXywgaGVhZCwgZmxhZykge1xuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgY2FzZSAnMGInOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDIpIHtcbiAgICAgICAgICAgIGJhc2UgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgY2FzZSAnMG8nOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDgpIHtcbiAgICAgICAgICAgIGJhc2UgPSA4O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICcwZCc6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMTApIHtcbiAgICAgICAgICAgIGJhc2UgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnMHgnOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDE2KSB7XG4gICAgICAgICAgICBiYXNlID0gMTY7XG4gICAgICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEludGVnZXIoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgfSk7XG5cbiAgICAgIGJhc2UgPSAoYmFzZSA9PT0gMCA/IDEwIDogYmFzZSk7XG5cbiAgICAgIGJhc2VfZGlnaXRzID0gJzAtJyArIChiYXNlIDw9IDEwID8gYmFzZSAtIDEgOiAnOWEtJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyAoYmFzZSAtIDExKSkpO1xuXG4gICAgICBpZiAoIShuZXcgUmVnRXhwKCdeXFxcXHMqWystXT9bJyArIGJhc2VfZGlnaXRzICsgJ10rXFxcXHMqJCcpKS50ZXN0KHN0cikpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEludGVnZXIoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgfVxuXG4gICAgICBpID0gcGFyc2VJbnQoc3RyLCBiYXNlKTtcblxuICAgICAgaWYgKGlzTmFOKGkpKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBJbnRlZ2VyKCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgRmxvYXQodmFsdWUpXG4gICAgJXh7XG4gICAgICB2YXIgc3RyO1xuXG4gICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IG5pbCBpbnRvIEZsb2F0XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS4kJGlzX3N0cmluZykge1xuICAgICAgICBzdHIgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csICckMScpO1xuXG4gICAgICAgIC8vU3BlY2lhbCBjYXNlIGZvciBoZXggc3RyaW5ncyBvbmx5OlxuICAgICAgICBpZiAoL15cXHMqWy0rXT8wW3hYXVswLTlhLWZBLUZdK1xccyokLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICByZXR1cm4gI3tJbnRlZ2VyKGBzdHJgKX07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIS9eXFxzKlstK10/WzAtOV0qXFwuP1swLTldKyhbZUVdWy0rXT9bMC05XSspP1xccyokLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgRmxvYXQoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7T3BhbC5jb2VyY2VfdG8hKHZhbHVlLCBGbG9hdCwgOnRvX2YpfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBIYXNoKGFyZylcbiAgICByZXR1cm4ge30gaWYgYXJnLm5pbD8gfHwgYXJnID09IFtdXG4gICAgcmV0dXJuIGFyZyBpZiBIYXNoID09PSBhcmdcbiAgICBPcGFsLmNvZXJjZV90byEoYXJnLCBIYXNoLCA6dG9faGFzaClcbiAgZW5kXG5cbiAgZGVmIGlzX2E/KGtsYXNzKVxuICAgICV4e1xuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzICYmICFrbGFzcy4kJGlzX21vZHVsZSkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ2NsYXNzIG9yIG1vZHVsZSByZXF1aXJlZCd9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gT3BhbC5pc19hKHNlbGYsIGtsYXNzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpdHNlbGZcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGtpbmRfb2Y/IGlzX2E/XG5cbiAgZGVmIGxhbWJkYSgmYmxvY2spXG4gICAgYE9wYWwubGFtYmRhKGJsb2NrKWBcbiAgZW5kXG5cbiAgZGVmIGxvYWQoZmlsZSlcbiAgICBmaWxlID0gT3BhbC5jb2VyY2VfdG8hKGZpbGUsIFN0cmluZywgOnRvX3N0cilcbiAgICBgT3BhbC5sb2FkKCN7ZmlsZX0pYFxuICBlbmRcblxuICBkZWYgbG9vcFxuICAgIHJldHVybiBlbnVtX2Zvcig6bG9vcCkgeyBGbG9hdDo6SU5GSU5JVFkgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICB3aGlsZSB0cnVlXG4gICAgICBiZWdpblxuICAgICAgICB5aWVsZFxuICAgICAgcmVzY3VlIFN0b3BJdGVyYXRpb24gPT4gZVxuICAgICAgICByZXR1cm4gZS5yZXN1bHRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbmlsP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cblxuICBkZWYgcHJpbnRmKCphcmdzKVxuICAgIGlmIGFyZ3MuYW55P1xuICAgICAgcHJpbnQgZm9ybWF0KCphcmdzKVxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBwcm9jKCZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjcmVhdGUgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYGJsb2NrLiQkaXNfbGFtYmRhID0gZmFsc2VgXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIHB1dHMoKnN0cnMpXG4gICAgJHN0ZG91dC5wdXRzKCpzdHJzKVxuICBlbmRcblxuICBkZWYgcCgqYXJncylcbiAgICBhcmdzLmVhY2ggeyB8b2JqfCAkc3Rkb3V0LnB1dHMgb2JqLmluc3BlY3QgfVxuXG4gICAgYXJncy5sZW5ndGggPD0gMSA/IGFyZ3NbMF0gOiBhcmdzXG4gIGVuZFxuXG4gIGRlZiBwcmludCgqc3RycylcbiAgICAkc3Rkb3V0LnByaW50KCpzdHJzKVxuICBlbmRcblxuICBkZWYgd2Fybigqc3RycywgdXBsZXZlbDogbmlsKVxuICAgIGlmIHVwbGV2ZWxcbiAgICAgIHVwbGV2ZWwgPSBPcGFsLmNvZXJjZV90byEodXBsZXZlbCwgSW50ZWdlciwgOnRvX3N0cilcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwibmVnYXRpdmUgbGV2ZWwgKCN7dXBsZXZlbH0pXCIgaWYgdXBsZXZlbCA8IDBcbiAgICAgIGxvY2F0aW9uID0gY2FsbGVyKHVwbGV2ZWwgKyAyLCAxKS5maXJzdFxuICAgICAgbG9jYXRpb24gPSBcIiN7bG9jYXRpb259OiBcIiBpZiBsb2NhdGlvblxuICAgICAgc3RycyA9IHN0cnMubWFwIHsgfHN8IFwiI3tsb2NhdGlvbn13YXJuaW5nOiAje3N9XCIgfVxuICAgIGVuZFxuXG4gICAgJHN0ZGVyci5wdXRzKCpzdHJzKSB1bmxlc3MgJFZFUkJPU0UubmlsPyB8fCBzdHJzLmVtcHR5P1xuICBlbmRcblxuICBkZWYgcmFpc2UoZXhjZXB0aW9uID0gdW5kZWZpbmVkLCBzdHJpbmcgPSBuaWwsIF9iYWNrdHJhY2UgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoZXhjZXB0aW9uID09IG51bGwgJiYgI3skIX0gIT09IG5pbCkge1xuICAgICAgICB0aHJvdyAjeyQhfTtcbiAgICAgIH1cbiAgICAgIGlmIChleGNlcHRpb24gPT0gbnVsbCkge1xuICAgICAgICBleGNlcHRpb24gPSAje1J1bnRpbWVFcnJvci5uZXd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7UnVudGltZUVycm9yLm5ldyBleGNlcHRpb259O1xuICAgICAgfVxuICAgICAgLy8gdXNpbmcgcmVzcG9uZF90bz8gYW5kIG5vdCBhbiB1bmRlZmluZWQgY2hlY2sgdG8gYXZvaWQgbWV0aG9kX21pc3NpbmcgbWF0Y2hpbmcgYXMgdHJ1ZVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfY2xhc3MgJiYgI3tleGNlcHRpb24ucmVzcG9uZF90bz8oOmV4Y2VwdGlvbil9KSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7ZXhjZXB0aW9uLmV4Y2VwdGlvbiBzdHJpbmd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3tleGNlcHRpb24uaXNfYT8oRXhjZXB0aW9uKX0pIHtcbiAgICAgICAgLy8gZXhjZXB0aW9uIGlzIGZpbmVcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBleGNlcHRpb24gPSAje1R5cGVFcnJvci5uZXcgJ2V4Y2VwdGlvbiBjbGFzcy9vYmplY3QgZXhwZWN0ZWQnfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7JCF9ICE9PSBuaWwpIHtcbiAgICAgICAgT3BhbC5leGNlcHRpb25zLnB1c2goI3skIX0pO1xuICAgICAgfVxuXG4gICAgICAjeyQhfSA9IGV4Y2VwdGlvbjtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZmFpbCByYWlzZVxuXG4gIGRlZiByYW5kKG1heCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gI3tSYW5kb206OkRFRkFVTFQucmFuZH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXguJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKG1heCA8IDApIHtcbiAgICAgICAgICBtYXggPSBNYXRoLmFicyhtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heCAlIDEgIT09IDApIHtcbiAgICAgICAgICBtYXggPSBtYXguJHRvX2koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXggPT09IDApIHtcbiAgICAgICAgICBtYXggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgUmFuZG9tOjpERUZBVUxULnJhbmQobWF4KVxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90bz8obmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICAleHtcbiAgICAgIHZhciBib2R5ID0gc2VsZlsnJCcgKyBuYW1lXTtcblxuICAgICAgaWYgKHR5cGVvZihib2R5KSA9PT0gXCJmdW5jdGlvblwiICYmICFib2R5LiQkc3R1Yikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGZbJyRyZXNwb25kX3RvX21pc3Npbmc/J10uJCRwcmlzdGluZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tyZXNwb25kX3RvX21pc3Npbmc/KG5hbWUsIGluY2x1ZGVfYWxsKX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90b19taXNzaW5nPyhtZXRob2RfbmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICBmYWxzZVxuICBlbmRcblxuICBPcGFsLnByaXN0aW5lKHNlbGYsIDpyZXNwb25kX3RvPywgOnJlc3BvbmRfdG9fbWlzc2luZz8pXG5cbiAgZGVmIHJlcXVpcmUoZmlsZSlcbiAgICBmaWxlID0gT3BhbC5jb2VyY2VfdG8hKGZpbGUsIFN0cmluZywgOnRvX3N0cilcbiAgICBgT3BhbC5yZXF1aXJlKCN7ZmlsZX0pYFxuICBlbmRcblxuICBkZWYgcmVxdWlyZV9yZWxhdGl2ZShmaWxlKVxuICAgIE9wYWwudHJ5X2NvbnZlcnQhKGZpbGUsIFN0cmluZywgOnRvX3N0cilcbiAgICBmaWxlID0gRmlsZS5leHBhbmRfcGF0aCBGaWxlLmpvaW4oYE9wYWwuY3VycmVudF9maWxlYCwgJy4uJywgZmlsZSlcblxuICAgIGBPcGFsLnJlcXVpcmUoI3tmaWxlfSlgXG4gIGVuZFxuXG4gICMgYHBhdGhgIHNob3VsZCBiZSB0aGUgZnVsbCBwYXRoIHRvIGJlIGZvdW5kIGluIHJlZ2lzdGVyZWQgbW9kdWxlcyAoYE9wYWwubW9kdWxlc2ApXG4gIGRlZiByZXF1aXJlX3RyZWUocGF0aClcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgcGF0aCA9ICN7RmlsZS5leHBhbmRfcGF0aChwYXRoKX1cbiAgICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgIGlmIChwYXRoID09PSAnLicpIHBhdGggPSAnJztcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gT3BhbC5tb2R1bGVzKSB7XG4gICAgICAgIGlmICgje2BuYW1lYC5zdGFydF93aXRoPyhwYXRoKX0pIHtcbiAgICAgICAgICByZXN1bHQucHVzaChbbmFtZSwgT3BhbC5yZXF1aXJlKG5hbWUpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNlbmQgICAgICAgIF9fc2VuZF9fXG4gIGFsaWFzIHB1YmxpY19zZW5kIF9fc2VuZF9fXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIGBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBzbGVlcChzZWNvbmRzID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKHNlY29uZHMgPT09IG5pbCkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IE5pbENsYXNzIGludG8gdGltZSBpbnRlcnZhbFwifVxuICAgICAgfVxuICAgICAgaWYgKCFzZWNvbmRzLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWNvbmRzLmNsYXNzfSBpbnRvIHRpbWUgaW50ZXJ2YWxcIn1cbiAgICAgIH1cbiAgICAgIGlmIChzZWNvbmRzIDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd0aW1lIGludGVydmFsIG11c3QgYmUgcG9zaXRpdmUnfVxuICAgICAgfVxuICAgICAgdmFyIGdldF90aW1lID0gT3BhbC5nbG9iYWwucGVyZm9ybWFuY2UgP1xuICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9IDpcbiAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIG5ldyBEYXRlKCl9XG5cbiAgICAgIHZhciB0ID0gZ2V0X3RpbWUoKTtcbiAgICAgIHdoaWxlIChnZXRfdGltZSgpIC0gdCA8PSBzZWNvbmRzICogMTAwMCk7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChzZWNvbmRzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzcmFuZChzZWVkID0gUmFuZG9tLm5ld19zZWVkKVxuICAgIFJhbmRvbS5zcmFuZChzZWVkKVxuICBlbmRcblxuICBkZWYgU3RyaW5nKHN0cilcbiAgICBPcGFsLmNvZXJjZV90bz8oc3RyLCBTdHJpbmcsIDp0b19zdHIpIHx8XG4gICAgICBPcGFsLmNvZXJjZV90byEoc3RyLCBTdHJpbmcsIDp0b19zKVxuICBlbmRcblxuICBkZWYgdGFwKCZibG9jaylcbiAgICB5aWVsZCBzZWxmXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiM8I3tzZWxmLmNsYXNzfToweCN7X19pZF9fLnRvX3MoMTYpfT5cIlxuICBlbmRcblxuICBkZWYgY2F0Y2goc3ltKVxuICAgIHlpZWxkXG4gIHJlc2N1ZSBVbmNhdWdodFRocm93RXJyb3IgPT4gZVxuICAgIHJldHVybiBlLmFyZyBpZiBlLnN5bSA9PSBzeW1cbiAgICByYWlzZVxuICBlbmRcblxuICBkZWYgdGhyb3coKmFyZ3MpXG4gICAgcmFpc2UgVW5jYXVnaHRUaHJvd0Vycm9yLCBhcmdzXG4gIGVuZFxuXG4gICMgYmFzaWMgaW1wbGVtZW50YXRpb24gb2Ygb3BlbiwgZGVsZWdhdGUgdG8gRmlsZS5vcGVuXG4gIGRlZiBvcGVuKCphcmdzLCAmYmxvY2spXG4gICAgRmlsZS5vcGVuKCphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB5aWVsZF9zZWxmXG4gICAgcmV0dXJuIGVudW1fZm9yKDp5aWVsZF9zZWxmKSB7IDEgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgeWllbGQgc2VsZlxuICBlbmRcblxuICBhbGlhcyB0aGVuIHlpZWxkX3NlbGZcblxuICBPcGFsLnByaXN0aW5lKHNlbGYsIDptZXRob2RfbWlzc2luZylcbmVuZFxuXG5jbGFzcyBPYmplY3RcbiAgaW5jbHVkZSBLZXJuZWxcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsIm1ldGhvZF9taXNzaW5nIiwicmFpc2UiLCJuZXciLCJzeW1ib2wiLCJpbnNwZWN0IiwiYXJncyIsIj1+IiwiIX4iLCJzZWxmIiwib2JqIiwiISIsIj09PSIsIiRyZXRfb3JfMSIsIm9iamVjdF9pZCIsIj09Iiwib3RoZXIiLCI8PT4iLCJtZXRob2QiLCJuYW1lIiwiY2xhc3MiLCJtZXRob2RzIiwiYWxsIiwicHVibGljX21ldGhvZHMiLCJBcnJheSIsImNvZXJjZV90bz8iLCJvYmplY3QiLCJhdF9leGl0IiwiJF9fYXRfZXhpdF9fIiwiJHJldF9vcl8yIiwiPDwiLCJibG9jayIsImNhbGxlciIsIjEiLCJjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJjbG9uZSIsImNvcHkiLCJhbGxvY2F0ZSIsImluaXRpYWxpemVfY2xvbmUiLCJpbml0aWFsaXplX2NvcHkiLCJkZWZpbmVfc2luZ2xldG9uX21ldGhvZCIsImRlZmluZV9tZXRob2QiLCJzaW5nbGV0b25fY2xhc3MiLCJkdXAiLCJpbml0aWFsaXplX2R1cCIsImVudW1fZm9yIiwiZm9yIiwiZXF1YWw/IiwiZXhpdCIsIiRyZXRfb3JfMyIsImVtcHR5PyIsInBvcCIsImNhbGwiLCJleHRlbmQiLCJhcHBlbmRfZmVhdHVyZXMiLCJleHRlbmRfb2JqZWN0IiwiZXh0ZW5kZWQiLCJoYXNoIiwiX19pZF9fIiwidG9fcyIsImluc3RhbmNlX29mPyIsImluc3RhbmNlX3ZhcmlhYmxlX2RlZmluZWQ/IiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJpbnN0YW5jZV92YXJpYWJsZV9nZXQiLCJpbnN0YW5jZV92YXJpYWJsZV9zZXQiLCJyZW1vdmVfaW5zdGFuY2VfdmFyaWFibGUiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJJbnRlZ2VyIiwidmFsdWUiLCJyZXNwb25kX3RvPyIsInRvX2ludCIsImNvZXJjZV90byEiLCJiYXNlIiwiRmxvYXQiLCJIYXNoIiwiJHJldF9vcl80IiwiYXJnIiwibmlsPyIsImlzX2E/IiwiaXRzZWxmIiwibGFtYmRhIiwibG9hZCIsImZpbGUiLCJsb29wIiwiYmxvY2tfZ2l2ZW4/IiwiZSIsInJlc3VsdCIsInByaW50ZiIsImFueT8iLCJwcmludCIsImZvcm1hdCIsInByb2MiLCJwdXRzIiwiJHN0ZG91dCIsInN0cnMiLCJwIiwiZWFjaCIsIjw9IiwibGVuZ3RoIiwiW10iLCIwIiwid2FybiIsInVwbGV2ZWwiLCI8IiwibG9jYXRpb24iLCIrIiwiMiIsImZpcnN0IiwibWFwIiwicyIsIiRyZXRfb3JfNSIsIiRWRVJCT1NFIiwiJHN0ZGVyciIsIiQhIiwiZXhjZXB0aW9uIiwic3RyaW5nIiwicmFuZCIsIm1heCIsInJlc3BvbmRfdG9fbWlzc2luZz8iLCJpbmNsdWRlX2FsbCIsInByaXN0aW5lIiwicmVxdWlyZSIsInJlcXVpcmVfcmVsYXRpdmUiLCJ0cnlfY29udmVydCEiLCJleHBhbmRfcGF0aCIsImpvaW4iLCJyZXF1aXJlX3RyZWUiLCJwYXRoIiwic3RhcnRfd2l0aD8iLCJzbGVlcCIsInNlY29uZHMiLCJzcmFuZCIsIm5ld19zZWVkIiwic2VlZCIsIlN0cmluZyIsIiRyZXRfb3JfNiIsInN0ciIsInRhcCIsInRvX3Byb2MiLCIxNiIsImNhdGNoIiwic3ltIiwidGhyb3ciLCJvcGVuIiwieWllbGRfc2VsZiIsImluY2x1ZGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUVBLEVBQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRTtBQUFBQyxJQUFBQSxrQ0FBQUEsMkJBQUFBLDBCQUFtQixNQUFELEVBSnBCLEVBSUVBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQUpGO0FBSW9DLE1BQUEsK0NBSnBDO0FBQUE7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUFJNkIsTUFBQSxrQkFKN0I7QUFBQSxNQUtJLFdBQUFDLE9BQUFBLENBQU0sNkJBQUFDLEtBQUFBLENBQWtCLEVBQUEsR0FBQSxvQkFBQSxHQUFBLENBQXFCQyxNQUFyQixDQUFBLEdBQUEsUUFBQSxHQUFBLEtBQW9DQyxTQUFBQSxDQUFBQSxDQUFwQyxHQUErQ0QsUUFBUUUsSUFBekVILENBQU5ELENBTEo7QUFJRUQsSUFBQUEsQ0FBQUEsdUNBQUFBLENBQUE7QUFBQTtBQUlBTSxJQUFBQSxzQkFBQUEsc0JBQUFBLFNBQU8sR0FBUEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQTtBQURGQSxJQUFBQSxDQUFBQSxpQ0FBQUEsQ0FKQTtBQUFBO0FBUUFDLElBQUFBLHNCQUFBQSx3QkFBQUEsU0FBTyxHQUFQQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFFQyxJQUFBRixPQUFBQSxDQUFRRyxHQUFSSCxDQUFGSSxNQUFBQSxDQUFBQTtBQURGSCxJQUFBQSxDQUFBQSxtQ0FBQUEsQ0FSQTtBQUFBO0FBWUFJLElBQUFBLHVCQUFBQSxzQkFBQUEsU0FBUSxLQUFSQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxJQUFBLFFBakJKQyxDQUFBQSxnQkFpQklDLFdBQUFBLENBQUFBLENBQUFDLE9BQUFBLENBQWFDLEtBQUFGLFdBQUFBLENBQUFBLENBQWJDLENBakJKRixDQWlCSSxDQUFBO0FBQUEsUUFqQkosT0FBQTtBQWlCSSxNQUFBO0FBQUEsUUFBZ0MsT0FBQUosSUFBQU0sT0FBQUEsQ0FBUUMsS0FBUkQ7QUFBaEMsTUFBQTtBQURGSCxJQUFBQSxDQUFBQSxpQ0FBQUEsQ0FaQTtBQUFBO0FBZ0JBSyxJQUFBQSx1QkFBQUEsc0JBQUFBLFNBQVEsS0FBUkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQTs7QUFFQSxjQUFnQlIsSUFBQU0sT0FBQUEsQ0FBUUMsS0FBUkQsQ0FBYzs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFaRUUsSUFBQUEsQ0FBQUEsaUNBQUFBLENBaEJBO0FBQUE7QUErQkFDLElBQUFBLDBCQUFBQSxtQkFBQUEsa0JBQVcsSUFBWEE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7O0FBRUE7QUFDQSxZQUFVaEIsT0FBQUEsQ0FBTSx5QkFBQUMsS0FBQUEsQ0FBYyxFQUFBLEdBQUEsb0JBQUEsR0FBQSxDQUFxQmdCLElBQXJCLENBQUEsR0FBQSxlQUFBLEdBQUEsQ0FBeUNWLElBQUFXLE9BQUFBLENBQUFBLENBQXpDLENBQUEsR0FBQSxLQUF3REQsSUFBdEVoQixDQUFORCxDQUFrRjtBQUM1Rjs7QUFFQSxhQUFlLHNCQUFBQyxLQUFBQSxDQUFXTSxNQUFPLGdCQUFrQkEsSUFBQVcsT0FBQUEsQ0FBQUEsR0FBZSxNQUFPRCxJQUExRGhCLENBQWdFO0FBQy9FO0FBVEVlLElBQUFBLENBQUFBLDhCQUFBQSxDQS9CQTtBQUFBO0FBMkNBRyxJQUFBQSwyQkFBQUEsb0JBQUFBLG1CQUFZLEdBQVpBO0FBQUFBLE1BQUFBOztBQUFBQTtBQS9DRjtBQStDYyxNQUFBO0FBQUEsTUFBQSxRQUFNLElBQU47QUFBQSxNQUFBLENBL0NkO0FBQUE7QUFpREEsa0JBQW9CQyxHQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUF0REE7QUErQ0VELElBQUFBLENBQUFBLGdDQUFBQSxDQTNDQTtBQUFBO0FBcURBRSxJQUFBQSxrQ0FBQUEsMkJBQUFBLDBCQUFtQixHQUFuQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBekRGO0FBeURxQixNQUFBO0FBQUEsTUFBQSxRQUFNLElBQU47QUFBQSxNQUFBLENBekRyQjtBQUFBO0FBMkRBLGtCQUFvQkQsR0FBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBaEVBO0FBeURFQyxJQUFBQSxDQUFBQSx1Q0FBQUEsQ0FyREE7QUFBQTtBQStEQUMsSUFBQUEseUJBQUFBLGtCQUFBQSxpQkFBVSxNQUFWQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFrQixvQkFBQUMsZUFBQUEsQ0FBZ0JDLFFBQVEsdUJBQU8sUUFBL0JELENBQXdDO0FBQzFEOztBQUVBLGdCQUFrQixvQkFBQUEsZUFBQUEsQ0FBZ0JDLFFBQVEsdUJBQU8sTUFBL0JELENBQXNDO0FBQ3hEOztBQUVBO0FBQ0E7QUFuQkVELElBQUFBLENBQUFBLDZCQUFBQSxDQS9EQTtBQUFBO0FBcUZBRyxJQUFBQSwyQkFBQUEscUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTtBQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUF6RkY7QUF5RmMsTUFBQSx5Q0F6RmQ7QUFBQSxNQTBGSUMscUJBMUZKLGFBQUEsSUFBQSxRQUFBQyxDQUFBQSxZQTBGSUQsa0JBMUZKQyxDQUFBLENBQUE7QUFBQSxRQUFBLE9BQUE7QUFBQSxNQUFBO0FBQUEsUUEwRnFCLE9BQUE7QUExRnJCLE1BQUEsQ0FBQSxrQkFBQTtBQUFBLE1BMkZJRCxrQkFBQUUsT0FBQUEsQ0FBZ0JDLEtBQWhCRCxDQTNGSjtBQUFBLE1BNEZJLE9BQUFDLEtBNUZKO0FBeUZFSixJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FyRkE7QUFBQTtBQTJGQUssSUFBQUEsMEJBQUFBLG9CQUFBQSxrQkFBVyxLQUFELEVBQVksTUFBdEJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQS9GRjtBQStGYSxNQUFBO0FBQUEsTUFBQSxVQUFRQyxDQUFSO0FBQUEsTUFBQSxDQS9GYjtBQUFBO0FBK0Z3QixNQUFBO0FBQUEsTUFBQSxXQUFTLEdBQVQ7QUFBQSxNQUFBLENBL0Z4QjtBQUFBO0FBaUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBOUdBO0FBK0ZFRCxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0EzRkE7QUFBQTtBQTZHQVosSUFBQUEseUJBQUFBLG1CQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLFlBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsOEJBQUFBLENBN0dBO0FBQUE7QUFpSEFjLElBQUFBLDJDQUFBQSxxQ0FBQUEsbUNBQTRCLEtBQTVCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEVBLElBQUFBLENBQUFBLGdEQUFBQSxDQWpIQTtBQUFBO0FBNkhBQyxJQUFBQSwwQ0FBQUEsb0NBQUFBLGtDQUEyQixLQUEzQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdCRUEsSUFBQUEsQ0FBQUEsK0NBQUFBLENBN0hBO0FBQUE7QUE2SkFDLElBQUFBLHlCQUFBQSxtQkFBQUEsaUJBaktGLE9BaUtFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFqS0Y7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxDQUFBO0FBQUE7QUFpS1ksTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBLFdBQVE7QUFBUixNQUFBLENBaktaO0FBQUEsTUFrS0lDLE9BQU81QixJQUFBVyxPQUFBQSxDQUFBQSxDQUFBa0IsVUFBQUEsQ0FBQUEsQ0FsS1g7QUFBQSxNQW9LSUQsSUFBQUgseUJBQUFBLENBQTZCekIsSUFBN0J5QixDQXBLSjtBQUFBLE1BcUtJRyxJQUFBRix3QkFBQUEsQ0FBNEIxQixJQUE1QjBCLENBcktKO0FBQUEsTUFzS0lFLElBQUFFLGtCQUFBQSxDQUFzQjlCLElBQXRCOEIsQ0F0S0o7QUFBQSxNQXdLSSxPQUFBRixJQXhLSjtBQWlLRUQsSUFBQUEsQ0FBQUEsK0JBQUFBLENBN0pBO0FBQUE7QUF1S0FHLElBQUFBLG9DQUFBQSw4QkFBQUEsNEJBQXFCLEtBQXJCQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBQyxpQkFBQUEsQ0FBZ0J4QixLQUFoQndCO0FBREZELElBQUFBLENBQUFBLHlDQUFBQSxDQXZLQTtBQUFBO0FBMktBRSxJQUFBQSwyQ0FBQUEscUNBQUFBLG1DQUE0QixJQUFELEVBQU8sTUFBbENBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQS9LRjtBQStLd0QsTUFBQSx5REEvS3hEO0FBQUEsTUFBQTtBQUFBLE1BZ0xJLE9BQUFDLFVBQUFDLGlCQUFBQSxDQUFBQSxDQUFBRCxpQkFBQUEsRUFBQUEsQ0FBOEJ2QixNQUFNRCxNQUFwQ3dCLENBQUFBLEVBQTZDWCxnQkFBN0NXLENBaExKO0FBK0tFRCxJQUFBQSxDQUFBQSxpREFBQUEsQ0EzS0E7QUFBQTtBQStLQUcsSUFBQUEsdUJBQUFBLGlCQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBUCxPQUFPNUIsSUFBQVcsT0FBQUEsQ0FBQUEsQ0FBQWtCLFVBQUFBLENBQUFBLENBQVA7QUFBQSxNQUVBRCxJQUFBSCx5QkFBQUEsQ0FBNkJ6QixJQUE3QnlCLENBRkE7QUFBQSxNQUdBRyxJQUFBUSxnQkFBQUEsQ0FBb0JwQyxJQUFwQm9DLENBSEE7QUFBQSxNQUtBLE9BQUFSLElBTEE7QUFERk8sSUFBQUEsQ0FBQUEsNEJBQUFBLENBL0tBO0FBQUE7QUF3TEFDLElBQUFBLGtDQUFBQSw0QkFBQUEsMEJBQW1CLEtBQW5CQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBTCxpQkFBQUEsQ0FBZ0J4QixLQUFoQndCO0FBREZLLElBQUFBLENBQUFBLHVDQUFBQSxDQXhMQTtBQUFBO0FBNExBQyxJQUFBQSw0QkFBQUEsc0JBQUFBLG9CQWhNRixFQWdNYyxFQWhNZCxFQWdNRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBaE1GO0FBZ01zQyxNQUFBLDBDQWhNdEM7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQWdNZSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUEsV0FBUyxNQUFUO0FBQUEsTUFBQSxDQWhNZjtBQUFBO0FBZ00rQixNQUFBLGtCQWhNL0I7QUFBQSxNQWlNSSxPQUFBQyxNQUFBLDBCQUFBQSxPQUFBQSxHQUFldEMsTUFBTVMsZUFBUSxVQUFDWixJQUFELEVBQTdCeUMsRUFBcUNoQixnQkFBckNnQixDQWpNSjtBQWdNRUQsSUFBQUEsQ0FBQUEsa0NBQUFBLENBNUxBO0FBQUEsSUFnTUEsaUJBQU0sU0FBTixFQUFjLFVBQWQsQ0FoTUE7QUFBQTtBQWtNQUUsSUFBQUEsMEJBQUFBLHdCQUFBQSxTQUFXLEtBQVhBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsY0FBRDtBQURGQSxJQUFBQSxDQUFBQSxtQ0FBQUEsQ0FsTUE7QUFBQTtBQXNNQUMsSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkFBUyxNQUFUQTtBQUFBQSxNQUFBQTtBQUFBQTs7QUFBQUE7QUExTUY7QUEwTVcsTUFBQTtBQUFBLE1BQUEsV0FBUyxJQUFUO0FBQUEsTUFBQSxDQTFNWDtBQUFBLE1BMk1JckIscUJBM01KLGFBQUEsSUFBQSxRQUFBc0IsQ0FBQUEsWUEyTUl0QixrQkEzTUpzQixDQUFBLENBQUE7QUFBQSxRQUFBLE9BQUE7QUFBQSxNQUFBO0FBQUEsUUEyTXFCLE9BQUE7QUEzTXJCLE1BQUEsQ0FBQSxrQkFBQTtBQUFBLE1BNk1JLFNBQUEsUUFBTXRCLGtCQUFBdUIsV0FBQUEsQ0FBQUEsQ0FBTixDQUFBO0FBQUE7QUFDRSxRQUFBcEIsUUFBUUgsa0JBQUF3QixLQUFBQSxDQUFBQSxDQUFSO0FBQUEsUUFDQXJCLEtBQUFzQixNQUFBQSxDQUFBQSxDQURBO0FBREYsTUFBQSxDQTdNSjtBQUFBO0FBbU5BO0FBQ0E7QUFDQTtBQUNBLG9DQUFzQyx1QkFBUTtBQUM5Qzs7QUFFQTtBQUNBLElBMU5BO0FBQUEsTUEyTkksT0FBQSxHQTNOSjtBQTBNRUosSUFBQUEsQ0FBQUEsOEJBQUFBLENBdE1BO0FBQUE7QUEwTkFLLElBQUFBLDBCQUFBQSxvQkFBQUEsa0JBOU5GLEVBOE5FQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE5TkY7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUE4TmEsTUFBQSxrQkE5TmI7QUFBQTtBQWdPQSwwQkFBd0JYLGlCQUFBQSxDQUFBQSxDQUFnQjs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBLGNBQVl6QyxPQUFBQSxDQUFNLDJCQUFXLEVBQUEsR0FBQSxzQkFBQSxHQUFBLENBQXVCLENBQUMsR0FBRCxDQUFBa0IsT0FBQUEsQ0FBQUEsQ0FBdkIsQ0FBQSxHQUFBLG9CQUFqQmxCLENBQXdFO0FBQ3BGOztBQUVBLFFBQVUsQ0FBQyxHQUFELENBQUFxRCxpQkFBQUEsQ0FBdUIsU0FBdkJBLENBQWtDO0FBQzVDLFFBQVUsQ0FBQyxHQUFELENBQUFDLGVBQUFBLENBQW9CL0MsSUFBcEIrQyxDQUF5QjtBQUNuQyxRQUFVLENBQUMsR0FBRCxDQUFBQyxVQUFBQSxDQUFlaEQsSUFBZmdELENBQW9CO0FBQzlCO0FBQ0EsSUE3T0E7QUFBQSxNQStPSSxPQUFBaEQsSUEvT0o7QUE4TkU2QyxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0ExTkE7QUFBQTtBQThPQUksSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsV0FBQUMsUUFBQUEsQ0FBQUE7QUFERkQsSUFBQUEsQ0FBQUEsNkJBQUFBLENBOU9BO0FBQUE7QUFrUEFsQixJQUFBQSxtQ0FBQUEsNkJBQUFBLDJCQUFvQixLQUFwQkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BdFBGLE9BQUE7QUFzUEVBLElBQUFBLENBQUFBLHdDQUFBQSxDQWxQQTtBQUFBO0FBcVBBbkMsSUFBQUEsMkJBQUFBLHFCQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsV0FBQXVELE1BQUFBLENBQUFBO0FBREZ2RCxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FyUEE7QUFBQTtBQXlQQXdELElBQUFBLGdDQUFBQSw4QkFBQUEsU0FBaUIsS0FBakJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0EsWUFBVTNELE9BQUFBLENBQU0sMkJBQVcsMEJBQWpCQSxDQUE0QztBQUN0RDs7QUFFQTtBQUNBO0FBUEUyRCxJQUFBQSxDQUFBQSx5Q0FBQUEsQ0F6UEE7QUFBQTtBQW1RQUMsSUFBQUEsOENBQUFBLDRDQUFBQSxTQUErQixJQUEvQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQTNDLE9BQU8sb0JBQUE0Qyw0QkFBQUEsQ0FBNkI1QyxJQUE3QjRDLENBQVA7QUFBQSxNQUVBLE9BQUMsOENBQUQsQ0FGQTtBQURGRCxJQUFBQSxDQUFBQSx1REFBQUEsQ0FuUUE7QUFBQTtBQXlRQUUsSUFBQUEseUNBQUFBLG1DQUFBQSxpQ0FBMEIsSUFBMUJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUE3QyxPQUFPLG9CQUFBNEMsNEJBQUFBLENBQTZCNUMsSUFBN0I0QyxDQUFQO0FBQUE7QUFHSjs7QUFFQTtBQUNBLElBTkk7QUFERkMsSUFBQUEsQ0FBQUEsOENBQUFBLENBelFBO0FBQUE7QUFtUkFDLElBQUFBLHlDQUFBQSxtQ0FBQUEsaUNBQTBCLElBQUQsRUFBTyxLQUFoQ0E7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQTlDLE9BQU8sb0JBQUE0Qyw0QkFBQUEsQ0FBNkI1QyxJQUE3QjRDLENBQVA7QUFBQSxNQUVBLE9BQUMsdUNBQUQsQ0FGQTtBQURGRSxJQUFBQSxDQUFBQSw4Q0FBQUEsQ0FuUkE7QUFBQTtBQXlSQUMsSUFBQUEsNENBQUFBLHNDQUFBQSxvQ0FBNkIsSUFBN0JBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUEvQyxPQUFPLG9CQUFBNEMsNEJBQUFBLENBQTZCNUMsSUFBN0I0QyxDQUFQO0FBQUE7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBVkk7QUFBQSxNQVlBLFdBQUE3RCxPQUFBQSxDQUFNLDJCQUFXLEVBQUEsR0FBQSxvQkFBQSxHQUFBLENBQXFCaUIsSUFBckIsQ0FBQSxHQUFBLGNBQWpCakIsQ0FaQTtBQURGZ0UsSUFBQUEsQ0FBQUEsaURBQUFBLENBelJBO0FBQUE7QUF5U0FDLElBQUFBLHNDQUFBQSxnQ0FBQUEsOEJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFoQkVBLElBQUFBLENBQUFBLDJDQUFBQSxDQXpTQTtBQUFBO0FBNFRBQyxJQUFBQSwyQkFBQUEscUJBQUFBLG1CQUFZLEtBQUQsRUFBUSxJQUFuQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBaFVGLE1BQUE7QUFBQTtBQWtVQTs7QUFFQTtBQUNBO0FBQ0EsY0FBWWxFLE9BQUFBLENBQU0sK0JBQWUscUNBQXJCQTtBQUNaO0FBQ0E7QUFDQSxjQUFZQSxPQUFBQSxDQUFNLDJCQUFXLGdDQUFqQkE7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQkFBY0EsT0FBQUEsQ0FBTSxrQ0FBa0JtRSxLQUF4Qm5FO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBY21FLEtBQUFDLGdCQUFBQSxDQUFrQixRQUFsQkEsQ0FBMkI7QUFDekMsY0FBZ0JELEtBQUFFLFFBQUFBLENBQUFBLENBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFpQixvQkFBQUMsZUFBQUEsQ0FBZ0JILE9BQU8seUJBQVMsTUFBaENHLENBQXVDO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBa0MsdUJBQVE7QUFDMUM7QUFDQSxjQUFZdEUsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsZ0JBQUEsR0FBQSxDQUFpQnVFLElBQWpCLENBQXJCdkU7QUFDWjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVVBLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLGlDQUFBLEdBQUEsQ0FBa0NtRSxLQUFsQyxDQUFBLEdBQUEsSUFBckJuRTtBQUNWOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsWUFBVUEsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsaUNBQUEsR0FBQSxDQUFrQ21FLEtBQWxDLENBQUEsR0FBQSxJQUFyQm5FO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQSxZQUFVQSxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSxpQ0FBQSxHQUFBLENBQWtDbUUsS0FBbEMsQ0FBQSxHQUFBLElBQXJCbkU7QUFDVjs7QUFFQTtBQUNBLElBclpBO0FBZ1VFa0UsSUFBQUEsQ0FBQUEsaUNBQUFBLENBNVRBO0FBQUE7QUFvWkFNLElBQUFBLHlCQUFBQSxtQkFBQUEsaUJBQVUsS0FBVkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7O0FBRUE7QUFDQSxZQUFVeEUsT0FBQUEsQ0FBTSwyQkFBVyw4QkFBakJBO0FBQ1Y7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW1Ca0UsU0FBQUEsQ0FBUyxHQUFUQSxDQUFlO0FBQ2xDOztBQUVBO0FBQ0EsY0FBWWxFLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLCtCQUFBLEdBQUEsQ0FBZ0NtRSxLQUFoQyxDQUFBLEdBQUEsSUFBckJuRTtBQUNaOztBQUVBO0FBQ0E7O0FBRUEsYUFBZSxvQkFBQXNFLGVBQUFBLENBQWdCSCxPQUFPLHVCQUFPLE1BQTlCRyxDQUFxQztBQUNwRDtBQTFCRUUsSUFBQUEsQ0FBQUEsOEJBQUFBLENBcFpBO0FBQUE7QUFpYkFDLElBQUFBLHdCQUFBQSxrQkFBQUEsZ0JBQVMsR0FBVEE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQSxJQUFBLFFBQWEsYUFBQSxJQUFBLFFBdGJqQkMsQ0FBQUEsWUFzYmlCQyxHQUFBQyxTQUFBQSxDQUFBQSxDQXRiakJGLENBc2JpQixDQUFBO0FBQUEsUUF0YmpCLE9BQUE7QUFzYmlCLE1BQUE7QUFBQSxRQUFZLE9BQUFDLEdBQUE5RCxPQUFBQSxDQUFPLEVBQVBBO0FBQVosTUFBQSxDQUFBLGtCQUFiLENBQUE7QUFBQSxRQUFBLE9BQU8sWUFBQSxFQUFQLENBQUE7QUFBQSxNQUNBLElBQUEsUUFBYyxvQkFBQUgsUUFBQUEsQ0FBU2lFLEdBQVRqRSxDQUFkLENBQUE7QUFBQSxRQUFBLE9BQU9pRSxHQUFQLENBREE7QUFBQSxNQUVBLE9BQUEsb0JBQUFMLGVBQUFBLENBQWdCSyxLQUFLLHNCQUFNLFNBQTNCTCxDQUZBO0FBREZHLElBQUFBLENBQUFBLDZCQUFBQSxDQWpiQTtBQUFBO0FBdWJBSSxJQUFBQSx5QkFBQUEsdUJBQUFBLFNBQVUsS0FBVkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQSxZQUFVN0UsT0FBQUEsQ0FBTSwyQkFBVywwQkFBakJBLENBQTRDO0FBQ3REOztBQUVBO0FBQ0E7QUFQRTZFLElBQUFBLENBQUFBLGtDQUFBQSxDQXZiQTtBQUFBO0FBaWNBQyxJQUFBQSwwQkFBQUEsb0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBdkU7QUFERnVFLElBQUFBLENBQUFBLCtCQUFBQSxDQWpjQTtBQUFBLElBcWNBLGlCQUFNLFVBQU4sRUFBZSxPQUFmLENBcmNBO0FBQUE7QUF1Y0FDLElBQUFBLDBCQUFBQSxvQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQTNjRjtBQTJjYSxNQUFBLHdDQTNjYjtBQUFBLE1BNGNJLE9BQUMsa0JBQUQsQ0E1Y0o7QUEyY0VBLElBQUFBLENBQUFBLCtCQUFBQSxDQXZjQTtBQUFBO0FBMmNBQyxJQUFBQSx3QkFBQUEsa0JBQUFBLGdCQUFTLElBQVRBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFDLE9BQU8sb0JBQUFYLGVBQUFBLENBQWdCVyxNQUFNLHdCQUFRLFFBQTlCWCxDQUFQO0FBQUEsTUFDQSxPQUFDLFVBQVlXLElBQUssQ0FEbEI7QUFERkQsSUFBQUEsQ0FBQUEsNkJBQUFBLENBM2NBO0FBQUE7QUFnZEFFLElBQUFBLHdCQUFBQSxrQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQUNFLE1BQUEsSUFBa0RDLGdCQUFsRDtBQUFBLE1BQUE7QUFBQSxRQUFBLE9BQU92QyxVQUFBQSxZQUFBQSxFQUFBQSxDQUFTLE1BQVRBLENBQUFBLEVBcmRYLGlCQUFBLEVBQUE7O0FBQUEsUUFxZDZCLE9BQUEsSUFBQSxxQkFBQSxhQXJkN0IsbUJBQUEsa0JBQUEsTUFxZFdBO0FBQVAsTUFBQSxDQUFBO0FBQUEsTUFFQSxPQUFBLFFBQU0sSUFBTixDQUFBO0FBQUE7QUFDRSxRQUNFO0FBQUEsVUFBQSxxQkFBQTtBQUFBLFFBQUE7QUFBQSxVQUNGLHNCQUFPLENBQUEsNkJBQUEsQ0FBUCxJQUF3QndDLENBQUFBLFFBQUFBO0FBQXhCLFlBQUE7QUFBQSxjQUNFLE9BQU9BLENBQUFDLFFBQUFBLENBQUFBO0FBRFQsWUFBQTtBQUFBLFVBQUEsQ0FERTtBQUFBLFFBQUEsQ0FERjtBQURGLE1BQUEsQ0FGQTtBQUFBLE1BVUEsT0FBQTlFLElBVkE7QUFERjJFLElBQUFBLENBQUFBLDZCQUFBQSxDQWhkQTtBQUFBO0FBOGRBTixJQUFBQSx3QkFBQUEsc0JBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUE7QUFERkEsSUFBQUEsQ0FBQUEsaUNBQUFBLENBOWRBO0FBQUEsSUFrZUEsaUJBQU0sV0FBTixFQUFnQixRQUFoQixDQWxlQTtBQUFBO0FBb2VBVSxJQUFBQSwwQkFBQUEsb0JBQUFBLGtCQXhlRixFQXdlRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBeGVGO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBd2VhLE1BQUEsa0JBeGViO0FBQUEsTUF5ZUksSUFBQSxRQUFHbEYsSUFBQW1GLFNBQUFBLENBQUFBLENBQUgsQ0FBQTtBQUFBLFlBQ0VDLE9BQUFBLENBQU1DLFVBQUFBLFVBQUFBLEVBQU8sVUFBQ3JGLElBQUQsQ0FBUHFGLENBQU5ELENBREYsQ0F6ZUo7QUFBQSxNQTZlSSxPQUFBLEdBN2VKO0FBd2VFRixJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FwZUE7QUFBQTtBQTRlQUksSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBaGZGO0FBZ2ZXLE1BQUEsc0NBaGZYO0FBQUEsTUFpZkksSUFBQSxRQUFPN0QsS0FBUCxDQUFBO0FBQUEsTUFBQTtBQUFBLFlBQ0U3QixPQUFBQSxDQUFNLCtCQUFlLDZDQUFyQkE7QUFERixNQUFBLENBamZKO0FBQUEsTUFxZksseUJBcmZMO0FBQUEsTUFzZkksT0FBQTZCLEtBdGZKO0FBZ2ZFNkQsSUFBQUEsQ0FBQUEsNkJBQUFBLENBNWVBO0FBQUE7QUFxZkFDLElBQUFBLHdCQUFBQSxrQkFBQUEsZ0JBemZGLEVBeWZFQTtBQUFBQSxNQUFBQTtBQUFBQTs7QUFBQUE7QUF6ZkY7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUF5ZlcsTUFBQSxrQkF6Zlg7QUFBQSxNQTBmSSxPQUFBQSxNQUFBQyxhQUFBRCxRQUFBQSxFQUFhLFVBQUNFLElBQUQsQ0FBYkYsQ0ExZko7QUF5ZkVBLElBQUFBLENBQUFBLDhCQUFBQSxDQXJmQTtBQUFBO0FBeWZBRyxJQUFBQSxxQkFBQUEsZUFBQUEsYUE3ZkYsRUE2ZkVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQTdmRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQTZmUSxNQUFBLGtCQTdmUjtBQUFBLE1BOGZJQyxNQUFBM0YsSUFBQTJGLFFBQUFBLEVBQUFBLEVBQUFBLEVBOWZKLGlCQThmaUIsR0E5ZmpCLEVBQUE7QUFBQTs7QUFBQTtBQUFBO0FBOGZpQixRQUFBO0FBQUEsUUFBQTtBQUFBLFFBQUEsQ0E5ZmpCO0FBQUEsUUE4ZnNCLE9BQUFILGFBQUFELE1BQUFBLENBQWFuRixHQUFBTCxTQUFBQSxDQUFBQSxDQUFid0YsQ0E5ZnRCLENBQUEsbUJBQUEsa0JBQUEsTUE4ZklJLENBOWZKO0FBQUEsTUFnZ0JJLElBQUEsUUFBQUMsT0FBQTVGLElBQUE2RixRQUFBQSxDQUFBQSxDQUFBRCxFQUFlakUsQ0FBZmlFLENBQUEsQ0FBQTtBQUFBLFFBQW1CLE9BQUE1RixJQUFBOEYsT0FBQUEsQ0FBS0MsQ0FBTEQ7QUFBbkIsTUFBQTtBQUFBLFFBQTZCLE9BQUE5RjtBQUE3QixNQUFBLENBaGdCSjtBQTZmRTBGLElBQUFBLENBQUFBLDJCQUFBQSxDQXpmQTtBQUFBO0FBK2ZBTixJQUFBQSx5QkFBQUEsbUJBQUFBLGlCQW5nQkYsRUFtZ0JFQTtBQUFBQSxNQUFBQTtBQUFBQTs7QUFBQUE7QUFuZ0JGO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBbWdCWSxNQUFBLGtCQW5nQlo7QUFBQSxNQW9nQkksT0FBQUEsTUFBQUksYUFBQUosU0FBQUEsRUFBYyxVQUFDSyxJQUFELENBQWRMLENBcGdCSjtBQW1nQkVBLElBQUFBLENBQUFBLCtCQUFBQSxDQS9mQTtBQUFBO0FBbWdCQVksSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkF2Z0JGLEVBdWdCVSxFQXZnQlYsRUF1Z0JFQTtBQUFBQSxNQUFBQTtBQUFBQTtBQUFBQTs7QUFBQUE7QUF2Z0JGO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBQUEsTUFBQSx5Q0FBQTtBQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUEsQ0FBQTtBQUFBO0FBdWdCVyxNQUFBLGtCQXZnQlg7QUFBQTtBQXVnQmtCLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxZQUFTO0FBQVQsTUFBQSxDQXZnQmxCO0FBQUEsTUF3Z0JJLElBQUEsUUFBR0MsT0FBSCxDQUFBO0FBQUE7QUFDRSxRQUFBQSxVQUFVLG9CQUFBL0IsZUFBQUEsQ0FBZ0IrQixTQUFTLHlCQUFTLFFBQWxDL0IsQ0FBVjtBQUFBLFFBQ0EsSUFBQSxRQUFzRGdDLE9BQUFELE9BQUFDLEVBQVVILENBQVZHLENBQXRELENBQUE7QUFBQSxjQUFBdEcsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsa0JBQUEsR0FBQSxDQUFtQnFHLE9BQW5CLENBQUEsR0FBQSxHQUFyQnJHLENBQUEsQ0FEQTtBQUFBLFFBRUF1RyxlQUFXekUsUUFBQUEsQ0FBTzBFLFNBQUFILE9BQUFHLEVBQVVDLENBQVZELEdBQWF6RSxDQUFwQkQsQ0FBQTRFLE9BQUFBLENBQUFBLENBRlg7QUFBQSxRQUdBLElBQUEsUUFBOEJILFFBQTlCLENBQUE7QUFBQSxVQUFBQSxXQUFXLEVBQUEsR0FBQSxDQUFHQSxRQUFILENBQUEsR0FBQSxJQUFYLENBSEE7QUFBQSxRQUlBVixPQUFPYyxNQUFBZCxJQUFBYyxPQUFBQSxFQUFBQSxFQUFBQSxFQTdnQmIsaUJBNmdCeUIsQ0E3Z0J6QixFQUFBOztBQUFBO0FBQUE7QUE2Z0J5QixVQUFBO0FBQUEsVUFBQTtBQUFBLFVBQUEsQ0E3Z0J6QjtBQUFBLFVBNmdCNEIsT0FBQSxFQUFBLEdBQUEsQ0FBR0osUUFBSCxDQUFBLEdBQUEsV0FBQSxHQUFBLENBQXVCSyxDQUF2QixDQTdnQjVCLENBQUEsbUJBQUEsa0JBQUEsTUE2Z0JhRCxDQUpQLENBREYsQ0F4Z0JKO0FBQUEsTUFnaEJJLElBQUEsUUFBMkIsYUFBQSxJQUFBLFFBaGhCL0JFLENBQUFBLFlBZ2hCK0JDLGNBQUFsQyxTQUFBQSxDQUFBQSxDQWhoQi9CaUMsQ0FnaEIrQixDQUFBO0FBQUEsUUFoaEIvQixPQUFBO0FBZ2hCK0IsTUFBQTtBQUFBLFFBQWlCLE9BQUFoQixJQUFBNUMsV0FBQUEsQ0FBQUE7QUFBakIsTUFBQSxDQUFBLGtCQUEzQixDQUFBO0FBQUE7QUFBQSxNQUFBO0FBQUEsUUFBQSxPQUFBMEMsTUFBQW9CLGFBQUFwQixRQUFBQSxFQUFhLFVBQUNFLElBQUQsQ0FBYkY7QUFBQSxNQUFBLENBaGhCSjtBQXVnQkVTLElBQUFBLENBQUFBLDhCQUFBQSxDQW5nQkE7QUFBQTtBQStnQkFwRyxJQUFBQSx5QkFBQUEsbUJBQUFBLGlCQUFVLFNBQUQsRUFBd0IsTUFBeEIsRUFBc0MsVUFBL0NBO0FBQUFBLE1BQUFBO0FBQUFBOztBQUFBQTtBQW5oQkYsTUFBQTtBQUFBO0FBbWhCbUMsTUFBQTtBQUFBLE1BQUEsV0FBUyxHQUFUO0FBQUEsTUFBQSxDQW5oQm5DO0FBQUE7QUFtaEJpRCxNQUFBO0FBQUEsTUFBQSxlQUFhLEdBQWI7QUFBQSxNQUFBLENBbmhCakQ7QUFBQTtBQXFoQkEsK0JBQWlDZ0gsV0FBRztBQUNwQyxjQUFnQkEsV0FBRztBQUNuQjtBQUNBO0FBQ0Esb0JBQXNCLDRCQUFBL0csS0FBQUEsQ0FBQUEsQ0FBaUI7QUFDdkM7QUFDQTtBQUNBLG9CQUFzQiw0QkFBQUEsS0FBQUEsQ0FBaUJnSCxTQUFqQmhILENBQTJCO0FBQ2pEO0FBQ0E7QUFDQSx1Q0FBeUNnSCxTQUFBN0MsZ0JBQUFBLENBQXNCLFdBQXRCQSxDQUFrQztBQUMzRSxvQkFBc0I2QyxTQUFBQSxXQUFBQSxDQUFvQkMsTUFBcEJELENBQTJCO0FBQ2pEO0FBQ0EsZUFBaUJBLFNBQUFwQyxVQUFBQSxDQUFnQix5QkFBaEJBLENBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLG9CQUFzQix5QkFBQTVFLEtBQUFBLENBQWMsaUNBQWRBLENBQWdEO0FBQ3RFOztBQUVBLFVBQVkrRyxXQUFHO0FBQ2YsNkJBQStCQSxXQUFHO0FBQ2xDOztBQUVBLE1BQVFBLFdBQUc7O0FBRVg7QUFDQSxJQWhqQkE7QUFtaEJFaEgsSUFBQUEsQ0FBQUEsK0JBQUFBLENBL2dCQTtBQUFBLElBK2lCQSxpQkFBTSxNQUFOLEVBQVcsT0FBWCxDQS9pQkE7QUFBQTtBQWlqQkFtSCxJQUFBQSx3QkFBQUEsa0JBQUFBLGdCQUFTLEdBQVRBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXJqQkYsTUFBQTtBQUFBO0FBdWpCQTtBQUNBLGVBQWlCLElBQUEsc0JBQUEsWUFBQUEsTUFBQUEsQ0FBQUEsQ0FBcUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUF4a0JBO0FBQUEsTUF5a0JJLE9BQUEsSUFBQSxzQkFBQSxZQUFBQSxNQUFBQSxDQUFxQkMsR0FBckJELENBemtCSjtBQXFqQkVBLElBQUFBLENBQUFBLDhCQUFBQSxDQWpqQkE7QUFBQTtBQXdrQkEvQyxJQUFBQSwrQkFBQUEsNkJBQUFBLFNBQWdCLElBQUQsRUFBTyxXQUF0QkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBNWtCRjtBQTRrQndCLE1BQUE7QUFBQSxNQUFBLGdCQUFjLEtBQWQ7QUFBQSxNQUFBLENBNWtCeEI7QUFBQTtBQThrQkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFpQmlELHdCQUFBQSxDQUFvQnBHLE1BQU1xRyxXQUExQkQsQ0FBdUM7QUFDeEQ7QUFDQSxJQXpsQkE7QUE0a0JFakQsSUFBQUEsQ0FBQUEseUNBQUFBLENBeGtCQTtBQUFBO0FBd2xCQWlELElBQUFBLHVDQUFBQSxxQ0FBQUEsU0FBd0IsV0FBRCxFQUFjLFdBQXJDQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE1bEJGO0FBNGxCdUMsTUFBQTtBQUFBLE1BQUEsZ0JBQWMsS0FBZDtBQUFBLE1BQUEsQ0E1bEJ2QztBQUFBLE1BNmxCSSxPQUFBLEtBN2xCSjtBQTRsQkVBLElBQUFBLENBQUFBLGlEQUFBQSxDQXhsQkE7QUFBQSxJQTRsQkEsb0JBQUFFLFVBQUFBLENBQWNoSCxNQUFNLGVBQWMscUJBQWxDZ0gsQ0E1bEJBO0FBQUE7QUE4bEJBQyxJQUFBQSwyQkFBQUEscUJBQUFBLG1CQUFZLElBQVpBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUF2QyxPQUFPLG9CQUFBWCxlQUFBQSxDQUFnQlcsTUFBTSx3QkFBUSxRQUE5QlgsQ0FBUDtBQUFBLE1BQ0EsT0FBQyxhQUFlVyxJQUFLLENBRHJCO0FBREZ1QyxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0E5bEJBO0FBQUE7QUFtbUJBQyxJQUFBQSxvQ0FBQUEsOEJBQUFBLDRCQUFxQixJQUFyQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQSxvQkFBQUMsaUJBQUFBLENBQWtCekMsTUFBTSx3QkFBUSxRQUFoQ3lDLENBQUE7QUFBQSxNQUNBekMsT0FBTyxvQkFBQTBDLGFBQUFBLENBQWlCLG9CQUFBQyxNQUFBQSxDQUFXLG1CQUFvQixNQUFNM0MsSUFBckMyQyxDQUFqQkQsQ0FEUDtBQUFBLE1BR0EsT0FBQyxhQUFlMUMsSUFBSyxDQUhyQjtBQURGd0MsSUFBQUEsQ0FBQUEseUNBQUFBLENBbm1CQTtBQUFBO0FBMm1CQUksSUFBQUEsZ0NBQUFBLDBCQUFBQSx3QkFBaUIsSUFBakJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGOztBQUVBLGFBQWUsb0JBQUFGLGFBQUFBLENBQWlCRyxJQUFqQkg7QUFDZjtBQUNBO0FBQ0E7QUFDQSxZQUFjLENBQUMsSUFBRCxDQUFBSSxnQkFBQUEsQ0FBbUJELElBQW5CQyxDQUF5QjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQWRFRixJQUFBQSxDQUFBQSxxQ0FBQUEsQ0EzbUJBO0FBQUEsSUE0bkJBLGlCQUFNLE1BQU4sRUFBa0IsVUFBbEIsQ0E1bkJBO0FBQUEsSUE2bkJBLGlCQUFNLGFBQU4sRUFBa0IsVUFBbEIsQ0E3bkJBO0FBQUE7QUErbkJBcEYsSUFBQUEsbUNBQUFBLDZCQUFBQSwyQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyw4QkFBRDtBQURGQSxJQUFBQSxDQUFBQSx3Q0FBQUEsQ0EvbkJBO0FBQUE7QUFtb0JBdUYsSUFBQUEseUJBQUFBLG1CQUFBQSxpQkFBVSxPQUFWQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUF2b0JGO0FBdW9CWSxNQUFBO0FBQUEsTUFBQSxZQUFVLEdBQVY7QUFBQSxNQUFBLENBdm9CWjtBQUFBO0FBeW9CQTtBQUNBLFlBQVVoSSxPQUFBQSxDQUFNLDJCQUFXLDJDQUFqQkE7QUFDVjtBQUNBO0FBQ0EsWUFBVUEsT0FBQUEsQ0FBTSwyQkFBVyxFQUFBLEdBQUEsZ0JBQUEsR0FBQSxDQUFpQmlJLE9BQUEvRyxPQUFBQSxDQUFBQSxDQUFqQixDQUFBLEdBQUEscUJBQWpCbEI7QUFDVjtBQUNBO0FBQ0EsWUFBVUEsT0FBQUEsQ0FBTSwrQkFBZSxnQ0FBckJBO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUF6cEJBO0FBdW9CRWdJLElBQUFBLENBQUFBLCtCQUFBQSxDQW5vQkE7QUFBQTtBQXdwQkFFLElBQUFBLHlCQUFBQSxtQkFBQUEsaUJBQVUsSUFBVkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBNXBCRjtBQTRwQlksTUFBQTtBQUFBLE1BQUEsU0FBTyxzQkFBQUMsVUFBQUEsQ0FBQUEsQ0FBUDtBQUFBLE1BQUEsQ0E1cEJaO0FBQUEsTUE2cEJJLE9BQUEsc0JBQUFELE9BQUFBLENBQWFFLElBQWJGLENBN3BCSjtBQTRwQkVBLElBQUFBLENBQUFBLCtCQUFBQSxDQXhwQkE7QUFBQTtBQTRwQkFHLElBQUFBLDBCQUFBQSxvQkFBQUEsa0JBQVcsR0FBWEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsSUFBQSxRQWpxQkpDLENBQUFBLFlBaXFCSSxvQkFBQS9HLGVBQUFBLENBQWdCZ0gsS0FBSyx3QkFBUSxRQUE3QmhILENBanFCSitHLENBaXFCSSxDQUFBO0FBQUEsUUFqcUJKLE9BQUE7QUFpcUJJLE1BQUE7QUFBQSxRQUNFLE9BQUEsb0JBQUFoRSxlQUFBQSxDQUFnQmlFLEtBQUssd0JBQVEsTUFBN0JqRTtBQURGLE1BQUE7QUFERitELElBQUFBLENBQUFBLCtCQUFBQSxDQTVwQkE7QUFBQTtBQWlxQkFHLElBQUFBLHVCQUFBQSxpQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBcnFCRjtBQXFxQlUsTUFBQSxxQ0FycUJWO0FBQUEsTUFzcUJJLG1CQUFNakksSUFBTixDQXRxQko7QUFBQSxNQXVxQkksT0FBQUEsSUF2cUJKO0FBcXFCRWlJLElBQUFBLENBQUFBLDRCQUFBQSxDQWpxQkE7QUFBQTtBQXNxQkFDLElBQUFBLDJCQUFBQSxxQkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFsSTtBQURGa0ksSUFBQUEsQ0FBQUEsZ0NBQUFBLENBdHFCQTtBQUFBO0FBMHFCQS9FLElBQUFBLHdCQUFBQSxrQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsRUFBQSxHQUFBLElBQUEsR0FBQSxDQUFLbkQsSUFBQVcsT0FBQUEsQ0FBQUEsQ0FBTCxDQUFBLEdBQUEsS0FBQSxHQUFBLEtBQXFCdUMsUUFBQUEsQ0FBQUEsQ0FBQUMsTUFBQUEsQ0FBWWdGLEVBQVpoRixDQUFyQixDQUFBLEdBQUE7QUFERkEsSUFBQUEsQ0FBQUEsNkJBQUFBLENBMXFCQTtBQUFBO0FBOHFCQWlGLElBQUFBLHlCQUFBQSxtQkFBQUEsU0FBVSxHQUFWQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUEsTUFDRTtBQUFBLFFBQUEsT0FBQSxxQkFBQSxFQUFBO0FBQUEsTUFBQTtBQUFBLFFBQ0Ysc0JBQU8sQ0FBQSxrQ0FBQSxDQUFQLElBQTZCdkQsQ0FBQUEsUUFBQUE7QUFBN0IsVUFBQTtBQUFBO0FBQ0UsWUFBQSxJQUFnQkEsQ0FBQXdELEtBQUFBLENBQUFBLENBQUEvSCxPQUFBQSxDQUFTK0gsR0FBVC9ILENBQWhCO0FBQUEsY0FBQSxPQUFPdUUsQ0FBQVQsS0FBQUEsQ0FBQUEsQ0FBUCxDQUFBO0FBQUEsWUFDQSxXQUFBM0UsT0FBQUEsQ0FBQUEsQ0FEQTtBQURGLFVBQUE7QUFBQSxRQUFBLENBREU7QUFBQSxNQUFBO0FBREYySSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0E5cUJBO0FBQUE7QUFxckJBRSxJQUFBQSx5QkFBQUEsbUJBQUFBLFNBenJCRixFQXlyQkVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXpyQkY7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUF5ckJZLE1BQUEsa0JBenJCWjtBQUFBLE1BMHJCSSxXQUFBN0ksT0FBQUEsQ0FBTSxvQ0FBb0JJLElBQTFCSixDQTFyQko7QUF5ckJFNkksSUFBQUEsQ0FBQUEsK0JBQUFBLENBcnJCQTtBQUFBO0FBMHJCQUMsSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkE5ckJGLEVBOHJCRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBOXJCRjtBQThyQmtCLE1BQUEsc0NBOXJCbEI7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQThyQlcsTUFBQSxrQkE5ckJYO0FBQUEsTUErckJJLE9BQUFBLE1BQUEsb0JBQUFBLFFBQUFBLEVBQVUsVUFBQzFJLElBQUQsQ0FBVjBJLEVBQWtCakgsZ0JBQWxCaUgsQ0EvckJKO0FBOHJCRUEsSUFBQUEsQ0FBQUEsOEJBQUFBLENBMXJCQTtBQUFBO0FBOHJCQUMsSUFBQUEsOEJBQUFBLHdCQUFBQSxzQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBQ0UsTUFBQSxJQUEwQzVELGdCQUExQztBQUFBLE1BQUE7QUFBQSxRQUFBLE9BQU92QyxVQUFBQSxZQUFBQSxFQUFBQSxDQUFTLFlBQVRBLENBQUFBLEVBbnNCWCxpQkFBQSxFQUFBOztBQUFBLFFBbXNCbUMsT0FBQWIsQ0Fuc0JuQyxtQkFBQSxrQkFBQSxNQW1zQldhO0FBQVAsTUFBQSxDQUFBO0FBQUEsTUFDQSxPQUFBLG9CQUFNckMsSUFBTixDQUFBLENBREE7QUFERndJLElBQUFBLENBQUFBLG1DQUFBQSxDQTlyQkE7QUFBQSxJQW1zQkEsaUJBQU0sTUFBTixFQUFXLFlBQVgsQ0Fuc0JBO0FBQUEsSUFxc0JBLE9BQUEsb0JBQUF4QixVQUFBQSxDQUFjaEgsTUFBTSxnQkFBcEJnSCxDQXJzQkE7QUFERnpILEVBQUFBLEdBQUFBLFdBQUFBLFdBQUE7QUFBQSxFQXlzQkEsT0FBQW9CO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRSxXQUFBOEgsU0FBQUEsQ0FBUSxzQkFBUkE7QUFERjlILEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBenNCQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjUyMDYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Vycm9yLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEV4Y2VwdGlvbiA8IGBFcnJvcmBcbiAgIyBgdmFyIEtlcm5lbCRyYWlzZSA9ICN7S2VybmVsfS4kcmFpc2VgXG4gIGB2YXIgc3RhY2tfdHJhY2VfbGltaXRgXG5cbiAgZGVmIHNlbGYubmV3KCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIG1lc3NhZ2UgICA9IChhcmdzLmxlbmd0aCA+IDApID8gYXJnc1swXSA6IG5pbDtcbiAgICAgIHZhciBlcnJvciAgICAgPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKG1lc3NhZ2UpO1xuICAgICAgZXJyb3IubmFtZSAgICA9IHNlbGYuJCRuYW1lO1xuICAgICAgZXJyb3IubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICBPcGFsLnNlbmQoZXJyb3IsIGVycm9yLiRpbml0aWFsaXplLCBhcmdzKTtcblxuICAgICAgLy8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoKSB3aWxsIHVzZSAubmFtZSBhbmQgLnRvU3RyaW5nIHRvIGJ1aWxkIHRoZVxuICAgICAgLy8gZmlyc3QgbGluZSBvZiB0aGUgc3RhY2sgdHJhY2Ugc28gaXQgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGVycm9yXG4gICAgICAvLyBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC12Ni54L2RvY3MvYXBpL2Vycm9ycy5odG1sXG4gICAgICBpZiAoT3BhbC5jb25maWcuZW5hYmxlX3N0YWNrX3RyYWNlICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgIC8vIFBhc3NpbmcgS2VybmVsLnJhaXNlIHdpbGwgY3V0IHRoZSBzdGFjayB0cmFjZSBmcm9tIHRoYXQgcG9pbnQgYWJvdmVcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIHN0YWNrX3RyYWNlX2xpbWl0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgZW5kXG4gIGBzdGFja190cmFjZV9saW1pdCA9IHNlbGYuJG5ld2BcblxuICBkZWYgc2VsZi5leGNlcHRpb24oKmFyZ3MpXG4gICAgbmV3KCphcmdzKVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgqYXJncylcbiAgICAjIHVzaW5nIHNlbGYubWVzc2FnZSBha2EgQG1lc3NhZ2UgdG8gcmV0YWluIGNvbXBhdGliaWxpdHkgd2l0aCBuYXRpdmUgZXhjZXB0aW9uJ3MgbWVzc2FnZSBwcm9wZXJ0eVxuICAgIGBzZWxmLm1lc3NhZ2UgPSAoYXJncy5sZW5ndGggPiAwKSA/IGFyZ3NbMF0gOiBuaWxgXG4gIGVuZFxuXG4gIGRlZiBiYWNrdHJhY2VcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmJhY2t0cmFjZSkge1xuICAgICAgICAvLyBuaWwgaXMgYSB2YWxpZCBiYWNrdHJhY2VcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFja3RyYWNlID0gc2VsZi5zdGFjaztcblxuICAgICAgaWYgKHR5cGVvZihiYWNrdHJhY2UpID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYmFja3RyYWNlLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDAsIDE1KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJhY2t0cmFjZSkge1xuICAgICAgICByZXR1cm4gYmFja3RyYWNlLnNsaWNlKDAsIDE1KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGV4Y2VwdGlvbihzdHIgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoc3RyID09PSBuaWwgfHwgc2VsZiA9PT0gc3RyKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xvbmVkID0gI3tjbG9uZX07XG4gICAgICBjbG9uZWQubWVzc2FnZSA9IHN0cjtcbiAgICAgIGNsb25lZC5zdGFjayA9IHNlbGYuc3RhY2s7XG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cbiAgZW5kXG5cbiAgIyBub3QgdXNpbmcgYWxpYXMgbWVzc2FnZSB0b19zIGJlY2F1c2UgeW91IG5lZWQgdG8gYmUgYWJsZSB0byBvdmVycmlkZSB0b19zIGFuZCBoYXZlIG1lc3NhZ2UgdXNlIG92ZXJyaWRkZW4gbWV0aG9kLCB3b24ndCB3b3JrIHdpdGggYWxpYXNcbiAgZGVmIG1lc3NhZ2VcbiAgICB0b19zXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgYXNfc3RyID0gdG9fc1xuICAgIGFzX3N0ci5lbXB0eT8gPyBzZWxmLmNsYXNzLnRvX3MgOiBcIiM8I3tzZWxmLmNsYXNzLnRvX3N9OiAje3RvX3N9PlwiXG4gIGVuZFxuXG4gIGRlZiBzZXRfYmFja3RyYWNlKGJhY2t0cmFjZSlcbiAgICAleHtcbiAgICAgIHZhciB2YWxpZCA9IHRydWUsIGksIGlpO1xuXG4gICAgICBpZiAoYmFja3RyYWNlID09PSBuaWwpIHtcbiAgICAgICAgc2VsZi5iYWNrdHJhY2UgPSBuaWw7XG4gICAgICAgIHNlbGYuc3RhY2sgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAoYmFja3RyYWNlLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHNlbGYuYmFja3RyYWNlID0gW2JhY2t0cmFjZV07XG4gICAgICAgIHNlbGYuc3RhY2sgPSBiYWNrdHJhY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYmFja3RyYWNlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGJhY2t0cmFjZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWJhY2t0cmFjZVtpXS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ2JhY2t0cmFjZSBtdXN0IGJlIEFycmF5IG9mIFN0cmluZyd9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmJhY2t0cmFjZSA9IGJhY2t0cmFjZTtcbiAgICAgICAgc2VsZi5zdGFjayA9IGJhY2t0cmFjZS5qb2luKCdcXG4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhY2t0cmFjZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgIyB1c2luZyBzZWxmLm1lc3NhZ2UgYWthIEBtZXNzYWdlIHRvIHJldGFpbiBjb21wYXRpYmlsaXR5IHdpdGggbmF0aXZlIGV4Y2VwdGlvbidzIG1lc3NhZ2UgcHJvcGVydHlcbiAgICAoQG1lc3NhZ2UgJiYgQG1lc3NhZ2UudG9fcykgfHwgc2VsZi5jbGFzcy50b19zXG4gIGVuZFxuZW5kXG5cbiMga2VlcCB0aGUgaW5kZW50YXRpb24sIGl0IG1ha2VzIHRoZSBleGNlcHRpb24gaGllcmFyY2h5IGNsZWFyXG5jbGFzcyBTY3JpcHRFcnJvciAgICAgICA8IEV4Y2VwdGlvbjsgZW5kXG5jbGFzcyBTeW50YXhFcnJvciAgICAgICAgIDwgU2NyaXB0RXJyb3I7IGVuZFxuY2xhc3MgTG9hZEVycm9yICAgICAgICAgICA8IFNjcmlwdEVycm9yOyBlbmRcbmNsYXNzIE5vdEltcGxlbWVudGVkRXJyb3IgPCBTY3JpcHRFcnJvcjsgZW5kXG5cbmNsYXNzIFN5c3RlbUV4aXQgICAgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIE5vTWVtb3J5RXJyb3IgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIFNpZ25hbEV4Y2VwdGlvbiAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIEludGVycnVwdCAgICAgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIFNlY3VyaXR5RXJyb3IgICAgIDwgRXhjZXB0aW9uOyBlbmRcblxuY2xhc3MgU3RhbmRhcmRFcnJvciAgICAgPCBFeGNlcHRpb247IGVuZFxuY2xhc3MgRW5jb2RpbmdFcnJvciAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgWmVyb0RpdmlzaW9uRXJyb3IgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgTmFtZUVycm9yICAgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgTm9NZXRob2RFcnJvciAgICAgICAgIDwgTmFtZUVycm9yOyBlbmRcbmNsYXNzIFJ1bnRpbWVFcnJvciAgICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIEZyb3plbkVycm9yICAgICAgICAgICA8IFJ1bnRpbWVFcnJvcjsgZW5kXG5jbGFzcyBMb2NhbEp1bXBFcnJvciAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBUeXBlRXJyb3IgICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBBcmd1bWVudEVycm9yICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBJbmRleEVycm9yICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBTdG9wSXRlcmF0aW9uICAgICAgICAgPCBJbmRleEVycm9yOyBlbmRcbmNsYXNzIEtleUVycm9yICAgICAgICAgICAgICA8IEluZGV4RXJyb3I7IGVuZFxuY2xhc3MgUmFuZ2VFcnJvciAgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgRmxvYXREb21haW5FcnJvciAgICAgIDwgUmFuZ2VFcnJvcjsgZW5kXG5jbGFzcyBJT0Vycm9yICAgICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBTeXN0ZW1DYWxsRXJyb3IgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5cbm1vZHVsZSBFcnJub1xuICBjbGFzcyBFSU5WQUwgICAgICAgICAgICAgIDwgU3lzdGVtQ2FsbEVycm9yXG4gICAgZGVmIHNlbGYubmV3KG5hbWUgPSBuaWwpXG4gICAgICBtZXNzYWdlID0gJ0ludmFsaWQgYXJndW1lbnQnXG4gICAgICBtZXNzYWdlICs9IFwiIC0gI3tuYW1lfVwiIGlmIG5hbWVcbiAgICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFVuY2F1Z2h0VGhyb3dFcnJvciA8IEFyZ3VtZW50RXJyb3JcbiAgYXR0cl9yZWFkZXIgOnN5bSwgOmFyZ1xuXG4gIGRlZiBpbml0aWFsaXplKGFyZ3MpXG4gICAgQHN5bSA9IGFyZ3NbMF1cbiAgICBAYXJnID0gYXJnc1sxXSBpZiBhcmdzLmxlbmd0aCA+IDFcblxuICAgIHN1cGVyKFwidW5jYXVnaHQgdGhyb3cgI3tAc3ltLmluc3BlY3R9XCIpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5hbWVFcnJvclxuICBhdHRyX3JlYWRlciA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKG1lc3NhZ2UsIG5hbWUgPSBuaWwpXG4gICAgc3VwZXIgbWVzc2FnZVxuICAgIEBuYW1lID0gbmFtZVxuICBlbmRcbmVuZFxuXG5jbGFzcyBOb01ldGhvZEVycm9yXG4gIGF0dHJfcmVhZGVyIDphcmdzXG5cbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgbmFtZSA9IG5pbCwgYXJncyA9IFtdKVxuICAgIHN1cGVyIG1lc3NhZ2UsIG5hbWVcbiAgICBAYXJncyA9IGFyZ3NcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RvcEl0ZXJhdGlvblxuICBhdHRyX3JlYWRlciA6cmVzdWx0XG5lbmRcblxuY2xhc3MgS2V5RXJyb3JcbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgcmVjZWl2ZXI6IG5pbCwga2V5OiBuaWwpXG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBAcmVjZWl2ZXIgPSByZWNlaXZlclxuICAgIEBrZXkgPSBrZXlcbiAgZW5kXG5cbiAgZGVmIHJlY2VpdmVyXG4gICAgQHJlY2VpdmVyIHx8IHJhaXNlKEFyZ3VtZW50RXJyb3IsICdubyByZWNlaXZlciBpcyBhdmFpbGFibGUnKVxuICBlbmRcblxuICBkZWYga2V5XG4gICAgQGtleSB8fCByYWlzZShBcmd1bWVudEVycm9yLCAnbm8ga2V5IGlzIGF2YWlsYWJsZScpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBKU1xuICBjbGFzcyBFcnJvclxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwibmV3Iiwic2VsZiIsImV4Y2VwdGlvbiIsImFyZ3MiLCJpbml0aWFsaXplIiwiYmFja3RyYWNlIiwiY2xvbmUiLCJtZXNzYWdlIiwidG9fcyIsImluc3BlY3QiLCJhc19zdHIiLCJlbXB0eT8iLCJzZXRfYmFja3RyYWNlIiwicmFpc2UiLCIkcmV0X29yXzEiLCIkcmV0X29yXzIiLCJAbWVzc2FnZSIsIm1vZHVsZSIsIm5hbWUiLCIrIiwiYXR0cl9yZWFkZXIiLCJAc3ltIiwiW10iLCIwIiwiPiIsImxlbmd0aCIsIjEiLCJAYXJnIiwiQG5hbWUiLCJAYXJncyIsIkByZWNlaXZlciIsInJlY2VpdmVyIiwiQGtleSIsImtleSIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUVFLElBQUMscUJBQUQ7QUFBQSxJQUVBQyxVQUFJQyxJQUFKRCxVQUFBQSxtQkFBQUEsU0FMRixFQUtFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFMRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQUtlLE1BQUEsa0JBTGY7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBdkJBO0FBS0VBLElBQUFBLENBQUFBLCtCQUFBQSxDQUZBO0FBQUEsSUFzQkMsNkJBdEJEO0FBQUEsSUF3QkFFLFVBQUlELElBQUpDLGdCQUFBQSx5QkFBQUEscUJBM0JGLEVBMkJFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUEzQkY7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUEyQnFCLE1BQUEsa0JBM0JyQjtBQUFBLE1BNEJJLE9BQUFGLFVBQUFBLE9BQUFBLEVBQUksVUFBQ0csSUFBRCxDQUFKSCxDQTVCSjtBQTJC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QTs7QUFBQUE7QUFBQUEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFERmtCLEVBQUFBLEdBQUFBLFdBQUFBLFdBL01BOzsifX0seyJvZmZzZXQiOnsibGluZSI6NTczMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY29uc3RhbnRzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIlJVQllfUExBVEZPUk0gICAgICAgPSAnb3BhbCdcblJVQllfRU5HSU5FICAgICAgICAgPSAnb3BhbCdcblJVQllfVkVSU0lPTiAgICAgICAgPSAnMy4wLjInXG5SVUJZX0VOR0lORV9WRVJTSU9OID0gJzEuMi4wJ1xuUlVCWV9SRUxFQVNFX0RBVEUgICA9ICcyMDIxLTA3LTI4J1xuUlVCWV9QQVRDSExFVkVMICAgICA9IDBcblJVQllfUkVWSVNJT04gICAgICAgPSAnMCdcblJVQllfQ09QWVJJR0hUICAgICAgPSAnb3BhbCAtIENvcHlyaWdodCAoQykgMjAxMy0yMDIxIEFkYW0gQmV5bm9uIGFuZCB0aGUgT3BhbCBjb250cmlidXRvcnMnXG5SVUJZX0RFU0NSSVBUSU9OICAgID0gXCJvcGFsICN7UlVCWV9FTkdJTkVfVkVSU0lPTn0gKCN7UlVCWV9SRUxFQVNFX0RBVEV9IHJldmlzaW9uICN7UlVCWV9SRVZJU0lPTn0pXCJcbiJdLCJuYW1lcyI6WyIwIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBLEVBQUEsNkNBQXNCLE1BQXRCLENBQUE7QUFBQSxFQUNBLDJDQUFzQixNQUF0QixDQURBO0FBQUEsRUFFQSw0Q0FBc0IsT0FBdEIsQ0FGQTtBQUFBLEVBR0EsbURBQXNCLE9BQXRCLENBSEE7QUFBQSxFQUlBLGlEQUFzQixZQUF0QixDQUpBO0FBQUEsRUFLQSwrQ0FBc0JBLENBQXRCLENBTEE7QUFBQSxFQU1BLDZDQUFzQixHQUF0QixDQU5BO0FBQUEsRUFPQSw4Q0FBc0Isc0VBQXRCLENBUEE7QUFBQSxFQVFBLE9BQUEsZ0RBQXNCLEVBQUEsR0FBQSxPQUFBLEdBQUEsQ0FBUSxtQ0FBUixDQUFBLEdBQUEsSUFBQSxHQUFBLENBQWdDLGlDQUFoQyxDQUFBLEdBQUEsWUFBQSxHQUFBLENBQThELDZCQUE5RCxDQUFBLEdBQUEsR0FBdEIsQ0FSQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjU3NDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9ydW50aW1lJ1xucmVxdWlyZSAnY29yZWxpYi9oZWxwZXJzJ1xucmVxdWlyZSAnY29yZWxpYi9tb2R1bGUnXG5yZXF1aXJlICdjb3JlbGliL2NsYXNzJ1xucmVxdWlyZSAnY29yZWxpYi9iYXNpY19vYmplY3QnXG5yZXF1aXJlICdjb3JlbGliL2tlcm5lbCdcbnJlcXVpcmUgJ2NvcmVsaWIvZXJyb3InXG5cbnJlcXVpcmUgJ2NvcmVsaWIvY29uc3RhbnRzJ1xuIl0sIm5hbWVzIjpbInJlcXVpcmUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsaUJBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQURBO0FBQUEsTUFFQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FGQTtBQUFBLE1BR0FBLFNBQUFBLENBQVEsZUFBUkEsQ0FIQTtBQUFBLE1BSUFBLFNBQUFBLENBQVEsc0JBQVJBLENBSkE7QUFBQSxNQUtBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQUxBO0FBQUEsTUFNQUEsU0FBQUEsQ0FBUSxlQUFSQSxDQU5BO0FBQUEsRUFRQSxXQUFBQSxTQUFBQSxDQUFRLG1CQUFSQSxDQVJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6NTc2MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbmlsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIE5pbENsYXNzXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkbWV0YSA9ICN7c2VsZn1gXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgIVxuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgYG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsYFxuICBlbmRcblxuICBkZWYgXihvdGhlcilcbiAgICBgb3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgb3RoZXIgPT09IG5pbGBcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICduaWwnXG4gIGVuZFxuXG4gIGRlZiBuaWw/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgTmlsQ2xhc3NcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBbXVxuICBlbmRcblxuICBkZWYgdG9faFxuICAgIGBPcGFsLmhhc2goKWBcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICAwXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2YgdG9faVxuXG4gIGRlZiB0b19zXG4gICAgJydcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICBDb21wbGV4Lm5ldygwLCAwKVxuICBlbmRcblxuICBkZWYgcmF0aW9uYWxpemUoKmFyZ3MpXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciBpZiBhcmdzLmxlbmd0aCA+IDFcbiAgICBSYXRpb25hbCgwLCAxKVxuICBlbmRcblxuICBkZWYgdG9fclxuICAgIFJhdGlvbmFsKDAsIDEpXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBbXVxuICBlbmRcbmVuZFxuXG5OSUwgPSBuaWxcbiJdLCJuYW1lcyI6WyJjbGFzcyIsInNlbGYiLCJhbGxvY2F0ZSIsInJhaXNlIiwibmFtZSIsIiEiLCImIiwifCIsIl4iLCI9PSIsImR1cCIsImNsb25lIiwiaW5zcGVjdCIsIm5pbD8iLCJzaW5nbGV0b25fY2xhc3MiLCJ0b19hIiwidG9faCIsInRvX2kiLCIwIiwidG9fcyIsInRvX2MiLCJuZXciLCJyYXRpb25hbGl6ZSIsIj4iLCJhcmdzIiwibGVuZ3RoIiwiMSIsIlJhdGlvbmFsIiwidG9fciIsImluc3RhbmNlX3ZhcmlhYmxlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUMsMEJBQTRCQyxJQUE3QjtBQUFBLElBRUE7QUFBQSxNQUFBOztBQUFBO0FBQ0U7QUFBQUMsTUFBQUEsNEJBQUFBLGNBQUFBLG9CQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxXQUFBQyxPQUFBQSxDQUFNLDJCQUFXLEVBQUEsR0FBQSwwQkFBQSxHQUFBLEtBQTJCQyxNQUFBQSxDQUFBQSxDQUEzQixDQUFqQkQ7QUFERkQsTUFBQUEsQ0FBQUEseUJBQUFBLENBQUE7QUFBQTs7QUFJQSxNQUFBLHNCQUFNLEtBQU47aUJBSkE7QUFERixJQUFBLDRCQUFTRCxJQUFULFlBRkE7QUFBQTtBQVVBSSxJQUFBQSxxQkFBQUEsb0JBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUE7QUFERkEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBVkE7QUFBQTtBQWNBQyxJQUFBQSxxQkFBQUEsZ0JBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQTtBQURGQSxJQUFBQSxDQUFBQSwyQkFBQUEsQ0FkQTtBQUFBO0FBa0JBQyxJQUFBQSxx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QUFBLHVDQUFBQSxDQXhFQTtBQUFBO0FBNkVBTSxJQUFBQSx3QkFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBRCxVQUFBQSxDQUFTVCxHQUFHUSxDQUFaQztBQURGQyxJQUFBQSxDQUFBQSwrQkFBQUEsQ0E3RUE7QUFBQSxJQWlGQSxPQUFBQyxDQUFBQSxzQ0FBQUEsa0NBQUFBLDhCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBO0FBREZBLElBQUFBLENBQUFBLDZDQUFBQSxDQUFBQSw4QkFqRkE7QUFERjdCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBQUE7QUFBQSxFQXVGQSxPQUFBLG1DQUFNLEdBQU4sQ0F2RkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1OTI1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9ib29sZWFuLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEJvb2xlYW4gPCBgQm9vbGVhbmBcbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfYm9vbGVhbicsIHRydWUpYFxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRtZXRhJywgI3tzZWxmfSlgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgX19pZF9fXG4gICAgYHNlbGYudmFsdWVPZigpID8gMiA6IDBgXG4gIGVuZFxuXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cblxuICBkZWYgIVxuICAgIGBzZWxmICE9IHRydWVgXG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgIGAoc2VsZiA9PSB0cnVlKSA/IChvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbCkgOiBmYWxzZWBcbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID8gdHJ1ZSA6IChvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbClgXG4gIGVuZFxuXG4gIGRlZiBeKG90aGVyKVxuICAgIGAoc2VsZiA9PSB0cnVlKSA/IChvdGhlciA9PT0gZmFsc2UgfHwgb3RoZXIgPT09IG5pbCkgOiAob3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWwpYFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID09PSBvdGhlci52YWx1ZU9mKClgXG4gIGVuZFxuXG4gIGFsaWFzIGVxdWFsPyA9PVxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIEJvb2xlYW5cbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyAndHJ1ZScgOiAnZmFsc2UnYFxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIHNlbGZcbiAgZW5kXG5lbmRcblxuVHJ1ZUNsYXNzICA9IEJvb2xlYW5cbkZhbHNlQ2xhc3MgPSBCb29sZWFuXG5cblRSVUUgID0gdHJ1ZVxuRkFMU0UgPSBmYWxzZVxuIl0sIm5hbWVzIjpbImNsYXNzIiwic2VsZiIsImFsbG9jYXRlIiwicmFpc2UiLCJuYW1lIiwiX19pZF9fIiwiISIsIiYiLCJ8IiwiXiIsIj09Iiwic2luZ2xldG9uX2NsYXNzIiwidG9fcyIsImR1cCIsImNsb25lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQywyREFBRDtBQUFBLElBQ0MsZ0RBQWtEQyxJQUFLLENBRHhEO0FBQUEsSUFHQTtBQUFBLE1BQUE7O0FBQUE7QUFDRTtBQUFBQyxNQUFBQSw0QkFBQUEsY0FBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLFdBQUFDLE9BQUFBLENBQU0sMkJBQVcsRUFBQSxHQUFBLDBCQUFBLEdBQUEsS0FBMkJDLE1BQUFBLENBQUFBLENBQTNCLENBQWpCRDtBQURGRCxNQUFBQSxDQUFBQSx5QkFBQUEsQ0FBQTtBQUFBOztBQUlBLE1BQUEsc0JBQU0sS0FBTjtpQkFKQTtBQURGLElBQUEsNEJBQVNELElBQVQsWUFIQTtBQUFBO0FBV0FJLElBQUFBLDBCQUFBQSxvQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsc0JBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBWEE7QUFBQSxJQWVBLGlCQUFNLFdBQU4sRUFBZ0IsUUFBaEIsQ0FmQTtBQUFBO0FBaUJBQyxJQUFBQSxxQkFBQUEsbUJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsWUFBRDtBQURGQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FqQkE7QUFBQTtBQXFCQUMsSUFBQUEscUJBQUFBLGVBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQywyREFBRDtBQURGQSxJQUFBQSxDQUFBQSwwQkFBQUEsQ0FyQkE7QUFBQTtBQXlCQUMsSUFBQUEscUJBQUFBLGVBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQywwREFBRDtBQURGQSxJQUFBQSxDQUFBQSwwQkFBQUEsQ0F6QkE7QUFBQTtBQTZCQUMsSUFBQUEscUJBQUFBLGVBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyx3RkFBRDtBQURGQSxJQUFBQSxDQUFBQSwwQkFBQUEsQ0E3QkE7QUFBQTtBQWlDQUMsSUFBQUEsc0JBQUFBLG9CQUFBQSxTQUFPLEtBQVBBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsa0NBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBakNBO0FBQUEsSUFxQ0EsaUJBQU0sUUFBTixFQUFhLElBQWIsQ0FyQ0E7QUFBQSxJQXNDQSxpQkFBTSxNQUFOLEVBQVcsSUFBWCxDQXRDQTtBQUFBO0FBd0NBQyxJQUFBQSxtQ0FBQUEsNkJBQUFBLDJCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBO0FBREZBLElBQUFBLENBQUFBLHdDQUFBQSxDQXhDQTtBQUFBO0FBNENBQyxJQUFBQSx3QkFBQUEsa0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLGlDQUFEO0FBREZBLElBQUFBLENBQUFBLDZCQUFBQSxDQTVDQTtBQUFBO0FBZ0RBQyxJQUFBQSx1QkFBQUEsa0JBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFaO0FBREZZLElBQUFBLENBQUFBLDZCQUFBQSxDQWhEQTtBQUFBLElBb0RBLE9BQUFDLENBQUFBLHlCQUFBQSxvQkFBQUEsaUJBdERGLE9Bc0RFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUF0REY7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxDQUFBO0FBQUE7QUFzRFksTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBLFdBQVE7QUFBUixNQUFBLENBdERaO0FBQUEsTUF1REksT0FBQWIsSUF2REo7QUFzREVhLElBQUFBLENBQUFBLGdDQUFBQSxDQUFBQSxpQkFwREE7QUFERmQsRUFBQUEsR0FBQUEsV0FBQUEsRUFBaUIsT0FBakJBLFdBQUE7QUFBQSxFQTBEQSx5Q0FBYSx1QkFBYixDQTFEQTtBQUFBLEVBMkRBLDBDQUFhLHVCQUFiLENBM0RBO0FBQUEsRUE2REEsb0NBQVEsSUFBUixDQTdEQTtBQUFBLEVBOERBLE9BQUEscUNBQVEsS0FBUixDQTlEQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjYwMzUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbXBhcmFibGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBmYWxzeVxuXG5tb2R1bGUgQ29tcGFyYWJsZVxuICAleHtcbiAgICBmdW5jdGlvbiBub3JtYWxpemUod2hhdCkge1xuICAgICAgaWYgKE9wYWwuaXNfYSh3aGF0LCBPcGFsLkludGVnZXIpKSB7IHJldHVybiB3aGF0OyB9XG5cbiAgICAgIGlmICgje2B3aGF0YCA+IDB9KSB7IHJldHVybiAxOyB9XG4gICAgICBpZiAoI3tgd2hhdGAgPCAwfSkgeyByZXR1cm4gLTE7IH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhaWxfY29tcGFyaXNvbihsaHMsIHJocykge1xuICAgICAgdmFyIGNsYXNzX25hbWU7XG4gICAgICAje1xuICAgICAgICBjYXNlIGByaHNgXG4gICAgICAgIHdoZW4gbmlsLCB0cnVlLCBmYWxzZSwgSW50ZWdlciwgRmxvYXRcbiAgICAgICAgICBgY2xhc3NfbmFtZSA9IHJocy4kaW5zcGVjdCgpYFxuICAgICAgICBlbHNlXG4gICAgICAgICAgYGNsYXNzX25hbWUgPSByaHMuJCRjbGFzc2BcbiAgICAgICAgZW5kXG4gICAgICB9XG4gICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje2BsaHNgLmNsYXNzfSB3aXRoICN7YGNsYXNzX25hbWVgfSBmYWlsZWRcIn1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbXBfb3JfZmFpbChsaHMsIHJocykge1xuICAgICAgdmFyIGNtcCA9ICN7YGxoc2AgPD0+IGByaHNgfTtcbiAgICAgIGlmICgkZmFsc3koY21wKSkgZmFpbF9jb21wYXJpc29uKGxocywgcmhzKTtcbiAgICAgIHJldHVybiBub3JtYWxpemUoY21wKTtcbiAgICB9XG4gIH1cblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIHRydWUgaWYgZXF1YWw/KG90aGVyKVxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZltcIiQ8PT5cIl0gPT0gT3BhbC5LZXJuZWxbXCIkPD0+XCJdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgZm9yIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgaWYgKHNlbGYuJCRjb21wYXJhYmxlKSB7XG4gICAgICAgIGRlbGV0ZSBzZWxmLiQkY29tcGFyYWJsZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgY21wID0gKHNlbGYgPD0+IG90aGVyKVxuXG4gICAgYG5vcm1hbGl6ZShjbXApID09IDBgXG4gIGVuZFxuXG4gIGRlZiA+KG90aGVyKVxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPiAwYFxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgYGNtcF9vcl9mYWlsKHNlbGYsIG90aGVyKSA+PSAwYFxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpIDwgMGBcbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPD0gMGBcbiAgZW5kXG5cbiAgZGVmIGJldHdlZW4/KG1pbiwgbWF4KVxuICAgIHJldHVybiBmYWxzZSBpZiBzZWxmIDwgbWluXG4gICAgcmV0dXJuIGZhbHNlIGlmIHNlbGYgPiBtYXhcbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBjbGFtcChtaW4sIG1heCA9IG5pbClcbiAgICAleHtcbiAgICAgIHZhciBjLCBleGNsO1xuXG4gICAgICBpZiAobWF4ID09PSBuaWwpIHtcbiAgICAgICAgLy8gV2UgYXJlIGRlYWxpbmcgd2l0aCBhIG5ldyBSdWJ5IDIuNyBiZWhhdmlvdXIgdGhhdCB3ZSBhcmUgYWJsZSB0b1xuICAgICAgICAvLyBwcm92aWRlIGEgc2luZ2xlIFJhbmdlIGFyZ3VtZW50IGluc3RlYWQgb2YgMiBDb21wYXJhYmxlcy5cblxuICAgICAgICBpZiAoIU9wYWwuaXNfYShtaW4sIE9wYWwuUmFuZ2UpKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje21pbi5jbGFzc30gKGV4cGVjdGVkIFJhbmdlKVwifVxuICAgICAgICB9XG5cbiAgICAgICAgZXhjbCA9IG1pbi5leGNsO1xuICAgICAgICBtYXggPSBtaW4uZW5kO1xuICAgICAgICBtaW4gPSBtaW4uYmVnaW47XG5cbiAgICAgICAgaWYgKG1heCAhPT0gbmlsICYmIGV4Y2wpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdjYW5ub3QgY2xhbXAgd2l0aCBhbiBleGNsdXNpdmUgcmFuZ2UnfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW4gIT09IG5pbCAmJiBtYXggIT09IG5pbCAmJiBjbXBfb3JfZmFpbChtaW4sIG1heCkgPiAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ21pbiBhcmd1bWVudCBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXggYXJndW1lbnQnfVxuICAgICAgfVxuXG4gICAgICBpZiAobWluICE9PSBuaWwpIHtcbiAgICAgICAgYyA9IGNtcF9vcl9mYWlsKHNlbGYsIG1pbik7XG5cbiAgICAgICAgaWYgKGMgPT0gMCkgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmIChjIDwgMCkgcmV0dXJuIG1pbjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heCAhPT0gbmlsKSB7XG4gICAgICAgIGMgPSBjbXBfb3JfZmFpbChzZWxmLCBtYXgpO1xuXG4gICAgICAgIGlmIChjID4gMCkgcmV0dXJuIG1heDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsIj4iLCIwIiwiPCIsInJhaXNlIiwiY2xhc3MiLCI8PT4iLCI9PSIsImVxdWFsPyIsIm90aGVyIiwiY21wIiwic2VsZiIsIj49IiwiPD0iLCJiZXR3ZWVuPyIsIm1pbiIsIm1heCIsImNsYW1wIl0sIm1h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LGNBQVliLE9BQUFBLENBQU0sMkJBQVcsRUFBQSxHQUFBLHNCQUFBLEdBQUEsQ0FBdUJXLEdBQUFWLE9BQUFBLENBQUFBLENBQXZCLENBQUEsR0FBQSxtQkFBakJEO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBWUEsT0FBQUEsQ0FBTSwrQkFBZSxzQ0FBckJBO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVVBLE9BQUFBLENBQU0sK0JBQWUsZ0RBQXJCQTtBQUNWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBbEhBO0FBMkVFYSxJQUFBQSxDQUFBQSxrQ0FBQUEsQ0FBQUEsaUJBdkVBO0FBREZqQixFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjYxODUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JlZ2V4cC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGNvZXJjZV90b1xuXG5jbGFzcyBSZWdleHBFcnJvciA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuXG5jbGFzcyBSZWdleHAgPCBgUmVnRXhwYFxuICBJR05PUkVDQVNFID0gMVxuICBFWFRFTkRFRCA9IDJcbiAgTVVMVElMSU5FID0gNFxuXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX3JlZ2V4cCcsIHRydWUpYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIGFsbG9jYXRlZCA9IHN1cGVyXG4gICAgICBgI3thbGxvY2F0ZWR9LnVuaW5pdGlhbGl6ZWQgPSB0cnVlYFxuICAgICAgYWxsb2NhdGVkXG4gICAgZW5kXG5cbiAgICBkZWYgZXNjYXBlKHN0cmluZylcbiAgICAgIGBPcGFsLmVzY2FwZV9yZWdleHAoc3RyaW5nKWBcbiAgICBlbmRcblxuICAgIGRlZiBsYXN0X21hdGNoKG4gPSBuaWwpXG4gICAgICBpZiBuLm5pbD9cbiAgICAgICAgJH5cbiAgICAgIGVsc2VcbiAgICAgICAgJH5bbl1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYWxpYXMgcXVvdGUgZXNjYXBlXG5cbiAgICBkZWYgdW5pb24oKnBhcnRzKVxuICAgICAgJXh7XG4gICAgICAgIHZhciBpc19maXJzdF9wYXJ0X2FycmF5LCBxdW90ZWRfdmFsaWRhdGVkLCBwYXJ0LCBvcHRpb25zLCBlYWNoX3BhcnRfb3B0aW9ucztcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIC8oPyEpLztcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gZmFzdCBpZiB0aGVyZSdzIG9ubHkgb25lIGVsZW1lbnRcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PSAxICYmIHBhcnRzWzBdLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvdmVyIHRoZSAyIGFycmF5cyBwYXNzZWQgYXMgYXJndW1lbnRzIGNhc2VcbiAgICAgICAgaXNfZmlyc3RfcGFydF9hcnJheSA9IHBhcnRzWzBdLiQkaXNfYXJyYXk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxICYmIGlzX2ZpcnN0X3BhcnRfYXJyYXkpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ25vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgQXJyYXkgaW50byBTdHJpbmcnfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlYWwgd2l0aCBzcGxhdCBpc3N1ZXMgKHJlbGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9pc3N1ZXMvODU4KVxuICAgICAgICBpZiAoaXNfZmlyc3RfcGFydF9hcnJheSkge1xuICAgICAgICAgIHBhcnRzID0gcGFydHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICBpZiAocGFydC4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZC5wdXNoKCN7ZXNjYXBlKGBwYXJ0YCl9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocGFydC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgICAgZWFjaF9wYXJ0X29wdGlvbnMgPSAje2BwYXJ0YC5vcHRpb25zfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zICE9IGVhY2hfcGFydF9vcHRpb25zKSB7XG4gICAgICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnQWxsIGV4cHJlc3Npb25zIG11c3QgdXNlIHRoZSBzYW1lIG9wdGlvbnMnfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucyA9IGVhY2hfcGFydF9vcHRpb25zO1xuICAgICAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZC5wdXNoKCcoJytwYXJ0LnNvdXJjZSsnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1b3RlZF92YWxpZGF0ZWQucHVzaCgje2VzY2FwZShgcGFydGAudG9fc3RyKX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgIyBUYWtlIGFkdmFudGFnZSBvZiBsb2dpYyB0aGF0IGNhbiBwYXJzZSBvcHRpb25zIGZyb20gSlMgUmVnZXhcbiAgICAgIG5ldyhgcXVvdGVkX3ZhbGlkYXRlZGAuam9pbignfCcpLCBgb3B0aW9uc2ApXG4gICAgZW5kXG5cbiAgICBkZWYgbmV3KHJlZ2V4cCwgb3B0aW9ucyA9IHVuZGVmaW5lZClcbiAgICAgICV4e1xuICAgICAgICBpZiAocmVnZXhwLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2V4cCA9ICN7T3BhbC5jb2VyY2VfdG8hKHJlZ2V4cCwgU3RyaW5nLCA6dG9fc3RyKX07XG5cbiAgICAgICAgaWYgKHJlZ2V4cC5jaGFyQXQocmVnZXhwLmxlbmd0aCAtIDEpID09PSAnXFxcXCcgJiYgcmVnZXhwLmNoYXJBdChyZWdleHAubGVuZ3RoIC0gMikgIT09ICdcXFxcJykge1xuICAgICAgICAgICN7cmFpc2UgUmVnZXhwRXJyb3IsIFwidG9vIHNob3J0IGVzY2FwZSBzZXF1ZW5jZTogLyN7cmVnZXhwfS9cIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgI3shb3B0aW9uc30pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICB2YXIgdGVtcCA9ICcnO1xuICAgICAgICAgIGlmICgje0lHTk9SRUNBU0V9ICYgb3B0aW9ucykgeyB0ZW1wICs9ICdpJzsgfVxuICAgICAgICAgIGlmICgje01VTFRJTElORX0gICYgb3B0aW9ucykgeyB0ZW1wICs9ICdtJzsgfVxuICAgICAgICAgIG9wdGlvbnMgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSAnaSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHAsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgYWxpYXMgY29tcGlsZSBuZXdcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGBvdGhlciBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBzZWxmLnRvU3RyaW5nKCkgPT09IG90aGVyLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiA9PT0oc3RyaW5nKVxuICAgIGAje21hdGNoKE9wYWwuY29lcmNlX3RvPyhzdHJpbmcsIFN0cmluZywgOnRvX3N0cikpfSAhPT0gbmlsYFxuICBlbmRcblxuICBkZWYgPX4oc3RyaW5nKVxuICAgIG1hdGNoKHN0cmluZykgJiYgJH4uYmVnaW4oMClcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuXG4gIGRlZiBpbnNwZWN0XG4gICAgIyBVc2UgYSByZWdleHAgdG8gZXh0cmFjdCB0aGUgcmVndWxhciBleHByZXNzaW9uIGFuZCB0aGUgb3B0aW9uYWwgbW9kZSBtb2RpZmllcnMgZnJvbSB0aGUgc3RyaW5nLlxuICAgICMgSW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiwgZXNjYXBlIGFueSBmcm9udCBzbGFzaCAobm90IGFscmVhZHkgZXNjYXBlZCkgd2l0aCBhIGJhY2tzbGFzaC5cbiAgICAleHtcbiAgICAgIHZhciByZWdleHBfZm9ybWF0ID0gL15cXC8oLiopXFwvKFteXFwvXSopJC87XG4gICAgICB2YXIgdmFsdWUgPSBzZWxmLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbWF0Y2hlcyA9IHJlZ2V4cF9mb3JtYXQuZXhlYyh2YWx1ZSk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICB2YXIgcmVnZXhwX3BhdHRlcm4gPSBtYXRjaGVzWzFdO1xuICAgICAgICB2YXIgcmVnZXhwX2ZsYWdzID0gbWF0Y2hlc1syXTtcbiAgICAgICAgdmFyIGNoYXJzID0gcmVnZXhwX3BhdHRlcm4uc3BsaXQoJycpO1xuICAgICAgICB2YXIgY2hhcnNfbGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY2hhcl9lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciByZWdleHBfcGF0dGVybl9lc2NhcGVkID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnNfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY3VycmVudF9jaGFyID0gY2hhcnNbaV07XG4gICAgICAgICAgaWYgKCFjaGFyX2VzY2FwZWQgJiYgY3VycmVudF9jaGFyID09ICcvJykge1xuICAgICAgICAgICAgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCA9IHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQuY29uY2F0KCdcXFxcJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQgPSByZWdleHBfcGF0dGVybl9lc2NhcGVkLmNvbmNhdChjdXJyZW50X2NoYXIpO1xuICAgICAgICAgIGlmIChjdXJyZW50X2NoYXIgPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBpZiAoY2hhcl9lc2NhcGVkKSB7XG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IG92ZXIgZXNjYXBlXG4gICAgICAgICAgICAgIGNoYXJfZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hhcl9lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hhcl9lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnLycgKyByZWdleHBfcGF0dGVybl9lc2NhcGVkICsgJy8nICsgcmVnZXhwX2ZsYWdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1hdGNoKHN0cmluZywgcG9zID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIHZhciBtID0gc2VsZi5leGVjKCRjb2VyY2VfdG8oc3RyaW5nLCAje1N0cmluZ30sICd0b19zdHInKSk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgI3skfiA9IE1hdGNoRGF0YS5uZXcoYHNlbGZgLCBgbWApfTtcbiAgICAgICAgICByZXR1cm4gYmxvY2sgPT09IG5pbCA/ICN7JH59IDogI3t5aWVsZCAkfn07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBvcyA9ICRjb2VyY2VfdG8ocG9zLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChzdHJpbmcgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9ICRjb2VyY2VfdG8oc3RyaW5nLCAje1N0cmluZ30sICd0b19zdHInKTtcblxuICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgcG9zICs9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGdsb2JhbCBSZWdFeHAgbWFpbnRhaW5zIHN0YXRlLCBzbyBub3QgdXNpbmcgc2VsZi90aGlzXG4gICAgICB2YXIgbWQsIHJlID0gT3BhbC5nbG9iYWxfcmVnZXhwKHNlbGYpO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBtZCA9IHJlLmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgaWYgKG1kID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZC5pbmRleCA+PSBwb3MpIHtcbiAgICAgICAgICAjeyR+ID0gTWF0Y2hEYXRhLm5ldyhgcmVgLCBgbWRgKX07XG4gICAgICAgICAgcmV0dXJuIGJsb2NrID09PSBuaWwgPyAjeyR+fSA6ICN7eWllbGQgJH59O1xuICAgICAgICB9XG4gICAgICAgIHJlLmxhc3RJbmRleCA9IG1kLmluZGV4ICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtYXRjaD8oc3RyaW5nLCBwb3MgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZyA9PT0gbmlsID8gZmFsc2UgOiBzZWxmLnRlc3QoJGNvZXJjZV90byhzdHJpbmcsICN7U3RyaW5nfSwgJ3RvX3N0cicpKTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gJGNvZXJjZV90byhwb3MsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gJGNvZXJjZV90byhzdHJpbmcsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2xvYmFsIFJlZ0V4cCBtYWludGFpbnMgc3RhdGUsIHNvIG5vdCB1c2luZyBzZWxmL3RoaXNcbiAgICAgIHZhciBtZCwgcmUgPSBPcGFsLmdsb2JhbF9yZWdleHAoc2VsZik7XG5cbiAgICAgIG1kID0gcmUuZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKG1kID09PSBudWxsIHx8IG1kLmluZGV4IDwgcG9zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIH5cbiAgICBzZWxmID1+ICRfXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VcbiAgICBgc2VsZi5zb3VyY2VgXG4gIGVuZFxuXG4gIGRlZiBvcHRpb25zXG4gICAgIyBGbGFncyB3b3VsZCBiZSBuaWNlIHRvIHVzZSB3aXRoIHRoaXMsIGJ1dCBzdGlsbCBleHBlcmltZW50YWwgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHAvZmxhZ3NcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLnVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICd1bmluaXRpYWxpemVkIFJlZ2V4cCd9XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgIC8vIHNob3VsZCBiZSBzdXBwb3J0ZWQgaW4gSUU2IGFjY29yZGluZyB0byBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5LzdmNXoyNnc0KHY9dnMuOTQpLmFzcHhcbiAgICAgIGlmIChzZWxmLm11bHRpbGluZSkge1xuICAgICAgICByZXN1bHQgfD0gI3tNVUxUSUxJTkV9O1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYuaWdub3JlQ2FzZSkge1xuICAgICAgICByZXN1bHQgfD0gI3tJR05PUkVDQVNFfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2FzZWZvbGQ/XG4gICAgYHNlbGYuaWdub3JlQ2FzZWBcbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBzb3VyY2VcbmVuZFxuXG5jbGFzcyBNYXRjaERhdGFcbiAgYXR0cl9yZWFkZXIgOnBvc3RfbWF0Y2gsIDpwcmVfbWF0Y2gsIDpyZWdleHAsIDpzdHJpbmdcblxuICBkZWYgaW5pdGlhbGl6ZShyZWdleHAsIG1hdGNoX2dyb3VwcylcbiAgICAkfiAgICAgICAgICA9IHNlbGZcbiAgICBAcmVnZXhwICAgICA9IHJlZ2V4cFxuICAgIEBiZWdpbiAgICAgID0gYG1hdGNoX2dyb3Vwcy5pbmRleGBcbiAgICBAc3RyaW5nICAgICA9IGBtYXRjaF9ncm91cHMuaW5wdXRgXG4gICAgQHByZV9tYXRjaCAgPSBgbWF0Y2hfZ3JvdXBzLmlucHV0LnNsaWNlKDAsIG1hdGNoX2dyb3Vwcy5pbmRleClgXG4gICAgQHBvc3RfbWF0Y2ggPSBgbWF0Y2hfZ3JvdXBzLmlucHV0LnNsaWNlKG1hdGNoX2dyb3Vwcy5pbmRleCArIG1hdGNoX2dyb3Vwc1swXS5sZW5ndGgpYFxuICAgIEBtYXRjaGVzICAgID0gW11cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1hdGNoX2dyb3Vwcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBtYXRjaF9ncm91cHNbaV07XG5cbiAgICAgICAgaWYgKGdyb3VwID09IG51bGwpIHtcbiAgICAgICAgICAje0BtYXRjaGVzfS5wdXNoKG5pbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgI3tAbWF0Y2hlc30ucHVzaChncm91cCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXSgqYXJncylcbiAgICBAbWF0Y2hlc1sqYXJnc11cbiAgZW5kXG5cbiAgZGVmIG9mZnNldChuKVxuICAgICV4e1xuICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnTWF0Y2hEYXRhI29mZnNldCBvbmx5IHN1cHBvcnRzIDB0aCBlbGVtZW50J31cbiAgICAgIH1cbiAgICAgIHJldHVybiBbc2VsZi5iZWdpbiwgc2VsZi5iZWdpbiArIHNlbGYubWF0Y2hlc1tuXS5sZW5ndGhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgTWF0Y2hEYXRhID09PSBvdGhlclxuXG4gICAgYHNlbGYuc3RyaW5nID09IG90aGVyLnN0cmluZ2AgJiZcbiAgICAgIGBzZWxmLnJlZ2V4cC50b1N0cmluZygpID09IG90aGVyLnJlZ2V4cC50b1N0cmluZygpYCAmJlxuICAgICAgYHNlbGYucHJlX21hdGNoID09IG90aGVyLnByZV9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLnBvc3RfbWF0Y2ggPT0gb3RoZXIucG9zdF9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLmJlZ2luID09IG90aGVyLmJlZ2luYFxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIGJlZ2luKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdNYXRjaERhdGEjYmVnaW4gb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5iZWdpbjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlbmQobilcbiAgICAleHtcbiAgICAgIGlmIChuICE9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ01hdGNoRGF0YSNlbmQgb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5iZWdpbiArIHNlbGYubWF0Y2hlc1tuXS5sZW5ndGg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2FwdHVyZXNcbiAgICBgI3tAbWF0Y2hlc30uc2xpY2UoMSlgXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gXCIjPE1hdGNoRGF0YSBcIiArICN7YCN7QG1hdGNoZXN9WzBdYC5pbnNwZWN0fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9ICN7QG1hdGNoZXN9Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBcIiBcIiArIGkgKyBcIjpcIiArICN7YCN7QG1hdGNoZXN9W2ldYC5pbnNwZWN0fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ciArIFwiPlwiO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGAje0BtYXRjaGVzfS5sZW5ndGhgXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgZGVmIHRvX2FcbiAgICBAbWF0Y2hlc1xuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGAje0BtYXRjaGVzfVswXWBcbiAgZW5kXG5cbiAgZGVmIHZhbHVlc19hdCgqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBpLCBhLCBpbmRleCwgdmFsdWVzID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgaWYgKGFyZ3NbaV0uJCRpc19yYW5nZSkge1xuICAgICAgICAgIGEgPSAje2BhcmdzW2ldYC50b19hfTtcbiAgICAgICAgICBhLnVuc2hpZnQoaSwgMSk7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShhcmdzLCBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gI3tPcGFsLmNvZXJjZV90byEoYGFyZ3NbaV1gLCBJbnRlZ2VyLCA6dG9faW50KX07XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9ICN7QG1hdGNoZXN9Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChuaWwpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVzLnB1c2goI3tAbWF0Y2hlc31baW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCIxIiwiMiIsIjQiLCJhbGxvY2F0ZSIsImFsbG9jYXRlZCIsImVzY2FwZSIsImxhc3RfbWF0Y2giLCJuIiwibmlsPyIsIiR+IiwiW10iLCJ1bmlvbiIsInJhaXNlIiwib3B0aW9ucyIsInRvX3N0ciIsIm5ldyIsImpvaW4iLCJjb2VyY2VfdG8hIiwicmVnZXhwIiwiISIsInNlbGYiLCI9PSIsIj09PSIsIm1hdGNoIiwiY29lcmNlX3RvPyIsInN0cmluZyIsIj1+IiwiJHJldF9vcl8xIiwiYmVnaW4iLCIwIiwiaW5zcGVjdCIsIm1hdGNoPyIsIn4iLCIkXyIsInNvdXJjZSIsImNhc2Vmb2xkPyIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkByZWdleHAiLCJAYmVnaW4iLCJAc3RyaW5nIiwiQHByZV9tYXRjaCIsIkBwb3N0X21hdGNoIiwiQG1hdGNoZXMiLCJhcmdzIiwib2Zmc2V0Iiwib3RoZXIiLCIkcmV0X29yXzIiLCIkcmV0X29yXzMiLCIkcmV0X29yXzQiLCIkcmV0X29yXzUiLCJlbmQiLCJjYXB0dXJlcyIsImxlbmd0aCIsInRvX2EiLCJ0b19zIiwidmFsdWVzX2F0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFFQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBLEVBQUFBLEdBQUFBLFdBQUFBLEVBQW9CLDZCQUFwQkEsV0FBQTtBQUFBLEVBRUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFBLDBDQUFhQyxDQUFiLENBQUE7QUFBQSxJQUNBLHdDQUFXQyxDQUFYLENBREE7QUFBQSxJQUVBLHlDQUFZQyxDQUFaLENBRkE7QUFBQSxJQUlDLDBEQUpEO0FBQUEsSUFNQTtBQUFBLE1BQUE7O0FBQUE7QUFDRTtBQUFBQyxNQUFBQSw0QkFBQUEsY0FBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQTtBQUNFLFFBQUFDLFlBQVksV0FBQSxFQUFBLHNFQUFB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IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBjb2VyY2VfdG8sIHJlc3BvbmRfdG9cblxucmVxdWlyZSAnY29yZWxpYi9jb21wYXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9yZWdleHAnXG5cbmNsYXNzIFN0cmluZyA8IGBTdHJpbmdgXG4gIGluY2x1ZGUgQ29tcGFyYWJsZVxuXG4gICV4e1xuICAgIE9wYWwuZGVmaW5lUHJvcGVydHkoI3tzZWxmfS4kJHByb3RvdHlwZSwgJyQkaXNfc3RyaW5nJywgdHJ1ZSk7XG5cbiAgICBPcGFsLmRlZmluZVByb3BlcnR5KCN7c2VsZn0uJCRwcm90b3R5cGUsICckJGNhc3QnLCBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciBrbGFzcyA9IHRoaXMuJCRjbGFzcztcbiAgICAgIGlmIChrbGFzcy4kJGNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcga2xhc3MuJCRjb25zdHJ1Y3RvcihzdHJpbmcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGVmIF9faWRfX1xuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cblxuICBkZWYgc2VsZi50cnlfY29udmVydCh3aGF0KVxuICAgIE9wYWwuY29lcmNlX3RvPyh3aGF0LCBTdHJpbmcsIDp0b19zdHIpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5ldygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBhcmdzWzBdIHx8IFwiXCI7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3NbYXJncy5sZW5ndGgtMV07XG4gICAgICBzdHIgPSAkY29lcmNlX3RvKHN0ciwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLiQkaXNfaGFzaCkge1xuICAgICAgICBpZiAob3B0cy4kJHNtYXAuZW5jb2RpbmcpIHN0ciA9IHN0ci4kZm9yY2VfZW5jb2Rpbmcob3B0cy4kJHNtYXAuZW5jb2RpbmcpO1xuICAgICAgfVxuICAgICAgc3RyID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcihzdHIpO1xuICAgICAgaWYgKCFzdHIuJGluaXRpYWxpemUuJCRwcmlzdGluZSkgI3tgc3RyYC5pbml0aWFsaXplKCphcmdzKX07XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgZW5kXG5cbiAgIyBPdXIgaW5pdGlhbGl6ZSBtZXRob2QgZG9lcyBub3RoaW5nLCB0aGUgc3RyaW5nIHZhbHVlIHNldHVwIGlzIGJlaW5nXG4gICMgZG9uZSBieSBTdHJpbmcubmV3LiBUaGVyZWZvcmUgbm90IGFsbCBraW5kcyBvZiBzdWJjbGFzc2luZyB3aWxsIHdvcmsuXG4gICMgQXMgYSBydWxlIG9mIHRodW1iLCB3aGVuIHN1YmNsYXNzaW5nIFN0cmluZywgZWl0aGVyIG1ha2Ugc3VyZSB0byBvdmVycmlkZVxuICAjIC5uZXcgb3IgbWFrZSBzdXJlIHRoYXQgdGhlIGZpcnN0IGFyZ3VtZW50IGdpdmVuIHRvIGEgY29uc3RydWN0b3IgaXNcbiAgIyBhIHN0cmluZyB3ZSB3YW50IG91ciBzdWJjbGFzcy1zdHJpbmcgdG8gaG9sZC5cbiAgZGVmIGluaXRpYWxpemUoc3RyID0gdW5kZWZpbmVkLCBlbmNvZGluZzogbmlsLCBjYXBhY2l0eTogbmlsKVxuICBlbmRcblxuICBkZWYgJShkYXRhKVxuICAgIGlmIEFycmF5ID09PSBkYXRhXG4gICAgICBmb3JtYXQoc2VsZiwgKmRhdGEpXG4gICAgZWxzZVxuICAgICAgZm9ybWF0KHNlbGYsIGRhdGEpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKGNvdW50KVxuICAgICV4e1xuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJndW1lbnQnfVxuICAgICAgfVxuXG4gICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KCcnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgIHN0cmluZyA9IHNlbGYudG9TdHJpbmcoKTtcblxuICAgICAgLy8gQWxsIGNyZWRpdCBmb3IgdGhlIGJpdC10d2lkZGxpbmcgbWFnaWMgY29kZSBiZWxvdyBnb2VzIHRvIE1vemlsbGFcbiAgICAgIC8vIHBvbHlmaWxsIGltcGxlbWVudGF0aW9uIG9mIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KCkgcG9zdGVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwZWF0XG5cbiAgICAgIGlmIChzdHJpbmcubGVuZ3RoICogY291bnQgPj0gMSA8PCAyOCkge1xuICAgICAgICAje3JhaXNlIFJhbmdlRXJyb3IsICdtdWx0aXBseSBjb3VudCBtdXN0IG5vdCBvdmVyZmxvdyBtYXhpbXVtIHN0cmluZyBzaXplJ31cbiAgICAgIH1cblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoKGNvdW50ICYgMSkgPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ID4+Pj0gMTtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICBvdGhlciA9IGAkY29lcmNlX3RvKCN7b3RoZXJ9LCAje1N0cmluZ30sICd0b19zdHInKWBcblxuICAgICV4e1xuICAgICAgaWYgKG90aGVyID09IFwiXCIgJiYgc2VsZi4kJGNsYXNzID09PSBPcGFsLlN0cmluZykgcmV0dXJuICN7c2VsZn07XG4gICAgICBpZiAoc2VsZiA9PSBcIlwiICYmIG90aGVyLiQkY2xhc3MgPT09IE9wYWwuU3RyaW5nKSByZXR1cm4gI3tvdGhlcn07XG4gICAgICB2YXIgb3V0ID0gc2VsZiArIG90aGVyO1xuICAgICAgaWYgKHNlbGYuZW5jb2RpbmcgPT09IG91dC5lbmNvZGluZyAmJiBvdGhlci5lbmNvZGluZyA9PT0gb3V0LmVuY29kaW5nKSByZXR1cm4gb3V0O1xuICAgICAgaWYgKHNlbGYuZW5jb2RpbmcubmFtZSA9PT0gXCJVVEYtOFwiIHx8IG90aGVyLmVuY29kaW5nLm5hbWUgPT09IFwiVVRGLThcIikgcmV0dXJuIG91dDtcbiAgICAgIHJldHVybiBPcGFsLmVuYyhvdXQsIHNlbGYuZW5jb2RpbmcpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fc3RyXG4gICAgICBvdGhlciA9IG90aGVyLnRvX3N0ci50b19zXG5cbiAgICAgIGBzZWxmID4gb3RoZXIgPyAxIDogKHNlbGYgPCBvdGhlciA/IC0xIDogMClgXG4gICAgZWxzZVxuICAgICAgJXh7XG4gICAgICAgIHZhciBjbXAgPSAje290aGVyIDw9PiBzZWxmfTtcblxuICAgICAgICBpZiAoY21wID09PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjbXAgPiAwID8gLTEgOiAoY21wIDwgMCA/IDEgOiAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudG9TdHJpbmcoKSA9PT0gb3RoZXIudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICgkcmVzcG9uZF90byhvdGhlciwgJyR0b19zdHInKSkge1xuICAgICAgICByZXR1cm4gI3tvdGhlciA9PSBzZWxmfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGVxbD8gPT1cbiAgYWxpYXMgPT09ID09XG5cbiAgZGVmID1+KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndHlwZSBtaXNtYXRjaDogU3RyaW5nIGdpdmVuJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje290aGVyID1+IHNlbGZ9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLCBleGNsdWRlO1xuXG4gICAgICBpZiAoaW5kZXguJCRpc19yYW5nZSkge1xuICAgICAgICBleGNsdWRlID0gaW5kZXguZXhjbDtcbiAgICAgICAgbGVuZ3RoICA9ICRjb2VyY2VfdG8oaW5kZXguZW5kLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGluZGV4ICAgPSAkY29lcmNlX3RvKGluZGV4LmJlZ2luLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGluZGV4KSA+IHNpemUpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgIGxlbmd0aCArPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFleGNsdWRlKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggPSBsZW5ndGggLSBpbmRleDtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zdWJzdHIoaW5kZXgsIGxlbmd0aCkpO1xuICAgICAgfVxuXG5cbiAgICAgIGlmIChpbmRleC4kJGlzX3N0cmluZykge1xuICAgICAgICBpZiAobGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvcn1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi5pbmRleE9mKGluZGV4KSAhPT0gLTEgPyBzZWxmLiQkY2FzdChpbmRleCkgOiBuaWw7XG4gICAgICB9XG5cblxuICAgICAgaWYgKGluZGV4LiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHNlbGYubWF0Y2goaW5kZXgpO1xuXG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICN7JH4gPSBuaWx9XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgICN7JH4gPSBNYXRjaERhdGEubmV3KGBpbmRleGAsIGBtYXRjaGApfVxuXG4gICAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChtYXRjaFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAwICYmIC1sZW5ndGggPCBtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QobWF0Y2hbbGVuZ3RoICs9IG1hdGNoLmxlbmd0aF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8IG1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChtYXRjaFtsZW5ndGhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cblxuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2l6ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpbmRleCA+PSBzaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYuc3Vic3RyKGluZGV4LCAxKSk7XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA+IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnN1YnN0cihpbmRleCwgbGVuZ3RoKSk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBieXRlc2xpY2UgW11cblxuICBkZWYgYlxuICAgIGBuZXcgU3RyaW5nKCN7c2VsZn0pYC5mb3JjZV9lbmNvZGluZygnYmluYXJ5JylcbiAgZW5kXG5cbiAgZGVmIGNhcGl0YWxpemVcbiAgICBgc2VsZi4kJGNhc3Qoc2VsZi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHNlbGYuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCkpYFxuICBlbmRcblxuICBkZWYgY2FzZWNtcChvdGhlcilcbiAgICByZXR1cm4gbmlsIHVubGVzcyBvdGhlci5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgIG90aGVyID0gYCRjb2VyY2VfdG8ob3RoZXIsICN7U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXG4gICAgJXh7XG4gICAgICB2YXIgYXNjaWlfb25seSA9IC9eW1xceDAwLVxceDdGXSokLztcbiAgICAgIGlmIChhc2NpaV9vbmx5LnRlc3Qoc2VsZikgJiYgYXNjaWlfb25seS50ZXN0KG90aGVyKSkge1xuICAgICAgICBzZWxmID0gc2VsZi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBvdGhlciA9IG90aGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYgPD0+IG90aGVyXG4gIGVuZFxuXG4gIGRlZiBjYXNlY21wPyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBjbXAgPSAje2Nhc2VjbXAob3RoZXIpfTtcbiAgICAgIGlmIChjbXAgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNtcCA9PT0gMDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjZW50ZXIod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBgJGNvZXJjZV90bygje3dpZHRofSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgIHBhZHN0ciA9IGAkY29lcmNlX3RvKCN7cGFkc3RyfSwgI3tTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBsanVzdGlmaWVkID0gI3tsanVzdCAoKHdpZHRoICsgYHNlbGYubGVuZ3RoYCkgLyAyKS5jZWlsLCBwYWRzdHJ9LFxuICAgICAgICAgIHJqdXN0aWZpZWQgPSAje3JqdXN0ICgod2lkdGggKyBgc2VsZi5sZW5ndGhgKSAvIDIpLmZsb29yLCBwYWRzdHJ9O1xuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qocmp1c3RpZmllZCArIGxqdXN0aWZpZWQuc2xpY2Uoc2VsZi5sZW5ndGgpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaG9tcChzZXBhcmF0b3IgPSAkLylcbiAgICByZXR1cm4gc2VsZiBpZiBgc2VwYXJhdG9yID09PSBuaWwgfHwgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBzZXBhcmF0b3IgPSBPcGFsLmNvZXJjZV90byEoc2VwYXJhdG9yLCBTdHJpbmcsIDp0b19zdHIpLnRvX3NcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gXCJcXG5cIikge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnJlcGxhY2UoL1xccj9cXG4/JC8sICcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlcGFyYXRvciA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnJlcGxhY2UoLyhcXHI/XFxuKSskLywgJycpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VsZi5sZW5ndGggPj0gc2VwYXJhdG9yLmxlbmd0aCkge1xuICAgICAgICB2YXIgdGFpbCA9IHNlbGYuc3Vic3RyKHNlbGYubGVuZ3RoIC0gc2VwYXJhdG9yLmxlbmd0aCwgc2VwYXJhdG9yLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRhaWwgPT09IHNlcGFyYXRvcikge1xuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc3Vic3RyKDAsIHNlbGYubGVuZ3RoIC0gc2VwYXJhdG9yLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNob3BcbiAgICAleHtcbiAgICAgIHZhciBsZW5ndGggPSBzZWxmLmxlbmd0aCwgcmVzdWx0O1xuXG4gICAgICBpZiAobGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gXCJcIjtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5jaGFyQXQobGVuZ3RoIC0gMSkgPT09IFwiXFxuXCIgJiYgc2VsZi5jaGFyQXQobGVuZ3RoIC0gMikgPT09IFwiXFxyXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5zdWJzdHIoMCwgbGVuZ3RoIC0gMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnN1YnN0cigwLCBsZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hyXG4gICAgYHNlbGYuY2hhckF0KDApYFxuICBlbmRcblxuICBkZWYgY2xvbmVcbiAgICBjb3B5ID0gYG5ldyBTdHJpbmcoc2VsZilgXG4gICAgY29weS5jb3B5X3NpbmdsZXRvbl9tZXRob2RzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2Nsb25lKHNlbGYpXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IGBuZXcgU3RyaW5nKHNlbGYpYFxuICAgIGNvcHkuaW5pdGlhbGl6ZV9kdXAoc2VsZilcbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBjb3VudCgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdBcmd1bWVudEVycm9yOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKyknfVxuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggLSBzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cChjaGFyX2NsYXNzLCAnZycpLCAnJykubGVuZ3RoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZSgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdBcmd1bWVudEVycm9yOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKyknfVxuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAoY2hhcl9jbGFzcywgJ2cnKSwgJycpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfcHJlZml4KHByZWZpeClcbiAgICAleHtcbiAgICAgIGlmICghcHJlZml4LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHByZWZpeCA9ICRjb2VyY2VfdG8ocHJlZml4LCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuc2xpY2UoMCwgcHJlZml4Lmxlbmd0aCkgPT09IHByZWZpeCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zbGljZShwcmVmaXgubGVuZ3RoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfc3VmZml4KHN1ZmZpeClcbiAgICAleHtcbiAgICAgIGlmICghc3VmZml4LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHN1ZmZpeCA9ICRjb2VyY2VfdG8oc3VmZml4LCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuc2xpY2Uoc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSA9PT0gc3VmZml4KSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnNsaWNlKDAsIHNlbGYubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZG93bmNhc2VcbiAgICBgc2VsZi4kJGNhc3Qoc2VsZi50b0xvd2VyQ2FzZSgpKWBcbiAgZW5kXG5cbiAgZGVmIGVhY2hfbGluZShzZXBhcmF0b3IgPSAkLywgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9saW5lLCBzZXBhcmF0b3IgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSBuaWwpIHtcbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIHNlbGYpO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBzZXBhcmF0b3IgPSAkY29lcmNlX3RvKHNlcGFyYXRvciwgI3tTdHJpbmd9LCAndG9fc3RyJylcblxuICAgICAgdmFyIGEsIGksIG4sIGxlbmd0aCwgY2hvbXBlZCwgdHJhaWxpbmcsIHNwbGl0dGVkO1xuXG4gICAgICBpZiAoc2VwYXJhdG9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmb3IgKGEgPSBzZWxmLnNwbGl0KC8oXFxuezIsfSkvKSwgaSA9IDAsIG4gPSBhLmxlbmd0aDsgaSA8IG47IGkgKz0gMikge1xuICAgICAgICAgIGlmIChhW2ldIHx8IGFbaSArIDFdKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAoYVtpXSB8fCBcIlwiKSArIChhW2kgKyAxXSB8fCBcIlwiKTtcbiAgICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmLiQkY2FzdCh2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBjaG9tcGVkICA9ICN7Y2hvbXAoc2VwYXJhdG9yKX07XG4gICAgICB0cmFpbGluZyA9IHNlbGYubGVuZ3RoICE9IGNob21wZWQubGVuZ3RoO1xuICAgICAgc3BsaXR0ZWQgPSBjaG9tcGVkLnNwbGl0KHNlcGFyYXRvcik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNwbGl0dGVkLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSB8fCB0cmFpbGluZykge1xuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmLiQkY2FzdChzcGxpdHRlZFtpXSArIHNlcGFyYXRvcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmLiQkY2FzdChzcGxpdHRlZFtpXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYubGVuZ3RoID09PSAwYFxuICBlbmRcblxuICBkZWYgZW5kX3dpdGg/KCpzdWZmaXhlcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdWZmaXhlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VmZml4ID0gJGNvZXJjZV90byhzdWZmaXhlc1tpXSwgI3tTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgICBpZiAoc2VsZi5sZW5ndGggPj0gc3VmZml4Lmxlbmd0aCAmJlxuICAgICAgICAgICAgc2VsZi5zdWJzdHIoc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoLCBzdWZmaXgubGVuZ3RoKSA9PSBzdWZmaXgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGFsaWFzIGVxdWFsPyA9PT1cblxuICBkZWYgZ3N1YihwYXR0ZXJuLCByZXBsYWNlbWVudCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3tlbnVtX2ZvciA6Z3N1YiwgcGF0dGVybn07XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAnJywgbWF0Y2hfZGF0YSA9IG5pbCwgaW5kZXggPSAwLCBtYXRjaCwgX3JlcGxhY2VtZW50O1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnbScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdEluZGV4O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc2VsZik7XG5cbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICByZXN1bHQgKz0gc2VsZi5zbGljZShpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRjaF9kYXRhID0gI3tNYXRjaERhdGEubmV3IGBwYXR0ZXJuYCwgYG1hdGNoYH07XG5cbiAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsYXN0SW5kZXggPSBwYXR0ZXJuLmxhc3RJbmRleDtcbiAgICAgICAgICBfcmVwbGFjZW1lbnQgPSBibG9jayhtYXRjaFswXSk7XG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggPSBsYXN0SW5kZXg7IC8vIHNhdmUgYW5kIHJlc3RvcmUgbGFzdEluZGV4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVwbGFjZW1lbnQuJCRpc19oYXNoKSB7XG4gICAgICAgICAgX3JlcGxhY2VtZW50ID0gI3tgcmVwbGFjZW1lbnRgW2BtYXRjaFswXWBdLnRvX3N9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICghcmVwbGFjZW1lbnQuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gJGNvZXJjZV90byhyZXBsYWNlbWVudCwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9yZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LnJlcGxhY2UoLyhbXFxcXF0rKShbMC05KyZgJ10pL2csIGZ1bmN0aW9uIChvcmlnaW5hbCwgc2xhc2hlcywgY29tbWFuZCkge1xuICAgICAgICAgICAgaWYgKHNsYXNoZXMubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBtYXRjaC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIGNhc2UgXCImXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbMF07XG4gICAgICAgICAgICBjYXNlIFwiYFwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6ICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIChtYXRjaFtjb21tYW5kXSB8fCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXR0ZXJuLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICByZXN1bHQgKz0gKHNlbGYuc2xpY2UoaW5kZXgsIG1hdGNoLmluZGV4KSArIF9yZXBsYWNlbWVudCArIChzZWxmW21hdGNoLmluZGV4XSB8fCBcIlwiKSk7XG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgKz0gKHNlbGYuc2xpY2UoaW5kZXgsIG1hdGNoLmluZGV4KSArIF9yZXBsYWNlbWVudClcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgfVxuXG4gICAgICAjeyR+ID0gYG1hdGNoX2RhdGFgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiBoZXhcbiAgICB0b19pIDE2XG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhvdGhlcilcbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgb3RoZXIgPSAkY29lcmNlX3RvKG90aGVyLCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmluZGV4T2Yob3RoZXIpICE9PSAtMTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmRleChzZWFyY2gsIG9mZnNldCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICByZWdleDtcblxuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSAkY29lcmNlX3RvKG9mZnNldCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgIG9mZnNldCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYXJjaC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICByZWdleCA9IE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAoc2VhcmNoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoc2VsZik7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICAjeyR+ID0gbmlsfTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID49IG9mZnNldCkge1xuICAgICAgICAgICAgI3skfiA9IE1hdGNoRGF0YS5uZXcoYHJlZ2V4YCwgYG1hdGNoYCl9XG4gICAgICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoID0gJGNvZXJjZV90byhzZWFyY2gsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpZiAoc2VhcmNoLmxlbmd0aCA9PT0gMCAmJiBvZmZzZXQgPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXggPSBzZWxmLmluZGV4T2Yoc2VhcmNoLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRleCA9PT0gLTEgPyBuaWwgOiBpbmRleDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx1MDA3Ri1cXHUwMDlGXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICAgICAgICBtZXRhID0ge1xuICAgICAgICAgICAgJ1xcdTAwMDcnOiAnXFxcXGEnLFxuICAgICAgICAgICAgJ1xcdTAwMWInOiAnXFxcXGUnLFxuICAgICAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgICAgICdcXHYnOiAnXFxcXHYnLFxuICAgICAgICAgICAgJ1wiJyA6ICdcXFxcXCInLFxuICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlc2NhcGVkID0gc2VsZi5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGNocikge1xuICAgICAgICAgICAgaWYgKG1ldGFbY2hyXSkgcmV0dXJuIG1ldGFbY2hyXTtcbiAgICAgICAgICAgIGNociA9IGNoci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYgKGNociA8PSAweGZmICYmIChzZWxmLmVuY29kaW5nW1wiJGJpbmFyeT9cIl0oKSB8fCBzZWxmLmludGVybmFsX2VuY29kaW5nW1wiJGJpbmFyeT9cIl0oKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdcXFxceCcgKyAoJzAwJyArIGNoci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdcXFxcdScgKyAoJzAwMDAnICsgY2hyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICByZXR1cm4gJ1wiJyArIGVzY2FwZWQucmVwbGFjZSgvXFwjW1xcJFxcQFxce10vZywgJ1xcXFwkJicpICsgJ1wiJztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnRlcm5cbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgbGluZXMoc2VwYXJhdG9yID0gJC8sICZibG9jaylcbiAgICBlID0gZWFjaF9saW5lKHNlcGFyYXRvciwgJmJsb2NrKVxuICAgIGJsb2NrID8gc2VsZiA6IGUudG9fYVxuICBlbmRcblxuICBkZWYgbGp1c3Qod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBgJGNvZXJjZV90bygje3dpZHRofSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgIHBhZHN0ciA9IGAkY29lcmNlX3RvKCN7cGFkc3RyfSwgI3tTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBpbmRleCAgPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBcIlwiO1xuXG4gICAgICB3aWR0aCAtPSBzZWxmLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCB3aWR0aCkge1xuICAgICAgICByZXN1bHQgKz0gcGFkc3RyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZiArIHJlc3VsdC5zbGljZSgwLCB3aWR0aCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL15cXHMqLywgJycpYFxuICBlbmRcblxuICBkZWYgYXNjaWlfb25seT9cbiAgICAjIG5vbi1BU0NJSS1jb21wYXRpYmxlIGVuY29kaW5nIG11c3QgcmV0dXJuIGZhbHNlXG4gICAgJXh7XG4gICAgICBpZiAoIXNlbGYuZW5jb2RpbmcuYXNjaWkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiAvXltcXHgwMC1cXHg3Rl0qJC8udGVzdChzZWxmKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtYXRjaChwYXR0ZXJuLCBwb3MgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBTdHJpbmcgPT09IHBhdHRlcm4gfHwgcGF0dGVybi5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgICAgcGF0dGVybiA9IFJlZ2V4cC5uZXcocGF0dGVybi50b19zdHIpXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgUmVnZXhwID09PSBwYXR0ZXJuXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje3BhdHRlcm4uY2xhc3N9IChleHBlY3RlZCBSZWdleHApXCJcbiAgICBlbmRcblxuICAgIHBhdHRlcm4ubWF0Y2goc2VsZiwgcG9zLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBtYXRjaD8ocGF0dGVybiwgcG9zID0gdW5kZWZpbmVkKVxuICAgIGlmIFN0cmluZyA9PT0gcGF0dGVybiB8fCBwYXR0ZXJuLnJlc3BvbmRfdG8/KDp0b19zdHIpXG4gICAgICBwYXR0ZXJuID0gUmVnZXhwLm5ldyhwYXR0ZXJuLnRvX3N0cilcbiAgICBlbmRcblxuICAgIHVubGVzcyBSZWdleHAgPT09IHBhdHRlcm5cbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7cGF0dGVybi5jbGFzc30gKGV4cGVjdGVkIFJlZ2V4cClcIlxuICAgIGVuZFxuXG4gICAgcGF0dGVybi5tYXRjaD8oc2VsZiwgcG9zKVxuICBlbmRcblxuICBkZWYgbmV4dFxuICAgICV4e1xuICAgICAgdmFyIGkgPSBzZWxmLmxlbmd0aDtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdCgnJyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc2VsZjtcbiAgICAgIHZhciBmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4ID0gc2VsZi5zZWFyY2goL1thLXpBLVowLTldLyk7XG4gICAgICB2YXIgY2FycnkgPSBmYWxzZTtcbiAgICAgIHZhciBjb2RlO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb2RlID0gc2VsZi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB8fFxuICAgICAgICAgIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyKSkge1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgNTc6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gNDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IDY1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMjI6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gOTc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FycnkgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZpcnN0X2FscGhhbnVtX2NoYXJfaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMjU1KSB7XG4gICAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29kZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXJyeSA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIHJlc3VsdC5zbGljZShpICsgMSk7XG4gICAgICAgIGlmIChjYXJyeSAmJiAoaSA9PT0gMCB8fCBpID09PSBmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4KSkge1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgNjU6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk3OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQuc2xpY2UoaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhcnJ5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYXJyeSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QocmVzdWx0KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBvY3RcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgc3RyaW5nID0gc2VsZixcbiAgICAgICAgICByYWRpeCA9IDg7XG5cbiAgICAgIGlmICgvXlxccypfLy50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eKFxccypbKy1dPykoMFtib2R4XT8pKC4rKSQvaSwgZnVuY3Rpb24gKG9yaWdpbmFsLCBoZWFkLCBmbGFnLCB0YWlsKSB7XG4gICAgICAgIHN3aXRjaCAodGFpbC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgaWYgKHRhaWwuY2hhckF0KDEpID09PSAneCcgJiYgZmxhZyA9PT0gJzB4Jykge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgY2FzZSAnMGInOlxuICAgICAgICAgIHJhZGl4ID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICByYWRpeCA9IDg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzBkJzpcbiAgICAgICAgICByYWRpeCA9IDEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcweCc6XG4gICAgICAgICAgcmFkaXggPSAxNjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoc3RyaW5nLnJlcGxhY2UoL18oPyFfKS9nLCAnJyksIHJhZGl4KTtcbiAgICAgIHJldHVybiBpc05hTihyZXN1bHQpID8gMCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBvcmRcbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZi5jb2RlUG9pbnRBdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNvZGVQb2ludEF0KDApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNoYXJDb2RlQXQoMCk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcGFydGl0aW9uKHNlcClcbiAgICAleHtcbiAgICAgIHZhciBpLCBtO1xuXG4gICAgICBpZiAoc2VwLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIG0gPSBzZXAuZXhlYyhzZWxmKTtcbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgICBpID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3tNYXRjaERhdGEubmV3IGBzZXBgLCBgbWB9O1xuICAgICAgICAgIHNlcCA9IG1bMF07XG4gICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcCA9ICRjb2VyY2VfdG8oc2VwLCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaSA9IHNlbGYuaW5kZXhPZihzZXApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFtzZWxmLCAnJywgJyddO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzZWxmLnNsaWNlKDAsIGkpLFxuICAgICAgICBzZWxmLnNsaWNlKGksIGkgKyBzZXAubGVuZ3RoKSxcbiAgICAgICAgc2VsZi5zbGljZShpICsgc2VwLmxlbmd0aClcbiAgICAgIF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmV2ZXJzZVxuICAgIGBzZWxmLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJylgXG4gIGVuZFxuXG4gIGRlZiByaW5kZXgoc2VhcmNoLCBvZmZzZXQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbSwgciwgX207XG5cbiAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvZmZzZXQgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9ICRjb2VyY2VfdG8ob2Zmc2V0LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VhcmNoLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIG0gPSBudWxsO1xuICAgICAgICByID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChzZWFyY2gpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIF9tID0gci5leGVjKHNlbGYpO1xuICAgICAgICAgIGlmIChfbSA9PT0gbnVsbCB8fCBfbS5pbmRleCA+IG9mZnNldCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG0gPSBfbTtcbiAgICAgICAgICByLmxhc3RJbmRleCA9IG0uaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICBpID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3tNYXRjaERhdGEubmV3IGByYCwgYG1gfTtcbiAgICAgICAgICBpID0gbS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoID0gJGNvZXJjZV90byhzZWFyY2gsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpID0gc2VsZi5sYXN0SW5kZXhPZihzZWFyY2gsIG9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpID09PSAtMSA/IG5pbCA6IGk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmp1c3Qod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBgJGNvZXJjZV90bygje3dpZHRofSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgIHBhZHN0ciA9IGAkY29lcmNlX3RvKCN7cGFkc3RyfSwgI3tTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBjaGFycyAgICAgPSBNYXRoLmZsb29yKHdpZHRoIC0gc2VsZi5sZW5ndGgpLFxuICAgICAgICAgIHBhdHRlcm5zICA9IE1hdGguZmxvb3IoY2hhcnMgLyBwYWRzdHIubGVuZ3RoKSxcbiAgICAgICAgICByZXN1bHQgICAgPSBBcnJheShwYXR0ZXJucyArIDEpLmpvaW4ocGFkc3RyKSxcbiAgICAgICAgICByZW1haW5pbmcgPSBjaGFycyAtIHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQgKyBwYWRzdHIuc2xpY2UoMCwgcmVtYWluaW5nKSArIHNlbGYpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJwYXJ0aXRpb24oc2VwKVxuICAgICV4e1xuICAgICAgdmFyIGksIG0sIHIsIF9tO1xuXG4gICAgICBpZiAoc2VwLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIG0gPSBudWxsO1xuICAgICAgICByID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChzZXApO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgX20gPSByLmV4ZWMoc2VsZik7XG4gICAgICAgICAgaWYgKF9tID09PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbSA9IF9tO1xuICAgICAgICAgIHIubGFzdEluZGV4ID0gbS5pbmRleCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAje01hdGNoRGF0YS5uZXcgYHJgLCBgbWB9O1xuICAgICAgICAgIHNlcCA9IG1bMF07XG4gICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VwID0gJGNvZXJjZV90byhzZXAsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpID0gc2VsZi5sYXN0SW5kZXhPZihzZXApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFsnJywgJycsIHNlbGZdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzZWxmLnNsaWNlKDAsIGkpLFxuICAgICAgICBzZWxmLnNsaWNlKGksIGkgKyBzZXAubGVuZ3RoKSxcbiAgICAgICAgc2VsZi5zbGljZShpICsgc2VwLmxlbmd0aClcbiAgICAgIF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgcnN0cmlwXG4gICAgYHNlbGYucmVwbGFjZSgvW1xcc1xcdTAwMDBdKiQvLCAnJylgXG4gIGVuZFxuXG4gIGRlZiBzY2FuKHBhdHRlcm4sICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBtYXRjaF9kYXRhID0gbmlsLFxuICAgICAgICAgIG1hdGNoO1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnbScpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKG1hdGNoID0gcGF0dGVybi5leGVjKHNlbGYpKSAhPSBudWxsKSB7XG4gICAgICAgIG1hdGNoX2RhdGEgPSAje01hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgfTtcbiAgICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgICBtYXRjaC5sZW5ndGggPT0gMSA/IHJlc3VsdC5wdXNoKG1hdGNoWzBdKSA6IHJlc3VsdC5wdXNoKCN7YG1hdGNoX2RhdGFgLmNhcHR1cmVzfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2gubGVuZ3RoID09IDEgPyBibG9jayhtYXRjaFswXSkgOiBibG9jay5jYWxsKHNlbGYsICN7YG1hdGNoX2RhdGFgLmNhcHR1cmVzfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdHRlcm4ubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgI3skfiA9IGBtYXRjaF9kYXRhYH1cblxuICAgICAgcmV0dXJuIChibG9jayAhPT0gbmlsID8gc2VsZiA6IHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzbGljZSBbXVxuXG4gIGRlZiBzcGxpdChwYXR0ZXJuID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbWl0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbWl0ID0gI3tPcGFsLmNvZXJjZV90byEobGltaXQsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgaWYgKGxpbWl0ID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFtzZWxmXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkIHx8IHBhdHRlcm4gPT09IG5pbCkge1xuICAgICAgICBwYXR0ZXJuID0gI3skOyB8fCAnICd9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc3RyaW5nID0gc2VsZi50b1N0cmluZygpLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBpLCBpaTtcblxuICAgICAgaWYgKHBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9IE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAocGF0dGVybik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXR0ZXJuID0gJGNvZXJjZV90byhwYXR0ZXJuLCAje1N0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuICAgICAgICBpZiAocGF0dGVybiA9PT0gJyAnKSB7XG4gICAgICAgICAgcGF0dGVybiA9IC9cXHMrL2dtO1xuICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnbScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IHN0cmluZy5zcGxpdChwYXR0ZXJuKTtcblxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEgJiYgcmVzdWx0WzBdID09PSBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIFtzZWxmLiQkY2FzdChyZXN1bHRbMF0pXTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKChpID0gcmVzdWx0LmluZGV4T2YodW5kZWZpbmVkKSkgIT09IC0xKSB7XG4gICAgICAgIHJlc3VsdC5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNhc3RSZXN1bHQoKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXN1bHRbaV0gPSBzZWxmLiQkY2FzdChyZXN1bHRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA9PT0gMCkge1xuICAgICAgICB3aGlsZSAocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAgICByZXN1bHQubGVuZ3RoIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgY2FzdFJlc3VsdCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzdHJpbmcpO1xuXG4gICAgICBpZiAobGltaXQgPCAwKSB7XG4gICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCAmJiBtYXRjaFswXSA9PT0gJycgJiYgcGF0dGVybi5zb3VyY2UuaW5kZXhPZignKD89JykgPT09IC0xKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBtYXRjaC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc3RSZXN1bHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIG1hdGNoWzBdID09PSAnJykge1xuICAgICAgICByZXN1bHQuc3BsaWNlKGxpbWl0IC0gMSwgcmVzdWx0Lmxlbmd0aCAtIDEsIHJlc3VsdC5zbGljZShsaW1pdCAtIDEpLmpvaW4oJycpKTtcbiAgICAgICAgY2FzdFJlc3VsdCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAobGltaXQgPj0gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGkgPSAwO1xuICAgICAgd2hpbGUgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgIGkrKztcbiAgICAgICAgaW5kZXggPSBwYXR0ZXJuLmxhc3RJbmRleDtcbiAgICAgICAgaWYgKGkgKyAxID09PSBsaW1pdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gcGF0dGVybi5leGVjKHN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXN1bHQuc3BsaWNlKGxpbWl0IC0gMSwgcmVzdWx0Lmxlbmd0aCAtIDEsIHN0cmluZy5zbGljZShpbmRleCkpO1xuICAgICAgY2FzdFJlc3VsdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzcXVlZXplKCpzZXRzKVxuICAgICV4e1xuICAgICAgaWYgKHNldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnJlcGxhY2UoLyguKVxcMSsvZywgJyQxJykpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAoJygnICsgY2hhcl9jbGFzcyArICcpXFxcXDErJywgJ2cnKSwgJyQxJykpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN0YXJ0X3dpdGg/KCpwcmVmaXhlcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBwcmVmaXhlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocHJlZml4ZXNbaV0uJCRpc19yZWdleHApIHtcbiAgICAgICAgICB2YXIgcmVnZXhwID0gcHJlZml4ZXNbaV07XG4gICAgICAgICAgdmFyIG1hdGNoID0gcmVnZXhwLmV4ZWMoc2VsZik7XG5cbiAgICAgICAgICBpZiAobWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5pbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgI3skfiA9IE1hdGNoRGF0YS5uZXcoYHJlZ2V4cGAsIGBtYXRjaGApfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gJGNvZXJjZV90byhwcmVmaXhlc1tpXSwgI3tTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgICAgIGlmIChzZWxmLmluZGV4T2YocHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1tcXHNcXHUwMDAwXSokLywgJycpYFxuICBlbmRcblxuICBkZWYgc3ViKHBhdHRlcm4sIHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoIXBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9ICRjb2VyY2VfdG8ocGF0dGVybiwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQsIG1hdGNoID0gcGF0dGVybi5leGVjKHNlbGYpO1xuXG4gICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgcmVzdWx0ID0gc2VsZi50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgI3tNYXRjaERhdGEubmV3IGBwYXR0ZXJuYCwgYG1hdGNoYH1cblxuICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDEgZm9yIDIpJ31cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyBibG9jayhtYXRjaFswXSkgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlcGxhY2VtZW50LiQkaXNfaGFzaCkge1xuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAje2ByZXBsYWNlbWVudGBbYG1hdGNoWzBdYF0udG9fc30gKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSAkY29lcmNlX3RvKHJlcGxhY2VtZW50LCAje1N0cmluZ30sICd0b19zdHInKTtcblxuICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQucmVwbGFjZSgvKFtcXFxcXSspKFswLTkrJmAnXSkvZywgZnVuY3Rpb24gKG9yaWdpbmFsLCBzbGFzaGVzLCBjb21tYW5kKSB7XG4gICAgICAgICAgICBpZiAoc2xhc2hlcy5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG1hdGNoLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBtYXRjaFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgY2FzZSBcIiZcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBtYXRjaFswXTtcbiAgICAgICAgICAgIGNhc2UgXCJgXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgZGVmYXVsdDogIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgKG1hdGNoW2NvbW1hbmRdIHx8ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyByZXBsYWNlbWVudCArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3VjYyBuZXh0XG5cbiAgZGVmIHN1bShuID0gMTYpXG4gICAgJXh7XG4gICAgICBuID0gJGNvZXJjZV90byhuLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIHZhciByZXN1bHQgPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBzZWxmLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdCAmIChNYXRoLnBvdygyLCBuKSAtIDEpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN3YXBjYXNlXG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gc2VsZi5yZXBsYWNlKC8oW2Etel0rKXwoW0EtWl0rKS9nLCBmdW5jdGlvbigkMCwkMSwkMikge1xuICAgICAgICByZXR1cm4gJDEgPyAkMC50b1VwcGVyQ2FzZSgpIDogJDAudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2VsZi5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje3NlbGYuY2xhc3MubmV3IGBzdHJgfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5jaGFyQXQoMCkgPT09ICdfJykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRmxvYXQoc2VsZi5yZXBsYWNlKC9fL2csICcnKSk7XG5cbiAgICAgIGlmIChpc05hTihyZXN1bHQpIHx8IHJlc3VsdCA9PSBJbmZpbml0eSB8fCByZXN1bHQgPT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9faShiYXNlID0gMTApXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHN0cmluZyA9IHNlbGYudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICByYWRpeCA9ICRjb2VyY2VfdG8oYmFzZSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAocmFkaXggPT09IDEgfHwgcmFkaXggPCAwIHx8IHJhZGl4ID4gMzYpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tgcmFkaXhgfVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoL15cXHMqXy8udGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXihcXHMqWystXT8pKDBbYm9keF0/KSguKykkLywgZnVuY3Rpb24gKG9yaWdpbmFsLCBoZWFkLCBmbGFnLCB0YWlsKSB7XG4gICAgICAgIHN3aXRjaCAodGFpbC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgaWYgKHRhaWwuY2hhckF0KDEpID09PSAneCcgJiYgZmxhZyA9PT0gJzB4JyAmJiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDE2KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgY2FzZSAnMGInOlxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMikge1xuICAgICAgICAgICAgcmFkaXggPSAyO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDgpIHtcbiAgICAgICAgICAgIHJhZGl4ID0gODtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzBkJzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDEwKSB7XG4gICAgICAgICAgICByYWRpeCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMHgnOlxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMTYpIHtcbiAgICAgICAgICAgIHJhZGl4ID0gMTY7XG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFxuICAgICAgfSk7XG5cbiAgICAgIHJlc3VsdCA9IHBhcnNlSW50KHN0cmluZy5yZXBsYWNlKC9fKD8hXykvZywgJycpLCByYWRpeCk7XG4gICAgICByZXR1cm4gaXNOYU4ocmVzdWx0KSA/IDAgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIG1ldGhvZF9uYW1lID0gJyQnICsgYHNlbGYudmFsdWVPZigpYFxuXG4gICAgcHJvYyBkbyB8KmFyZ3MsICZibG9ja3xcbiAgICAgICV4e1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdubyByZWNlaXZlciBnaXZlbid9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdiA9IGFyZ3NbMF07XG5cbiAgICAgICAgaWYgKHJlY3YgPT0gbnVsbCkgcmVjdiA9IG5pbDtcblxuICAgICAgICB2YXIgYm9keSA9IHJlY3ZbI3ttZXRob2RfbmFtZX1dO1xuXG4gICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgIHJldHVybiByZWN2LiRtZXRob2RfbWlzc2luZy5hcHBseShyZWN2LCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBib2R5LiQkcCA9IGJsb2NrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGJvZHkuY2FsbChyZWN2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYm9keS5hcHBseShyZWN2LCBhcmdzLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGFsaWFzIHRvX3N0ciB0b19zXG5cbiAgYWxpYXMgdG9fc3ltIGludGVyblxuXG4gIGRlZiB0cihmcm9tLCB0bylcbiAgICAleHtcbiAgICAgIGZyb20gPSAkY29lcmNlX3RvKGZyb20sICN7U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG4gICAgICB0byA9ICRjb2VyY2VfdG8odG8sICN7U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG5cbiAgICAgIGlmIChmcm9tLmxlbmd0aCA9PSAwIHx8IGZyb20gPT09IHRvKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgaW5fcmFuZ2UsIGMsIGNoLCBzdGFydCwgZW5kLCBsZW5ndGg7XG4gICAgICB2YXIgc3VicyA9IHt9O1xuICAgICAgdmFyIGZyb21fY2hhcnMgPSBmcm9tLnNwbGl0KCcnKTtcbiAgICAgIHZhciBmcm9tX2xlbmd0aCA9IGZyb21fY2hhcnMubGVuZ3RoO1xuICAgICAgdmFyIHRvX2NoYXJzID0gdG8uc3BsaXQoJycpO1xuICAgICAgdmFyIHRvX2xlbmd0aCA9IHRvX2NoYXJzLmxlbmd0aDtcblxuICAgICAgdmFyIGludmVyc2UgPSBmYWxzZTtcbiAgICAgIHZhciBnbG9iYWxfc3ViID0gbnVsbDtcbiAgICAgIGlmIChmcm9tX2NoYXJzWzBdID09PSAnXicgJiYgZnJvbV9jaGFycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGludmVyc2UgPSB0cnVlO1xuICAgICAgICBmcm9tX2NoYXJzLnNoaWZ0KCk7XG4gICAgICAgIGdsb2JhbF9zdWIgPSB0b19jaGFyc1t0b19sZW5ndGggLSAxXVxuICAgICAgICBmcm9tX2xlbmd0aCAtPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnJvbV9jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgdmFyIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBmcm9tX2NoYXJzW2ldO1xuICAgICAgICBpZiAobGFzdF9mcm9tID09IG51bGwpIHtcbiAgICAgICAgICBsYXN0X2Zyb20gPSBjaDtcbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICBpZiAobGFzdF9mcm9tID09PSAnLScpIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGkgPT0gZnJvbV9sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgc3RhcnQgPSBsYXN0X2Zyb20uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBlbmQgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICBpbl9yYW5nZSA9IG51bGw7XG4gICAgICAgICAgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyb21fY2hhcnMgPSBmcm9tX2NoYXJzX2V4cGFuZGVkO1xuICAgICAgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcblxuICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJzW2Zyb21fY2hhcnNbaV1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0b19sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHRvX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICAgICAgdmFyIGxhc3RfdG8gPSBudWxsO1xuICAgICAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaCA9IHRvX2NoYXJzW2ldO1xuICAgICAgICAgICAgaWYgKGxhc3RfdG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBsYXN0X3RvID0gY2g7XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgICAgICBpZiAobGFzdF90byA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpID09IHRvX2xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xuICAgICAgICAgICAgICBzdGFydCA9IGxhc3RfdG8uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGMgPSBzdGFydCArIDE7IGMgPCBlbmQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgbGFzdF90byA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9fY2hhcnMgPSB0b19jaGFyc19leHBhbmRlZDtcbiAgICAgICAgICB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoX2RpZmYgPSBmcm9tX2xlbmd0aCAtIHRvX2xlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aF9kaWZmID4gMCkge1xuICAgICAgICAgIHZhciBwYWRfY2hhciA9ICh0b19sZW5ndGggPiAwID8gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV0gOiAnJyk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aF9kaWZmOyBpKyspIHtcbiAgICAgICAgICAgIHRvX2NoYXJzLnB1c2gocGFkX2NoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRvX2NoYXJzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdfc3RyID0gJydcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBzZWxmLmNoYXJBdChpKTtcbiAgICAgICAgdmFyIHN1YiA9IHN1YnNbY2hdO1xuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgIG5ld19zdHIgKz0gKHN1YiA9PSBudWxsID8gZ2xvYmFsX3N1YiA6IGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBuZXdfc3RyICs9IChzdWIgIT0gbnVsbCA/IHN1YiA6IGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KG5ld19zdHIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyX3MoZnJvbSwgdG8pXG4gICAgJXh7XG4gICAgICBmcm9tID0gJGNvZXJjZV90byhmcm9tLCAje1N0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuICAgICAgdG8gPSAkY29lcmNlX3RvKHRvLCAje1N0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuXG4gICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGluX3JhbmdlLCBjLCBjaCwgc3RhcnQsIGVuZCwgbGVuZ3RoO1xuICAgICAgdmFyIHN1YnMgPSB7fTtcbiAgICAgIHZhciBmcm9tX2NoYXJzID0gZnJvbS5zcGxpdCgnJyk7XG4gICAgICB2YXIgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcbiAgICAgIHZhciB0b19jaGFycyA9IHRvLnNwbGl0KCcnKTtcbiAgICAgIHZhciB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG5cbiAgICAgIHZhciBpbnZlcnNlID0gZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsX3N1YiA9IG51bGw7XG4gICAgICBpZiAoZnJvbV9jaGFyc1swXSA9PT0gJ14nICYmIGZyb21fY2hhcnMubGVuZ3RoID4gMSkge1xuICAgICAgICBpbnZlcnNlID0gdHJ1ZTtcbiAgICAgICAgZnJvbV9jaGFycy5zaGlmdCgpO1xuICAgICAgICBnbG9iYWxfc3ViID0gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV1cbiAgICAgICAgZnJvbV9sZW5ndGggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZyb21fY2hhcnNfZXhwYW5kZWQgPSBbXTtcbiAgICAgIHZhciBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgaW5fcmFuZ2UgPSBmYWxzZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gZnJvbV9jaGFyc1tpXTtcbiAgICAgICAgaWYgKGxhc3RfZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdF9mcm9tID0gY2g7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgaWYgKGxhc3RfZnJvbSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpID09IGZyb21fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xuICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcm9tX2NoYXJzID0gZnJvbV9jaGFyc19leHBhbmRlZDtcbiAgICAgIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG5cbiAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodG9fbGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0b19jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgICAgIHZhciBsYXN0X3RvID0gbnVsbDtcbiAgICAgICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b19sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2ggPSB0b19jaGFyc1tpXTtcbiAgICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBsYXN0X2Zyb20gPSBjaDtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0X3RvID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gdG9fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgICBpbl9yYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9fY2hhcnMgPSB0b19jaGFyc19leHBhbmRlZDtcbiAgICAgICAgICB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoX2RpZmYgPSBmcm9tX2xlbmd0aCAtIHRvX2xlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aF9kaWZmID4gMCkge1xuICAgICAgICAgIHZhciBwYWRfY2hhciA9ICh0b19sZW5ndGggPiAwID8gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV0gOiAnJyk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aF9kaWZmOyBpKyspIHtcbiAgICAgICAgICAgIHRvX2NoYXJzLnB1c2gocGFkX2NoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRvX2NoYXJzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbmV3X3N0ciA9ICcnXG4gICAgICB2YXIgbGFzdF9zdWJzdGl0dXRlID0gbnVsbFxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IHNlbGYuY2hhckF0KGkpO1xuICAgICAgICB2YXIgc3ViID0gc3Vic1tjaF1cbiAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICBpZiAoc3ViID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3N1YnN0aXR1dGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBuZXdfc3RyICs9IGdsb2JhbF9zdWI7XG4gICAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3X3N0ciArPSBjaDtcbiAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChzdWIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxhc3Rfc3Vic3RpdHV0ZSA9PSBudWxsIHx8IGxhc3Rfc3Vic3RpdHV0ZSAhPT0gc3ViKSB7XG4gICAgICAgICAgICAgIG5ld19zdHIgKz0gc3ViO1xuICAgICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSBzdWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3X3N0ciArPSBjaDtcbiAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QobmV3X3N0cik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdXBjYXNlXG4gICAgYHNlbGYuJCRjYXN0KHNlbGYudG9VcHBlckNhc2UoKSlgXG4gIGVuZFxuXG4gIGRlZiB1cHRvKHN0b3AsIGV4Y2wgPSBmYWxzZSwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6dXB0bywgc3RvcCwgZXhjbCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgJXh7XG4gICAgICB2YXIgYSwgYiwgcyA9IHNlbGYudG9TdHJpbmcoKTtcblxuICAgICAgc3RvcCA9ICRjb2VyY2VfdG8oc3RvcCwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG5cbiAgICAgIGlmIChzLmxlbmd0aCA9PT0gMSAmJiBzdG9wLmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgIGEgPSBzLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGIgPSBzdG9wLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgd2hpbGUgKGEgPD0gYikge1xuICAgICAgICAgIGlmIChleGNsICYmIGEgPT09IGIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJsb2NrKFN0cmluZy5mcm9tQ2hhckNvZGUoYSkpO1xuXG4gICAgICAgICAgYSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VJbnQocywgMTApLnRvU3RyaW5nKCkgPT09IHMgJiYgcGFyc2VJbnQoc3RvcCwgMTApLnRvU3RyaW5nKCkgPT09IHN0b3ApIHtcblxuICAgICAgICBhID0gcGFyc2VJbnQocywgMTApO1xuICAgICAgICBiID0gcGFyc2VJbnQoc3RvcCwgMTApO1xuXG4gICAgICAgIHdoaWxlIChhIDw9IGIpIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBhID09PSBiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhhLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgYSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgd2hpbGUgKHMubGVuZ3RoIDw9IHN0b3AubGVuZ3RoICYmIHMgPD0gc3RvcCkge1xuICAgICAgICAgIGlmIChleGNsICYmIHMgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJsb2NrKHMpO1xuXG4gICAgICAgICAgcyA9ICN7YHNgLnN1Y2N9O1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gY2hhcl9jbGFzc19mcm9tX2NoYXJfc2V0cyhzZXRzKSB7XG4gICAgICBmdW5jdGlvbiBleHBsb2RlX3NlcXVlbmNlc19pbl9jaGFyYWN0ZXJfc2V0KHNldCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICBpLCBsZW4gPSBzZXQubGVuZ3RoLFxuICAgICAgICAgICAgY3Vycl9jaGFyLFxuICAgICAgICAgICAgc2tpcF9uZXh0X2Rhc2gsXG4gICAgICAgICAgICBjaGFyX2NvZGVfZnJvbSxcbiAgICAgICAgICAgIGNoYXJfY29kZV91cHRvLFxuICAgICAgICAgICAgY2hhcl9jb2RlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjdXJyX2NoYXIgPSBzZXQuY2hhckF0KGkpO1xuICAgICAgICAgIGlmIChjdXJyX2NoYXIgPT09ICctJyAmJiBpID4gMCAmJiBpIDwgKGxlbiAtIDEpICYmICFza2lwX25leHRfZGFzaCkge1xuICAgICAgICAgICAgY2hhcl9jb2RlX2Zyb20gPSBzZXQuY2hhckNvZGVBdChpIC0gMSk7XG4gICAgICAgICAgICBjaGFyX2NvZGVfdXB0byA9IHNldC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICAgIGlmIChjaGFyX2NvZGVfZnJvbSA+IGNoYXJfY29kZV91cHRvKSB7XG4gICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BjaGFyX2NvZGVfZnJvbWB9LSN7YGNoYXJfY29kZV91cHRvYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY2hhcl9jb2RlID0gY2hhcl9jb2RlX2Zyb20gKyAxOyBjaGFyX2NvZGUgPCBjaGFyX2NvZGVfdXB0byArIDE7IGNoYXJfY29kZSsrKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJfY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBza2lwX25leHRfZGFzaCA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNraXBfbmV4dF9kYXNoID0gKGN1cnJfY2hhciA9PT0gJ1xcXFwnKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjdXJyX2NoYXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbihzZXRBLCBzZXRCKSB7XG4gICAgICAgIGlmIChzZXRBLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBzZXRCO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAgIGksIGxlbiA9IHNldEEubGVuZ3RoLFxuICAgICAgICAgICAgY2hyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaHIgPSBzZXRBLmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAoc2V0Qi5pbmRleE9mKGNocikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY2hyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgbGVuLCBzZXQsIG5lZywgY2hyLCB0bXAsXG4gICAgICAgICAgcG9zX2ludGVyc2VjdGlvbiA9ICcnLFxuICAgICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSAnJztcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gc2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzZXQgPSAkY29lcmNlX3RvKHNldHNbaV0sICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBuZWcgPSAoc2V0LmNoYXJBdCgwKSA9PT0gJ14nICYmIHNldC5sZW5ndGggPiAxKTtcbiAgICAgICAgc2V0ID0gZXhwbG9kZV9zZXF1ZW5jZXNfaW5fY2hhcmFjdGVyX3NldChuZWcgPyBzZXQuc2xpY2UoMSkgOiBzZXQpO1xuICAgICAgICBpZiAobmVnKSB7XG4gICAgICAgICAgbmVnX2ludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbihuZWdfaW50ZXJzZWN0aW9uLCBzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb24ocG9zX2ludGVyc2VjdGlvbiwgc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwICYmIG5lZ19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICB0bXAgPSAnJztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9zX2ludGVyc2VjdGlvbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNociA9IHBvc19pbnRlcnNlY3Rpb24uY2hhckF0KGkpO1xuICAgICAgICAgIGlmIChuZWdfaW50ZXJzZWN0aW9uLmluZGV4T2YoY2hyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRtcCArPSBjaHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSB0bXA7XG4gICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gJ1snICsgI3tSZWdleHAuZXNjYXBlKGBwb3NfaW50ZXJzZWN0aW9uYCl9ICsgJ10nO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVnX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiAnW14nICsgI3tSZWdleHAuZXNjYXBlKGBuZWdfaW50ZXJzZWN0aW9uYCl9ICsgJ10nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgW11cbiAgZW5kXG5cbiAgZGVmIHNlbGYuX2xvYWQoKmFyZ3MpXG4gICAgbmV3KCphcmdzKVxuICBlbmRcblxuICBkZWYgdW5pY29kZV9ub3JtYWxpemUoZm9ybSA9IDpuZmMpXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJJbnZhbGlkIG5vcm1hbGl6YXRpb24gZm9ybSAje2Zvcm19XCIgdW5sZXNzICVpW25mYyBuZmQgbmZrYyBuZmtkXS5pbmNsdWRlPyhmb3JtKVxuICAgIGBzZWxmLm5vcm1hbGl6ZSgje2Zvcm0udXBjYXNlfSlgXG4gIGVuZFxuXG4gIGRlZiB1bmljb2RlX25vcm1hbGl6ZWQ/KGZvcm0gPSA6bmZjKVxuICAgIHVuaWNvZGVfbm9ybWFsaXplKGZvcm0pID09IHNlbGZcbiAgZW5kXG5cbiAgZGVmIHVucGFjayhmb3JtYXQpXG4gICAgcmFpc2UgXCJUbyB1c2UgU3RyaW5nI3VucGFjaywgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvdW5wYWNrJy5cIlxuICBlbmRcblxuICBkZWYgdW5wYWNrMShmb3JtYXQpXG4gICAgcmFpc2UgXCJUbyB1c2UgU3RyaW5nI3VucGFjazEsIHlvdSBtdXN0IGZpcnN0IHJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nL3VucGFjaycuXCJcbiAgZW5kXG5cbiAgZGVmIGZyZWV6ZVxuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZiBzZWxmID09PSAnc3RyaW5nJykgcmV0dXJuIHNlbGY7XG4gICAgICBzZWxmLiQkZnJvemVuID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgK0AgZHVwXG5cbiAgZGVmIC1AXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIHNlbGYgPT09ICdzdHJpbmcnKSByZXR1cm4gc2VsZjtcbiAgICAgIGlmIChzZWxmLiQkZnJvemVuID09PSB0cnVlKSByZXR1cm4gc2VsZjtcbiAgICAgIGlmIChzZWxmLmVuY29kaW5nLm5hbWUgPT0gJ1VURi04JyAmJiBzZWxmLmludGVybmFsX2VuY29kaW5nLm5hbWUgPT0gJ1VURi04JykgcmV0dXJuIHNlbGYudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiBzZWxmLiRkdXAoKS4kZnJlZXplKCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZnJvemVuP1xuICAgIGB0eXBlb2Ygc2VsZiA9PT0gJ3N0cmluZycgfHwgc2VsZi4kJGZyb3plbiA9PT0gdHJ1ZWBcbiAgZW5kXG5cbiAgT3BhbC5wcmlzdGluZSBzZWxmLCA6aW5pdGlhbGl6ZVxuZW5kXG5cblN5bWJvbCA9IFN0cmluZ1xuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsImluY2x1ZGUiLCJzZWxmIiwiX19pZF9fIiwidHJ5X2NvbnZlcnQiLCJjb2VyY2VfdG8/Iiwid2hhdCIsIm5ldyIsImluaXRpYWxpemUiLCJhcmdzIiwiJSIsIj09PSIsImRhdGEiLCJmb3JtYXQiLCIqIiwicmFpc2UiLCIrIiwib3RoZXIiLCI8PT4iLCJyZXNwb25kX3RvPyIsInRvX3N0ciIsInRvX3MiLCI9PSIsIj1+IiwiW10iLCIkfiIsImIiLCJmb3JjZV9lbmNvZGluZyIsImNhcGl0YWxpemUiLCJjYXNlY21wIiwiY2FzZWNtcD8iLCJjZW50ZXIiLCJ3aWR0aCIsInBhZHN0ciIsImVtcHR5PyIsImxqdXN0IiwiLyIsIjIiLCJjZWlsIiwicmp1c3QiLCJmbG9vciIsImNob21wIiwiJC8iLCJzZXBhcmF0b3IiLCJjb2VyY2VfdG8hIiwiY2hvcCIsImNociIsImNsb25lIiwiY29weSIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJpbml0aWFsaXplX2Nsb25lIiwiZHVwIiwiaW5pdGlhbGl6ZV9kdXAiLCJjb3VudCIsImRlbGV0ZSIsImRlbGV0ZV9wcmVmaXgiLCJkZWxldGVfc3VmZml4IiwiZG93bmNhc2UiLCJlYWNoX2xpbmUiLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImVuZF93aXRoPyIsImdzdWIiLCJwYXR0ZXJuIiwiaGFzaCIsImhleCIsInRvX2kiLCIxNiIsImluY2x1ZGU/IiwiaW5kZXgiLCJpbnNwZWN0IiwiaW50ZXJuIiwibGluZXMiLCJlIiwiYmxvY2siLCJ0b19hIiwibHN0cmlwIiwiYXNjaWlfb25seT8iLCJtYXRjaCIsIiRyZXRfb3JfMSIsInBvcyIsIm1hdGNoPyIsIiRyZXRfb3JfMiIsIm5leHQiLCJvY3QiLCJvcmQiLCJwYXJ0aXRpb24iLCJyZXZlcnNlIiwicmluZGV4IiwicnBhcnRpdGlvbiIsInJzdHJpcCIsInNjYW4iLCJjYXB0dXJlcyIsInNwbGl0IiwibGltaXQiLCIkcmV0X29yXzMiLCIkOyIsInNxdWVlemUiLCJzdGFydF93aXRoPyIsInN0cmlwIiwic3ViIiwic3VtIiwic3dhcGNhc2UiLCJ0b19mIiwiMTAiLCJ0b19wcm9jIiwibWV0aG9kX25hbWUiLCJwcm9jIiwidHIiLCJ0cl9zIiwidXBjYXNlIiwidXB0byIsInN0b3AiLCJleGNsIiwic3VjYyIsImVzY2FwZSIsImluc3RhbmNlX3ZhcmlhYmxlcyIsIl9sb2FkIiwidW5pY29kZV9ub3JtYWxpemUiLCJmb3JtIiwidW5pY29kZV9ub3JtYWxpemVkPyIsInVucGFjayIsInVucGFjazEiLCJmcmVlemUiLCItQCIsImZyb3plbj8iLCJwcmlzdGluZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRUEsTUFBQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FBQTtBQUFBLE1BQ0FBLFNBQUFBLENBQVEsZ0JBQVJBLENBREE7QUFBQSxFQUdBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FBQTtBQUFBO0FBR0Ysd0JBQTBCQyxJQUFLOztBQUUvQix3QkFBMEJBLElBQUs7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQWJFO0FBQUE7QUFlQUMsSUFBQUEsMEJBQUFBLG1CQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxlQUFEO0FBREZBLElBQUFBLENBQUFBLDhCQUFBQSxDQWZBO0FBQUEsSUFtQkEsaUJBQU0sV0FBTixFQUFnQixRQUFoQixDQW5CQTtBQUFB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QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5FQSxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FqMERBO0FBQUE7QUEwMERBQyxJQUFBQSwyQkFBQUEseUJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsa0RBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsb0NBQUFBLENBMTBEQTtBQUFBLElBODBEQSxPQUFBLG9CQUFBQyxVQUFBQSxDQUFjNUgsTUFBTSxZQUFwQjRILENBOTBEQTtBQURGOUgsRUFBQUEsR0FBQUEsV0FBQUEsRUFBZ0IsTUFBaEJBLFdBSEE7QUFBQSxFQXExREEsT0FBQSxzQ0FBUyxzQkFBVCxDQXIxREE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo4OTIzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhYmxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogZmFsc3ksIHRydXRoeSwgY29lcmNlX3RvXG5cbm1vZHVsZSBFbnVtZXJhYmxlXG4gICV4e1xuICAgIGZ1bmN0aW9uIGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhbHVlID0gW25pbF07XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBhbGw/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICByZXR1cm4gZmFsc2UgdW5sZXNzIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgdW5sZXNzIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIHVubGVzcyBPcGFsLmRlc3RydWN0dXJlKHZhbHVlKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgYW55PyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgY29tcGFyYWJsZSA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG5cbiAgICAgICAgcmV0dXJuIHRydWUgaWYgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiB5aWVsZCgqdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIE9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBjaHVuaygmYmxvY2spXG4gICAgcmV0dXJuIHRvX2VudW0oOmNodW5rKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIDo6RW51bWVyYXRvci5uZXcgZG8gfHlpZWxkZXJ8XG4gICAgICAleHtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gbmlsLCBhY2N1bXVsYXRlID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gcmVsZWFzZUFjY3VtdWxhdGUoKSB7XG4gICAgICAgICAgaWYgKGFjY3VtdWxhdGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBwcmV2aW91c2AsIGBhY2N1bXVsYXRlYCl9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciBrZXkgPSBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgICAgaWYgKGtleSA9PT0gbmlsKSB7XG4gICAgICAgICAgICByZWxlYXNlQWNjdW11bGF0ZSgpO1xuICAgICAgICAgICAgYWNjdW11bGF0ZSA9IFtdO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBuaWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gbmlsIHx8IHByZXZpb3VzID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlbGVhc2VBY2N1bXVsYXRlKCk7XG4gICAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2aW91cyA9IGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgcmVsZWFzZUFjY3VtdWxhdGUoKTtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGNodW5rX3doaWxlKCZibG9jaylcbiAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHNsaWNlX3doZW4geyB8YmVmb3JlLCBhZnRlcnwgISh5aWVsZCBiZWZvcmUsIGFmdGVyKSB9XG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0X2NvbmNhdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb2xsZWN0X2NvbmNhdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgbWFwIHsgfGl0ZW18IHlpZWxkIGl0ZW0gfS5mbGF0dGVuKDEpXG4gIGVuZFxuXG4gIGRlZiBjb3VudChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICByZXN1bHQgPSAwXG5cbiAgICAleHtcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBgb2JqZWN0ICE9IG51bGxgXG4gICAgICBibG9jayA9IHByb2MgZG8gfCphcmdzfFxuICAgICAgICBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpID09IG9iamVjdFxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2submlsP1xuICAgICAgYmxvY2sgPSBwcm9jIHsgdHJ1ZSB9XG4gICAgZW5kXG5cbiAgICBlYWNoIGRvIHwqYXJnc3xcbiAgICAgIGByZXN1bHQrK2AgaWYgYE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKWBcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgY3ljbGUobiA9IG5pbCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6Y3ljbGUsIG4pIGRvXG4gICAgICAgIGlmIG4ubmlsP1xuICAgICAgICAgIHJlc3BvbmRfdG8/KDpzaXplKSA/IEZsb2F0OjpJTkZJTklUWSA6IG5pbFxuICAgICAgICBlbHNlXG4gICAgICAgICAgbiA9IE9wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KVxuICAgICAgICAgIG4gPiAwID8gZW51bWVyYXRvcl9zaXplICogbiA6IDBcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIG4gPSBPcGFsLmNvZXJjZV90byEgbiwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgICByZXR1cm4gaWYgYG4gPD0gMGBcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIGFsbCA9IFtdLCBpLCBsZW5ndGgsIHZhbHVlO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBhbGwucHVzaChwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgaWYgKGFsbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPT09IG5pbCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgYWxsW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAobiA+IDEpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhbGwubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIGFsbFtpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGV0ZWN0KGlmbm9uZSA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZGV0ZWN0LCBpZm5vbmUgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICB2YWx1ZSA9IE9wYWwuZGVzdHJ1Y3R1cmUoYXJncylcbiAgICAgIGlmIHlpZWxkKHZhbHVlKVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoaWZub25lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZihpZm5vbmUpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGlmbm9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpZm5vbmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGRyb3AobnVtYmVyKVxuICAgIG51bWJlciA9IGAkY29lcmNlX3RvKG51bWJlciwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYG51bWJlciA8IDBgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byBkcm9wIG5lZ2F0aXZlIHNpemUnXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgID0gW10sXG4gICAgICAgICAgY3VycmVudCA9IDA7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChudW1iZXIgPD0gY3VycmVudCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQrKztcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRyb3Bfd2hpbGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZHJvcF93aGlsZSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgICA9IFtdLFxuICAgICAgICAgIGRyb3BwaW5nID0gdHJ1ZTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgaWYgKGRyb3BwaW5nKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAgIGlmICgkZmFsc3kodmFsdWUpKSB7XG4gICAgICAgICAgICBkcm9wcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NvbnMobiwgJmJsb2NrKVxuICAgIGlmIGBhcmd1bWVudHMubGVuZ3RoICE9IDFgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMSlcIlxuICAgIGVuZFxuXG4gICAgbiA9IE9wYWwudHJ5X2NvbnZlcnQgbiwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYG4gPD0gMGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdpbnZhbGlkIHNpemUnXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfY29ucywgbikgZG9cbiAgICAgICAgZW51bV9zaXplID0gZW51bWVyYXRvcl9zaXplXG4gICAgICAgIGlmIGVudW1fc2l6ZS5uaWw/XG4gICAgICAgICAgbmlsXG4gICAgICAgIGVsc2lmIGVudW1fc2l6ZSA9PSAwIHx8IGVudW1fc2l6ZSA8IG5cbiAgICAgICAgICAwXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlbnVtX3NpemUgLSBuICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgYnVmZmVyID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG4gICAgICAgIGJ1ZmZlci5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IG4pIHtcbiAgICAgICAgICBidWZmZXIuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSBuKSB7XG4gICAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIGJ1ZmZlci5zbGljZSgwLCBuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfZW50cnkoKmRhdGEsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gdG9fZW51bSg6ZWFjaF9lbnRyeSwgKmRhdGEpIHsgZW51bWVyYXRvcl9zaXplIH1cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgZGF0YSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfc2xpY2UobiwgJmJsb2NrKVxuICAgIG4gPSBgJGNvZXJjZV90bygje259LCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgbiA8PSAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2ludmFsaWQgc2xpY2Ugc2l6ZSdcbiAgICBlbmRcblxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9zbGljZSwgbikgeyByZXNwb25kX3RvPyg6c2l6ZSkgPyAoc2l6ZSAvIG4pLmNlaWwgOiBuaWwgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBzbGljZSA9IFtdXG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgIHNsaWNlLnB1c2gocGFyYW0pO1xuXG4gICAgICAgIGlmIChzbGljZS5sZW5ndGggPT09IG4pIHtcbiAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2xpY2UpO1xuICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgLy8gb3VyIFwibGFzdFwiIGdyb3VwLCBpZiBzbWFsbGVyIHRoYW4gbiB0aGVuIHdvbid0IGhhdmUgYmVlbiB5aWVsZGVkXG4gICAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2xpY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZWFjaF93aXRoX2luZGV4KCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfaW5kZXgsICphcmdzKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGluZGV4ID0gMDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgYmxvY2socGFyYW0sIGluZGV4KTtcblxuICAgICAgICBpbmRleCsrO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3dpdGhfb2JqZWN0KG9iamVjdCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF93aXRoX29iamVjdCwgb2JqZWN0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgYmxvY2socGFyYW0sIG9iamVjdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG4gICAgfVxuXG4gICAgb2JqZWN0XG4gIGVuZFxuXG4gIGRlZiBlbnRyaWVzKCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXN1bHQucHVzaCgje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZpbHRlcl9tYXAoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZmlsdGVyX21hcCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBtYXAoJmJsb2NrKS5zZWxlY3QoJjppdHNlbGYpXG4gIGVuZFxuXG4gIGFsaWFzIGZpbmQgZGV0ZWN0XG5cbiAgZGVmIGZpbmRfYWxsKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmZpbmRfYWxsKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGZpbHRlciBmaW5kX2FsbFxuXG4gIGRlZiBmaW5kX2luZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZmluZF9pbmRleCBpZiBgb2JqZWN0ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcblxuICAgICV4e1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4ID0gMFxuXG4gICAgaWYgYG9iamVjdCAhPSBudWxsYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiBPcGFsLmRlc3RydWN0dXJlKHZhbHVlKSA9PSBvYmplY3RcbiAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYGluZGV4ICs9IDFgXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYGluZGV4ICs9IDFgXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZmlyc3QobnVtYmVyID0gdW5kZWZpbmVkKVxuICAgIGlmIGBudW1iZXIgPT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfHZhbHVlfFxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHJlc3VsdCA9IFtdXG4gICAgICBudW1iZXIgPSBgJGNvZXJjZV90byhudW1iZXIsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgaWYgYG51bWJlciA8IDBgXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIHRha2UgbmVnYXRpdmUgc2l6ZSdcbiAgICAgIGVuZFxuXG4gICAgICBpZiBgbnVtYmVyID09IDBgXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnQgPSAwXG5cbiAgICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgICBgcmVzdWx0LnB1c2goI3tPcGFsLmRlc3RydWN0dXJlKGFyZ3MpfSlgXG5cbiAgICAgICAgaWYgYG51bWJlciA8PSArK2N1cnJlbnRgXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgZmxhdF9tYXAgY29sbGVjdF9jb25jYXRcblxuICBkZWYgZ3JlcChwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IHVubGVzcyBwYXR0ZXJuLl9fc2VuZF9fKDo9PT0sICpjbXApXG4gICAgICBpZiBibG9ja19naXZlbj9cbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdIGlmIHZhbHVlLmxlbmd0aCA+IDFcbiAgICAgICAgdmFsdWUgPSB5aWVsZCgqdmFsdWUpXG4gICAgICBlbHNpZiB2YWx1ZS5sZW5ndGggPD0gMVxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdXG4gICAgICBlbmRcblxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIGdyZXBfdihwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IGlmIHBhdHRlcm4uX19zZW5kX18oOj09PSwgKmNtcClcbiAgICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZV0gaWYgdmFsdWUubGVuZ3RoID4gMVxuICAgICAgICB2YWx1ZSA9IHlpZWxkKCp2YWx1ZSlcbiAgICAgIGVsc2lmIHZhbHVlLmxlbmd0aCA8PSAxXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF1cbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSlcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgZ3JvdXBfYnkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Z3JvdXBfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaGFzaCA9IHt9XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICN7KGhhc2hbYHZhbHVlYF0gfHw9IFtdKSA8PCBgcGFyYW1gfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhvYmopXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICBpZiBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpID09IG9ialxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgaW5qZWN0KG9iamVjdCA9IHVuZGVmaW5lZCwgc3ltID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0O1xuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCAmJiBzeW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBbcmVzdWx0LCB2YWx1ZV0pO1xuXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHN5bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCEje1N5bWJvbCA9PT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiI3tvYmplY3QuaW5zcGVjdH0gaXMgbm90IGEgU3ltYm9sXCJ9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN5bSAgICA9IG9iamVjdDtcbiAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSAje2ByZXN1bHRgLl9fc2VuZF9fIHN5bSwgYHZhbHVlYH07XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGF6eVxuICAgIEVudW1lcmF0b3I6OkxhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVudW1lcmF0b3Jfc2l6ZVxuICAgIHJlc3BvbmRfdG8/KDpzaXplKSA/IHNpemUgOiBuaWxcbiAgZW5kXG5cbiAgYWxpYXMgbWFwIGNvbGxlY3RcblxuICBkZWYgbWF4KG4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChuID09PSB1bmRlZmluZWQgfHwgbiA9PT0gbmlsKSB7XG4gICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgW2l0ZW0sIHJlc3VsdF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICN7YGl0ZW1gIDw9PiBgcmVzdWx0YH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG4gPSAkY29lcmNlX3RvKG4sICN7SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICB9XG5cbiAgICBzb3J0KCZibG9jaykucmV2ZXJzZS5maXJzdChuKVxuICBlbmRcblxuICBkZWYgbWF4X2J5KG4gPSBuaWwsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1heF9ieSwgbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIHJldHVybiBzb3J0X2J5KCZibG9jaykucmV2ZXJzZS50YWtlIG5cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YHZhbHVlYCA8PT4gYGJ5YH0gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW1cbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBtZW1iZXI/IGluY2x1ZGU/XG5cbiAgZGVmIG1pbihuID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIG4ubmlsP1xuICAgICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIHJldHVybiBzb3J0IHsgfGEsIGJ8IHlpZWxkIGEsIGIgfS50YWtlIG5cbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHNvcnQudGFrZSBuXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZhbHVlID0gYmxvY2socGFyYW0sIHJlc3VsdCk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnY29tcGFyaXNvbiBmYWlsZWQnfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCN7T3BhbC5jb21wYXJlKGBwYXJhbWAsIGByZXN1bHRgKX0gPCAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbmlsIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbl9ieShuID0gbmlsLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDptaW5fYnksIG4pIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICB1bmxlc3Mgbi5uaWw/XG4gICAgICByZXR1cm4gc29ydF9ieSgmYmxvY2spLnRha2UgblxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGJ5O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgIDw9PiBgYnlgfSA8IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbVxuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG5pbCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtaW5tYXgoJmJsb2NrKVxuICAgIGJsb2NrIHx8PSBwcm9jIHsgfGEsIGJ8IGEgPD0+IGIgfVxuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gbmlsLCBtYXggPSBuaWwsIGZpcnN0X3RpbWUgPSB0cnVlO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuICAgICAgICBpZiAoZmlyc3RfdGltZSkge1xuICAgICAgICAgIG1pbiA9IG1heCA9IGVsZW1lbnQ7XG4gICAgICAgICAgZmlyc3RfdGltZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtaW5fY21wID0gI3tibG9jay5jYWxsKGBtaW5gLCBgZWxlbWVudGApfTtcblxuICAgICAgICAgIGlmIChtaW5fY21wID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ31cbiAgICAgICAgICB9IGVsc2UgaWYgKG1pbl9jbXAgPiAwKSB7XG4gICAgICAgICAgICBtaW4gPSBlbGVtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtYXhfY21wID0gI3tibG9jay5jYWxsKGBtYXhgLCBgZWxlbWVudGApfTtcblxuICAgICAgICAgIGlmIChtYXhfY21wID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ31cbiAgICAgICAgICB9IGVsc2UgaWYgKG1heF9jbXAgPCAwKSB7XG4gICAgICAgICAgICBtYXggPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbm1heF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDptaW5tYXhfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBtaW5fcmVzdWx0ID0gbmlsLFxuICAgICAgICAgIG1heF9yZXN1bHQgPSBuaWwsXG4gICAgICAgICAgbWluX2J5LFxuICAgICAgICAgIG1heF9ieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKChtaW5fYnkgPT09IHVuZGVmaW5lZCkgfHwgI3tgdmFsdWVgIDw9PiBgbWluX2J5YH0gPCAwKSB7XG4gICAgICAgICAgbWluX3Jlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIG1pbl9ieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgobWF4X2J5ID09PSB1bmRlZmluZWQpIHx8ICN7YHZhbHVlYCA8PT4gYG1heF9ieWB9ID4gMCkge1xuICAgICAgICAgIG1heF9yZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBtYXhfYnkgICAgID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIFttaW5fcmVzdWx0LCBtYXhfcmVzdWx0XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBub25lPyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgY29tcGFyYWJsZSA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaXRlbSA9IE9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGl0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgb25lPyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgY291bnQgPSAwXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgICAgIGNvdW50ICs9IDFcbiAgICAgICAgICByZXR1cm4gZmFsc2UgaWYgY291bnQgPiAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIG5leHQgdW5sZXNzIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgY291bnQgKz0gMVxuXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgbmV4dCB1bmxlc3MgT3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcbiAgICAgICAgY291bnQgKz0gMVxuXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgY291bnQgPT0gMVxuICBlbmRcblxuICBkZWYgcGFydGl0aW9uKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnBhcnRpdGlvbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciB0cnV0aHkgPSBbXSwgZmFsc3kgPSBbXSwgcmVzdWx0O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICB0cnV0aHkucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZmFsc3kucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIFt0cnV0aHksIGZhbHN5XTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHJlZHVjZSBpbmplY3RcblxuICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKCRmYWxzeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlX2VhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmV2ZXJzZV9lYWNoKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXN1bHQucHVzaChhcmd1bWVudHMpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIE9wYWwueWllbGRYKGJsb2NrLCByZXN1bHRbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc2VsZWN0IGZpbmRfYWxsXG5cbiAgZGVmIHNsaWNlX2JlZm9yZShwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2JvdGggcGF0dGVybiBhbmQgYmxvY2sgYXJlIGdpdmVuJ1xuICAgIGVuZFxuXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZXhwZWN0ZWQgMSlcIlxuICAgIGVuZFxuXG4gICAgRW51bWVyYXRvci5uZXcgZG8gfGV8XG4gICAgICAleHtcbiAgICAgICAgdmFyIHNsaWNlID0gW107XG5cbiAgICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkgJiYgc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBibG9jayhwYXJhbSwgI3twYXR0ZXJuLmR1cH0pO1xuXG4gICAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICN7cGF0dGVybiA9PT0gYHBhcmFtYH07XG5cbiAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2xpY2VfYWZ0ZXIocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdib3RoIHBhdHRlcm4gYW5kIGJsb2NrIGFyZSBnaXZlbidcbiAgICBlbmRcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWQgJiYgYmxvY2sgIT09IG5pbCB8fCBhcmd1bWVudHMubGVuZ3RoID4gMWBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGV4cGVjdGVkIDEpXCJcbiAgICBlbmRcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBibG9jayA9IHByb2MgeyB8ZXwgcGF0dGVybiA9PT0gZSB9XG4gICAgZW5kXG5cbiAgICBFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgYWNjdW11bGF0ZTtcblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgIGVuZF9jaHVuayA9IE9wYWwueWllbGQxKGJsb2NrLCBlbGVtZW50KTtcblxuICAgICAgICAgIGlmIChhY2N1bXVsYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJHRydXRoeShlbmRfY2h1bmspKSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAje3lpZWxkZXIueWllbGQoYGFjY3VtdWxhdGVgKX07XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjdW11bGF0ZS5wdXNoKGVsZW1lbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICAgIGlmIChhY2N1bXVsYXRlICE9IG51bGwpIHtcbiAgICAgICAgICAje3lpZWxkZXIueWllbGQoYGFjY3VtdWxhdGVgKX07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNsaWNlX3doZW4oJmJsb2NrKVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKScgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgRW51bWVyYXRvci5uZXcgZG8gfHlpZWxkZXJ8XG4gICAgICAleHtcbiAgICAgICAgdmFyIHNsaWNlID0gbmlsLCBsYXN0X2FmdGVyID0gbmlsO1xuXG4gICAgICAgIHNlbGYuJGVhY2hfY29ucy4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGFyYW1zID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgIGJlZm9yZSA9IHBhcmFtc1swXSxcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBwYXJhbXNbMV0sXG4gICAgICAgICAgICAgIG1hdGNoID0gT3BhbC55aWVsZFgoYmxvY2ssIFtiZWZvcmUsIGFmdGVyXSk7XG5cbiAgICAgICAgICBsYXN0X2FmdGVyID0gYWZ0ZXI7XG5cbiAgICAgICAgICBpZiAoc2xpY2UgPT09IG5pbCkge1xuICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJHRydXRoeShtYXRjaCkpIHtcbiAgICAgICAgICAgIHNsaWNlLnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgICN7eWllbGRlci55aWVsZChgc2xpY2VgKX07XG4gICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbGljZS5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaF9jb25zKDIpO1xuXG4gICAgICAgIGlmIChzbGljZSAhPT0gbmlsKSB7XG4gICAgICAgICAgc2xpY2UucHVzaChsYXN0X2FmdGVyKTtcbiAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHNsaWNlYCl9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzb3J0KCZibG9jaylcbiAgICBhcnkgPSB0b19hXG4gICAgYmxvY2sgPSAtPihhLCBiKSB7IGEgPD0+IGIgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgYXJ5LnNvcnQoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgc29ydF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzb3J0X2J5KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGR1cCA9IG1hcCBkb1xuICAgICAgYXJnID0gT3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYClcbiAgICAgIFt5aWVsZChhcmcpLCBhcmddXG4gICAgZW5kXG4gICAgZHVwLnNvcnQhIHsgfGEsIGJ8IGBhWzBdYCA8PT4gYGJbMF1gIH1cbiAgICBkdXAubWFwISB7IHxpfCBgaVsxXWAgfVxuICBlbmRcblxuICBkZWYgc3VtKGluaXRpYWwgPSAwKVxuICAgIHJlc3VsdCA9IGluaXRpYWxcblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgaXRlbSA9IGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICAgICAgICAgeWllbGQoKmFyZ3MpXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgT3BhbC5kZXN0cnVjdHVyZShhcmdzKVxuICAgICAgICAgICAgIGVuZFxuICAgICAgcmVzdWx0ICs9IGl0ZW1cbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgdGFrZShudW0pXG4gICAgZmlyc3QobnVtKVxuICBlbmRcblxuICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDp0YWtlX3doaWxlIHVubGVzcyBibG9ja1xuXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG5cbiAgICAgIHVubGVzcyB5aWVsZCh2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgZW5kXG5cbiAgICAgIGByZXN1bHQucHVzaCh2YWx1ZSlgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB1bmlxKCZibG9jaylcbiAgICBoYXNoID0ge31cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG5cbiAgICAgIHByb2R1Y2VkID0gaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgICAgICAgICAgICAgeWllbGQodmFsdWUpXG4gICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICBlbmRcblxuICAgICAgdW5sZXNzIGhhc2gua2V5Pyhwcm9kdWNlZClcbiAgICAgICAgaGFzaFtwcm9kdWNlZF0gPSB2YWx1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBoYXNoLnZhbHVlc1xuICBlbmRcblxuICBkZWYgdGFsbHlcbiAgICBncm91cF9ieSgmOml0c2VsZikudHJhbnNmb3JtX3ZhbHVlcygmOmNvdW50KVxuICBlbmRcblxuICBhbGlhcyB0b19hIGVudHJpZXNcblxuICBkZWYgdG9faCgqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiBtYXAoJmJsb2NrKS50b19oKCphcmdzKSBpZiBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAje3t9fTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG4gICAgICAgIHZhciBhcnkgPSAje09wYWwuY29lcmNlX3RvPyhgcGFyYW1gLCBBcnJheSwgOnRvX2FyeSl9LCBrZXksIHZhbDtcbiAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGVsZW1lbnQgdHlwZSAje2BhcnlgLmNsYXNzfSAoZXhwZWN0ZWQgYXJyYXkpXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyeS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgYXJyYXkgbGVuZ3RoIChleHBlY3RlZCAyLCB3YXMgI3tgYXJ5YC5sZW5ndGh9KVwifVxuICAgICAgICB9XG4gICAgICAgIGtleSA9IGFyeVswXTtcbiAgICAgICAgdmFsID0gYXJ5WzFdO1xuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWwpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgemlwKCpvdGhlcnMsICZibG9jaylcbiAgICB0b19hLnppcCgqb3RoZXJzKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImFsbD8iLCJlYWNoIiwiY29tcGFyYWJsZSIsInB1YmxpY19zZW5kIiwicGF0dGVybiIsImJsb2NrX2dpdmVuPyIsInZhbHVlIiwiZGVzdHJ1Y3R1cmUiLCJhbnk/IiwiY2h1bmsiLCJ0b19lbnVtIiwiZW51bWVyYXRvcl9zaXplIiwibmV3IiwieWllbGRlciIsInlpZWxkIiwiY2h1bmtfd2hpbGUiLCJyYWlzZSIsInNsaWNlX3doZW4iLCJiZWZvcmUiLCJhZnRlciIsIiEiLCJjb2xsZWN0IiwiZW51bV9mb3IiLCJjb2xsZWN0X2NvbmNhdCIsIm1hcCIsIml0ZW0iLCJmbGF0dGVuIiwiMSIsImNvdW50IiwicmVzdWx0IiwiMCIsIndhcm4iLCJibG9jayIsInByb2MiLCJhcmdzIiwiPT0iLCJvYmplY3QiLCJuaWw/IiwiY3ljbGUiLCJuIiwicmVzcG9uZF90bz8iLCJjb2VyY2VfdG8hIiwiPiIsIioiLCJkZXRlY3QiLCJpZm5vbmUiLCJkcm9wIiwibnVtYmVyIiwiZHJvcF93aGlsZSIsImVhY2hfY29ucyIsInRyeV9jb252ZXJ0IiwiZW51bV9zaXplIiwiJHJldF9vcl8xIiwiPCIsIisiLCItIiwiZWFjaF9lbnRyeSIsImRhdGEiLCJlYWNoX3NsaWNlIiwiLyIsInNpemUiLCJjZWlsIiwiZWFjaF93aXRoX2luZGV4Iiwic2VsZiIsImVhY2hfd2l0aF9vYmplY3QiLCJlbnRyaWVzIiwiZmlsdGVyX21hcCIsInNlbGVjdCIsImZpbmRfYWxsIiwiZmluZF9pbmRleCIsImluZGV4IiwiZmlyc3QiLCJjdXJyZW50IiwiZ3JlcCIsImNtcCIsIl9fc2VuZF9fIiwibGVuZ3RoIiwiPD0iLCJbXSIsInB1c2giLCJncmVwX3YiLCJncm91cF9ieSIsImhhc2giLCIkcmV0X29yXzIiLCIkd3JpdGVyIiwiW109IiwiPDwiLCJpbmNsdWRlPyIsIm9iaiIsImluamVjdCIsIj09PSIsImluc3BlY3QiLCJzeW0iLCJsYXp5IiwiZW51bSQiLCJtYXgiLCI8PT4iLCJzb3J0IiwicmV2ZXJzZSIsIm1heF9ieSIsInNvcnRfYnkiLCJ0YWtlIiwibWluIiwiYSIsImIiLCJjb21wYXJlIiwibWluX2J5IiwibWlubWF4IiwiJHJldF9vcl8zIiwiY2FsbCIsIm1pbm1heF9ieSIsIm5vbmU/Iiwib25lPyIsInBhcnRpdGlvbiIsInJlamVjdCIsInJldmVyc2VfZWFjaCIsInNsaWNlX2JlZm9yZSIsImUiLCJkdXAiLCJzbGljZV9hZnRlciIsImFyeSIsInRvX2EiLCJhcmciLCJzb3J0ISIsIm1hcCEiLCJzdW0iLCJpbml0aWFsIiwibnVtIiwidGFrZV93aGlsZSIsInVuaXEiLCJwcm9kdWNlZCIsImtleT8iLCJ2YWx1ZXMiLCJ0YWxseSIsInRyYW5zZm9ybV92YWx1ZXMiLCJ0b19oIiwiY29lcmNlX3RvPyIsImNsYXNzIiwiemlwIiwib3RoZXJzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQUVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFaRTtBQUFBO0FBY0FDLElBQUFBLHdCQUFBQSx5QkFBQUEsU0FBUyxPQUFUQSxHQUFBQTs7QUFB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QWlCLFVBQUNyRyxJQUFELENBQWpCcUcsQ0FBUCxDQXZ0Q0o7QUFBQTtBQTB0Q0EsaUJBQW1CLFlBQUEsRUFBRzs7QUFFdEI7QUFDQSxvQkFBc0Isb0JBQUFoSSxhQUFBQSxDQUFrQixTQUFsQkEsQ0FBOEI7QUFDcEQsa0JBQW9CLG9CQUFBaUksZUFBQUEsQ0FBaUIsT0FBUSx1QkFBTyxRQUFoQ0EsQ0FBeUM7QUFDN0Q7QUFDQSxjQUFZeEgsT0FBQUEsQ0FBTSwyQkFBVyxFQUFBLEdBQUEscUJBQUEsR0FBQSxDQUFzQixDQUFDLEdBQUQsQ0FBQXlILE9BQUFBLENBQUFBLENBQXRCLENBQUEsR0FBQSxtQkFBakJ6SDtBQUNaO0FBQ0E7QUFDQSxjQUFZQSxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSxzQ0FBQSxHQUFBLENBQXVDLENBQUMsR0FBRCxDQUFBNEQsUUFBQUEsQ0FBQUEsQ0FBdkMsQ0FBQSxHQUFBLEdBQXJCNUQ7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBOXVDQTtBQXN0Q0V1SCxJQUFBQSxDQUFBQSxtQ0FBQUEsQ0FsdENBO0FBQUEsSUE2dUNBLE9BQUFHLENBQUFBLHVCQUFBQSxzQkFBQUEsZUFqdkNGLEVBaXZDRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBanZDRjtBQWl2Q21CLE1BQUEsMENBanZDbkI7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQWl2Q1UsTUFBQSxvQkFqdkNWO0FBQUEsTUFrdkNJLE9BQUFBLFVBQUFqQixNQUFBQSxDQUFBQSxDQUFBaUIsT0FBQUEsRUFBUyxVQUFDQyxNQUFELENBQVRELENBbHZDSjtBQWl2Q0VBLElBQUFBLENBQUFBLGtDQUFBQSxDQUFBQSxlQTd1Q0E7QUFERjNJLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTA4OTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmF0b3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBicmVha2VyLCBzbGljZSwgZmFsc3ksIHRydXRoeSwgY29lcmNlX3RvXG5cbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuY2xhc3MgRW51bWVyYXRvclxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX2VudW1lcmF0b3IgPSB0cnVlYFxuXG4gIGRlZiBzZWxmLmZvcihvYmplY3QsIG1ldGhvZCA9IDplYWNoLCAqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9iaiA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICBvYmoub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgb2JqLnNpemUgICA9IGJsb2NrO1xuICAgICAgb2JqLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIG9iai5hcmdzICAgPSBhcmdzO1xuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoKiwgJmJsb2NrKVxuICAgIGlmIGJsb2NrXG4gICAgICBAb2JqZWN0ID0gR2VuZXJhdG9yLm5ldygmYmxvY2spXG4gICAgICBAbWV0aG9kID0gOmVhY2hcbiAgICAgIEBhcmdzICAgPSBbXVxuICAgICAgQHNpemUgICA9IGBhcmd1bWVudHNbMF0gfHwgbmlsYFxuXG4gICAgICBpZiBAc2l6ZSAmJiAhQHNpemUucmVzcG9uZF90bz8oOmNhbGwpXG4gICAgICAgIEBzaXplID0gYCRjb2VyY2VfdG8oI3tAc2l6ZX0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIEBvYmplY3QgPSBgYXJndW1lbnRzWzBdYFxuICAgICAgQG1ldGhvZCA9IGBhcmd1bWVudHNbMV0gfHwgXCJlYWNoXCJgXG4gICAgICBAYXJncyAgID0gYCRzbGljZS5jYWxsKGFyZ3VtZW50cywgMilgXG4gICAgICBAc2l6ZSAgID0gbmlsXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIHNlbGYgaWYgYmxvY2submlsPyAmJiBhcmdzLmVtcHR5P1xuXG4gICAgYXJncyA9IEBhcmdzICsgYXJnc1xuXG4gICAgcmV0dXJuIHNlbGYuY2xhc3MubmV3KEBvYmplY3QsIEBtZXRob2QsICphcmdzKSBpZiBibG9jay5uaWw/XG5cbiAgICBAb2JqZWN0Ll9fc2VuZF9fKEBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBzaXplXG4gICAgQHNpemUucmVzcG9uZF90bz8oOmNhbGwpID8gQHNpemUuY2FsbCgqQGFyZ3MpIDogQHNpemVcbiAgZW5kXG5cbiAgZGVmIHdpdGhfaW5kZXgob2Zmc2V0ID0gMCwgJmJsb2NrKVxuICAgIG9mZnNldCA9IGlmIG9mZnNldFxuICAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob2Zmc2V0LCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgIGVuZFxuXG4gICAgcmV0dXJuIGVudW1fZm9yKDp3aXRoX2luZGV4LCBvZmZzZXQpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LCBpbmRleCA9IG9mZnNldDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHBhcmFtLCBpbmRleCk7XG5cbiAgICAgICAgaW5kZXgrKztcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiRlYWNoKCk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyB3aXRoX29iamVjdCBlYWNoX3dpdGhfb2JqZWN0XG5cbiAgZGVmIGVhY2hfd2l0aF9pbmRleCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfaW5kZXgpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHN1cGVyXG4gICAgQG9iamVjdFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIHJlc3VsdCA9IFwiIzwje3NlbGYuY2xhc3N9OiAje0BvYmplY3QuaW5zcGVjdH06I3tAbWV0aG9kfVwiXG5cbiAgICBpZiBAYXJncy5hbnk/XG4gICAgICByZXN1bHQgKz0gXCIoI3tAYXJncy5pbnNwZWN0W1JhbmdlLm5ldygxLCAtMildfSlcIlxuICAgIGVuZFxuXG4gICAgcmVzdWx0ICsgJz4nXG4gIGVuZFxuXG4gIGNsYXNzIEdlbmVyYXRvclxuICAgIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gICAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgICAgcmFpc2UgTG9jYWxKdW1wRXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIEBibG9jayA9IGJsb2NrXG4gICAgZW5kXG5cbiAgICBkZWYgZWFjaCgqYXJncywgJmJsb2NrKVxuICAgICAgeWllbGRlciA9IFlpZWxkZXIubmV3KCZibG9jaylcblxuICAgICAgJXh7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXJncy51bnNoaWZ0KCN7eWllbGRlcn0pO1xuXG4gICAgICAgICAgT3BhbC55aWVsZFgoI3tAYmxvY2t9LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlID09PSAkYnJlYWtlcikge1xuICAgICAgICAgICAgcmV0dXJuICRicmVha2VyLiR2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgY2xhc3MgWWllbGRlclxuICAgIGRlZiBpbml0aWFsaXplKCZibG9jaylcbiAgICAgIEBibG9jayA9IGJsb2NrXG4gICAgZW5kXG5cbiAgICBkZWYgeWllbGQoKnZhbHVlcylcbiAgICAgICV4e1xuICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWCgje0BibG9ja30sIHZhbHVlcyk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAkYnJlYWtlcikge1xuICAgICAgICAgIHRocm93ICRicmVha2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIDw8KCp2YWx1ZXMpXG4gICAgICBzZWxmLnlpZWxkKCp2YWx1ZXMpXG5cbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgY2xhc3MgTGF6eSA8IHNlbGZcbiAgICBjbGFzcyBTdG9wTGF6eUVycm9yIDwgRXhjZXB0aW9uOyBlbmRcblxuICAgIGRlZiBpbml0aWFsaXplKG9iamVjdCwgc2l6ZSA9IG5pbCwgJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IG5ldyB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgQGVudW1lcmF0b3IgPSBvYmplY3RcblxuICAgICAgc3VwZXIgc2l6ZSBkbyB8eWllbGRlciwgKmVhY2hfYXJnc3xcbiAgICAgICAgb2JqZWN0LmVhY2goKmVhY2hfYXJncykgZG8gfCphcmdzfFxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KCN7eWllbGRlcn0pO1xuXG4gICAgICAgICAgICBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIHJlc2N1ZSBFeGNlcHRpb25cbiAgICAgICAgbmlsXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIGZvcmNlIHRvX2FcblxuICAgIGRlZiBsYXp5XG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgY29sbGVjdCgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBtYXAgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICAje2VudW0ueWllbGQgYHZhbHVlYH07XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGNvbGxlY3RfY29uY2F0KCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IG1hcCB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgje2B2YWx1ZWAucmVzcG9uZF90bz8gOmZvcmNlfSAmJiAje2B2YWx1ZWAucmVzcG9uZF90bz8gOmVhY2h9KSB7XG4gICAgICAgICAgICAje2B2YWx1ZWAuZWFjaCB7IHx2fCBlbnVtLnlpZWxkIHYgfX1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSAje09wYWwudHJ5X2NvbnZlcnQgYHZhbHVlYCwgQXJyYXksIDp0b19hcnl9O1xuXG4gICAgICAgICAgICBpZiAoYXJyYXkgPT09IG5pbCkge1xuICAgICAgICAgICAgICAje2VudW0ueWllbGQgYHZhbHVlYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgI3tgdmFsdWVgLmVhY2ggeyB8dnwgZW51bS55aWVsZCB2IH19O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZHJvcChuKVxuICAgICAgbiA9IGAkY29lcmNlX3RvKCN7bn0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgaWYgbiA8IDBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gZHJvcCBuZWdhdGl2ZSBzaXplJ1xuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnRfc2l6ZSA9IGVudW1lcmF0b3Jfc2l6ZVxuICAgICAgc2V0X3NpemUgICAgID0gaWYgSW50ZWdlciA9PT0gY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICAgIG4gPCBjdXJyZW50X3NpemUgPyBuIDogY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIGRyb3BwZWQgPSAwXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBzZXRfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICBpZiBkcm9wcGVkIDwgblxuICAgICAgICAgIGRyb3BwZWQgKz0gMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBkcm9wX3doaWxlKCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IGRyb3Bfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIHN1Y2NlZWRpbmcgPSB0cnVlXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgc3VjY2VlZGluZ1xuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAoJGZhbHN5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBzdWNjZWVkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBlbnVtX2ZvcihtZXRob2QgPSA6ZWFjaCwgKmFyZ3MsICZibG9jaylcbiAgICAgIHNlbGYuY2xhc3MuZm9yKHNlbGYsIG1ldGhvZCwgKmFyZ3MsICZibG9jaylcbiAgICBlbmRcblxuICAgIGFsaWFzIGZpbHRlciBmaW5kX2FsbFxuXG4gICAgZGVmIGZpbmRfYWxsKCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IHNlbGVjdCB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIGZsYXRfbWFwIGNvbGxlY3RfY29uY2F0XG5cbiAgICBkZWYgZ3JlcChwYXR0ZXJuLCAmYmxvY2spXG4gICAgICBpZiBibG9ja1xuICAgICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShhcmdzKX0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAje3BhdHRlcm4gPT09IGBwYXJhbWB9O1xuXG4gICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCBgT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKWB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGFyZ3MpfSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICN7cGF0dGVybiA9PT0gYHBhcmFtYH07XG5cbiAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAje2VudW0ueWllbGQgYHBhcmFtYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYWxpYXMgbWFwIGNvbGxlY3RcblxuICAgIGFsaWFzIHNlbGVjdCBmaW5kX2FsbFxuXG4gICAgZGVmIHJlamVjdCgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSByZWplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoJGZhbHN5KHZhbHVlKSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB0YWtlKG4pXG4gICAgICBuID0gYCRjb2VyY2VfdG8oI3tufSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICBpZiBuIDwgMFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byB0YWtlIG5lZ2F0aXZlIHNpemUnXG4gICAgICBlbmRcblxuICAgICAgY3VycmVudF9zaXplID0gZW51bWVyYXRvcl9zaXplXG4gICAgICBzZXRfc2l6ZSAgICAgPSBpZiBJbnRlZ2VyID09PSBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgICAgbiA8IGN1cnJlbnRfc2l6ZSA/IG4gOiBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbmRcblxuICAgICAgdGFrZW4gPSAwXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBzZXRfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICBpZiB0YWtlbiA8IG5cbiAgICAgICAgICBlbnVtLnlpZWxkKCphcmdzKVxuICAgICAgICAgIHRha2VuICs9IDFcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJhaXNlIFN0b3BMYXp5RXJyb3JcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB0YWtlX3doaWxlKCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IHRha2Vfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICN7cmFpc2UgU3RvcExhenlFcnJvcn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIHRvX2VudW0gZW51bV9mb3JcblxuICAgIGRlZiBpbnNwZWN0XG4gICAgICBcIiM8I3tzZWxmLmNsYXNzfTogI3tAZW51bWVyYXRvci5pbnNwZWN0fT5cIlxuICAgIGVuZFxuICBlbmRcblxuICBjbGFzcyBBcml0aG1ldGljU2VxdWVuY2UgPCBzZWxmXG4gICAgIyBXZSBuZWVkIHRvIHN0dWIgdGhpcyBmb3IgdGhlIHRpbWUgYmVpbmdcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwiZm9yIiwic2VsZiIsImFsbG9jYXRlIiwiaW5pdGlhbGl6ZSIsImJsb2NrIiwiQG9iamVjdCIsIm5ldyIsIkBtZXRob2QiLCJAYXJncyIsIkBzaXplIiwiJHJldF9vcl8xIiwicmVzcG9uZF90bz8iLCIhIiwiZWFjaCIsIiRyZXRfb3JfMiIsIm5pbD8iLCJhcmdzIiwiZW1wdHk/IiwiKyIsIl9fc2VuZF9fIiwic2l6ZSIsImNhbGwiLCJ3aXRoX2luZGV4IiwiMCIsIm9mZnNldCIsImVudW1fZm9yIiwiZGVzdHJ1Y3R1cmUiLCJlYWNoX3dpdGhfaW5kZXgiLCJibG9ja19naXZlbj8iLCJpbnNwZWN0IiwicmVzdWx0IiwiYW55PyIsIltdIiwiMSIsIi0yIiwicmFpc2UiLCJAYmxvY2siLCJ5aWVsZGVyIiwieWllbGQiLCI8PCIsInZhbHVlcyIsIkBlbnVtZXJhdG9yIiwib2JqZWN0IiwiZWFjaF9hcmdzIiwibGF6eSIsImNvbGxlY3QiLCJlbnVtZXJhdG9yX3NpemUiLCJlbnVtJCIsImNvbGxlY3RfY29uY2F0IiwidiIsInRyeV9jb252ZXJ0IiwiZHJvcCIsIm4iLCI8IiwiY3VycmVudF9zaXplIiwic2V0X3NpemUiLCI9PT0iLCJkcm9wcGVkIiwiZHJvcF93aGlsZSIsInN1Y2NlZWRpbmciLCJtZXRob2QiLCJmaW5kX2FsbCIsImdyZXAiLCJwYXR0ZXJuIiwicmVqZWN0IiwidGFrZSIsInRha2VuIiwidGFrZV93aGlsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRUEsTUFBQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsMEJBQVJBLENBQUE7QUFBQSxJQUVDLHVDQUZEO0FBQUEsSUFJQUMsVUFBSUMsSUFBSkQsVUFBQUEsb0JBQUFBLFNBQWEsTUFBRCxFQVZkLEVBVWMsRUFWZCxFQVVFQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFWRjtBQVU4QyxNQUFBLHdDQVY5QztBQUFBO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBVXVCLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxXQUFTLE1BQVQ7QUFBQSxNQUFBLENBVnZCO0FBQUE7QUFVdUMsTUFBQSxrQkFWdkM7QUFBQTtBQVlBLG9CQUFrQkUsVUFBQUEsQ0FBQUEsQ0FBUzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQXBCQTtBQVVFRixJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FKQTtBQUFBO0FBaUJBRyxJQUFBQSw4QkFBQUEsMkJBQUFBLHNCQXZCRixFQXVCRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFB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QUFBQSxDQUFBQSxDQUFwQixDQUFBLEdBQUE7QUFERkEsTUFBQUEsQ0FBQUEsOEJBQUFBLENBQUFBLG1CQXpPQTtBQURGL0IsSUFBQUEsR0FBQUEsV0FBQUEsRUFBYUcsSUFBYkgsV0FySkE7QUFBQSxJQW9ZQSxPQUFBQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQUFBLElBQUFBLEdBQUFBLFdBQUFBLEVBQTJCRyxJQUEzQkgsV0FwWUE7QUFERkEsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjExNjQzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9udW1lcmljLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcblxuY2xhc3MgTnVtZXJpY1xuICBpbmNsdWRlIENvbXBhcmFibGVcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGlmIG90aGVyLmluc3RhbmNlX29mPyBzZWxmLmNsYXNzXG4gICAgICByZXR1cm4gW290aGVyLCBzZWxmXVxuICAgIGVuZFxuXG4gICAgW0Zsb2F0KG90aGVyKSwgRmxvYXQoc2VsZildXG4gIGVuZFxuXG4gIGRlZiBfX2NvZXJjZWRfXyhtZXRob2QsIG90aGVyKVxuICAgIGlmIG90aGVyLnJlc3BvbmRfdG8/KDpjb2VyY2UpXG4gICAgICBhLCBiID0gb3RoZXIuY29lcmNlKHNlbGYpXG4gICAgICBhLl9fc2VuZF9fIG1ldGhvZCwgYlxuICAgIGVsc2VcbiAgICAgIGNhc2UgbWV0aG9kXG4gICAgICB3aGVuIDorLCA6LSwgOiosIDovLCA6JSwgOiYsIDp8LCA6XiwgOioqXG4gICAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje290aGVyLmNsYXNzfSBjYW4ndCBiZSBjb2VyY2VkIGludG8gTnVtZXJpY1wiXG4gICAgICB3aGVuIDo+LCA6Pj0sIDo8LCA6PD0sIDo8PT5cbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje290aGVyLmNsYXNzfSBmYWlsZWRcIlxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgZXF1YWw/IG90aGVyXG4gICAgICByZXR1cm4gMFxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiArQFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgMCAtIHNlbGZcbiAgZW5kXG5cbiAgZGVmICUob3RoZXIpXG4gICAgc2VsZiAtIG90aGVyICogZGl2KG90aGVyKVxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgc2VsZiA8IDAgPyAtc2VsZiA6IHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFiczJcbiAgICBzZWxmICogc2VsZlxuICBlbmRcblxuICBkZWYgYW5nbGVcbiAgICBzZWxmIDwgMCA/IE1hdGg6OlBJIDogMFxuICBlbmRcblxuICBhbGlhcyBhcmcgYW5nbGVcblxuICBkZWYgY2VpbChuZGlnaXRzID0gMClcbiAgICB0b19mLmNlaWwobmRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIGNvbmpcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGNvbmp1Z2F0ZSBjb25qXG5cbiAgZGVmIGRlbm9taW5hdG9yXG4gICAgdG9fci5kZW5vbWluYXRvclxuICBlbmRcblxuICBkZWYgZGl2KG90aGVyKVxuICAgIHJhaXNlIFplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSBvJyBpZiBvdGhlciA9PSAwXG5cbiAgICAoc2VsZiAvIG90aGVyKS5mbG9vclxuICBlbmRcblxuICBkZWYgZGl2bW9kKG90aGVyKVxuICAgIFtkaXYob3RoZXIpLCBzZWxmICUgb3RoZXJdXG4gIGVuZFxuXG4gIGRlZiBmZGl2KG90aGVyKVxuICAgIHRvX2YgLyBvdGhlclxuICBlbmRcblxuICBkZWYgZmxvb3IobmRpZ2l0cyA9IDApXG4gICAgdG9fZi5mbG9vcihuZGlnaXRzKVxuICBlbmRcblxuICBkZWYgaVxuICAgIENvbXBsZXgoMCwgc2VsZilcbiAgZW5kXG5cbiAgZGVmIGltYWdcbiAgICAwXG4gIGVuZFxuXG4gIGFsaWFzIGltYWdpbmFyeSBpbWFnXG5cbiAgZGVmIGludGVnZXI/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgYWxpYXMgbWFnbml0dWRlIGFic1xuXG4gIGFsaWFzIG1vZHVsbyAlXG5cbiAgZGVmIG5vbnplcm8/XG4gICAgemVybz8gPyBuaWwgOiBzZWxmXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICB0b19yLm51bWVyYXRvclxuICBlbmRcblxuICBhbGlhcyBwaGFzZSBhcmdcblxuICBkZWYgcG9sYXJcbiAgICBbYWJzLCBhcmddXG4gIGVuZFxuXG4gIGRlZiBxdW8ob3RoZXIpXG4gICAgT3BhbC5jb2VyY2VfdG8hKHNlbGYsIFJhdGlvbmFsLCA6dG9fcikgLyBvdGhlclxuICBlbmRcblxuICBkZWYgcmVhbFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlYWw/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgcmVjdFxuICAgIFtzZWxmLCAwXVxuICBlbmRcblxuICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG5cbiAgZGVmIHJvdW5kKGRpZ2l0cyA9IHVuZGVmaW5lZClcbiAgICB0b19mLnJvdW5kKGRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIHN0ZXAobGltaXQgPSB1bmRlZmluZWQsIHN0ZXAgPSB1bmRlZmluZWQsIHRvOiB1bmRlZmluZWQsIGJ5OiB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkICYmIHRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAndG8gaXMgZ2l2ZW4gdHdpY2UnfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RlcCAhPT0gdW5kZWZpbmVkICYmIGJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnc3RlcCBpcyBnaXZlbiB0d2ljZSd9XG4gICAgICB9XG5cbiAgICAgIGlmICh0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbWl0ID0gdG87XG4gICAgICB9XG5cbiAgICAgIGlmIChieSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0ZXAgPSBieTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGltaXQgPSBuaWw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUGFyYW1ldGVycygpIHtcbiAgICAgICAgaWYgKHN0ZXAgPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnc3RlcCBtdXN0IGJlIG51bWVyaWMnfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgIT0gbnVsbCAmJiAje3N0ZXAgPT0gMH0pIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwic3RlcCBjYW4ndCBiZSAwXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCA9PT0gbmlsIHx8IHN0ZXAgPT0gbnVsbCkge1xuICAgICAgICAgIHN0ZXAgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpZ24gPSAje3N0ZXAgPD0+IDB9O1xuXG4gICAgICAgIGlmIChzaWduID09PSBuaWwpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiMCBjYW4ndCBiZSBjb2VyY2VkIGludG8gI3tzdGVwLmNsYXNzfVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbWl0ID09PSBuaWwgfHwgbGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgIGxpbWl0ID0gc2lnbiA+IDAgPyAje0Zsb2F0OjpJTkZJTklUWX0gOiAjey1GbG9hdDo6SU5GSU5JVFl9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3tPcGFsLmNvbXBhcmUoc2VsZiwgbGltaXQpfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGVwRmxvYXRTaXplKCkge1xuICAgICAgICBpZiAoKHN0ZXAgPiAwICYmIHNlbGYgPiBsaW1pdCkgfHwgKHN0ZXAgPCAwICYmIHNlbGYgPCBsaW1pdCkpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSBJbmZpbml0eSB8fCBzdGVwID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYWJzID0gTWF0aC5hYnMsIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgICAgICAgZXJyID0gKGFicyhzZWxmKSArIGFicyhsaW1pdCkgKyBhYnMobGltaXQgLSBzZWxmKSkgLyBhYnMoc3RlcCkgKiAje0Zsb2F0OjpFUFNJTE9OfTtcblxuICAgICAgICAgIGlmIChlcnIgPT09IEluZmluaXR5IHx8IGVyciA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVyciA+IDAuNSkge1xuICAgICAgICAgICAgICBlcnIgPSAwLjU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmbG9vcigobGltaXQgLSBzZWxmKSAvIHN0ZXAgKyBlcnIpICsgMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGVwU2l6ZSgpIHtcbiAgICAgICAgdmFsaWRhdGVQYXJhbWV0ZXJzKCk7XG5cbiAgICAgICAgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCAlIDEgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gc3RlcEZsb2F0U2l6ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKChzdGVwID4gMCAmJiBzZWxmID4gbGltaXQpIHx8IChzdGVwIDwgMCAmJiBzZWxmIDwgbGltaXQpKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNlaWwgPSBNYXRoLmNlaWwsIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgICAgICBsaHMgPSBhYnMoc2VsZiAtIGxpbWl0KSArIDEsXG4gICAgICAgICAgICAgIHJocyA9IGFicyhzdGVwKTtcblxuICAgICAgICAgIHJldHVybiBjZWlsKGxocyAvIHJocyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBlbnVtX2Zvcig6c3RlcCwgbGltaXQsIHN0ZXAsICZgc3RlcFNpemVgKSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhbGlkYXRlUGFyYW1ldGVycygpO1xuXG4gICAgICB2YXIgaXNEZXNjID0gI3tzdGVwLm5lZ2F0aXZlP30sXG4gICAgICAgICAgaXNJbmYgPSAje3N0ZXAgPT0gMH0gfHxcbiAgICAgICAgICAgICAgICAgIChsaW1pdCA9PT0gSW5maW5pdHkgJiYgIWlzRGVzYykgfHxcbiAgICAgICAgICAgICAgICAgIChsaW1pdCA9PT0gLUluZmluaXR5ICYmIGlzRGVzYyk7XG5cbiAgICAgIGlmIChzZWxmLiQkaXNfbnVtYmVyICYmIHN0ZXAuJCRpc19udW1iZXIgJiYgbGltaXQuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKHNlbGYgJSAxID09PSAwICYmIChpc0luZiB8fCBsaW1pdCAlIDEgPT09IDApICYmIHN0ZXAgJSAxID09PSAwKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc2VsZjtcblxuICAgICAgICAgIGlmIChpc0luZikge1xuICAgICAgICAgICAgZm9yICg7OyB2YWx1ZSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRGVzYykge1xuICAgICAgICAgICAgZm9yICg7IHZhbHVlID49IGxpbWl0OyB2YWx1ZSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICg7IHZhbHVlIDw9IGxpbWl0OyB2YWx1ZSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYmVnaW4gPSAje3RvX2Z9LnZhbHVlT2YoKTtcbiAgICAgICAgICBzdGVwID0gI3tzdGVwLnRvX2Z9LnZhbHVlT2YoKTtcbiAgICAgICAgICBsaW1pdCA9ICN7bGltaXQudG9fZn0udmFsdWVPZigpO1xuXG4gICAgICAgICAgdmFyIG4gPSBzdGVwRmxvYXRTaXplKCk7XG5cbiAgICAgICAgICBpZiAoIWlzRmluaXRlKHN0ZXApKSB7XG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgYmxvY2soYmVnaW4pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgYmxvY2soYmVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICB2YXIgZCA9IGkgKiBzdGVwICsgc2VsZjtcbiAgICAgICAgICAgICAgaWYgKHN0ZXAgPj0gMCA/IGxpbWl0IDwgZCA6IGxpbWl0ID4gZCkge1xuICAgICAgICAgICAgICAgIGQgPSBsaW1pdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBibG9jayhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvdW50ZXIgPSBzZWxmXG5cbiAgICB3aGlsZSBgaXNEZXNjID8gI3tjb3VudGVyID49IGxpbWl0fSA6ICN7Y291bnRlciA8PSBsaW1pdH1gXG4gICAgICB5aWVsZCBjb3VudGVyXG4gICAgICBjb3VudGVyICs9IHN0ZXBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICBDb21wbGV4KHNlbGYsIDApXG4gIGVuZFxuXG4gIGRlZiB0b19pbnRcbiAgICB0b19pXG4gIGVuZFxuXG4gIGRlZiB0cnVuY2F0ZShuZGlnaXRzID0gMClcbiAgICB0b19mLnRydW5jYXRlKG5kaWdpdHMpXG4gIGVuZFxuXG4gIGRlZiB6ZXJvP1xuICAgIHNlbGYgPT0gMFxuICBlbmRcblxuICBkZWYgcG9zaXRpdmU/XG4gICAgc2VsZiA+IDBcbiAgZW5kXG5cbiAgZGVmIG5lZ2F0aXZlP1xuICAgIHNlbGYgPCAwXG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IHRydWUpXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZmluaXRlP1xuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIGluZmluaXRlP1xuICAgIG5pbFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsImluY2x1ZGUiLCJjb2VyY2UiLCJvdGhlciIsImluc3RhbmNlX29mPyIsInNlbGYiLCJGbG9hdCIsIl9fY29lcmNlZF9fIiwicmVzcG9uZF90bz8iLCJhIiwiYiIsIl9fc2VuZF9fIiwibWV0aG9kIiwicmFpc2UiLCI8PT4iLCJlcXVhbD8iLCIwIiwiK0AiLCItQCIsIi0iLCIlIiwiKiIsImRpdiIsImFicyIsIjwiLCJhYnMyIiwiYW5nbGUiLCJjZWlsIiwidG9fZiIsIm5kaWdpdHMiLCJjb25qIiwiZGVub21pbmF0b3IiLCJ0b19yIiwiPT0iLCIvIiwiZmxvb3IiLCJkaXZtb2QiLCJmZGl2IiwiaSIsIkNvbXBsZXgiLCJpbWFnIiwiaW50ZWdlcj8iLCJub256ZXJvPyIsInplcm8/IiwibnVtZXJhdG9yIiwicG9sYXIiLCJhcmciLCJxdW8iLCJjb2VyY2VfdG8hIiwicmVhbCIsInJlYWw/IiwicmVjdCIsInJvdW5kIiwiZGlnaXRzIiwic3RlcCIsImNvbXBhcmUiLCJsaW1pdCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwibmVnYXRpdmU/IiwiY291bnRlciIsIj49IiwiPD0iLCIrIiwidG9fYyIsInRvX2ludCIsInRvX2kiLCJ0cnVuY2F0ZSIsInBvc2l0aXZlPyIsIj4iLCJkdXAiLCJjbG9uZSIsImZpbml0ZT8iLCJpbmZpbml0ZT8iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsb0JBQVJBLENBQUE7QUFBQSxFQUVBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxTQUFBQSxDQUFRLDBCQUFSQSxDQUFBO0FBQUE7QUFFQUMsSUFBQUEsMEJBQUFBLG9CQUFBQSxrQkFBVyxLQUFYQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBLElBQUEsUUFBR0MsS0FBQUMsaUJBQUFBLENBQW1CQyxJQUFBTCxPQUFBQSxDQUFBQSxDQUFuQkksQ0FBSCxDQUFBO0FBQUEsUUFDRSxPQUFPLENBQUNELEtBQUQsRUFBUUUsSUFBUixDQURULENBQUE7QUFBQSxNQUlBLE9BQUEsS0FBQ0MsT0FBQUEsQ0FBTUgsS0FBTkcsQ0FBRCxNQUFlQSxPQUFBQSxDQUFNRCxJQUFOQyxDQUFmLENBSkE7QUFERkosSUFBQUEsQ0FBQUEsK0JBQUFBLENBRkE7QUFBQTtBQVVBSyxJQUFBQSwrQkFBQUEseUJBQUFBLHVCQUFnQixNQUFELEVBQVMsS0FBeEJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLElBQUEsUUFBR0osS0FBQUssZ0JBQUFBLENBQWtCLFFBQWxCQSxDQUFILENBQUE7QUFBQTtBQUNFLFFBQUEsS0FBT0wsS0FBQUQsUUFBQUEsQ0FBYUcsSUFBYkgsQ0FBUCxzQkFBQSxFQUFBTyxDQUFBQSxpQ0FBQUEsQ0FBQSxFQUFHQyxDQUFBQSxpQ0FBQUEsQ0FBSCxJQUFBO0FBQUEsUUFDQSxPQUFBRCxDQUFBRSxVQUFBQSxDQUFXQyxRQUFRRixDQUFuQkMsQ0FEQTtBQURGLE1BQUE7QUFBQSxRQUlFLE9BQUEsYUFBQSxRQUFLQyxNQUFMO0FBQUEsUUFDQSxJQUFLLGtCQUFMLElBQVMsa0JBQVQsSUFBYSxrQkFBYixJQUFpQixrQkFBakIsSUFBcUIsa0JBQXJCLElBQXlCLGtCQUF6QixJQUE2QixrQkFBN0IsSUFBaUMsa0JBQWpDLElBQXFDLG1CQUFyQyxHQUNFLFdBQUFDLE9BQUFBLENBQU0sMkJBQVcsRUFBQSxHQUFBLENBQUdWLEtBQUFILE9BQUFBLENBQUFBLENBQUgsQ0FBQSxHQUFBLGdDQUFqQmEsQ0FERjtBQURBLFFBQUEsS0FHQSxJQUFLLGtCQUFMLElBQVMsbUJBQVQsSUFBYyxrQkFBZCxJQUFrQixtQkFBbEIsSUFBdUIsb0JBQXZCLEdBQ0UsV0FBQUEsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsZ0JBQUEsR0FBQSxDQUFpQlIsSUFBQUwsT0FBQUEsQ0FBQUEsQ0FBakIsQ0FBQSxHQUFBLFFBQUEsR0FBQSxDQUFvQ0csS0FBQUgsT0FBQUEsQ0FBQUEsQ0FBcEMsQ0FBQSxHQUFBLFNBQXJCYSxDQURGO0FBSEEsUUFBQSxtQkFBQTtBQUpGLE1BQUE7QUFERk4sSUFBQUEsQ0FBQUEsb0NBQUFBLENBVkE7QUFBQTtBQXdCQU8sSUFBQUEsdUJBQUFBLHVCQUFBQSxTQUFRLEtBQVJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUEsSUFBQSxZQUFHQyxXQUFBQSxDQUFPWixLQUFQWSxDQUFILENBQUE7QUFBQSxRQUNFLE9BQU9DLENBRFQsQ0FBQTtBQUFBLE1BSUEsT0FBQSxHQUpBO0FBREZGLElBQUFBLENBQUFBLGtDQUFBQSxDQXhCQTtBQUFBO0FBZ0NBRyxJQUFBQSxzQkFBQUEsb0JBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFaO0FBREZZLElBQUFBLENBQUFBLCtCQUFBQSxDQWhDQTtBQUFBO0FBb0NBQyxJQUFBQSxzQkFBQUEscUJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFDLFVBQUFILENBQUFHLEVBQUlkLElBQUpjO0FBREZELElBQUFBLENBQUFBLGdDQUFBQSxDQXBDQTtBQUFBO0FBd0NBRSxJQUFBQSxxQkFBQUEsc0JBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQUQsVUFBQWQsSUFBQWMsRUFBT0UsVUFBQWxCLEtBQUFrQixNQUFRQyxLQUFBQSxDQUFJbkIsS0FBSm1CLENBQVJELENBQVBGO0FBREZDLElBQUFBLENBQUFBLGlDQUFBQSxDQXhDQTtBQUFBO0FBNENBRyxJQUFBQSx1QkFBQUEsaUJBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLElBQUFDLE9BQUFuQixJQUFBbUIsRUFBT1IsQ0FBUFEsQ0FBQTtBQUFBLFFBQVcsT0FBQ25CLElBQURhLE9BQUFBLENBQUFBO0FBQVgsTUFBQTtBQUFBLFFBQW1CLE9BQUFiO0FBQW5CLE1BQUE7QUFERmtCLElBQUFBLENBQUFBLDRCQUFBQSxDQTVDQTtBQUFBO0FBZ0RBRSxJQUFBQSx3QkFBQUEsa0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBSixVQUFBaEIsSUFBQWdCLEVBQU9oQixJQUFQZ0I7QUFERkksSUFBQUEsQ0FBQUEsNkJBQUFBLENBaERBO0FBQUE7QUFvREFDLElBQUFBLHlCQUFBQSxtQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLElBQUFGLE9BQUFuQixJQUFBbUIsRUFBT1IsQ0FBUFEsQ0FBQTtBQUFBLFFBQVcsT0FBQSxJQUFBLG9CQUFBO0FBQVgsTUFBQTtBQUFBLFFBQXNCLE9BQUFSO0FBQXRCLE1BQUE7QUFERlUsSUFBQUEsQ0FBQUEsOEJBQUFBLENBcERBO0FBQUEsSUF3REEsaUJBQU0sS0FBTixFQUFVLE9BQVYsQ0F4REE7QUFBQTtBQTBEQUMsSUFBQUEsd0JBQUFBLG1CQUFBQSxnQkFBUyxPQUFUQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE5REY7QUE4RFcsTUFBQTtBQUFBLE1BQUEsWUFBVVgsQ0FBVjtBQUFBLE1BQUEsQ0E5RFg7QUFBQSxNQStESSxXQUFBWSxNQUFBQSxDQUFBQSxDQUFBRCxNQUFBQSxDQUFVRSxPQUFWRixDQS9ESjtBQThERUEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBMURBO0FBQUE7QUE4REFHLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUF6QjtBQURGeUIsSUFBQUEsQ0FBQUEsOEJBQUFBLENBOURBO0FBQUEsSUFrRUEsaUJBQU0sV0FBTixFQUFnQixNQUFoQixDQWxFQTtBQUFBO0FBb0VBQyxJQUFBQSwrQkFBQUEsMEJBQUFBLHVCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBQyxNQUFBQSxDQUFBQSxDQUFBRCxhQUFBQSxDQUFBQTtBQURGQSxJQUFBQSxDQUFBQSxxQ0FBQUEsQ0FwRUE7QUFBQTtBQXdFQVQsSUFBQUEsdUJBQUFBLGtCQUFBQSxlQUFRLEtBQVJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUEsSUFBMkNuQixLQUFBOEIsT0FBQUEsQ0FBU2pCLENBQVRpQixDQUEzQztBQUFBLFlBQUFwQixPQUFBQSxDQUFNLG1DQUFtQixjQUF6QkEsQ0FBQSxDQUFBO0FBQUEsTUFFQSxPQUFDcUIsV0FBQTdCLElBQUE2QixFQUFPL0IsS0FBUCtCLENBQURDLE9BQUFBLENBQUFBLENBRkE7QUFERmIsSUFBQUEsQ0FBQUEsNkJBQUFBLENBeEVBO0FBQUE7QUE4RUFjLElBQUFBLDBCQUFBQSxxQkFBQUEsa0JBQVcsS0FBWEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxLQUFDZCxLQUFBQSxDQUFJbkIsS0FBSm1CLENBQUQsRUFBYWpCLElBQUFlLE1BQUFBLENBQU9qQixLQUFQaUIsQ0FBYjtBQURGZ0IsSUFBQUEsQ0FBQUEsZ0NBQUFBLENBOUVBO0FBQUE7QUFrRkFDLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQVMsS0FBVEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQUgsZUFBQU4sTUFBQUEsQ0FBQUEsQ0FBQU0sRUFBTy9CLEtBQVArQjtBQURGRyxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FsRkE7QUFBQTtBQXNGQUYsSUFBQUEseUJBQUFBLG9CQUFBQSxpQkFBVSxPQUFWQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUExRkY7QUEwRlksTUFBQTtBQUFBLE1BQUEsWUFBVW5CLENBQVY7QUFBQSxNQUFBLENBMUZaO0FBQUEsTUEyRkksV0FBQVksTUFBQUEsQ0FBQUEsQ0FBQU8sT0FBQUEsQ0FBV04sT0FBWE0sQ0EzRko7QUEwRkVBLElBQUFBLENBQUFBLGdDQUFBQSxDQXRGQTtBQUFBO0FBMEZBRyxJQUFBQSxxQkFBQUEsZ0JBQUFBLGFBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLFdBQUFDLFNBQUFBLENBQVF2QixHQUFHWCxJQUFYa0M7QUFERkQsSUFBQUEsQ0FBQUEsMkJBQUFBLENBMUZBO0FBQUE7QUE4RkFFLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUF4QjtBQURGd0IsSUFBQUEsQ0FBQUEsOEJBQUFBLENBOUZBO0FBQUEsSUFrR0EsaUJBQU0sV0FBTixFQUFnQixNQUFoQixDQWxHQTtBQUFBO0FBb0dBQyxJQUFBQSw0QkFBQUEsMkJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUE7QUFERkEsSUFBQUEsQ0FBQUEsc0NBQUFBLENBcEdBO0FBQUEsSUF3R0EsaUJBQU0sV0FBTixFQUFnQixLQUFoQixDQXhHQTtBQUFBLElBMEdBLGlCQUFNLFFBQU4sRUFBYSxHQUFiLENBMUdBO0FBQUE7QUE0R0FDLElBQUFBLDRCQUFBQSwyQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsSUFBQSxZQUFBQyxVQUFBQSxDQUFBQSxDQUFBLENBQUE7QUFBQSxRQUFRLE9BQUE7QUFBUixNQUFBO0FBQUEsUUFBYyxPQUFBdEM7QUFBZCxNQUFBO0FBREZxQyxJQUFBQSxDQUFBQSxzQ0FBQUEsQ0E1R0E7QUFBQTtBQWdIQUUsSUFBQUEsNkJBQUFBLHdCQUFBQSxxQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsV0FBQVosTUFBQUEsQ0FBQUEsQ0FBQVksV0FBQUEsQ0FBQUE7QUFERkEsSUFBQUEsQ0FBQUEsbUNBQUFBLENBaEhBO0FBQUEsSUFvSEEsaUJBQU0sT0FBTixFQUFZLEtBQVosQ0FwSEE7QUFBQTtBQXNIQUMsSUFBQUEseUJBQUFBLG9CQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxLQUFDdEIsS0FBQUEsQ0FBQUEsQ0FBRCxNQUFNdUIsS0FBQUEsQ0FBQUEsQ0FBTjtBQURGRCxJQUFBQSxDQUFBQSwrQkFBQUEsQ0F0SEE7QUFBQTtBQTBIQUUsSUFBQUEsdUJBQUFBLGtCQUFBQSxlQUFRLEtBQVJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFiLFdBQUEsb0JBQUFjLGVBQUFBLENBQWdCM0MsTUFBTSwwQkFBVSxNQUFoQzJDLENBQUFkLEVBQXlDL0IsS0FBekMrQjtBQURGYSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0ExSEE7QUFBQTtBQThIQUUsSUFBQUEsd0JBQUFBLG1CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQTVDO0FBREY0QyxJQUFBQSxDQUFBQSw4QkFBQUEsQ0E5SEE7QUFBQTtBQWtJQUMsSUFBQUEseUJBQUFBLHdCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBO0FBREZBLElBQUFBLENBQUFBLG1DQUFBQSxDQWxJQTtBQUFBO0FBc0lBQyxJQUFBQSx3QkFBQUEsbUJBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLENBQUM5QyxJQUFELEVBQU9XLENBQVA7QUFERm1DLElBQUFBLENBQUFBLDhCQUFBQSxDQXRJQTtBQUFBLElBMElBLGlCQUFNLGFBQU4sRUFBa0IsTUFBbEIsQ0ExSUE7QUFBQTtBQTRJQUMsSUFBQUEseUJBQUFBLG9CQUFBQSxpQkFBVSxNQUFWQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFoSkYsTUFBQTtBQUFBLE1BaUpJLFdBQUF4QixNQUFBQSxDQUFBQSxDQUFBd0IsT0FBQUEsQ0FBV0MsTUFBWEQsQ0FqSko7QUFnSkVBLElBQUFBLENBQUFBLGdDQUFBQSxDQTVJQTtBQUFBO0FBZ0pBRSxJQUFBQSx3QkFBQUEsbUJBQUFBLGdCQXBKRixFQW9KVSxFQXBKVixFQW9KVSxFQXBKVixFQW9KRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBcEpGO0FBb0o4RSxNQUFBLHVDQXBKOUU7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQUFBLE1BQUEseUNBQUE7QUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBLENBQUE7QUFBQTtBQW9KVyxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBLENBcEpYO0FBQUE7QUFvSjhCLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUEsQ0FwSjlCO0FBQUE7QUFvSmdELE1BQUEsMEJBcEpoRDtBQUFBO0FBb0orRCxNQUFBLDBCQXBKL0Q7QUFBQTtBQXNKQTtBQUNBLFlBQVV6QyxPQUFBQSxDQUFNLCtCQUFlLG1CQUFyQkE7QUFDVjs7QUFFQTtBQUNBLFlBQVVBLE9BQUFBLENBQU0sK0JBQWUscUJBQXJCQTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFZQSxPQUFBQSxDQUFNLDJCQUFXLHNCQUFqQkE7QUFDWjs7QUFFQSw0QkFBOEJ5QyxJQUFBckIsT0FBQUEsQ0FBUWpCLENBQVJpQixDQUFVO0FBQ3hDLGNBQVlwQixPQUFBQSxDQUFNLCtCQUFlLGlCQUFyQkE7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQXFCeUMsSUFBQXhDLFFBQUFBLENBQVNFLENBQVRGLENBQVc7O0FBRWhDO0FBQ0EsY0FBWUQsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsMEJBQUEsR0FBQSxDQUEyQnlDLElBQUF0RCxPQUFBQSxDQUFBQSxDQUEzQixDQUFyQmE7QUFDWjs7QUFFQTtBQUNBLDZCQUErQixJQUFBLHFCQUFBLGFBQWdCLEdBQU0sSUFBQSxxQkFBQSxhQUFESyxPQUFBQSxDQUFBQSxDQUFpQjtBQUNyRTs7QUFFQSxRQUFVLG9CQUFBcUMsU0FBQUEsQ0FBYWxELE1BQU1tRCxLQUFuQkQ7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUFpRixJQUFBLHFCQUFBLFlBQWU7O0FBRWhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQTdPQTtBQUFBLE1BK09JLElBQXdERSxlQUF4RDtBQUFBLE1BQUE7QUFBQSxRQUFBLE9BQU9DLFVBQUFBLFlBQUFBLEVBQUFBLENBQVMsUUFBT0YsT0FBT0YsSUFBdkJJLENBQUFBLEVBQThCLENBQUMsUUFBRCxZQUE5QkE7QUFBUCxNQUFBLENBL09KO0FBQUE7QUFrUEE7O0FBRUEsbUJBQXFCSixJQUFBSyxjQUFBQSxDQUFBQSxDQUFlO0FBQ3BDLGtCQUFvQkwsSUFBQXJCLE9BQUFBLENBQVFqQixDQUFSaUIsQ0FBVTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQXdCTCxNQUFBQSxDQUFBQSxDQUFLO0FBQzdCLGlCQUFtQjBCLElBQUExQixNQUFBQSxDQUFBQSxDQUFVO0FBQzdCLGtCQUFvQjRCLEtBQUE1QixNQUFBQSxDQUFBQSxDQUFXOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUF0U0E7QUFBQSxNQXdTSWdDLFVBQVV2RCxJQXhTZDtBQUFBLE1BMFNJLE9BQUEsUUFBTyxTQUFXd0QsT0FBQUQsT0FBQUMsRUFBV0wsS0FBWEssQ0FBaUIsR0FBS0MsT0FBQUYsT0FBQUUsRUFBV04sS0FBWE0sQ0FBeEMsQ0FBQTtBQUFBO0FBQ0UsUUFBQSxtQkFBTUYsT0FBTixDQUFBO0FBQUEsUUFDQUEsVUE1U05HLFNBNFNNSCxPQTVTTkcsRUE0U2lCVCxJQTVTakJTLENBMlNNO0FBREYsTUFBQSxDQTFTSjtBQW9KRVQsSUFBQUEsQ0FBQUEsK0JBQUFBLENBaEpBO0FBQUE7QUE0U0FVLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLFdBQUF6QixTQUFBQSxDQUFRbEMsTUFBTVcsQ0FBZHVCO0FBREZ5QixJQUFBQSxDQUFBQSw4QkFBQUEsQ0E1U0E7QUFBQTtBQWdUQUMsSUFBQUEsMEJBQUFBLHFCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsV0FBQUMsTUFBQUEsQ0FBQUE7QUFERkQsSUFBQUEsQ0FBQUEsZ0NBQUFBLENBaFRBO0FBQUE7QUFvVEFFLElBQUFBLDRCQUFBQSx1QkFBQUEsb0JBQWEsT0FBYkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBeFRGO0FBd1RlLE1BQUE7QUFBQSxNQUFBLFlBQVVuRCxDQUFWO0FBQUEsTUFBQSxDQXhUZjtBQUFBLE1BeVRJLFdBQUFZLE1BQUFBLENBQUFBLENBQUF1QyxVQUFBQSxDQUFjdEMsT0FBZHNDLENBelRKO0FBd1RFQSxJQUFBQSxDQUFBQSxtQ0FBQUEsQ0FwVEE7QUFBQTtBQXdUQXhCLElBQUFBLHlCQUFBQSx3QkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQXRDLElBQUE0QixPQUFBQSxDQUFRakIsQ0FBUmlCO0FBREZVLElBQUFBLENBQUFBLG1DQUFBQSxDQXhUQTtBQUFBO0FBNFRBeUIsSUFBQUEsNkJBQUFBLDRCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBQyxPQUFBaEUsSUFBQWdFLEVBQU9yRCxDQUFQcUQ7QUFERkQsSUFBQUEsQ0FBQUEsdUNBQUFBLENBNVRBO0FBQUE7QUFnVUFULElBQUFBLDZCQUFBQSw0QkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQW5DLE9BQUFuQixJQUFBbUIsRUFBT1IsQ0FBUFE7QUFERm1DLElBQUFBLENBQUFBLHVDQUFBQSxDQWhVQTtBQUFBO0FBb1VBVyxJQUFBQSx1QkFBQUEsa0JBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFqRTtBQURGaUUsSUFBQUEsQ0FBQUEsNkJBQUFBLENBcFVBO0FBQUE7QUF3VUFDLElBQUFBLHlCQUFBQSxvQkFBQUEsaUJBNVVGLE9BNFVFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE1VUY7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxDQUFBO0FBQUE7QUE0VVksTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBLFdBQVE7QUFBUixNQUFBLENBNVVaO0FBQUEsTUE2VUksT0FBQWxFLElBN1VKO0FBNFVFa0UsSUFBQUEsQ0FBQUEsZ0NBQUFBLENBeFVBO0FBQUE7QUE0VUFDLElBQUFBLDJCQUFBQSwwQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQTtBQURGQSxJQUFBQSxDQUFBQSxxQ0FBQUEsQ0E1VUE7QUFBQSxJQWdWQSxPQUFBQyxDQUFBQSw2QkFBQUEsNEJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUE7QUFERkEsSUFBQUEsQ0FBQUEsdUNBQUFBLENBQUFBLHFCQWhWQTtBQURGekUsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjEyMTU3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9hcnJheS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgZmFsc3ksIGhhc2hfaWRzLCB5aWVsZDEsIGhhc2hfZ2V0LCBoYXNoX3B1dCwgaGFzaF9kZWxldGUsIGNvZXJjZV90bywgcmVzcG9uZF90b1xuXG5yZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5yZXF1aXJlICdjb3JlbGliL251bWVyaWMnXG5cbmNsYXNzIEFycmF5IDwgYEFycmF5YFxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICAjIE1hcmsgYWxsIGphdmFzY3JpcHQgYXJyYXlzIGFzIGJlaW5nIHZhbGlkIHJ1YnkgYXJyYXlzXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2FycmF5JywgdHJ1ZSlgXG5cbiAgJXh7XG4gICAgLy8gUmVjZW50IHZlcnNpb25zIG9mIFY4ICg+IDcuMSkgb25seSB1c2UgYW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIHdoZW4gQXJyYXkucHJvdG90eXBlIGlzIHVubW9kaWZpZWQuXG4gICAgLy8gRm9yIGluc3RhbmNlLCBcImFycmF5LXNwbGljZS50cVwiIGhhcyBhIFwiZmFzdCBwYXRoXCIgKEV4dHJhY3RGYXN0SlNBcnJheSwgZGVmaW5lZCBpbiBcInNyYy9jb2RlZ2VuL2NvZGUtc3R1Yi1hc3NlbWJsZXIuY2NcIilcbiAgICAvLyBidXQgaXQncyBvbmx5IGVuYWJsZWQgd2hlbiBcIklzUHJvdG90eXBlSW5pdGlhbEFycmF5UHJvdG90eXBlKClcIiBpcyB0cnVlLlxuICAgIC8vXG4gICAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgVjggd2VyZSB1c2luZyByZWxhdGl2ZWx5IGZhc3QgSlMtd2l0aC1leHRlbnNpb25zIGNvZGUgZXZlbiB3aGVuIEFycmF5LnByb3RvdHlwZSBpcyBtb2RpZmllZDpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdjgvdjgvYmxvYi83LjAuMS9zcmMvanMvYXJyYXkuanMjTDU5OS1MNjQyXG4gICAgLy9cbiAgICAvLyBJbiBzaG9ydCwgQXJyYXkgb3BlcmF0aW9ucyBhcmUgc2xvdyBpbiByZWNlbnQgdmVyc2lvbnMgb2YgVjggd2hlbiB0aGUgQXJyYXkucHJvdG90eXBlIGhhcyBiZWVuIHRhbXBlcmVkLlxuICAgIC8vIFNvLCB3aGVuIHBvc3NpYmxlLCB3ZSBhcmUgdXNpbmcgZmFzdGVyIG9wZW4tY29kZWQgdmVyc2lvbiB0byBib29zdCB0aGUgcGVyZm9ybWFuY2UuXG5cbiAgICAvLyBBcyBvZiBWOCA4LjQsIGRlcGVuZGluZyBvbiB0aGUgc2l6ZSBvZiB0aGUgYXJyYXksIHRoaXMgaXMgdXAgdG8gfjI1eCB0aW1lcyBmYXN0ZXIgdGhhbiBBcnJheSNzaGlmdCgpXG4gICAgLy8gSW1wbGVtZW50YXRpb24gaXMgaGVhdmlseSBpbnNwaXJlZCBieTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvYmE2ODQ4MDViNmMwZWRlZDc2ZTVjZDg5ZWUwMDMyOGFjN2E1OTM2NS9saWIvaW50ZXJuYWwvdXRpbC5qcyNMMzQxLUwzNDdcbiAgICBmdW5jdGlvbiBzaGlmdE5vQXJnKGxpc3QpIHtcbiAgICAgIHZhciByID0gbGlzdFswXTtcbiAgICAgIHZhciBpbmRleCA9IDE7XG4gICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgbGlzdFtpbmRleCAtIDFdID0gbGlzdFtpbmRleF07XG4gICAgICB9XG4gICAgICBsaXN0LnBvcCgpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheVN1YmNsYXNzKG9iaiwga2xhc3MpIHtcbiAgICAgIGlmIChrbGFzcy4kJG5hbWUgPT09IE9wYWwuQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrbGFzcy4kYWxsb2NhdGUoKS4kcmVwbGFjZSgje2BvYmpgLnRvX2F9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBIGhlbHBlciBmb3Iga2VlcF9pZiBhbmQgZGVsZXRlX2lmLCBmaWx0ZXIgaXMgZWl0aGVyIE9wYWwudHJ1dGh5XG4gICAgLy8gb3IgT3BhbC5mYWxzeS5cbiAgICBmdW5jdGlvbiBmaWx0ZXJJZihzZWxmLCBmaWx0ZXIsIGJsb2NrKSB7XG4gICAgICB2YXIgdmFsdWUsIHJhaXNlZCA9IG51bGwsIHVwZGF0ZWQgPSBuZXcgQXJyYXkoc2VsZi5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaTIgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghcmFpc2VkKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSlcbiAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICByYWlzZWQgPSBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmFpc2VkIHx8IGZpbHRlcih2YWx1ZSkpIHtcbiAgICAgICAgICB1cGRhdGVkW2kyXSA9IHNlbGZbaV1cbiAgICAgICAgICBpMiArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpMiAhPT0gaSkge1xuICAgICAgICBzZWxmLnNwbGljZS5hcHBseShzZWxmLCBbMCwgdXBkYXRlZC5sZW5ndGhdLmNvbmNhdCh1cGRhdGVkKSk7XG4gICAgICAgIHNlbGYuc3BsaWNlKGkyLCB1cGRhdGVkLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyYWlzZWQpIHRocm93IHJhaXNlZDtcbiAgICB9XG4gIH1cblxuICBkZWYgc2VsZi5bXSgqb2JqZWN0cylcbiAgICBgdG9BcnJheVN1YmNsYXNzKG9iamVjdHMsIHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShzaXplID0gbmlsLCBvYmogPSBuaWwsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChvYmogIT09IG5pbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogYmxvY2sgc3VwZXJzZWRlcyBkZWZhdWx0IHZhbHVlIGFyZ3VtZW50Jyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaXplID4gI3tJbnRlZ2VyOjpNQVh9KSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2FycmF5IHNpemUgdG9vIGJpZyd9XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4yKVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoc2l6ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgI3tyZXBsYWNlKHNpemUudG9fYSl9XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0gZWxzZSBpZiAoI3tzaXplLnJlc3BvbmRfdG8/IDp0b19hcnl9KSB7XG4gICAgICAgICAgI3tyZXBsYWNlKHNpemUudG9fYXJ5KX1cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzaXplID0gJGNvZXJjZV90byhzaXplLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ31cbiAgICAgIH1cblxuICAgICAgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xuICAgICAgdmFyIGksIHZhbHVlO1xuXG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgc2VsZi5wdXNoKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwLCB2YWx1ZTsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIHZhbHVlID0gYmxvY2soaSk7XG4gICAgICAgICAgc2VsZltpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQob2JqKVxuICAgIE9wYWwuY29lcmNlX3RvPyBvYmosIEFycmF5LCA6dG9fYXJ5XG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgb3RoZXJbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICBpZiAoJGhhc2hfZGVsZXRlKGhhc2gsIGl0ZW0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgb3RoZXIgPSBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3tBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgc2VsZltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBvdGhlcltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoLiRrZXlzKCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICByZXR1cm4gam9pbihvdGhlci50b19zdHIpIGlmIG90aGVyLnJlc3BvbmRfdG8/IDp0b19zdHJcblxuICAgIG90aGVyID0gYCRjb2VyY2VfdG8ob3RoZXIsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgIGlmIGBvdGhlciA8IDBgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJndW1lbnQnXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBjb252ZXJ0ZWQgPSAje3RvX2F9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChjb252ZXJ0ZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgb3RoZXIgPSBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3tBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICBgc2VsZi5jb25jYXQob3RoZXIpYFxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICBvdGhlciA9IGlmIEFycmF5ID09PSBvdGhlclxuICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGAkY29lcmNlX3RvKG90aGVyLCAje0FycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgIHJldHVybiBbXSBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG4gICAgcmV0dXJuIGBzZWxmLnNsaWNlKClgIGlmIGBvdGhlci5sZW5ndGggPT09IDBgXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW07XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBvdGhlcltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwgaXRlbSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPDwob2JqZWN0KVxuICAgIGBzZWxmLnB1c2gob2JqZWN0KWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgIG90aGVyID0gb3RoZXIudG9fYVxuICAgIGVsc2lmIG90aGVyLnJlc3BvbmRfdG8/IDp0b19hcnlcbiAgICAgIG90aGVyID0gb3RoZXIudG9fYXJ5LnRvX2FcbiAgICBlbHNlXG4gICAgICByZXR1cm5cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCN7aGFzaH0gPT09ICN7b3RoZXIuaGFzaH0pIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb3VudCA9IE1hdGgubWluKHNlbGYubGVuZ3RoLCBvdGhlci5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHRtcCA9ICN7YHNlbGZbaV1gIDw9PiBgb3RoZXJbaV1gfTtcblxuICAgICAgICBpZiAodG1wICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tgc2VsZi5sZW5ndGhgIDw9PiBgb3RoZXIubGVuZ3RoYH07XG4gICAgfVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxZXEoYXJyYXksIG90aGVyKSB7XG4gICAgICAgIHZhciBpLCBsZW5ndGgsIGEsIGI7XG5cbiAgICAgICAgaWYgKGFycmF5ID09PSBvdGhlcilcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBpZiAoIW90aGVyLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBpZiAoJHJlc3BvbmRfdG8ob3RoZXIsICckdG9fYXJ5JykpIHtcbiAgICAgICAgICAgIHJldHVybiAje2BvdGhlcmAgPT0gYGFycmF5YH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJyYXkuJCRjb25zdHJ1Y3RvciAhPT0gQXJyYXkpXG4gICAgICAgICAgYXJyYXkgPSAje2BhcnJheWAudG9fYX07XG4gICAgICAgIGlmIChvdGhlci4kJGNvbnN0cnVjdG9yICE9PSBBcnJheSlcbiAgICAgICAgICBvdGhlciA9ICN7YG90aGVyYC50b19hfTtcblxuICAgICAgICBpZiAoYXJyYXkubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZWN1cnNlZFsje2BhcnJheWAub2JqZWN0X2lkfV0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYSA9IGFycmF5W2ldO1xuICAgICAgICAgIGIgPSBvdGhlcltpXTtcbiAgICAgICAgICBpZiAoYS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgICBpZiAoYi4kJGlzX2FycmF5ICYmIGIubGVuZ3RoICE9PSBhLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlY3Vyc2VkLmhhc093blByb3BlcnR5KCN7YGFgLm9iamVjdF9pZH0pKSB7XG4gICAgICAgICAgICAgIGlmICghX2VxZXEoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEje2BhYCA9PSBgYmB9KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9lcWVxKHNlbGYsIG90aGVyKTtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBpbmRleCkge1xuICAgICAgdmFyIHNpemUgPSBzZWxmLmxlbmd0aCxcbiAgICAgICAgICBleGNsdWRlLCBmcm9tLCB0bywgcmVzdWx0O1xuXG4gICAgICBleGNsdWRlID0gaW5kZXguZXhjbDtcbiAgICAgIGZyb20gICAgPSAkY29lcmNlX3RvKGluZGV4LmJlZ2luLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcbiAgICAgIHRvICAgICAgPSAkY29lcmNlX3RvKGluZGV4LmVuZCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICBmcm9tICs9IHNpemU7XG5cbiAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZnJvbSA+IHNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICB0byArPSBzaXplO1xuXG4gICAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFleGNsdWRlKSB7XG4gICAgICAgIHRvICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoZnJvbSwgdG8pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkYXJyYXlfc2xpY2VfaW5kZXhfbGVuZ3RoKHNlbGYsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHZhciBzaXplID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgZXhjbHVkZSwgZnJvbSwgdG8sIHJlc3VsdDtcblxuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzaXplO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBpbmRleCA+IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgZGVmIFtdKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoaW5kZXguJCRpc19yYW5nZSkge1xuICAgICAgICByZXR1cm4gJGFycmF5X3NsaWNlX3JhbmdlKHNlbGYsIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJGFycmF5X3NsaWNlX2luZGV4X2xlbmd0aChzZWxmLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0oaW5kZXgsIHZhbHVlLCBleHRyYSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpLCBzaXplID0gc2VsZi5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgUmFuZ2UgPT09IGluZGV4XG4gICAgICBkYXRhID0gaWYgQXJyYXkgPT09IHZhbHVlXG4gICAgICAgICAgICAgICB2YWx1ZS50b19hXG4gICAgICAgICAgICAgZWxzaWYgdmFsdWUucmVzcG9uZF90bz8gOnRvX2FyeVxuICAgICAgICAgICAgICAgdmFsdWUudG9fYXJ5LnRvX2FcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICBbdmFsdWVdXG4gICAgICAgICAgICAgZW5kXG5cbiAgICAgICV4e1xuICAgICAgICB2YXIgZXhjbHVkZSA9IGluZGV4LmV4Y2wsXG4gICAgICAgICAgICBmcm9tICAgID0gJGNvZXJjZV90byhpbmRleC5iZWdpbiwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpLFxuICAgICAgICAgICAgdG8gICAgICA9ICRjb2VyY2VfdG8oaW5kZXguZW5kLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgZnJvbSArPSBzaXplO1xuXG4gICAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgICAje3JhaXNlIFJhbmdlRXJyb3IsIFwiI3tpbmRleC5pbnNwZWN0fSBvdXQgb2YgcmFuZ2VcIn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICAgIHRvICs9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV4Y2x1ZGUpIHtcbiAgICAgICAgICB0byArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb20gPiBzaXplKSB7XG4gICAgICAgICAgZm9yIChpID0gc2l6ZTsgaSA8IGZyb207IGkrKykge1xuICAgICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIDBdLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIHRvIC0gZnJvbV0uY29uY2F0KGRhdGEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBpZiBgZXh0cmEgPT09IHVuZGVmaW5lZGBcbiAgICAgICAgbGVuZ3RoID0gMVxuICAgICAgZWxzZVxuICAgICAgICBsZW5ndGggPSB2YWx1ZVxuICAgICAgICB2YWx1ZSAgPSBleHRyYVxuXG4gICAgICAgIGRhdGEgPSBpZiBBcnJheSA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICAgdmFsdWUudG9fYVxuICAgICAgICAgICAgICAgZWxzaWYgdmFsdWUucmVzcG9uZF90bz8gOnRvX2FyeVxuICAgICAgICAgICAgICAgICB2YWx1ZS50b19hcnkudG9fYVxuICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICBbdmFsdWVdXG4gICAgICAgICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIG9sZDtcblxuICAgICAgICBpbmRleCAgPSAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIG9sZCAgICA9IGluZGV4O1xuICAgICAgICAgIGluZGV4ICs9IHNpemU7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAje3JhaXNlIEluZGV4RXJyb3IsIFwiaW5kZXggI3tgb2xkYH0gdG9vIHNtYWxsIGZvciBhcnJheTsgbWluaW11bSAje2Atc2VsZi5sZW5ndGhgfVwifTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICN7cmFpc2UgSW5kZXhFcnJvciwgXCJuZWdhdGl2ZSBsZW5ndGggKCN7bGVuZ3RofSlcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA+IHNpemUpIHtcbiAgICAgICAgICBmb3IgKGkgPSBzaXplOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0cmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNlbGZbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2luZGV4LCBsZW5ndGhdLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhbnk/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBgaWYgKHNlbGYubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2VgXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpdGVtID0gc2VsZltpXSwgaXRlbS5sZW5ndGggJiYgI3tgaXRlbVswXWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXQoaW5kZXgpXG4gICAgJXh7XG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7SW50ZWdlcn0sICd0b19pbnQnKVxuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoX2luZGV4KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmJzZWFyY2hfaW5kZXggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gMCxcbiAgICAgICAgICBtYXggPSBzZWxmLmxlbmd0aCxcbiAgICAgICAgICBtaWQsXG4gICAgICAgICAgdmFsLFxuICAgICAgICAgIHJldCxcbiAgICAgICAgICBzbWFsbGVyID0gZmFsc2UsXG4gICAgICAgICAgc2F0aXNmaWVkID0gbmlsO1xuXG4gICAgICB3aGlsZSAobWluIDwgbWF4KSB7XG4gICAgICAgIG1pZCA9IG1pbiArIE1hdGguZmxvb3IoKG1heCAtIG1pbikgLyAyKTtcbiAgICAgICAgdmFsID0gc2VsZlttaWRdO1xuICAgICAgICByZXQgPSAkeWllbGQxKGJsb2NrLCB2YWwpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IHRydWUpIHtcbiAgICAgICAgICBzYXRpc2ZpZWQgPSBtaWQ7XG4gICAgICAgICAgc21hbGxlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmV0ID09PSBmYWxzZSB8fCByZXQgPT09IG5pbCkge1xuICAgICAgICAgIHNtYWxsZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXQuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICBpZiAocmV0ID09PSAwKSB7IHJldHVybiBtaWQ7IH1cbiAgICAgICAgICBzbWFsbGVyID0gKHJldCA8IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgcmV0YC5jbGFzc30gKG11c3QgYmUgbnVtZXJpYywgdHJ1ZSwgZmFsc2Ugb3IgbmlsKVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNtYWxsZXIpIHsgbWF4ID0gbWlkOyB9IGVsc2UgeyBtaW4gPSBtaWQgKyAxOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzYXRpc2ZpZWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnNlYXJjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpic2VhcmNoIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGluZGV4ID0gYnNlYXJjaF9pbmRleCgmYmxvY2spXG5cbiAgICAleHtcbiAgICAgIGlmIChpbmRleCAhPSBudWxsICYmIGluZGV4LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjeWNsZShuID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpjeWNsZSwgbikgZG9cbiAgICAgICAgaWYgbi5uaWw/XG4gICAgICAgICAgRmxvYXQ6OklORklOSVRZXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBuID0gT3BhbC5jb2VyY2VfdG8hKG4sIEludGVnZXIsIDp0b19pbnQpXG4gICAgICAgICAgbiA+IDAgPyBlbnVtZXJhdG9yX3NpemUgKiBuIDogMFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgcmV0dXJuIGlmIGVtcHR5PyB8fCBuID09IDBcblxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbmd0aCwgdmFsdWU7XG5cbiAgICAgIGlmIChuID09PSBuaWwpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG4gPSAje09wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xlYXJcbiAgICBgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY291bnQob2JqZWN0ID0gbmlsLCAmYmxvY2spXG4gICAgaWYgb2JqZWN0IHx8IGJsb2NrXG4gICAgICBzdXBlclxuICAgIGVsc2VcbiAgICAgIHNpemVcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgICByZXBsYWNlIG90aGVyXG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICBzZWxmW2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiBiaW5vbWlhbF9jb2VmZmljaWVudChuLCBrKSB7XG4gICAgICBpZiAobiA9PT0gayB8fCBrID09PSAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoayA+IDAgJiYgbiA+IGspIHtcbiAgICAgICAgcmV0dXJuIGJpbm9taWFsX2NvZWZmaWNpZW50KG4gLSAxLCBrIC0gMSkgKyBiaW5vbWlhbF9jb2VmZmljaWVudChuIC0gMSwgayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBjb21iaW5hdGlvbihuKVxuICAgIG51bSA9IE9wYWwuY29lcmNlX3RvISBuLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb21iaW5hdGlvbiwgbnVtKSB7IGBiaW5vbWlhbF9jb2VmZmljaWVudCgje3NlbGZ9Lmxlbmd0aCwgbnVtKWAgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHN0YWNrLCBjaG9zZW4sIGxldiwgZG9uZSwgbmV4dDtcblxuICAgICAgaWYgKG51bSA9PT0gMCkge1xuICAgICAgICAje3lpZWxkIFtdfVxuICAgICAgfSBlbHNlIGlmIChudW0gPT09IDEpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICN7eWllbGQgYFtzZWxmW2ldXWB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA9PT0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgI3t5aWVsZCBgc2VsZi5zbGljZSgpYH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA+PSAwICYmIG51bSA8IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPD0gbnVtICsgMTsgaSsrKSB7XG4gICAgICAgICAgc3RhY2sucHVzaCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNob3NlbiA9IFtdO1xuICAgICAgICBsZXYgPSAwO1xuICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIHN0YWNrWzBdID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgY2hvc2VuW2xldl0gPSBzZWxmW3N0YWNrW2xldisxXV07XG4gICAgICAgICAgd2hpbGUgKGxldiA8IG51bSAtIDEpIHtcbiAgICAgICAgICAgIGxldisrO1xuICAgICAgICAgICAgbmV4dCA9IHN0YWNrW2xldisxXSA9IHN0YWNrW2xldl0gKyAxO1xuICAgICAgICAgICAgY2hvc2VuW2xldl0gPSBzZWxmW25leHRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAjeyB5aWVsZCBgY2hvc2VuLnNsaWNlKClgIH1cbiAgICAgICAgICBsZXYrKztcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBkb25lID0gKGxldiA9PT0gMCk7XG4gICAgICAgICAgICBzdGFja1tsZXZdKys7XG4gICAgICAgICAgICBsZXYtLTtcbiAgICAgICAgICB9IHdoaWxlICggc3RhY2tbbGV2KzFdICsgbnVtID09PSBzZWxmLmxlbmd0aCArIGxldiArIDEgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXBlYXRlZF9jb21iaW5hdGlvbihuKVxuICAgIG51bSA9IE9wYWwuY29lcmNlX3RvISBuLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnJlcGVhdGVkX2NvbWJpbmF0aW9uLCBudW0pIHsgYGJpbm9taWFsX2NvZWZmaWNpZW50KHNlbGYubGVuZ3RoICsgbnVtIC0gMSwgbnVtKWAgfVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBpdGVyYXRlKG1heCwgZnJvbSwgYnVmZmVyLCBzZWxmKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IG1heCkge1xuICAgICAgICAgIHZhciBjb3B5ID0gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgI3t5aWVsZCBgY29weWB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHNlbGZbaV0pO1xuICAgICAgICAgIGl0ZXJhdGUobWF4LCBpLCBidWZmZXIsIHNlbGYpO1xuICAgICAgICAgIGJ1ZmZlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobnVtID49IDApIHtcbiAgICAgICAgaXRlcmF0ZShudW0sIDAsIFtdLCBzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY29tcGFjdFxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKGl0ZW0gPSBzZWxmW2ldKSAhPT0gbmlsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0IVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gc2VsZi5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmW2ldID09PSBuaWwpIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsID8gbmlsIDogc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25jYXQoKm90aGVycylcbiAgICBvdGhlcnMgPSBvdGhlcnMubWFwIGRvIHxvdGhlcnxcbiAgICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIGlmIG90aGVyLmVxdWFsPyhzZWxmKVxuICAgICAgICBvdGhlciA9IG90aGVyLmR1cFxuICAgICAgZW5kXG5cbiAgICAgIG90aGVyXG4gICAgZW5kXG5cbiAgICBvdGhlcnMuZWFjaCBkbyB8b3RoZXJ8XG4gICAgICAleHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2VsZi5wdXNoKG90aGVyW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZGVsZXRlKG9iamVjdClcbiAgICAleHtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHNlbGYubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb3JpZ2luYWw7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgIHNlbGYuc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gb3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKCN7YmxvY2tfZ2l2ZW4/fSkge1xuICAgICAgICAgIHJldHVybiAje3lpZWxkfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfYXQoaW5kZXgpXG4gICAgJXh7XG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gc2VsZltpbmRleF07XG5cbiAgICAgIHNlbGYuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZGVsZXRlX2lmKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgJXh7ZmlsdGVySWYoc2VsZiwgJGZhbHN5LCBibG9jayl9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZGlmZmVyZW5jZSgqYXJyYXlzKVxuICAgIGFycmF5cy5yZWR1Y2UodG9fYS5kdXApIHsgfGEsIGJ8IGEgLSBiIH1cbiAgZW5kXG5cbiAgZGVmIGRpZyhpZHgsICppZHhzKVxuICAgIGl0ZW0gPSBzZWxmW2lkeF1cblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBpZHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqaWR4cylcbiAgZW5kXG5cbiAgZGVmIGRyb3AobnVtYmVyKVxuICAgICV4e1xuICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZShudW1iZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5BcnJheSAmJlxuICAgICAgICAgIHNlbGYuJCRjbGFzcy4kYWxsb2NhdGUuJCRwcmlzdGluZSAmJlxuICAgICAgICAgIHNlbGYuJGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLiQkcHJpc3RpbmUgJiZcbiAgICAgICAgICBzZWxmLiRpbml0aWFsaXplX2R1cC4kJHByaXN0aW5lKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9pbmRleCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2luZGV4KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxbChhcnJheSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGksIGxlbmd0aCwgYSwgYjtcblxuICAgICAgICBpZiAoIW90aGVyLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9ICN7b3RoZXIudG9fYX07XG5cbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzZWRbI3tgYXJyYXlgLm9iamVjdF9pZH1dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGEgPSBhcnJheVtpXTtcbiAgICAgICAgICBiID0gb3RoZXJbaV07XG4gICAgICAgICAgaWYgKGEuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgaWYgKGIuJCRpc19hcnJheSAmJiBiLmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZC5oYXNPd25Qcm9wZXJ0eSgje2BhYC5vYmplY3RfaWR9KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEje2BhYC5lcWw/KGBiYCl9KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9lcWwoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZldGNoKGluZGV4LCBkZWZhdWx0cyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gaW5kZXg7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwgJiYgZGVmYXVsdHMgIT0gbnVsbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGJsb2NrIHN1cGVyc2VkZXMgZGVmYXVsdCB2YWx1ZSBhcmd1bWVudCcpfVxuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICByZXR1cm4gYmxvY2sob3JpZ2luYWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmYXVsdHMgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAje3JhaXNlIEluZGV4RXJyb3IsIFwiaW5kZXggI3tgb3JpZ2luYWxgfSBvdXRzaWRlIG9mIGFycmF5IGJvdW5kczogMC4uLjBcIn1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAje3JhaXNlIEluZGV4RXJyb3IsIFwiaW5kZXggI3tgb3JpZ2luYWxgfSBvdXRzaWRlIG9mIGFycmF5IGJvdW5kczogLSN7YHNlbGYubGVuZ3RoYH0uLi4je2BzZWxmLmxlbmd0aGB9XCJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZpbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlO1xuICAgIH1cblxuICAgIGlmIGJsb2NrXG4gICAgICBpZiBgYXJncy5sZW5ndGggPiAyYFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5sZW5ndGh9IGZvciAwLi4yKVwiXG4gICAgICBlbmRcblxuICAgICAgb25lLCB0d28gPSBhcmdzXG4gICAgZWxzZVxuICAgICAgaWYgYGFyZ3MubGVuZ3RoID09IDBgXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxLi4zKSdcbiAgICAgIGVsc2lmIGBhcmdzLmxlbmd0aCA+IDNgXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLmxlbmd0aH0gZm9yIDEuLjMpXCJcbiAgICAgIGVuZFxuXG4gICAgICBvYmosIG9uZSwgdHdvID0gYXJnc1xuICAgIGVuZFxuXG4gICAgaWYgUmFuZ2UgPT09IG9uZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCAnbGVuZ3RoIGludmFsaWQgd2l0aCByYW5nZScgaWYgdHdvXG5cbiAgICAgIGxlZnQgICA9IGAkY29lcmNlX3RvKG9uZS5iZWdpbiwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgYGxlZnQgKz0gdGhpcy5sZW5ndGhgIGlmIGBsZWZ0IDwgMGBcbiAgICAgIHJhaXNlIFJhbmdlRXJyb3IsIFwiI3tvbmUuaW5zcGVjdH0gb3V0IG9mIHJhbmdlXCIgaWYgYGxlZnQgPCAwYFxuXG4gICAgICByaWdodCA9IGAkY29lcmNlX3RvKG9uZS5lbmQsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGByaWdodCArPSB0aGlzLmxlbmd0aGAgaWYgYHJpZ2h0IDwgMGBcbiAgICAgIGByaWdodCArPSAxYCB1bmxlc3Mgb25lLmV4Y2x1ZGVfZW5kP1xuXG4gICAgICByZXR1cm4gc2VsZiBpZiBgcmlnaHQgPD0gbGVmdGBcbiAgICBlbHNpZiBvbmVcbiAgICAgIGxlZnQgICA9IGAkY29lcmNlX3RvKG9uZSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgYGxlZnQgKz0gdGhpcy5sZW5ndGhgIGlmIGBsZWZ0IDwgMGBcbiAgICAgIGxlZnQgICA9IDAgaWYgYGxlZnQgPCAwYFxuXG4gICAgICBpZiB0d29cbiAgICAgICAgcmlnaHQgPSBgJGNvZXJjZV90byh0d28sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgICByZXR1cm4gc2VsZiBpZiBgcmlnaHQgPT0gMGBcblxuICAgICAgICBgcmlnaHQgKz0gbGVmdGBcbiAgICAgIGVsc2VcbiAgICAgICAgcmlnaHQgPSBgdGhpcy5sZW5ndGhgXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBsZWZ0ICA9IDBcbiAgICAgIHJpZ2h0ID0gYHRoaXMubGVuZ3RoYFxuICAgIGVuZFxuXG4gICAgaWYgYGxlZnQgPiB0aGlzLmxlbmd0aGBcbiAgICAgICV4e1xuICAgICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aDsgaSA8IHJpZ2h0OyBpKyspIHtcbiAgICAgICAgICBzZWxmW2ldID0gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBpZiBgcmlnaHQgPiB0aGlzLmxlbmd0aGBcbiAgICAgIGB0aGlzLmxlbmd0aCA9IHJpZ2h0YFxuICAgIGVuZFxuXG4gICAgaWYgYmxvY2tcbiAgICAgICV4e1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRoaXMubGVuZ3RoOyBsZWZ0IDwgcmlnaHQ7IGxlZnQrKykge1xuICAgICAgICAgIHZhbHVlID0gYmxvY2sobGVmdCk7XG4gICAgICAgICAgc2VsZltsZWZ0XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgJXh7XG4gICAgICAgIGZvciAobGVuZ3RoID0gdGhpcy5sZW5ndGg7IGxlZnQgPCByaWdodDsgbGVmdCsrKSB7XG4gICAgICAgICAgc2VsZltsZWZ0XSA9ICN7b2JqfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZmlyc3QoY291bnQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoY291bnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IDAgPyBuaWwgOiBzZWxmWzBdO1xuICAgICAgfVxuXG4gICAgICBjb3VudCA9ICRjb2VyY2VfdG8oY291bnQsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnNsaWNlKDAsIGNvdW50KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuKGxldmVsID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gX2ZsYXR0ZW4oYXJyYXksIGxldmVsKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIGksIGxlbmd0aCxcbiAgICAgICAgICAgIGl0ZW0sIGFyeTtcblxuICAgICAgICBhcnJheSA9ICN7YGFycmF5YC50b19hfTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBhcnJheVtpXTtcblxuICAgICAgICAgIGlmICghJHJlc3BvbmRfdG8oaXRlbSwgJyR0b19hcnknLCB0cnVlKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnkgPSAje2BpdGVtYC50b19hcnl9O1xuXG4gICAgICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXJ5ID09PSBzZWxmKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3J9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoX2ZsYXR0ZW4oYXJ5KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgX2ZsYXR0ZW4oYXJ5LCBsZXZlbCAtIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwgPSAkY29lcmNlX3RvKGxldmVsLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZmxhdHRlbihzZWxmLCBsZXZlbCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZmxhdHRlbiEobGV2ZWwgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgZmxhdHRlbmVkID0gI3tmbGF0dGVuIGxldmVsfTtcblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09IGZsYXR0ZW5lZC5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoc2VsZltpXSAhPT0gZmxhdHRlbmVkW2ldKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA9PSBsZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICN7cmVwbGFjZSBgZmxhdHRlbmVkYH07XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgICV4e1xuICAgICAgdmFyIHRvcCA9ICgkaGFzaF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgcmVzdWx0ID0gWydBJ10sXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIGl0ZW0sIGksIGtleTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICRoYXNoX2lkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gZWFybHkgZm9yIHJlY3Vyc2l2ZSBzdHJ1Y3R1cmVzXG4gICAgICAgIGlmICgkaGFzaF9pZHNbaGFzaF9pZF0pIHtcbiAgICAgICAgICByZXR1cm4gJ3NlbGYnO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gJGhhc2hfaWRzKSB7XG4gICAgICAgICAgaXRlbSA9ICRoYXNoX2lkc1trZXldO1xuICAgICAgICAgIGlmICgje2VxbD8oYGl0ZW1gKX0pIHtcbiAgICAgICAgICAgIHJldHVybiAnc2VsZic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJGhhc2hfaWRzW2hhc2hfaWRdID0gc2VsZjtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0uJGhhc2goKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJywnKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAkaGFzaF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhtZW1iZXIpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gbWVtYmVyfSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmRleChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlO1xuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGdpdmVuIGJsb2NrIG5vdCB1c2VkJyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFsdWUgPSBibG9jayhzZWxmW2ldKTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UgJiYgdmFsdWUgIT09IG5pbCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7ZW51bV9mb3IgOmluZGV4fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNlcnQoaW5kZXgsICpvYmplY3RzKVxuICAgICV4e1xuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoICsgMTtcblxuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICN7IHJhaXNlIEluZGV4RXJyb3IsIFwiI3tpbmRleH0gaXMgb3V0IG9mIGJvdW5kc1wiIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHNlbGYubGVuZ3RoOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgc2VsZi5wdXNoKG5pbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2luZGV4LCAwXS5jb25jYXQob2JqZWN0cykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBpZCAgICAgPSAje19faWRfX307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gI3tzZWxmW2BpYF19O1xuXG4gICAgICAgIGlmICgje2BpdGVtYC5fX2lkX199ID09PSBpZCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCdbLi4uXScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCN7YGl0ZW1gLmluc3BlY3R9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnXSc7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW50ZXJzZWN0aW9uKCphcnJheXMpXG4gICAgYXJyYXlzLnJlZHVjZSh0b19hLmR1cCkgeyB8YSwgYnwgYSAmIGIgfVxuICBlbmRcblxuICBkZWYgam9pbihzZXAgPSBuaWwpXG4gICAgcmV0dXJuICcnIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIGlmIGBzZXAgPT09IG5pbGBcbiAgICAgIHNlcCA9ICQsXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBpLCBsZW5ndGgsIGl0ZW0sIHRtcDtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICBpZiAoJHJlc3BvbmRfdG8oaXRlbSwgJyR0b19zdHInKSkge1xuICAgICAgICAgIHRtcCA9ICN7YGl0ZW1gLnRvX3N0cn07XG5cbiAgICAgICAgICBpZiAodG1wICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCN7YHRtcGAudG9fc30pO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJHJlc3BvbmRfdG8oaXRlbSwgJyR0b19hcnknKSkge1xuICAgICAgICAgIHRtcCA9ICN7YGl0ZW1gLnRvX2FyeX07XG5cbiAgICAgICAgICBpZiAodG1wID09PSBzZWxmKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3J9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0bXAgIT09IG5pbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goI3tgdG1wYC5qb2luKHNlcCl9KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRyZXNwb25kX3RvKGl0ZW0sICckdG9fcycpKSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fc307XG5cbiAgICAgICAgICBpZiAodG1wICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcCk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICN7cmFpc2UgTm9NZXRob2RFcnJvci5uZXcoXCIje2BPcGFsLmluc3BlY3QoaXRlbSlgfSBkb2Vzbid0IHJlc3BvbmQgdG8gI3RvX3N0ciwgI3RvX2FyeSBvciAjdG9fc1wiLCAndG9fc3RyJyl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VwID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oI3tPcGFsLmNvZXJjZV90byEoc2VwLCBTdHJpbmcsIDp0b19zdHIpLnRvX3N9KTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBrZWVwX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmtlZXBfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICAleHtmaWx0ZXJJZihzZWxmLCAkdHJ1dGh5LCBibG9jayl9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGFzdChjb3VudCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChjb3VudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gMCA/IG5pbCA6IHNlbGZbc2VsZi5sZW5ndGggLSAxXTtcbiAgICAgIH1cblxuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSd9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY291bnQgPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICBjb3VudCA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZShzZWxmLmxlbmd0aCAtIGNvdW50LCBzZWxmLmxlbmd0aCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYHNlbGYubGVuZ3RoYFxuICBlbmRcblxuICBhbGlhcyBtYXAgY29sbGVjdFxuXG4gIGFsaWFzIG1hcCEgY29sbGVjdCFcblxuICBkZWYgbWF4KG4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBlYWNoLm1heChuLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBtaW4oJmJsb2NrKVxuICAgIGVhY2gubWluKCZibG9jaylcbiAgZW5kXG5cbiAgJXh7XG4gICAgLy8gUmV0dXJucyB0aGUgcHJvZHVjdCBvZiBmcm9tLCBmcm9tLTEsIC4uLiwgZnJvbSAtIGhvd19tYW55ICsgMS5cbiAgICBmdW5jdGlvbiBkZXNjZW5kaW5nX2ZhY3RvcmlhbChmcm9tLCBob3dfbWFueSkge1xuICAgICAgdmFyIGNvdW50ID0gaG93X21hbnkgPj0gMCA/IDEgOiAwO1xuICAgICAgd2hpbGUgKGhvd19tYW55KSB7XG4gICAgICAgIGNvdW50ICo9IGZyb207XG4gICAgICAgIGZyb20tLTtcbiAgICAgICAgaG93X21hbnktLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gIH1cblxuICBkZWYgcGVybXV0YXRpb24obnVtID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpwZXJtdXRhdGlvbiwgbnVtKSBkb1xuICAgICAgICBgZGVzY2VuZGluZ19mYWN0b3JpYWwoc2VsZi5sZW5ndGgsIG51bSA9PT0gdW5kZWZpbmVkID8gc2VsZi5sZW5ndGggOiBudW0pYFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBwZXJtdXRlLCBvZmZlbnNpdmUsIG91dHB1dDtcblxuICAgICAgaWYgKG51bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG51bSA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG51bSA9ICRjb2VyY2VfdG8obnVtLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChudW0gPCAwIHx8IHNlbGYubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgIC8vIG5vIHBlcm11dGF0aW9ucywgeWllbGQgbm90aGluZ1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSAwKSB7XG4gICAgICAgIC8vIGV4YWN0bHkgb25lIHBlcm11dGF0aW9uOiB0aGUgemVyby1sZW5ndGggYXJyYXlcbiAgICAgICAgI3sgeWllbGQgW10gfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSAxKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsLCBlYXN5IGNhc2VcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgI3sgeWllbGQgYFtzZWxmW2ldXWAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZ2VuZXJhbCBjYXNlXG4gICAgICAgICN7IHBlcm0gPSBBcnJheS5uZXcobnVtKSB9O1xuICAgICAgICAjeyB1c2VkID0gQXJyYXkubmV3KGBzZWxmLmxlbmd0aGAsIGZhbHNlKSB9O1xuXG4gICAgICAgIHBlcm11dGUgPSBmdW5jdGlvbihudW0sIHBlcm0sIGluZGV4LCB1c2VkLCBibGspIHtcbiAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZigjeyAhdXNlZFtgaWBdIH0pIHtcbiAgICAgICAgICAgICAgcGVybVtpbmRleF0gPSBpO1xuICAgICAgICAgICAgICBpZihpbmRleCA8IG51bSAtIDEpIHtcbiAgICAgICAgICAgICAgICB1c2VkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwZXJtdXRlLmNhbGwoc2VsZiwgbnVtLCBwZXJtLCBpbmRleCArIDEsIHVzZWQsIGJsayk7XG4gICAgICAgICAgICAgICAgdXNlZFtpXSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGVybS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc2VsZltwZXJtW2pdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICR5aWVsZDEoYmxrLCBvdXRwdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YmxvY2tfZ2l2ZW4/fSkge1xuICAgICAgICAgIC8vIG9mZmVuc2l2ZSAoYm90aCBkZWZpbml0aW9ucykgY29weS5cbiAgICAgICAgICBvZmZlbnNpdmUgPSBzZWxmLnNsaWNlKCk7XG4gICAgICAgICAgcGVybXV0ZS5jYWxsKG9mZmVuc2l2ZSwgbnVtLCBwZXJtLCAwLCB1c2VkLCBibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcGVybXV0ZS5jYWxsKHNlbGYsIG51bSwgcGVybSwgMCwgdXNlZCwgYmxvY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVwZWF0ZWRfcGVybXV0YXRpb24obilcbiAgICBudW0gPSBPcGFsLmNvZXJjZV90byEgbiwgSW50ZWdlciwgOnRvX2ludFxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVwZWF0ZWRfcGVybXV0YXRpb24sIG51bSkgeyBudW0gPj0gMCA/IHNpemUqKm51bSA6IDAgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZ1bmN0aW9uIGl0ZXJhdGUobWF4LCBidWZmZXIsIHNlbGYpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gbWF4KSB7XG4gICAgICAgICAgdmFyIGNvcHkgPSBidWZmZXIuc2xpY2UoKTtcbiAgICAgICAgICAje3lpZWxkIGBjb3B5YH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYnVmZmVyLnB1c2goc2VsZltpXSk7XG4gICAgICAgICAgaXRlcmF0ZShtYXgsIGJ1ZmZlciwgc2VsZik7XG4gICAgICAgICAgYnVmZmVyLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGUobnVtLCBbXSwgc2VsZi5zbGljZSgpKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwb3AoY291bnQgPSB1bmRlZmluZWQpXG4gICAgaWYgYGNvdW50ID09PSB1bmRlZmluZWRgXG4gICAgICByZXR1cm4gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuICAgICAgcmV0dXJuIGBzZWxmLnBvcCgpYFxuICAgIGVuZFxuXG4gICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYGNvdW50IDwgMGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIFtdIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIGlmIGBjb3VudCA9PT0gMWBcbiAgICAgIGBbc2VsZi5wb3AoKV1gXG4gICAgZWxzaWYgYGNvdW50ID4gc2VsZi5sZW5ndGhgXG4gICAgICBgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpYFxuICAgIGVsc2VcbiAgICAgIGBzZWxmLnNwbGljZShzZWxmLmxlbmd0aCAtIGNvdW50LCBzZWxmLmxlbmd0aClgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBwcm9kdWN0KCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gI3tibG9ja19naXZlbj99ID8gbnVsbCA6IFtdLFxuICAgICAgICAgIG4gPSBhcmdzLmxlbmd0aCArIDEsXG4gICAgICAgICAgY291bnRlcnMgPSBuZXcgQXJyYXkobiksXG4gICAgICAgICAgbGVuZ3RocyAgPSBuZXcgQXJyYXkobiksXG4gICAgICAgICAgYXJyYXlzICAgPSBuZXcgQXJyYXkobiksXG4gICAgICAgICAgaSwgbSwgc3ViYXJyYXksIGxlbiwgcmVzdWx0bGVuID0gMTtcblxuICAgICAgYXJyYXlzWzBdID0gc2VsZjtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgYXJyYXlzW2ldID0gJGNvZXJjZV90byhhcmdzW2kgLSAxXSwgI3tBcnJheX0sICd0b19hcnknKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBsZW4gPSBhcnJheXNbaV0ubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdGxlbiAqPSBsZW47XG4gICAgICAgIGlmIChyZXN1bHRsZW4gPiAyMTQ3NDgzNjQ3KSB7XG4gICAgICAgICAgI3tyYWlzZSBSYW5nZUVycm9yLCAndG9vIGJpZyB0byBwcm9kdWN0J31cbiAgICAgICAgfVxuICAgICAgICBsZW5ndGhzW2ldID0gbGVuO1xuICAgICAgICBjb3VudGVyc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIG91dGVyX2xvb3A6IGZvciAoOzspIHtcbiAgICAgICAgc3ViYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHN1YmFycmF5LnB1c2goYXJyYXlzW2ldW2NvdW50ZXJzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHN1YmFycmF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAje3lpZWxkIGBzdWJhcnJheWB9XG4gICAgICAgIH1cbiAgICAgICAgbSA9IG4gLSAxO1xuICAgICAgICBjb3VudGVyc1ttXSsrO1xuICAgICAgICB3aGlsZSAoY291bnRlcnNbbV0gPT09IGxlbmd0aHNbbV0pIHtcbiAgICAgICAgICBjb3VudGVyc1ttXSA9IDA7XG4gICAgICAgICAgaWYgKC0tbSA8IDApIGJyZWFrIG91dGVyX2xvb3A7XG4gICAgICAgICAgY291bnRlcnNbbV0rKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0IHx8IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHVzaCgqb2JqZWN0cylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYucHVzaChvYmplY3RzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGFwcGVuZCBwdXNoXG5cbiAgZGVmIHJhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICBpZiAoaXRlbS5sZW5ndGggJiYgaXRlbVsxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCN7YGl0ZW1bMV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlamVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBibG9jayhzZWxmW2ldKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzZWxmW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIG9yaWdpbmFsID0gbGVuZ3RoXG4gICAgZGVsZXRlX2lmKCZibG9jaylcblxuICAgIHVubGVzcyBsZW5ndGggPT0gb3JpZ2luYWxcbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJlcGxhY2Uob3RoZXIpXG4gICAgb3RoZXIgPSBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3tBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKTtcbiAgICAgIHNlbGYucHVzaC5hcHBseShzZWxmLCBvdGhlcik7XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmV2ZXJzZVxuICAgIGBzZWxmLnNsaWNlKDApLnJldmVyc2UoKWBcbiAgZW5kXG5cbiAgZGVmIHJldmVyc2UhXG4gICAgYHNlbGYucmV2ZXJzZSgpYFxuICBlbmRcblxuICBkZWYgcmV2ZXJzZV9lYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJldmVyc2VfZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgcmV2ZXJzZS5lYWNoKCZibG9jaylcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByaW5kZXgob2JqZWN0ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaSwgdmFsdWU7XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cbiAgICAgIH1cblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IHNlbGYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAoaSA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgje2BzZWxmW2ldYCA9PSBgb2JqZWN0YH0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSBzZWxmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGkgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IGZhbHNlICYmIHZhbHVlICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICN7ZW51bV9mb3IgOnJpbmRleH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcm90YXRlKG4gPSAxKVxuICAgICV4e1xuICAgICAgdmFyIGFyeSwgaWR4LCBmaXJzdFBhcnQsIGxhc3RQYXJ0O1xuXG4gICAgICBuID0gJGNvZXJjZV90byhuLCAje0ludGVnZXJ9LCAndG9faW50JylcblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBhcnkgPSBzZWxmLnNsaWNlKCk7XG4gICAgICBpZHggPSBuICUgYXJ5Lmxlbmd0aDtcblxuICAgICAgZmlyc3RQYXJ0ID0gYXJ5LnNsaWNlKGlkeCk7XG4gICAgICBsYXN0UGFydCA9IGFyeS5zbGljZSgwLCBpZHgpO1xuICAgICAgcmV0dXJuIGZpcnN0UGFydC5jb25jYXQobGFzdFBhcnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdGF0ZSEoY250ID0gMSlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCB8fCBzZWxmLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIGNudCA9ICRjb2VyY2VfdG8oY250LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgfVxuICAgIGFyeSA9IHJvdGF0ZShjbnQpXG4gICAgcmVwbGFjZSBhcnlcbiAgZW5kXG5cbiAgY2xhc3MgU2FtcGxlUmFuZG9tXG4gICAgZGVmIGluaXRpYWxpemUocm5nKVxuICAgICAgQHJuZyA9IHJuZ1xuICAgIGVuZFxuXG4gICAgZGVmIHJhbmQoc2l6ZSlcbiAgICAgIHJhbmRvbSA9IGAkY29lcmNlX3RvKCN7QHJuZy5yYW5kKHNpemUpfSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ3JhbmRvbSB2YWx1ZSBtdXN0IGJlID49IDAnIGlmIGByYW5kb20gPCAwYFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ3JhbmRvbSB2YWx1ZSBtdXN0IGJlIGxlc3MgdGhhbiBBcnJheSBzaXplJyB1bmxlc3MgYHJhbmRvbSA8IHNpemVgXG5cbiAgICAgIHJhbmRvbVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2FtcGxlKGNvdW50ID0gdW5kZWZpbmVkLCBvcHRpb25zID0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBhdCBLZXJuZWwucmFuZChgc2VsZi5sZW5ndGhgKSBpZiBgY291bnQgPT09IHVuZGVmaW5lZGBcblxuICAgIGlmIGBvcHRpb25zID09PSB1bmRlZmluZWRgXG4gICAgICBpZiAobyA9IE9wYWwuY29lcmNlX3RvPyBjb3VudCwgSGFzaCwgOnRvX2hhc2gpXG4gICAgICAgIG9wdGlvbnMgPSBvXG4gICAgICAgIGNvdW50ID0gbmlsXG4gICAgICBlbHNlXG4gICAgICAgIG9wdGlvbnMgPSBuaWxcbiAgICAgICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgb3B0aW9ucyA9IGAkY29lcmNlX3RvKG9wdGlvbnMsICN7SGFzaH0sICd0b19oYXNoJylgXG4gICAgZW5kXG5cbiAgICBpZiBjb3VudCAmJiBgY291bnQgPCAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2NvdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnXG4gICAgZW5kXG5cbiAgICBybmcgPSBvcHRpb25zWzpyYW5kb21dIGlmIG9wdGlvbnNcbiAgICBybmcgPSBpZiBybmcgJiYgcm5nLnJlc3BvbmRfdG8/KDpyYW5kKVxuICAgICAgICAgICAgU2FtcGxlUmFuZG9tLm5ldyBybmdcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBLZXJuZWxcbiAgICAgICAgICBlbmRcblxuICAgIHJldHVybiBgc2VsZlsje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfV1gIHVubGVzcyBjb3VudFxuXG4gICAgJXh7XG5cbiAgICAgIHZhciBhYmFuZG9uLCBzcGluLCByZXN1bHQsIGksIGosIGssIHRhcmdldEluZGV4LCBvbGRWYWx1ZTtcblxuICAgICAgaWYgKGNvdW50ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgY291bnQgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIFtzZWxmWyN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9XV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgaiA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICBqID0gaSA9PT0gMCA/IGkgKyAxIDogaSAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbc2VsZltpXSwgc2VsZltqXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHNlbGYubGVuZ3RoIC8gY291bnQgPiAzKSB7XG4gICAgICAgICAgICBhYmFuZG9uID0gZmFsc2U7XG4gICAgICAgICAgICBzcGluID0gMDtcblxuICAgICAgICAgICAgcmVzdWx0ID0gI3sgQXJyYXkubmV3KGNvdW50KSB9O1xuICAgICAgICAgICAgaSA9IDE7XG5cbiAgICAgICAgICAgIHJlc3VsdFswXSA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICBrID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgICAgIGogPSAwO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChqIDwgaSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChrID09PSByZXN1bHRbal0pIHtcbiAgICAgICAgICAgICAgICAgIHNwaW4rKztcbiAgICAgICAgICAgICAgICAgIGlmIChzcGluID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFiYW5kb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGsgPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFiYW5kb24pIHsgYnJlYWs7IH1cblxuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhYmFuZG9uKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgICAgICAgcmVzdWx0W2ldID0gaztcblxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYWJhbmRvbikge1xuICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHNlbGZbcmVzdWx0W2ldXTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoKTtcblxuICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY291bnQ7IGMrKykge1xuICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgIG9sZFZhbHVlID0gcmVzdWx0W2NdO1xuICAgICAgICAgICAgcmVzdWx0W2NdID0gcmVzdWx0W3RhcmdldEluZGV4XTtcbiAgICAgICAgICAgIHJlc3VsdFt0YXJnZXRJbmRleF0gPSBvbGRWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY291bnQgPT09IHNlbGYubGVuZ3RoID8gcmVzdWx0IDogI3tgcmVzdWx0YFswLCBjb3VudF19O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW0sIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBpdGVtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcbiAgICAgICN7IGtlZXBfaWYoJmJsb2NrKSB9O1xuICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbCA/IG5pbCA6IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBmaWx0ZXIgc2VsZWN0XG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxuXG4gIGRlZiBzaGlmdChjb3VudCA9IHVuZGVmaW5lZClcbiAgICBpZiBgY291bnQgPT09IHVuZGVmaW5lZGBcbiAgICAgIHJldHVybiBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG4gICAgICByZXR1cm4gYHNoaWZ0Tm9Bcmcoc2VsZilgXG4gICAgZW5kXG5cbiAgICBjb3VudCA9IGAkY29lcmNlX3RvKGNvdW50LCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgY291bnQgPCAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gW10gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuXG4gICAgYHNlbGYuc3BsaWNlKDAsIGNvdW50KWBcbiAgZW5kXG5cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcblxuICBkZWYgc2h1ZmZsZShybmcgPSB1bmRlZmluZWQpXG4gICAgZHVwLnRvX2Euc2h1ZmZsZSEocm5nKVxuICBlbmRcblxuICBkZWYgc2h1ZmZsZSEocm5nID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIHJhbmRnZW4sIGkgPSBzZWxmLmxlbmd0aCwgaiwgdG1wO1xuXG4gICAgICBpZiAocm5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcm5nID0gI3tPcGFsLmNvZXJjZV90bz8ocm5nLCBIYXNoLCA6dG9faGFzaCl9O1xuXG4gICAgICAgIGlmIChybmcgIT09IG5pbCkge1xuICAgICAgICAgIHJuZyA9ICN7cm5nWzpyYW5kb21dfTtcblxuICAgICAgICAgIGlmIChybmcgIT09IG5pbCAmJiAje3JuZy5yZXNwb25kX3RvPyg6cmFuZCl9KSB7XG4gICAgICAgICAgICByYW5kZ2VuID0gcm5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaSkge1xuICAgICAgICBpZiAocmFuZGdlbikge1xuICAgICAgICAgIGogPSByYW5kZ2VuLiRyYW5kKGkpLiR0b19pbnQoKTtcblxuICAgICAgICAgIGlmIChqIDwgMCkge1xuICAgICAgICAgICAgI3tyYWlzZSBSYW5nZUVycm9yLCBcInJhbmRvbSBudW1iZXIgdG9vIHNtYWxsICN7YGpgfVwifVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChqID49IGkpIHtcbiAgICAgICAgICAgICN7cmFpc2UgUmFuZ2VFcnJvciwgXCJyYW5kb20gbnVtYmVyIHRvbyBiaWcgI3tgamB9XCJ9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGogPSAje3JhbmQoYGlgKX07XG4gICAgICAgIH1cblxuICAgICAgICB0bXAgPSBzZWxmWy0taV07XG4gICAgICAgIHNlbGZbaV0gPSBzZWxmW2pdO1xuICAgICAgICBzZWxmW2pdID0gdG1wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNsaWNlIFtdXG5cbiAgZGVmIHNsaWNlIShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgIHJlc3VsdCA9IG5pbFxuXG4gICAgaWYgYGxlbmd0aCA9PT0gdW5kZWZpbmVkYFxuICAgICAgaWYgUmFuZ2UgPT09IGluZGV4XG4gICAgICAgIHJhbmdlID0gaW5kZXhcbiAgICAgICAgcmVzdWx0ID0gc2VsZltyYW5nZV1cblxuICAgICAgICByYW5nZV9zdGFydCA9IGAkY29lcmNlX3RvKHJhbmdlLmJlZ2luLCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgIHJhbmdlX2VuZCA9IGAkY29lcmNlX3RvKHJhbmdlLmVuZCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlX3N0YXJ0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9lbmQgPCAwKSB7XG4gICAgICAgICAgICByYW5nZV9lbmQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYW5nZV9lbmQgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJhbmdlX2VuZCA9IHNlbGYubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5leGNsKSB7XG4gICAgICAgICAgICAgIHJhbmdlX2VuZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByYW5nZV9sZW5ndGggPSByYW5nZV9lbmQgLSByYW5nZV9zdGFydDtcbiAgICAgICAgICBpZiAocmFuZ2UuZXhjbCkge1xuICAgICAgICAgICAgcmFuZ2VfZW5kIC09IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlX2xlbmd0aCArPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IHNlbGYubGVuZ3RoICYmIHJhbmdlX3N0YXJ0ID49IDAgJiYgcmFuZ2VfZW5kIDwgc2VsZi5sZW5ndGggJiYgcmFuZ2VfZW5kID49IDAgJiYgcmFuZ2VfbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2VsZi5zcGxpY2UocmFuZ2Vfc3RhcnQsIHJhbmdlX2xlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXJ0ID0gYCRjb2VyY2VfdG8oaW5kZXgsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSBzZWxmW3N0YXJ0XTtcblxuICAgICAgICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgc2VsZi5zaGlmdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnNwbGljZShzdGFydCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBzdGFydCA9IGAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBsZW5ndGggPSBgJGNvZXJjZV90byhsZW5ndGgsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgJXh7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxlbmd0aDtcblxuICAgICAgICByZXN1bHQgPSAje3NlbGZbc3RhcnQsIGxlbmd0aF19O1xuXG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICBzdGFydCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCArIGxlbmd0aCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggLSBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCA8IHNlbGYubGVuZ3RoICYmIHN0YXJ0ID49IDApIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShzdGFydCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgc29ydCgmYmxvY2spXG4gICAgcmV0dXJuIHNlbGYgdW5sZXNzIGBzZWxmLmxlbmd0aCA+IDFgXG5cbiAgICAleHtcbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIGJsb2NrID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiAje2BhYCA8PT4gYGJgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHJldCA9IGJsb2NrKHgsIHkpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7YHhgLmluc3BlY3R9IHdpdGggI3tgeWAuaW5zcGVjdH0gZmFpbGVkXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICN7YHJldGAgPiAwfSA/IDEgOiAoI3tgcmV0YCA8IDB9ID8gLTEgOiAwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvcnQhKCZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcbiAgICAgICAgcmVzdWx0ID0gI3tgc2VsZi5zbGljZSgpYC5zb3J0KCZibG9jayl9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9ICN7YHNlbGYuc2xpY2UoKWAuc29ydH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYubGVuZ3RoID0gMDtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnB1c2gocmVzdWx0W2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc29ydF9ieSEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c29ydF9ieSEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHJlcGxhY2Ugc29ydF9ieSgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB0YWtlKGNvdW50KVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3J9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZSgwLCBjb3VudCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICB2YWx1ZSA9IGJsb2NrKGl0ZW0pO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGNsYXNzID09PSBPcGFsLkFycmF5KSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLkFycmF5LiRuZXcoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fYXJ5XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9faCgmYmxvY2spXG4gICAgYXJyYXkgPSBzZWxmXG4gICAgYXJyYXkgPSBhcnJheS5tYXAoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbiA9IGFycmF5Lmxlbmd0aCwgYXJ5LCBrZXksIHZhbCwgaGFzaCA9ICN7e319O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXJ5ID0gI3tPcGFsLmNvZXJjZV90bz8oYGFycmF5W2ldYCwgQXJyYXksIDp0b19hcnkpfTtcbiAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGVsZW1lbnQgdHlwZSAje2BhcnlgLmNsYXNzfSBhdCAje2BpYH0gKGV4cGVjdGVkIGFycmF5KVwifVxuICAgICAgICB9XG4gICAgICAgIGlmIChhcnkubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIGFycmF5IGxlbmd0aCBhdCAje2BpYH0gKGV4cGVjdGVkIDIsIHdhcyAje2BhcnlgLmxlbmd0aH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gYXJ5WzBdO1xuICAgICAgICB2YWwgPSBhcnlbMV07XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG5cbiAgZGVmIHRyYW5zcG9zZVxuICAgIHJldHVybiBbXSBpZiBlbXB0eT9cblxuICAgIHJlc3VsdCA9IFtdXG4gICAgbWF4ICAgID0gbmlsXG5cbiAgICBlYWNoIGRvIHxyb3d8XG4gICAgICByb3cgPSBpZiBBcnJheSA9PT0gcm93XG4gICAgICAgICAgICAgIHJvdy50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGAkY29lcmNlX3RvKHJvdywgI3tBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAgIG1heCB8fD0gYHJvdy5sZW5ndGhgXG5cbiAgICAgIGlmIGByb3cubGVuZ3RoYCAhPSBtYXhcbiAgICAgICAgcmFpc2UgSW5kZXhFcnJvciwgXCJlbGVtZW50IHNpemUgZGlmZmVycyAoI3tgcm93Lmxlbmd0aGB9IHNob3VsZCBiZSAje21heH0pXCJcbiAgICAgIGVuZFxuXG4gICAgICBgcm93Lmxlbmd0aGAudGltZXMgZG8gfGl8XG4gICAgICAgIGVudHJ5ID0gKHJlc3VsdFtpXSB8fD0gW10pXG4gICAgICAgIGVudHJ5IDw8IHJvdy5hdChpKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIHVuaW9uKCphcnJheXMpXG4gICAgYXJyYXlzLnJlZHVjZSh1bmlxKSB7IHxhLCBifCBhIHwgYiB9XG4gIGVuZFxuXG4gIGRlZiB1bmlxKCZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbSwga2V5O1xuXG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBpdGVtKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwgaXRlbSwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICAgIGtleSA9ICR5aWVsZDEoYmxvY2ssIGl0ZW0pO1xuICAgICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwga2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7YGhhc2hgLnZhbHVlc307XG4gICAgfVxuICBlbmRcblxuICBkZWYgdW5pcSEoJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsX2xlbmd0aCA9IHNlbGYubGVuZ3RoLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbSwga2V5O1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvcmlnaW5hbF9sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAga2V5ID0gKGJsb2NrID09PSBuaWwgPyBpdGVtIDogJHlpZWxkMShibG9jaywgaXRlbSkpO1xuXG4gICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwga2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgaXRlbSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnNwbGljZShpLCAxKTtcbiAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgIGktLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbF9sZW5ndGggPyBuaWwgOiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHVuc2hpZnQoKm9iamVjdHMpXG4gICAgJXh7XG4gICAgICB2YXIgc2VsZkxlbmd0aCA9IHNlbGYubGVuZ3RoXG4gICAgICB2YXIgb2JqZWN0c0xlbmd0aCA9IG9iamVjdHMubGVuZ3RoXG4gICAgICBpZiAob2JqZWN0c0xlbmd0aCA9PSAwKSByZXR1cm4gc2VsZjtcbiAgICAgIHZhciBpbmRleCA9IHNlbGZMZW5ndGggLSBvYmplY3RzTGVuZ3RoXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHNMZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnB1c2goc2VsZltpbmRleCArIGldKVxuICAgICAgfVxuICAgICAgdmFyIGxlbiA9IHNlbGZMZW5ndGggLSAxXG4gICAgICB3aGlsZSAobGVuIC0gb2JqZWN0c0xlbmd0aCA+PSAwKSB7XG4gICAgICAgIHNlbGZbbGVuXSA9IHNlbGZbbGVuIC0gb2JqZWN0c0xlbmd0aF1cbiAgICAgICAgbGVuLS1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0c0xlbmd0aDsgaisrKSB7XG4gICAgICAgIHNlbGZbal0gPSBvYmplY3RzW2pdXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHByZXBlbmQgdW5zaGlmdFxuXG4gIGRlZiB2YWx1ZXNfYXQoKmFyZ3MpXG4gICAgb3V0ID0gW11cblxuICAgIGFyZ3MuZWFjaCBkbyB8ZWxlbXxcbiAgICAgIGlmIGVsZW0uaXNfYT8gUmFuZ2VcbiAgICAgICAgZmluaXNoID0gYCRjb2VyY2VfdG8oI3tlbGVtLmxhc3R9LCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgIHN0YXJ0ID0gYCRjb2VyY2VfdG8oI3tlbGVtLmZpcnN0fSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgKyBzZWxmLmxlbmd0aDtcbiAgICAgICAgICAgICN7bmV4dH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKGZpbmlzaCA8IDApIHtcbiAgICAgICAgICAgIGZpbmlzaCA9IGZpbmlzaCArIHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoI3tlbGVtLmV4Y2x1ZGVfZW5kP30pIHtcbiAgICAgICAgICAgIGZpbmlzaC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmluaXNoIDwgc3RhcnQpIHtcbiAgICAgICAgICAgICN7bmV4dH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQudXB0byhmaW5pc2gpIHsgfGl8IG91dCA8PCBhdChpKSB9XG4gICAgICBlbHNlXG4gICAgICAgIGkgPSBgJGNvZXJjZV90byhlbGVtLCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgIG91dCA8PCBhdChpKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBvdXRcbiAgZW5kXG5cbiAgZGVmIHppcCgqb3RoZXJzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIHNpemUgPSBzZWxmLmxlbmd0aCwgcGFydCwgbywgaSwgaiwgamo7XG5cbiAgICAgIGZvciAoaiA9IDAsIGpqID0gb3RoZXJzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgbyA9IG90aGVyc1tqXTtcbiAgICAgICAgaWYgKG8uJCRpc19hcnJheSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvLiQkaXNfcmFuZ2UgfHwgby4kJGlzX2VudW1lcmF0b3IpIHtcbiAgICAgICAgICBvdGhlcnNbal0gPSBvLiR0YWtlKHNpemUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyc1tqXSA9ICN7KFxuICAgICAgICAgIE9wYWwuY29lcmNlX3RvPyhgb2AsIEFycmF5LCA6dG9fYXJ5KSB8fFxuICAgICAgICAgIE9wYWwuY29lcmNlX3RvIShgb2AsIEVudW1lcmF0b3IsIDp0b19lbnVtLCA6ZWFjaClcbiAgICAgICAgKS50b19hfTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBwYXJ0ID0gW3NlbGZbaV1dO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gb3RoZXJzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICBvID0gb3RoZXJzW2pdW2ldO1xuXG4gICAgICAgICAgaWYgKG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgbyA9IG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0W2ogKyAxXSA9IG87XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRbaV0gPSBwYXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgYmxvY2socmVzdWx0W2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5pbmhlcml0ZWQoa2xhc3MpXG4gICAgJXh7XG4gICAgICBrbGFzcy4kJHByb3RvdHlwZS4kdG9fYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbGljZSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgc3VwZXIucmVqZWN0IHsgfGl2YXJ8IGAvXkBcXGQrJC8udGVzdCgje2l2YXJ9KWAgfHwgaXZhciA9PSAnQGxlbmd0aCcgfVxuICBlbmRcblxuICBPcGFsLnByaXN0aW5lIHNpbmdsZXRvbl9jbGFzcywgOmFsbG9jYXRlXG4gIE9wYWwucHJpc3RpbmUgc2VsZiwgOmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLCA6aW5pdGlhbGl6ZV9kdXBcblxuICBkZWYgcGFjaygqYXJncylcbiAgICByYWlzZSBcIlRvIHVzZSBBcnJheSNwYWNrLCB5b3UgbXVzdCBmaXJzdCByZXF1aXJlICdjb3JlbGliL2FycmF5L3BhY2snLlwiXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiaW5jbHVkZSIsInRvX2EiLCJbXSIsInNlbGYiLCJpbml0aWFsaXplIiwid2FybiIsInJhaXNlIiwicmVwbGFjZSIsInNpemUiLCJyZXNwb25kX3RvPyIsInRvX2FyeSIsInRyeV9jb252ZXJ0IiwiY29lcmNlX3RvPyIsIm9iaiIsIiYiLCJvdGhlciIsIj09PSIsInwiLCIqIiwiam9pbiIsInRvX3N0ciIsIisiLCItIiwiPDwiLCI8PT4iLCJoYXNoIiwiPT0iLCJvYmplY3RfaWQiLCJbXT0iLCJpbmRleCIsImRhdGEiLCJ2YWx1ZSIsImluc3BlY3QiLCJsZW5ndGgiLCIxIiwiZXh0cmEiLCJhbnk/IiwiYXNzb2MiLCJvYmplY3QiLCJhdCIsImJzZWFyY2hfaW5kZXgiLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImJzZWFyY2giLCJibG9jayIsImN5Y2xlIiwibiIsIm5pbD8iLCJjb2VyY2VfdG8hIiwiPiIsIjAiLCJlbnVtZXJhdG9yX3NpemUiLCIkcmV0X29yXzEiLCJlbXB0eT8iLCJjbGVhciIsImNvdW50IiwiJHJldF9vcl8yIiwiaW5pdGlhbGl6ZV9jb3B5IiwiY29sbGVjdCIsImNvbGxlY3QhIiwiY29tYmluYXRpb24iLCJudW0iLCJyZXBlYXRlZF9jb21iaW5hdGlvbiIsImNvbXBhY3QiLCJjb21wYWN0ISIsImNvbmNhdCIsIm90aGVycyIsIm1hcCIsImVxdWFsPyIsImR1cCIsImVhY2giLCJkZWxldGUiLCJkZWxldGVfYXQiLCJkZWxldGVfaWYiLCJkaWZmZXJlbmNlIiwicmVkdWNlIiwiYXJyYXlzIiwiYSIsImIiLCJkaWciLCJpdGVtIiwiaWR4IiwiaWR4cyIsImRyb3AiLCJlYWNoX2luZGV4IiwiZXFsPyIsImZldGNoIiwiZmlsbCIsImFyZ3MiLCJvbmUiLCJ0d28iLCJsZWZ0IiwicmlnaHQiLCJleGNsdWRlX2VuZD8iLCJmaXJzdCIsImZsYXR0ZW4iLCJmbGF0dGVuISIsImxldmVsIiwiaW5jbHVkZT8iLCJtZW1iZXIiLCJpbnNlcnQiLCJfX2lkX18iLCJpbnRlcnNlY3Rpb24iLCJzZXAiLCIkLCIsInRvX3MiLCJuZXciLCJrZWVwX2lmIiwibGFzdCIsIm1heCIsIm1pbiIsInBlcm11dGF0aW9uIiwicGVybSIsInVzZWQiLCIhIiwicmVwZWF0ZWRfcGVybXV0YXRpb24iLCI+PSIsIioqIiwicG9wIiwicHJvZHVjdCIsInB1c2giLCJyYXNzb2MiLCJyZWplY3QiLCJyZWplY3QhIiwib3JpZ2luYWwiLCJyZXZlcnNlIiwicmV2ZXJzZSEiLCJyZXZlcnNlX2VhY2giLCJyaW5kZXgiLCJyb3RhdGUiLCJyb3RhdGUhIiwiYXJ5IiwiY250IiwiQHJuZyIsInJuZyIsInJhbmQiLCJyYW5kb20iLCJzYW1wbGUiLCJvIiwib3B0aW9ucyIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsInNlbGVjdCIsInNlbGVjdCEiLCJzaGlmdCIsInNodWZmbGUiLCJzaHVmZmxlISIsInNsaWNlISIsInJlc3VsdCIsInJhbmdlIiwicmFuZ2Vfc3RhcnQiLCJyYW5nZV9lbmQiLCJzdGFydCIsInNvcnQiLCI8Iiwic29ydCEiLCJzb3J0X2J5ISIsInNvcnRfYnkiLCJ0YWtlIiwidGFrZV93aGlsZSIsInRvX2giLCJhcnJheSIsInRyYW5zcG9zZSIsInJvdyIsIiRyZXRfb3JfNSIsIiE9IiwidGltZXMiLCJlbnRyeSIsIiRyZXRfb3JfNiIsImkiLCIkd3JpdGVyIiwidW5pb24iLCJ1bmlxIiwidmFsdWVzIiwidW5pcSEiLCJ1bnNoaWZ0IiwidmFsdWVzX2F0Iiwib3V0IiwiZWxlbSIsImlzX2E/IiwiZmluaXNoIiwidXB0byIsInppcCIsIiRyZXRfb3JfNyIsImluaGVyaXRlZCIsImluc3RhbmNlX3ZhcmlhYmxlcyIsIiRyZXRfb3Jf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QSw0REFBQTtBQUFBO0FBODJFVyxNQUFBLGtCQTkyRVg7QUFBQSxNQSsyRUksV0FBQXhMLE9BQUFBLENBQU0saUVBQU5BLENBLzJFSjtBQTgyRUV3TCxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FBQUEsZ0JBdjJFQTtBQURGL0wsRUFBQUEsR0FBQUEsV0FBQUEsRUFBZSxLQUFmQSxXQUhBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTUyMTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2hhc2gucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG4jIC0tLVxuIyBJbnRlcm5hbCBwcm9wZXJ0aWVzOlxuI1xuIyAtICQkbWFwICAgICAgICAgW0pTOjpPYmplY3Q8U3RyaW5nID0+IGhhc2gtYnVja2V0Pl0gdGhlIGhhc2ggdGFibGUgZm9yIG9yZGluYXJ5IGtleXNcbiMgLSAkJHNtYXAgICAgICAgIFtKUzo6T2JqZWN0PFN0cmluZyA9PiBoYXNoLWJ1Y2tldD5dIHRoZSBoYXNoIHRhYmxlIGZvciBzdHJpbmcga2V5c1xuIyAtICQka2V5cyAgICAgICAgW0FycmF5PGhhc2gtYnVja2V0Pl0gdGhlIGxpc3Qgb2YgYWxsIGtleXNcbiMgLSAkJHByb2MgICAgICAgIFtQcm9jLG51bGwsbmlsXSB0aGUgZGVmYXVsdCBwcm9jIHVzZWQgZm9yIG1pc3Npbmcga2V5c1xuIyAtIGhhc2gtYnVja2V0ICAgW0pTOjpPYmplY3RdIGFuIGVsZW1lbnQgb2YgYSBsaW5rZWQgbGlzdCB0aGF0IGhvbGRzIGhhc2ggdmFsdWVzLCBrZXlzIGFyZSBge2tleTosa2V5X2hhc2g6LHZhbHVlOixuZXh0On1gXG5jbGFzcyBIYXNoXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gICMgTWFyayBhbGwgaGFzaCBpbnN0YW5jZXMgYXMgdmFsaWQgaGFzaGVzICh1c2VkIHRvIGNoZWNrIGtleXdvcmQgYXJncywgZXRjKVxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX2hhc2ggPSB0cnVlYFxuXG4gIGRlZiBzZWxmLltdKCphcmd2KVxuICAgICV4e1xuICAgICAgdmFyIGhhc2gsIGFyZ2MgPSBhcmd2Lmxlbmd0aCwgaTtcblxuICAgICAgaWYgKGFyZ2MgPT09IDEpIHtcbiAgICAgICAgaGFzaCA9ICN7T3BhbC5jb2VyY2VfdG8/KGFyZ3ZbMF0sIEhhc2gsIDp0b19oYXNoKX07XG4gICAgICAgIGlmIChoYXNoICE9PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gI3thbGxvY2F0ZS5tZXJnZSEoYGhhc2hgKX07XG4gICAgICAgIH1cblxuICAgICAgICBhcmd2ID0gI3tPcGFsLmNvZXJjZV90bz8oYXJndlswXSwgQXJyYXksIDp0b19hcnkpfTtcbiAgICAgICAgaWYgKGFyZ3YgPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ29kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ2MgPSBhcmd2Lmxlbmd0aDtcbiAgICAgICAgaGFzaCA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdjOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWFyZ3ZbaV0uJCRpc19hcnJheSkgY29udGludWU7XG4gICAgICAgICAgc3dpdGNoKGFyZ3ZbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaGFzaC4kc3RvcmUoYXJndltpXVswXSwgbmlsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV1bMF0sIGFyZ3ZbaV1bMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIG51bWJlciBvZiBlbGVtZW50cyAoI3tgYXJndltpXS5sZW5ndGhgfSBmb3IgMS4uMilcIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ2MgJSAyICE9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ29kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoJ31cbiAgICAgIH1cblxuICAgICAgaGFzaCA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnYzsgaSArPSAyKSB7XG4gICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV0sIGFyZ3ZbaSArIDFdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5hbGxvY2F0ZVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKCk7XG5cbiAgICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuXG4gICAgICBoYXNoLiQkbm9uZSA9IG5pbDtcbiAgICAgIGhhc2guJCRwcm9jID0gbmlsO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iailcbiAgICBPcGFsLmNvZXJjZV90bz8ob2JqLCBIYXNoLCA6dG9faGFzaClcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoZGVmYXVsdHMgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChkZWZhdWx0cyAhPT0gdW5kZWZpbmVkICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMSBmb3IgMCknfVxuICAgICAgfVxuICAgICAgc2VsZi4kJG5vbmUgPSAoZGVmYXVsdHMgPT09IHVuZGVmaW5lZCA/IG5pbCA6IGRlZmF1bHRzKTtcbiAgICAgIHNlbGYuJCRwcm9jID0gYmxvY2s7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW90aGVyLiQkaXNfaGFzaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggIT09IG90aGVyLiQka2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBvdGhlci4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBvdGhlcl92YWx1ZSA9IE9wYWwuaGFzaF9nZXQob3RoZXIsIGtleS5rZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG90aGVyX3ZhbHVlID09PSB1bmRlZmluZWQgfHwgIXZhbHVlWyckZXFsPyddKG90aGVyX3ZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA+PShvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggPCBvdGhlci4kJGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdCA9IHRydWVcblxuICAgIG90aGVyLmVhY2ggZG8gfG90aGVyX2tleSwgb3RoZXJfdmFsfFxuICAgICAgdmFsID0gZmV0Y2gob3RoZXJfa2V5LCBgbnVsbGApXG5cbiAgICAgICV4e1xuICAgICAgICBpZiAodmFsID09IG51bGwgfHwgdmFsICE9PSBvdGhlcl92YWwpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggPD0gb3RoZXIuJCRrZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmID49IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8KG90aGVyKVxuICAgIG90aGVyID0gT3BhbC5jb2VyY2VfdG8hKG90aGVyLCBIYXNoLCA6dG9faGFzaClcbiAgICBvdGhlciA+IHNlbGZcbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIG90aGVyID0gT3BhbC5jb2VyY2VfdG8hKG90aGVyLCBIYXNoLCA6dG9faGFzaClcbiAgICBvdGhlciA+PSBzZWxmXG4gIGVuZFxuXG4gIGRlZiBbXShrZXkpXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJGRlZmF1bHQoa2V5KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0oa2V5LCB2YWx1ZSlcbiAgICAleHtcbiAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXNzb2Mob2JqZWN0KVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIGlmICgje2BrZXlgID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBba2V5LCBzZWxmLiQkc21hcFtrZXldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCN7YGtleS5rZXlgID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBba2V5LmtleSwga2V5LnZhbHVlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbGVhclxuICAgICV4e1xuICAgICAgT3BhbC5oYXNoX2luaXQoc2VsZik7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbG9uZVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBuZXcgc2VsZi4kJGNsYXNzKCk7XG5cbiAgICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuICAgICAgT3BhbC5oYXNoX2Nsb25lKHNlbGYsIGhhc2gpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0XG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9IE9wYWwuaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgIT09IG5pbCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFjdCFcbiAgICAleHtcbiAgICAgIHZhciBjaGFuZ2VzX3dlcmVfbWFkZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbmdlc193ZXJlX21hZGUgPSB0cnVlO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2VzX3dlcmVfbWFkZSA/IHNlbGYgOiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFyZV9ieV9pZGVudGl0eVxuICAgICV4e1xuICAgICAgdmFyIGksIGlpLCBrZXksIGtleXMgPSBzZWxmLiQka2V5cywgaWRlbnRpdHlfaGFzaDtcblxuICAgICAgaWYgKHNlbGYuJCRieV9pZGVudGl0eSkgcmV0dXJuIHNlbGY7XG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlbGYuJCRieV9pZGVudGl0eSA9IHRydWVcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGlkZW50aXR5X2hhc2ggPSAjeyB7fS5jb21wYXJlX2J5X2lkZW50aXR5IH07XG4gICAgICBmb3IoaSA9IDAsIGlpID0ga2V5cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICgha2V5LiQkaXNfc3RyaW5nKSBrZXkgPSBrZXkua2V5O1xuICAgICAgICBPcGFsLmhhc2hfcHV0KGlkZW50aXR5X2hhc2gsIGtleSwgT3BhbC5oYXNoX2dldChzZWxmLCBrZXkpKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kJGJ5X2lkZW50aXR5ID0gdHJ1ZTtcbiAgICAgIHNlbGYuJCRtYXAgPSBpZGVudGl0eV9oYXNoLiQkbWFwO1xuICAgICAgc2VsZi4kJHNtYXAgPSBpZGVudGl0eV9oYXNoLiQkc21hcDtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhcmVfYnlfaWRlbnRpdHk/XG4gICAgYHNlbGYuJCRieV9pZGVudGl0eSA9PT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmIGRlZmF1bHQoa2V5ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkICYmIHNlbGYuJCRwcm9jICE9PSBuaWwgJiYgc2VsZi4kJHByb2MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJHByb2MuJGNhbGwoc2VsZiwga2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLiQkbm9uZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJG5vbmU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdD0ob2JqZWN0KVxuICAgICV4e1xuICAgICAgc2VsZi4kJHByb2MgPSBuaWw7XG4gICAgICBzZWxmLiQkbm9uZSA9IG9iamVjdDtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWZhdWx0X3Byb2NcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkcHJvYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkcHJvYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdF9wcm9jPShkZWZhdWx0X3Byb2MpXG4gICAgJXh7XG4gICAgICB2YXIgcHJvYyA9IGRlZmF1bHRfcHJvYztcblxuICAgICAgaWYgKHByb2MgIT09IG5pbCkge1xuICAgICAgICBwcm9jID0gI3tPcGFsLmNvZXJjZV90byEoYHByb2NgLCBQcm9jLCA6dG9fcHJvYyl9O1xuXG4gICAgICAgIGlmICgje2Bwcm9jYC5sYW1iZGE/fSAmJiAje2Bwcm9jYC5hcml0eS5hYnN9ICE9PSAyKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdkZWZhdWx0X3Byb2MgdGFrZXMgdHdvIGFyZ3VtZW50cyd9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJCRub25lID0gbmlsO1xuICAgICAgc2VsZi4kJHByb2MgPSBwcm9jO1xuXG4gICAgICByZXR1cm4gZGVmYXVsdF9wcm9jO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShrZXksICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9IE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3t5aWVsZCBrZXl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9pZigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpkZWxldGVfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZHVwIGNsb25lXG5cbiAgZGVmIGRpZyhrZXksICprZXlzKVxuICAgIGl0ZW0gPSBzZWxmW2tleV1cblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqa2V5cylcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9rZXkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9rZXkpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBibG9jayhrZXkuJCRpc19zdHJpbmcgPyBrZXkgOiBrZXkua2V5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBlYWNoX3BhaXIgZWFjaFxuXG4gIGRlZiBlYWNoX3ZhbHVlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfdmFsdWUpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBibG9jayhrZXkuJCRpc19zdHJpbmcgPyBzZWxmLiQkc21hcFtrZXldIDoga2V5LnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYuJCRrZXlzLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuXG4gIGRlZiBleGNlcHQoKmtleXMpXG4gICAgZHVwLmV4Y2VwdCEoKmtleXMpXG4gIGVuZFxuXG4gIGRlZiBleGNlcHQhKCprZXlzKVxuICAgIGtleXMuZWFjaCB7IHxrZXl8IGRlbGV0ZShrZXkpIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmZXRjaChrZXksIGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrKGtleSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByYWlzZSBLZXlFcnJvci5uZXcoXCJrZXkgbm90IGZvdW5kOiAje2tleS5pbnNwZWN0fVwiLCBrZXk6IGtleSwgcmVjZWl2ZXI6IHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBmZXRjaF92YWx1ZXMoKmtleXMsICZibG9jaylcbiAgICBrZXlzLm1hcCB7IHxrZXl8IGZldGNoKGtleSwgJmJsb2NrKSB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuKGxldmVsID0gMSlcbiAgICBsZXZlbCA9IE9wYWwuY29lcmNlX3RvIShsZXZlbCwgSW50ZWdlciwgOnRvX2ludClcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcblxuICAgICAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgICAgIGlmIChsZXZlbCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCgje2B2YWx1ZWAuZmxhdHRlbihgbGV2ZWwgLSAyYCl9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBoYXNfa2V5PyhrZXkpXG4gICAgYE9wYWwuaGFzaF9nZXQoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkYFxuICBlbmRcblxuICBkZWYgaGFzX3ZhbHVlPyh2YWx1ZSlcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmICgje2Aoa2V5LiQkaXNfc3RyaW5nID8gc2VsZi4kJHNtYXBba2V5XSA6IGtleS52YWx1ZSlgID09IHZhbHVlfSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgJXh7XG4gICAgICB2YXIgdG9wID0gKE9wYWwuaGFzaF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIHJlc3VsdCA9IFsnSGFzaCddLFxuICAgICAgICAgIGtleSwgaXRlbTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9pZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9wYWxbaGFzaF9pZF0pIHtcbiAgICAgICAgICByZXR1cm4gJ3NlbGYnO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gT3BhbC5oYXNoX2lkcykge1xuICAgICAgICAgIGl0ZW0gPSBPcGFsLmhhc2hfaWRzW2tleV07XG4gICAgICAgICAgaWYgKCN7ZXFsPyhgaXRlbWApfSkge1xuICAgICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLmhhc2hfaWRzW2hhc2hfaWRdID0gc2VsZjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHNlbGYuJCRzbWFwW2tleV0uJGhhc2goKV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChba2V5LmtleV9oYXNoLCBrZXkudmFsdWUuJGhhc2goKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuc29ydCgpLmpvaW4oKTtcblxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluY2x1ZGU/IGhhc19rZXk/XG5cbiAgZGVmIGluZGV4KG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5kZXhlcygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gYXJnc1tpXTtcbiAgICAgICAgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgje2RlZmF1bHR9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluZGljZXMgaW5kZXhlc1xuXG4gIGB2YXIgaW5zcGVjdF9pZHNgXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciB0b3AgPSAoaW5zcGVjdF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgaW5zcGVjdF9pZHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnNwZWN0X2lkcy5oYXNPd25Qcm9wZXJ0eShoYXNoX2lkKSkge1xuICAgICAgICAgIHJldHVybiAney4uLn0nO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zcGVjdF9pZHNbaGFzaF9pZF0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5LiRpbnNwZWN0KCkgKyAnPT4nICsgdmFsdWUuJGluc3BlY3QoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ3snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnfSc7XG5cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBpbnNwZWN0X2lkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGludmVydFxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwgdmFsdWUsIGtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGtlZXBfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6a2VlcF9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbmlsKSB7XG4gICAgICAgICAgaWYgKE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBrZXkgaW5kZXhcblxuICBhbGlhcyBrZXk/IGhhc19rZXk/XG5cbiAgZGVmIGtleXNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5LmtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgc2VsZi4kJGtleXMubGVuZ3RoYFxuICBlbmRcblxuICBhbGlhcyBtZW1iZXI/IGhhc19rZXk/XG5cbiAgZGVmIG1lcmdlKCpvdGhlcnMsICZibG9jaylcbiAgICBkdXAubWVyZ2UhKCpvdGhlcnMsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIG1lcmdlISgqb3RoZXJzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaSwgaiwgb3RoZXIsIG90aGVyX2tleXMsIGxlbmd0aCwga2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgb3RoZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG90aGVyID0gI3tPcGFsLmNvZXJjZV90byEoYG90aGVyc1tpXWAsIEhhc2gsIDp0b19oYXNoKX07XG4gICAgICAgIG90aGVyX2tleXMgPSBvdGhlci4kJGtleXMsIGxlbmd0aCA9IG90aGVyX2tleXMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBrZXkgPSBvdGhlcl9rZXlzW2pdO1xuXG4gICAgICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdGhlcl92YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT3BhbC5oYXNoX3B1dChzZWxmLCBrZXksIG90aGVyX3ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBrZXkgPSBvdGhlcl9rZXlzW2pdO1xuXG4gICAgICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdGhlcl92YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCBvdGhlcl92YWx1ZSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPcGFsLmhhc2hfcHV0KHNlbGYsIGtleSwgYmxvY2soa2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVoYXNoXG4gICAgJXh7XG4gICAgICBPcGFsLmhhc2hfcmVoYXNoKHNlbGYpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbmlsKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgY2hhbmdlc193ZXJlX21hZGUgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gZmFsc2UgJiYgb2JqICE9PSBuaWwpIHtcbiAgICAgICAgICBpZiAoT3BhbC5oYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXNfd2VyZV9tYWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhbmdlc193ZXJlX21hZGUgPyBzZWxmIDogbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlcGxhY2Uob3RoZXIpXG4gICAgb3RoZXIgPSBPcGFsLmNvZXJjZV90byEob3RoZXIsIEhhc2gsIDp0b19oYXNoKVxuXG4gICAgJXh7XG4gICAgICBPcGFsLmhhc2hfaW5pdChzZWxmKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG90aGVyX2tleXMgPSBvdGhlci4kJGtleXMsIGxlbmd0aCA9IG90aGVyX2tleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvdGhlcl92YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IG90aGVyX2tleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCBvdGhlcl92YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgb3RoZXIuZGVmYXVsdF9wcm9jXG4gICAgICBzZWxmLmRlZmF1bHRfcHJvYyA9IG90aGVyLmRlZmF1bHRfcHJvY1xuICAgIGVsc2VcbiAgICAgIHNlbGYuZGVmYXVsdCA9IG90aGVyLmRlZmF1bHRcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9IE9wYWwuaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG5pbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSBuaWwpIHtcbiAgICAgICAgICBpZiAoT3BhbC5oYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBzZWxmO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBmaWx0ZXIgc2VsZWN0XG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxuXG4gIGRlZiBzaGlmdFxuICAgICV4e1xuICAgICAgdmFyIGtleXMgPSBzZWxmLiQka2V5cyxcbiAgICAgICAgICBrZXk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAga2V5ID0ga2V5c1swXTtcblxuICAgICAgICBrZXkgPSBrZXkuJCRpc19zdHJpbmcgPyBrZXkgOiBrZXkua2V5O1xuXG4gICAgICAgIHJldHVybiBba2V5LCBPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kZGVmYXVsdChuaWwpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcblxuICBkZWYgc2xpY2UoKmtleXMpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldLCB2YWx1ZSA9IE9wYWwuaGFzaF9nZXQoc2VsZiwga2V5KTtcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3RvcmUgW109XG5cbiAgZGVmIHRvX2FcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9faCgmYmxvY2spXG4gICAgcmV0dXJuIG1hcCgmYmxvY2spLnRvX2ggaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkY2xhc3MgPT09IE9wYWwuSGFzaCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc2ggPSBuZXcgT3BhbC5IYXNoKCk7XG5cbiAgICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuICAgICAgT3BhbC5oYXNoX2Nsb25lKHNlbGYsIGhhc2gpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19oYXNoXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIHByb2MgZG8gfGtleSA9IHVuZGVmaW5lZHxcbiAgICAgICV4e1xuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBrZXkgZ2l2ZW4nfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGZba2V5XVxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyB0b19zIGluc3BlY3RcblxuICBkZWYgdHJhbnNmb3JtX2tleXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX2tleXMpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSBPcGFsLnlpZWxkMShibG9jaywga2V5KTtcblxuICAgICAgICBPcGFsLmhhc2hfcHV0KHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJhbnNmb3JtX2tleXMhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV9rZXlzISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBrZXlzID0gT3BhbC5zbGljZS5jYWxsKHNlbGYuJCRrZXlzKSxcbiAgICAgICAgICBpLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgbmV3X2tleTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3X2tleSA9IE9wYWwueWllbGQxKGJsb2NrLCBrZXkpO1xuXG4gICAgICAgIE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KTtcbiAgICAgICAgT3BhbC5oYXNoX3B1dChzZWxmLCBuZXdfa2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV92YWx1ZXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX3ZhbHVlcykgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHZhbHVlKTtcblxuICAgICAgICBPcGFsLmhhc2hfcHV0KHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJhbnNmb3JtX3ZhbHVlcyEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX3ZhbHVlcyEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgdXBkYXRlIG1lcmdlIVxuXG4gIGFsaWFzIHZhbHVlPyBoYXNfdmFsdWU/XG5cbiAgYWxpYXMgdmFsdWVzX2F0IGluZGV4ZXNcblxuICBkZWYgdmFsdWVzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzZWxmLiQkc21hcFtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsImluY2x1ZGUiLCJbXSIsInNlbGYiLCJjb2VyY2VfdG8/IiwiYXJndiIsIjAiLCJhbGxvY2F0ZSIsIm1lcmdlISIsInJhaXNlIiwidHJ5X2NvbnZlcnQiLCJvYmoiLCJpbml0aWFsaXplIiwiPT0iLCI+PSIsIm90aGVyIiwiY29lcmNlX3RvISIsInJlc3VsdCIsImVhY2giLCJ2YWwiLCJmZXRjaCIsIm90aGVyX2tleSIsIj4iLCI8IiwiPD0iLCJbXT0iLCJhc3NvYyIsIm9iamVjdCIsImNsZWFyIiwiY2xvbmUiLCJjb21wYWN0IiwiY29tcGFjdCEiLCJjb21wYXJlX2J5X2lkZW50aXR5IiwiY29tcGFyZV9ieV9pZGVudGl0eT8iLCJkZWZhdWx0IiwiZGVmYXVsdD0iLCJkZWZhdWx0X3Byb2MiLCJkZWZhdWx0X3Byb2M9IiwibGFtYmRhPyIsImFyaXR5IiwiYWJzIiwiZGVsZXRlIiwia2V5IiwiZGVsZXRlX2lmIiwiYmxvY2siLCJlbnVtX2ZvciIsInNpemUiLCJkaWciLCJpdGVtIiwicmVzcG9uZF90bz8iLCJrZXlzIiwiZWFjaF9rZXkiLCJlYWNoX3ZhbHVlIiwiZW1wdHk/IiwiZXhjZXB0IiwiZXhjZXB0ISIsImR1cCIsIm5ldyIsImluc3BlY3QiLCJmZXRjaF92YWx1ZXMiLCJtYXAiLCJmbGF0dGVuIiwiMSIsImxldmVsIiwiaGFzX2tleT8iLCJoYXNfdmFsdWU/IiwidmFsdWUiLCJoYXNoIiwiZXFsPyIsImluZGV4IiwiaW5kZXhlcyIsImludmVydCIsImtlZXBfaWYiLCJsZW5ndGgiLCJtZXJnZSIsIm90aGVycyIsInJhc3NvYyIsInJlaGFzaCIsInJlamVjdCIsInJlamVjdCEiLCJyZXBsYWNlIiwiJHdyaXRlciIsIi0iLCJzZWxlY3QiLCJzZWxlY3QhIiwic2hpZnQiLCJzbGljZSIsInRvX2EiLCJ0b19oIiwiYmxvY2tfZ2l2ZW4/IiwidG9faGFzaCIsInRvX3Byb2MiLCJwcm9jIiwidHJhbnNmb3JtX2tleXMiLCJ0cmFuc2Zvcm1fa2V5cyEiLCJ0cmFuc2Zvcm1fdmFsdWVzIiwidHJhbnNmb3JtX3ZhbHVlcyEiLCJ2YWx1ZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsb0JBQVJBLENBQUE7QUFBQSxFQVVBLE9BQUFDO0FBQUFBLEVBQUFB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QUFBLENBdm9DQTtBQUFBLElBOHBDQSxpQkFBTSxRQUFOLEVBQWEsUUFBYixDQTlwQ0E7QUFBQSxJQWdxQ0EsaUJBQU0sUUFBTixFQUFhLFlBQWIsQ0FocUNBO0FBQUEsSUFrcUNBLGlCQUFNLFdBQU4sRUFBZ0IsU0FBaEIsQ0FscUNBO0FBQUEsSUFvcUNBLE9BQUFDLENBQUFBLDBCQUFBQSxrQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFmRUEsSUFBQUEsQ0FBQUEsNkJBQUFBLENBQUFBLGtCQXBxQ0E7QUFERmpHLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBVkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNjc1MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbnVtYmVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvbnVtZXJpYydcblxuY2xhc3MgTnVtYmVyIDwgTnVtZXJpY1xuICBPcGFsLmJyaWRnZShgTnVtYmVyYCwgc2VsZilcbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfbnVtYmVyJywgdHJ1ZSlgXG4gIGBzZWxmLiQkaXNfbnVtYmVyX2NsYXNzID0gdHJ1ZWBcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG4gIGVuZFxuXG4gIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIgPT09IG5pbCkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7b3RoZXIuY2xhc3N9IGludG8gRmxvYXRcIn07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvdGhlci4kJGlzX3N0cmluZykge1xuICAgICAgICByZXR1cm4gWyN7RmxvYXQob3RoZXIpfSwgc2VsZl07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgje290aGVyLnJlc3BvbmRfdG8/KDp0b19mKX0pIHtcbiAgICAgICAgcmV0dXJuIFsje09wYWwuY29lcmNlX3RvIShvdGhlciwgRmxvYXQsIDp0b19mKX0sIHNlbGZdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIFtvdGhlciwgc2VsZl07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje290aGVyLmNsYXNzfSBpbnRvIEZsb2F0XCJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIF9faWRfX1xuICAgIGAoc2VsZiAqIDIpICsgMWBcbiAgZW5kXG5cbiAgYWxpYXMgb2JqZWN0X2lkIF9faWRfX1xuXG4gIGRlZiArKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmICsgb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOissIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIC0gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOi0sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAqKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmICogb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOiosIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAvKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIC8gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOi8sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGZkaXYgL1xuXG4gIGRlZiAlKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmIChvdGhlciA9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIgPT0gMCkge1xuICAgICAgICAgICN7cmFpc2UgWmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlciA8IDAgfHwgc2VsZiA8IDApIHtcbiAgICAgICAgICByZXR1cm4gKHNlbGYgJSBvdGhlciArIG90aGVyKSAlIG90aGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZWxmICUgb3RoZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6JSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgJiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Jiwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgfCBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6fCwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIF4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgXiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Xiwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPCBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6PCwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIDw9IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo8PSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmID4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Piwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmID49IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo+PSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgIyBDb21wdXRlIHRoZSByZXN1bHQgb2YgdGhlIHNwYWNlc2hpcCBvcGVyYXRvciBpbnNpZGUgaXRzIG93biBmdW5jdGlvbiBzbyBpdFxuICAjIGNhbiBiZSBvcHRpbWl6ZWQgZGVzcGl0ZSBhIHRyeS9maW5hbGx5IGNvbnN0cnVjdC5cbiAgJXh7XG4gICAgdmFyIHNwYWNlc2hpcF9vcGVyYXRvciA9IGZ1bmN0aW9uKHNlbGYsIG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKGlzTmFOKHNlbGYpIHx8IGlzTmFOKG90aGVyKSkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZiA+IG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZiA8IG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOjw9PiwgYG90aGVyYH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBgc3BhY2VzaGlwX29wZXJhdG9yKHNlbGYsIG90aGVyKWBcbiAgcmVzY3VlIEFyZ3VtZW50RXJyb3JcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIDw8KGNvdW50KVxuICAgIGNvdW50ID0gT3BhbC5jb2VyY2VfdG8hIGNvdW50LCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBgI3tjb3VudH0gPiAwID8gc2VsZiA8PCAje2NvdW50fSA6IHNlbGYgPj4gLSN7Y291bnR9YFxuICBlbmRcblxuICBkZWYgPj4oY291bnQpXG4gICAgY291bnQgPSBPcGFsLmNvZXJjZV90byEgY291bnQsIEludGVnZXIsIDp0b19pbnRcblxuICAgIGAje2NvdW50fSA+IDAgPyBzZWxmID4+ICN7Y291bnR9IDogc2VsZiA8PCAtI3tjb3VudH1gXG4gIGVuZFxuXG4gIGRlZiBbXShiaXQpXG4gICAgYml0ID0gT3BhbC5jb2VyY2VfdG8hIGJpdCwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgJXh7XG4gICAgICBpZiAoI3tiaXR9IDwgMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmICgje2JpdH0gPj0gMzIpIHtcbiAgICAgICAgcmV0dXJuICN7IHNlbGYgfSA8IDAgPyAxIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoc2VsZiA+PiAje2JpdH0pICYgMTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiArQFxuICAgIGArc2VsZmBcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgYC1zZWxmYFxuICBlbmRcblxuICBkZWYgflxuICAgIGB+c2VsZmBcbiAgZW5kXG5cbiAgZGVmICoqKG90aGVyKVxuICAgIGlmIEludGVnZXIgPT09IG90aGVyXG4gICAgICBpZiAhKEludGVnZXIgPT09IHNlbGYpIHx8IG90aGVyID4gMFxuICAgICAgICBgTWF0aC5wb3coc2VsZiwgb3RoZXIpYFxuICAgICAgZWxzZVxuICAgICAgICBSYXRpb25hbC5uZXcoc2VsZiwgMSkqKm90aGVyXG4gICAgICBlbmRcbiAgICBlbHNpZiBzZWxmIDwgMCAmJiAoRmxvYXQgPT09IG90aGVyIHx8IFJhdGlvbmFsID09PSBvdGhlcilcbiAgICAgIENvbXBsZXgubmV3KHNlbGYsIDApKipvdGhlci50b19mXG4gICAgZWxzaWYgYG90aGVyLiQkaXNfbnVtYmVyICE9IG51bGxgXG4gICAgICBgTWF0aC5wb3coc2VsZiwgb3RoZXIpYFxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqKiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZi52YWx1ZU9mKCkgPT09IG90aGVyLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7b3RoZXIucmVzcG9uZF90bz8gOj09fSkge1xuICAgICAgICByZXR1cm4gI3tvdGhlciA9PSBzZWxmfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudmFsdWVPZigpID09PSBvdGhlci52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgje290aGVyLnJlc3BvbmRfdG8/IDo9PX0pIHtcbiAgICAgICAgcmV0dXJuICN7b3RoZXIgPT0gc2VsZn07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFic1xuICAgIGBNYXRoLmFicyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGFiczJcbiAgICBgTWF0aC5hYnMoc2VsZiAqIHNlbGYpYFxuICBlbmRcblxuICBkZWYgYWxsYml0cz8obWFzaylcbiAgICBtYXNrID0gT3BhbC5jb2VyY2VfdG8hIG1hc2ssIEludGVnZXIsIDp0b19pbnRcbiAgICBgKHNlbGYgJiBtYXNrKSA9PSBtYXNrYFxuICBlbmRcblxuICBkZWYgYW55Yml0cz8obWFzaylcbiAgICBtYXNrID0gT3BhbC5jb2VyY2VfdG8hIG1hc2ssIEludGVnZXIsIDp0b19pbnRcbiAgICBgKHNlbGYgJiBtYXNrKSAhPT0gMGBcbiAgZW5kXG5cbiAgZGVmIGFuZ2xlXG4gICAgcmV0dXJuIHNlbGYgaWYgbmFuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSAwKSB7XG4gICAgICAgIGlmICgxIC8gc2VsZiA+IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VsZiA8IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguUEk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBhcmcgYW5nbGVcbiAgYWxpYXMgcGhhc2UgYW5nbGVcblxuICBkZWYgYml0X2xlbmd0aFxuICAgIHVubGVzcyBJbnRlZ2VyID09PSBzZWxmXG4gICAgICByYWlzZSBOb01ldGhvZEVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYGJpdF9sZW5ndGhgIGZvciAje3NlbGZ9OkZsb2F0XCIsICdiaXRfbGVuZ3RoJylcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT09IDAgfHwgc2VsZiA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAwLFxuICAgICAgICAgIHZhbHVlICA9IHNlbGYgPCAwID8gfnNlbGYgOiBzZWxmO1xuXG4gICAgICB3aGlsZSAodmFsdWUgIT0gMCkge1xuICAgICAgICByZXN1bHQgICArPSAxO1xuICAgICAgICB2YWx1ZSAgPj4+PSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNlaWwobmRpZ2l0cyA9IDApXG4gICAgJXh7XG4gICAgICB2YXIgZiA9ICN7dG9fZn07XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCAmJiBuZGlnaXRzID49IDApIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgcmVzdWx0ID0gTWF0aC5jZWlsKGYgKiBmYWN0b3IpIC8gZmFjdG9yO1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNocihlbmNvZGluZyA9IHVuZGVmaW5lZClcbiAgICBgT3BhbC5lbmMoU3RyaW5nLmZyb21DaGFyQ29kZShzZWxmKSwgZW5jb2RpbmcgfHwgXCJCSU5BUllcIilgXG4gIGVuZFxuXG4gIGRlZiBkZW5vbWluYXRvclxuICAgIGlmIG5hbj8gfHwgaW5maW5pdGU/XG4gICAgICAxXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGRvd250byhzdG9wLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpkb3dudG8sIHN0b3ApIGRvXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tzdG9wLmNsYXNzfSBmYWlsZWRcIiB1bmxlc3MgTnVtZXJpYyA9PT0gc3RvcFxuICAgICAgICBzdG9wID4gc2VsZiA/IDAgOiBzZWxmIC0gc3RvcCArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoIXN0b3AuJCRpc19udW1iZXIpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCJ9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gc2VsZjsgaSA+PSBzdG9wOyBpLS0pIHtcbiAgICAgICAgYmxvY2soaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIGVxdWFsPyhvdGhlcilcbiAgICBzZWxmID09IG90aGVyIHx8IGBpc05hTihzZWxmKSAmJiBpc05hTihvdGhlcilgXG4gIGVuZFxuXG4gIGRlZiBldmVuP1xuICAgIGBzZWxmICUgMiA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGZsb29yKG5kaWdpdHMgPSAwKVxuICAgICV4e1xuICAgICAgdmFyIGYgPSAje3RvX2Z9O1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDAgJiYgbmRpZ2l0cyA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxuICAgICAgICAgIHJlc3VsdCA9IE1hdGguZmxvb3IoZiAqIGZhY3RvcikgLyBmYWN0b3I7XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBNYXRoLnJvdW5kKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2NkKG90aGVyKVxuICAgIHVubGVzcyBJbnRlZ2VyID09PSBvdGhlclxuICAgICAgcmFpc2UgVHlwZUVycm9yLCAnbm90IGFuIGludGVnZXInXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBtaW4gPSBNYXRoLmFicyhzZWxmKSxcbiAgICAgICAgICBtYXggPSBNYXRoLmFicyhvdGhlcik7XG5cbiAgICAgIHdoaWxlIChtaW4gPiAwKSB7XG4gICAgICAgIHZhciB0bXAgPSBtaW47XG5cbiAgICAgICAgbWluID0gbWF4ICUgbWluO1xuICAgICAgICBtYXggPSB0bXA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2NkbGNtKG90aGVyKVxuICAgIFtnY2Qob3RoZXIpLCBsY20ob3RoZXIpXVxuICBlbmRcblxuICBkZWYgaW50ZWdlcj9cbiAgICBgc2VsZiAlIDEgPT09IDBgXG4gIGVuZFxuXG4gIGRlZiBpc19hPyhrbGFzcylcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSBJbnRlZ2VyICYmIEludGVnZXIgPT09IHNlbGZcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSBJbnRlZ2VyICYmIEludGVnZXIgPT09IHNlbGZcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSBGbG9hdCAmJiBGbG9hdCA9PT0gc2VsZlxuXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgYWxpYXMga2luZF9vZj8gaXNfYT9cblxuICBkZWYgaW5zdGFuY2Vfb2Y/KGtsYXNzKVxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IEludGVnZXIgJiYgSW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IEludGVnZXIgJiYgSW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IEZsb2F0ICYmIEZsb2F0ID09PSBzZWxmXG5cbiAgICBzdXBlclxuICBlbmRcblxuICBkZWYgbGNtKG90aGVyKVxuICAgIHVubGVzcyBJbnRlZ2VyID09PSBvdGhlclxuICAgICAgcmFpc2UgVHlwZUVycm9yLCAnbm90IGFuIGludGVnZXInXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IDAgfHwgb3RoZXIgPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoc2VsZiAqIG90aGVyIC8gI3tnY2Qob3RoZXIpfSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBtYWduaXR1ZGUgYWJzXG5cbiAgYWxpYXMgbW9kdWxvICVcblxuICBkZWYgbmV4dFxuICAgIGBzZWxmICsgMWBcbiAgZW5kXG5cbiAgZGVmIG5vYml0cz8obWFzaylcbiAgICBtYXNrID0gT3BhbC5jb2VyY2VfdG8hIG1hc2ssIEludGVnZXIsIDp0b19pbnRcbiAgICBgKHNlbGYgJiBtYXNrKSA9PSAwYFxuICBlbmRcblxuICBkZWYgbm9uemVybz9cbiAgICBgc2VsZiA9PSAwID8gbmlsIDogc2VsZmBcbiAgZW5kXG5cbiAgZGVmIG51bWVyYXRvclxuICAgIGlmIG5hbj8gfHwgaW5maW5pdGU/XG4gICAgICBzZWxmXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIG9kZD9cbiAgICBgc2VsZiAlIDIgIT09IDBgXG4gIGVuZFxuXG4gIGRlZiBvcmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwb3coYiwgbSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IDApIHtcbiAgICAgICAgI3tyYWlzZSBaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCd9XG4gICAgICB9XG5cbiAgICAgIGlmIChtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICN7c2VsZioqYn07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoISgje0ludGVnZXIgPT09IGJ9KSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnSW50ZWdlciNwb3coKSAybmQgYXJndW1lbnQgbm90IGFsbG93ZWQgdW5sZXNzIGEgMXN0IGFyZ3VtZW50IGlzIGludGVnZXInfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGIgPCAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdJbnRlZ2VyI3BvdygpIDFzdCBhcmd1bWVudCBjYW5ub3QgYmUgbmVnYXRpdmUgd2hlbiAybmQgYXJndW1lbnQgc3BlY2lmaWVkJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKCN7SW50ZWdlciA9PT0gbX0pKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdJbnRlZ2VyI3BvdygpIDJuZCBhcmd1bWVudCBub3QgYWxsb3dlZCB1bmxlc3MgYWxsIGFyZ3VtZW50cyBhcmUgaW50ZWdlcnMnfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG0gPT09IDApIHtcbiAgICAgICAgICAje3JhaXNlIFplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAjeyhzZWxmKipiKSAlIG19XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHJlZFxuICAgIGBzZWxmIC0gMWBcbiAgZW5kXG5cbiAgZGVmIHF1byhvdGhlcilcbiAgICBpZiBJbnRlZ2VyID09PSBzZWxmXG4gICAgICBzdXBlclxuICAgIGVsc2VcbiAgICAgIHNlbGYgLyBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmF0aW9uYWxpemUoZXBzID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjEpXCJ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIEludGVnZXIgPT09IHNlbGZcbiAgICAgIFJhdGlvbmFsLm5ldyhzZWxmLCAxKVxuICAgIGVsc2lmIGluZmluaXRlP1xuICAgICAgcmFpc2UgRmxvYXREb21haW5FcnJvciwgJ0luZmluaXR5J1xuICAgIGVsc2lmIG5hbj9cbiAgICAgIHJhaXNlIEZsb2F0RG9tYWluRXJyb3IsICdOYU4nXG4gICAgZWxzaWYgYGVwcyA9PSBudWxsYFxuICAgICAgZiwgbiAgPSBNYXRoLmZyZXhwIHNlbGZcbiAgICAgIGYgICAgID0gTWF0aC5sZGV4cChmLCBGbG9hdDo6TUFOVF9ESUcpLnRvX2lcbiAgICAgIG4gICAgLT0gRmxvYXQ6Ok1BTlRfRElHXG5cbiAgICAgIFJhdGlvbmFsLm5ldygyICogZiwgMSA8PCAoMSAtIG4pKS5yYXRpb25hbGl6ZShSYXRpb25hbC5uZXcoMSwgMSA8PCAoMSAtIG4pKSlcbiAgICBlbHNlXG4gICAgICB0b19yLnJhdGlvbmFsaXplKGVwcylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJlbWFpbmRlcih5KVxuICAgIHNlbGYgLSB5ICogKHNlbGYgLyB5KS50cnVuY2F0ZVxuICBlbmRcblxuICBkZWYgcm91bmQobmRpZ2l0cyA9IHVuZGVmaW5lZClcbiAgICBpZiBJbnRlZ2VyID09PSBzZWxmXG4gICAgICBpZiBgbmRpZ2l0cyA9PSBudWxsYFxuICAgICAgICByZXR1cm4gc2VsZlxuICAgICAgZW5kXG5cbiAgICAgIGlmIEZsb2F0ID09PSBuZGlnaXRzICYmIG5kaWdpdHMuaW5maW5pdGU/XG4gICAgICAgIHJhaXNlIFJhbmdlRXJyb3IsICdJbmZpbml0eSdcbiAgICAgIGVuZFxuXG4gICAgICBuZGlnaXRzID0gT3BhbC5jb2VyY2VfdG8hKG5kaWdpdHMsIEludGVnZXIsIDp0b19pbnQpXG5cbiAgICAgIGlmIG5kaWdpdHMgPCBJbnRlZ2VyOjpNSU5cbiAgICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ291dCBvZiBib3VuZHMnXG4gICAgICBlbmRcblxuICAgICAgaWYgYG5kaWdpdHMgPj0gMGBcbiAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBuZGlnaXRzID0gLW5kaWdpdHNcblxuICAgICAgJXh7XG4gICAgICAgIGlmICgwLjQxNTI0MSAqIG5kaWdpdHMgLSAwLjEyNSA+ICN7c2l6ZX0pIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxuICAgICAgICAgICAgeCA9IE1hdGguZmxvb3IoKE1hdGguYWJzKHNlbGYpICsgZiAvIDIpIC8gZikgKiBmO1xuXG4gICAgICAgIHJldHVybiBzZWxmIDwgMCA/IC14IDogeDtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBpZiBuYW4/ICYmIGBuZGlnaXRzID09IG51bGxgXG4gICAgICAgIHJhaXNlIEZsb2F0RG9tYWluRXJyb3IsICdOYU4nXG4gICAgICBlbmRcblxuICAgICAgbmRpZ2l0cyA9IE9wYWwuY29lcmNlX3RvIShgbmRpZ2l0cyB8fCAwYCwgSW50ZWdlciwgOnRvX2ludClcblxuICAgICAgaWYgbmRpZ2l0cyA8PSAwXG4gICAgICAgIGlmIG5hbj9cbiAgICAgICAgICByYWlzZSBSYW5nZUVycm9yLCAnTmFOJ1xuICAgICAgICBlbHNpZiBpbmZpbml0ZT9cbiAgICAgICAgICByYWlzZSBGbG9hdERvbWFpbkVycm9yLCAnSW5maW5pdHknXG4gICAgICAgIGVuZFxuICAgICAgZWxzaWYgbmRpZ2l0cyA9PSAwXG4gICAgICAgIHJldHVybiBgTWF0aC5yb3VuZChzZWxmKWBcbiAgICAgIGVsc2lmIG5hbj8gfHwgaW5maW5pdGU/XG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgXywgZXhwID0gTWF0aC5mcmV4cChzZWxmKVxuXG4gICAgICBpZiBuZGlnaXRzID49IChGbG9hdDo6RElHICsgMikgLSAoZXhwID4gMCA/IGV4cCAvIDQgOiBleHAgLyAzIC0gMSlcbiAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBpZiBuZGlnaXRzIDwgLShleHAgPiAwID8gZXhwIC8gMyArIDEgOiBleHAgLyA0KVxuICAgICAgICByZXR1cm4gMFxuICAgICAgZW5kXG5cbiAgICAgIGBNYXRoLnJvdW5kKHNlbGYgKiBNYXRoLnBvdygxMCwgbmRpZ2l0cykpIC8gTWF0aC5wb3coMTAsIG5kaWdpdHMpYFxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBzdWNjIG5leHRcblxuICBkZWYgdGltZXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dGltZXMpIHsgc2VsZiB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGY7IGkrKykge1xuICAgICAgICBibG9jayhpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIGBzZWxmIDwgMCA/IE1hdGguY2VpbChzZWxmKSA6IE1hdGguZmxvb3Ioc2VsZilgXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2ludCB0b19pXG5cbiAgZGVmIHRvX3JcbiAgICBpZiBJbnRlZ2VyID09PSBzZWxmXG4gICAgICBSYXRpb25hbC5uZXcoc2VsZiwgMSlcbiAgICBlbHNlXG4gICAgICBmLCBlICA9IE1hdGguZnJleHAoc2VsZilcbiAgICAgIGYgICAgID0gTWF0aC5sZGV4cChmLCBGbG9hdDo6TUFOVF9ESUcpLnRvX2lcbiAgICAgIGUgICAgLT0gRmxvYXQ6Ok1BTlRfRElHXG5cbiAgICAgIChmICogKEZsb2F0OjpSQURJWCoqZSkpLnRvX3JcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX3MoYmFzZSA9IDEwKVxuICAgIGJhc2UgPSBPcGFsLmNvZXJjZV90byEgYmFzZSwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYmFzZSA8IDIgfHwgYmFzZSA+IDM2XG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwiXG4gICAgZW5kXG5cbiAgICBgc2VsZi50b1N0cmluZyhiYXNlKWBcbiAgZW5kXG5cbiAgZGVmIHRydW5jYXRlKG5kaWdpdHMgPSAwKVxuICAgICV4e1xuICAgICAgdmFyIGYgPSAje3RvX2Z9O1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDAgJiYgbmRpZ2l0cyA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxuICAgICAgICAgIHJlc3VsdCA9IHBhcnNlSW50KGYgKiBmYWN0b3IsIDEwKSAvIGZhY3RvcjtcblxuICAgICAgaWYgKGYgJSAxID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IE1hdGgucm91bmQocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluc3BlY3QgdG9fc1xuXG4gIGRlZiBkaWdpdHMoYmFzZSA9IDEwKVxuICAgIGlmIHNlbGYgPCAwXG4gICAgICByYWlzZSBNYXRoOjpEb21haW5FcnJvciwgJ291dCBvZiBkb21haW4nXG4gICAgZW5kXG5cbiAgICBiYXNlID0gT3BhbC5jb2VyY2VfdG8hIGJhc2UsIEludGVnZXIsIDp0b19pbnRcblxuICAgIGlmIGJhc2UgPCAyXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwiXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9IHNlbGYsIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAodmFsdWUgIT09IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUgJSBiYXNlKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSAvIGJhc2UsIDEwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkaXZtb2Qob3RoZXIpXG4gICAgaWYgbmFuPyB8fCBvdGhlci5uYW4/XG4gICAgICByYWlzZSBGbG9hdERvbWFpbkVycm9yLCAnTmFOJ1xuICAgIGVsc2lmIGluZmluaXRlP1xuICAgICAgcmFpc2UgRmxvYXREb21haW5FcnJvciwgJ0luZmluaXR5J1xuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB1cHRvKHN0b3AsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnVwdG8sIHN0b3ApIGRvXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tzdG9wLmNsYXNzfSBmYWlsZWRcIiB1bmxlc3MgTnVtZXJpYyA9PT0gc3RvcFxuICAgICAgICBzdG9wIDwgc2VsZiA/IDAgOiBzdG9wIC0gc2VsZiArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoIXN0b3AuJCRpc19udW1iZXIpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCJ9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gc2VsZjsgaSA8PSBzdG9wOyBpKyspIHtcbiAgICAgICAgYmxvY2soaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgemVybz9cbiAgICBgc2VsZiA9PSAwYFxuICBlbmRcblxuICAjIFNpbmNlIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcmUgMzIgYml0LCBkZWNsYXJlIGl0IHRvIGJlIHNvLlxuICBkZWYgc2l6ZVxuICAgIDRcbiAgZW5kXG5cbiAgZGVmIG5hbj9cbiAgICBgaXNOYU4oc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBmaW5pdGU/XG4gICAgYHNlbGYgIT0gSW5maW5pdHkgJiYgc2VsZiAhPSAtSW5maW5pdHkgJiYgIWlzTmFOKHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5maW5pdGU/XG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gKzE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmID09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwb3NpdGl2ZT9cbiAgICBgc2VsZiAhPSAwICYmIChzZWxmID09IEluZmluaXR5IHx8IDEgLyBzZWxmID4gMClgXG4gIGVuZFxuXG4gIGRlZiBuZWdhdGl2ZT9cbiAgICBgc2VsZiA9PSAtSW5maW5pdHkgfHwgMSAvIHNlbGYgPCAwYFxuICBlbmRcbmVuZFxuXG5GaXhudW0gPSBOdW1iZXJcblxuY2xhc3MgSW50ZWdlciA8IE51bWVyaWNcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxuICBgc2VsZi4kJGlzX2ludGVnZXJfY2xhc3MgPSB0cnVlYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcblxuICAgIGRlZiBzcXJ0KG4pXG4gICAgICBuID0gT3BhbC5jb2VyY2VfdG8hKG4sIEludGVnZXIsIDp0b19pbnQpXG4gICAgICAleHtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBNYXRoOjpEb21haW5FcnJvciwgJ051bWVyaWNhbCBhcmd1bWVudCBpcyBvdXQgb2YgZG9tYWluIC0gXCJpc3FydFwiJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUludChNYXRoLnNxcnQobiksIDEwKTtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgTUFYID0gYE1hdGgucG93KDIsIDMwKSAtIDFgXG4gIE1JTiA9IGAtTWF0aC5wb3coMiwgMzApYFxuZW5kXG5cbmNsYXNzIEZsb2F0IDwgTnVtZXJpY1xuICBgc2VsZi4kJGlzX251bWJlcl9jbGFzcyA9IHRydWVgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuXG4gICAgZGVmID09PShvdGhlcilcbiAgICAgIGAhIW90aGVyLiQkaXNfbnVtYmVyYFxuICAgIGVuZFxuICBlbmRcblxuICBJTkZJTklUWSA9IGBJbmZpbml0eWBcbiAgTUFYICAgICAgPSBgTnVtYmVyLk1BWF9WQUxVRWBcbiAgTUlOICAgICAgPSBgTnVtYmVyLk1JTl9WQUxVRWBcbiAgTkFOICAgICAgPSBgTmFOYFxuXG4gIERJRyAgICAgID0gMTVcbiAgTUFOVF9ESUcgPSA1M1xuICBSQURJWCAgICA9IDJcblxuICBFUFNJTE9OID0gYE51bWJlci5FUFNJTE9OIHx8IDIuMjIwNDQ2MDQ5MjUwMzEzMDgwODQ3MjYzMzM2MTgxNkUtMTZgXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJicmlkZ2UiLCJzZWxmIiwiYWxsb2NhdGUiLCJyYWlzZSIsIm5hbWUiLCJjb2VyY2UiLCJvdGhlciIsIkZsb2F0IiwicmVzcG9uZF90bz8iLCJjb2VyY2VfdG8hIiwiX19pZF9fIiwiKyIsIl9fY29lcmNlZF9fIiwiLSIsIioiLCIvIiwiJSIsIiYiLCJ8IiwiXiIsIjwiLCI8PSIsIj4iLCI+PSIsIjw9PiIsIjw8IiwiY291bnQiLCI+PiIsIltdIiwiYml0IiwiK0AiLCItQCIsIn4iLCIqKiIsIj09PSIsIiRyZXRfb3JfMSIsIiEiLCIwIiwibmV3IiwiMSIsIiRyZXRfb3JfMiIsIiRyZXRfb3JfMyIsInRvX2YiLCI9PSIsImFicyIsImFiczIiLCJhbGxiaXRzPyIsIm1hc2siLCJhbnliaXRzPyIsImFuZ2xlIiwibmFuPyIsImJpdF9sZW5ndGgiLCJjZWlsIiwiY2hyIiwiZGVub21pbmF0b3IiLCIkcmV0X29yXzQiLCJpbmZpbml0ZT8iLCJkb3dudG8iLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsInN0b3AiLCJlcXVhbD8iLCIkcmV0X29yXzUiLCJldmVuPyIsImZsb29yIiwiZ2NkIiwiZ2NkbGNtIiwibGNtIiwiaW50ZWdlcj8iLCJpc19hPyIsIiRyZXRfb3JfNiIsImtsYXNzIiwiJHJldF9vcl83IiwiJHJldF9vcl84IiwiaW5zdGFuY2Vfb2Y/IiwiJHJldF9vcl85IiwiJHJldF9vcl8xMCIsIiRyZXRfb3JfMTEiLCJuZXh0Iiwibm9iaXRzPyIsIm5vbnplcm8/IiwibnVtZXJhdG9yIiwiJHJldF9vcl8xMiIsIm9kZD8iLCJvcmQiLCJwb3ciLCJiIiwibSIsInByZWQiLCJxdW8iLCJyYXRpb25hbGl6ZSIsImZyZXhwIiwiZiIsIm4iLCJsZGV4cCIsInRvX2kiLCIyIiwidG9fciIsImVwcyIsInJlbWFpbmRlciIsInkiLCJ0cnVuY2F0ZSIsInJvdW5kIiwiJHJldF9vcl8xMyIsIm5kaWdpdHMiLCJzaXplIiwiJHJldF9vcl8xNCIsIiRyZXRfb3JfMTUiLCJfIiwiZXhwIiwiNCIsIjMiLCJ0aW1lcyIsImJsb2NrIiwiZSIsInRvX3MiLCIxMCIsImJhc2UiLCIkcmV0X29yXzE2IiwiMzYiLCJkaWdpdHMiLCJkaXZtb2QiLCIkcmV0X29yXzE3IiwidXB0byIsInplcm8/IiwiZmluaXRlPyIsInBvc2l0aXZlPyIsIm5lZ2F0aXZlPyIsInNxcnQiLCIxNSIsIjUzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQUFBO0FBQUEsRUFFQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUEsb0JBQUFDLFFBQUFBLENBQWEsUUFBU0MsSUFBdEJELENBQUE7QUFBQSxJQUNDLDBEQUREO0FBQUEsSUFFQyw2QkFGRDtBQUFBLElBSUE7QUFBQSxNQUFBOztBQUFBO0FBQ0U7QUFBQUUsTUFBQUEsNEJBQUFBLGNBQUFBLG9CQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxXQUFBQyxPQUFBQSxDQUFNLDJCQUFXLEVBQUEsR0FBQSwwQkFBQSxHQUFBLEtBQTJCQyxNQUFBQSxDQUFBQSxDQUEzQixDQUFqQkQ7QUFERkQsTUFBQUEsQ0FBQUEseUJBQUFBLENBQUE7QUFBQTs7QUFJQSxNQUFBLHNCQUFNLEtBQU47aUJB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QUFBLFFBQUFBOztBQUFBQSxRQUNFLFdBQUFDLE9BQUFBLENBQU0sMkJBQVcsRUFBQSxHQUFBLDBCQUFBLEdBQUEsS0FBMkJDLE1BQUFBLENBQUFBLENBQTNCLENBQWpCRDtBQURGRCxNQUFBQSxDQUFBQSwwQkFBQUEsQ0FBQTtBQUFBO0FBSUEsTUFBQSxzQkFBTSxLQUFOLEVBSkE7QUFBQSxNQU1BLE9BQUFnQyxDQUFBQSx1QkFBQUEsZUFBQUEsU0FBUSxLQUFSQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxPQUFDLG1CQUFEO0FBREZBLE1BQUFBLENBQUFBLDBCQUFBQSxDQUFBQSxlQU5BO0FBREYsSUFBQSw0QkFBU2pDLElBQVQsWUFGQTtBQUFBLElBY0Esd0NBQVksUUFBWixDQWRBO0FBQUEsSUFlQSxtQ0FBWSxnQkFBWixDQWZBO0FBQUEsSUFnQkEsbUNBQVksZ0JBQVosQ0FoQkE7QUFBQSxJQWlCQSxtQ0FBWSxHQUFaLENBakJBO0FBQUEsSUFtQkEsbUNBQVdnSSxFQUFYLENBbkJBO0FBQUEsSUFvQkEsd0NBQVdDLEVBQVgsQ0FwQkE7QUFBQSxJQXFCQSxxQ0FBV2xDLENBQVgsQ0FyQkE7QUFBQSxJQXVCQSxPQUFBLHVDQUFXLHVEQUFYLENBdkJBO0FBREZqRyxFQUFBQSxHQUFBQSxXQUFBQSxFQUFjLHVCQUFkQSxXQTMxQkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNzk4NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZ2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG5jbGFzcyBSYW5nZVxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX3JhbmdlID0gdHJ1ZWBcblxuICBhdHRyX3JlYWRlciA6YmVnaW4sIDplbmRcblxuICBkZWYgaW5pdGlhbGl6ZShmaXJzdCwgbGFzdCwgZXhjbHVkZSA9IGZhbHNlKVxuICAgIHJhaXNlIE5hbWVFcnJvciwgXCInaW5pdGlhbGl6ZScgY2FsbGVkIHR3aWNlXCIgaWYgQGJlZ2luXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2JhZCB2YWx1ZSBmb3IgcmFuZ2UnIHVubGVzcyBmaXJzdCA8PT4gbGFzdCB8fCBmaXJzdC5uaWw/IHx8IGxhc3QubmlsP1xuXG4gICAgQGJlZ2luID0gZmlyc3RcbiAgICBAZW5kICAgPSBsYXN0XG4gICAgQGV4Y2wgID0gZXhjbHVkZVxuICBlbmRcblxuICBkZWYgPT09KHZhbHVlKVxuICAgIGluY2x1ZGU/IHZhbHVlXG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGlzX2luZmluaXRlKHNlbGYpIHtcbiAgICAgIGlmIChzZWxmLmJlZ2luID09PSBuaWwgfHwgc2VsZi5lbmQgPT09IG5pbCB8fFxuICAgICAgICAgIHNlbGYuYmVnaW4gPT09IC1JbmZpbml0eSB8fCBzZWxmLmVuZCA9PT0gSW5maW5pdHkgfHxcbiAgICAgICAgICBzZWxmLmJlZ2luID09PSBJbmZpbml0eSB8fCBzZWxmLmVuZCA9PT0gLUluZmluaXR5KSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBkZWYgY291bnQoJmJsb2NrKVxuICAgIGlmICFibG9ja19naXZlbj8gJiYgYGlzX2luZmluaXRlKHNlbGYpYFxuICAgICAgcmV0dXJuIEZsb2F0OjpJTkZJTklUWVxuICAgIGVuZFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgcmFpc2UgVHlwZUVycm9yLCAnY2Fubm90IGNvbnZlcnQgZW5kbGVzcyByYW5nZSB0byBhbiBhcnJheScgaWYgYGlzX2luZmluaXRlKHNlbGYpYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBjb3Zlcj8odmFsdWUpXG4gICAgYmVnX2NtcCA9IChAYmVnaW4ubmlsPyAmJiAtMSkgfHwgKEBiZWdpbiA8PT4gdmFsdWUpIHx8IGZhbHNlXG4gICAgZW5kX2NtcCA9IChAZW5kLm5pbD8gJiYgLTEpIHx8ICh2YWx1ZSA8PT4gQGVuZCkgfHwgZmFsc2VcbiAgICBpZiBAZXhjbFxuICAgICAgZW5kX2NtcCAmJiBlbmRfY21wIDwgMFxuICAgIGVsc2VcbiAgICAgIGVuZF9jbXAgJiYgZW5kX2NtcCA8PSAwXG4gICAgZW5kICYmIGJlZ19jbXAgJiYgYmVnX2NtcCA8PSAwXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGksIGxpbWl0O1xuXG4gICAgICBpZiAoI3tAYmVnaW59LiQkaXNfbnVtYmVyICYmICN7QGVuZH0uJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKCN7QGJlZ2lufSAlIDEgIT09IDAgfHwgI3tAZW5kfSAlIDEgIT09IDApIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBpdGVyYXRlIGZyb20gRmxvYXRcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9ICN7QGJlZ2lufSwgbGltaXQgPSAje0BlbmR9ICsgI3tAZXhjbCA/IDAgOiAxfTsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICBibG9jayhpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBpZiAoI3tAYmVnaW59LiQkaXNfc3RyaW5nICYmICN7QGVuZH0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgI3tAYmVnaW4udXB0byhAZW5kLCBAZXhjbCwgJmJsb2NrKX1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudCA9IEBiZWdpblxuICAgIGxhc3QgICAgPSBAZW5kXG5cbiAgICB1bmxlc3MgY3VycmVudC5yZXNwb25kX3RvPyg6c3VjYylcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBpdGVyYXRlIGZyb20gI3tjdXJyZW50LmNsYXNzfVwiXG4gICAgZW5kXG5cbiAgICB3aGlsZSBAZW5kLm5pbD8gfHwgKGN1cnJlbnQgPD0+IGxhc3QpIDwgMFxuICAgICAgeWllbGQgY3VycmVudFxuXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5zdWNjXG4gICAgZW5kXG5cbiAgICB5aWVsZCBjdXJyZW50IGlmICFAZXhjbCAmJiBjdXJyZW50ID09IGxhc3RcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBSYW5nZSA9PT0gb3RoZXJcblxuICAgIEBleGNsID09PSBvdGhlci5leGNsdWRlX2VuZD8gJiZcbiAgICAgIEBiZWdpbi5lcWw/KG90aGVyLmJlZ2luKSAmJlxuICAgICAgQGVuZC5lcWw/KG90aGVyLmVuZClcbiAgZW5kXG5cbiAgYWxpYXMgPT0gZXFsP1xuXG4gIGRlZiBleGNsdWRlX2VuZD9cbiAgICBAZXhjbFxuICBlbmRcblxuICBkZWYgZmlyc3QobiA9IHVuZGVmaW5lZClcbiAgICByYWlzZSBSYW5nZUVycm9yLCAnY2Fubm90IGdldCB0aGUgbWluaW11bSBvZiBiZWdpbmxlc3MgcmFuZ2UnIGlmIEBiZWdpbi5uaWw/XG4gICAgcmV0dXJuIEBiZWdpbiBpZiBgbiA9PSBudWxsYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGFsaWFzIGluY2x1ZGU/IGNvdmVyP1xuXG4gIGRlZiBsYXN0KG4gPSB1bmRlZmluZWQpXG4gICAgcmFpc2UgUmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1heGltdW0gb2YgZW5kbGVzcyByYW5nZScgaWYgQGVuZC5uaWw/XG4gICAgcmV0dXJuIEBlbmQgaWYgYG4gPT0gbnVsbGBcbiAgICB0b19hLmxhc3QobilcbiAgZW5kXG5cbiAgIyBGSVhNRTogY3VycmVudGx5IGhhcmRjb2RlZCB0byBhc3N1bWUgcmFuZ2UgaG9sZHMgbnVtZXJpY3NcbiAgZGVmIG1heFxuICAgIGlmIEBlbmQubmlsP1xuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1heGltdW0gb2YgZW5kbGVzcyByYW5nZSdcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIHN1cGVyXG4gICAgZWxzaWYgIUBiZWdpbi5uaWw/ICYmIChAYmVnaW4gPiBAZW5kIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBAZXhjbCAmJiBAYmVnaW4gPT0gQGVuZClcbiAgICAgIG5pbFxuICAgIGVsc2VcbiAgICAgIGAje0BleGNsfSA/ICN7QGVuZH0gLSAxIDogI3tAZW5kfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgbWVtYmVyPyBjb3Zlcj9cblxuICBkZWYgbWluXG4gICAgaWYgQGJlZ2luLm5pbD9cbiAgICAgIHJhaXNlIFJhbmdlRXJyb3IsICdjYW5ub3QgZ2V0IHRoZSBtaW5pbXVtIG9mIGJlZ2lubGVzcyByYW5nZSdcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIHN1cGVyXG4gICAgZWxzaWYgIUBlbmQubmlsPyAmJiAoQGJlZ2luID4gQGVuZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIEBleGNsICYmIEBiZWdpbiA9PSBAZW5kKVxuICAgICAgbmlsXG4gICAgZWxzZVxuICAgICAgQGJlZ2luXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzaXplXG4gICAgaW5maW5pdHkgPSBGbG9hdDo6SU5GSU5JVFlcblxuICAgIHJldHVybiAwIGlmIChAYmVnaW4gPT0gaW5maW5pdHkgJiYgIUBlbmQubmlsPykgfHwgKEBlbmQgPT0gLWluZmluaXR5ICYmICFAYmVnaW4ubmlsPylcbiAgICByZXR1cm4gaW5maW5pdHkgaWYgYGlzX2luZmluaXRlKHNlbGYpYFxuICAgIHJldHVybiBuaWwgdW5sZXNzIE51bWVyaWMgPT09IEBiZWdpbiAmJiBOdW1lcmljID09PSBAZW5kXG5cbiAgICByYW5nZV9iZWdpbiA9IEBiZWdpblxuICAgIHJhbmdlX2VuZCAgID0gQGVuZFxuICAgIHJhbmdlX2VuZCAgLT0gMSBpZiBAZXhjbFxuXG4gICAgcmV0dXJuIDAgaWYgcmFuZ2VfZW5kIDwgcmFuZ2VfYmVnaW5cblxuICAgIGBNYXRoLmFicyhyYW5nZV9lbmQgLSByYW5nZV9iZWdpbikgKyAxYC50b19pXG4gIGVuZFxuXG4gIGRlZiBzdGVwKG4gPSAxKVxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gY29lcmNlU3RlcFNpemUoKSB7XG4gICAgICAgIGlmICghbi4kJGlzX251bWJlcikge1xuICAgICAgICAgIG4gPSAje09wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KX1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIG5lZ2F0aXZlXCJ9XG4gICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIDBcIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbnVtZXJhdG9yU2l6ZSgpIHtcbiAgICAgICAgaWYgKCEje0BiZWdpbi5yZXNwb25kX3RvPyg6c3VjYyl9KSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje0BiZWdpbn0uJCRpc19zdHJpbmcgJiYgI3tAZW5kfS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobiAlIDEgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gI3soc2l6ZSAvIG4pLmNlaWx9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG4gaXMgYSBmbG9hdFxuICAgICAgICAgIHZhciBiZWdpbiA9IHNlbGYuYmVnaW4sIGVuZCA9IHNlbGYuZW5kLFxuICAgICAgICAgICAgICBhYnMgPSBNYXRoLmFicywgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICAgICAgICBlcnIgPSAoYWJzKGJlZ2luKSArIGFicyhlbmQpICsgYWJzKGVuZCAtIGJlZ2luKSkgLyBhYnMobikgKiAje0Zsb2F0OjpFUFNJTE9OfSxcbiAgICAgICAgICAgICAgc2l6ZTtcblxuICAgICAgICAgIGlmIChlcnIgPiAwLjUpIHtcbiAgICAgICAgICAgIGVyciA9IDAuNTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5leGNsKSB7XG4gICAgICAgICAgICBzaXplID0gZmxvb3IoKGVuZCAtIGJlZ2luKSAvIG4gLSBlcnIpO1xuICAgICAgICAgICAgaWYgKHNpemUgKiBuICsgYmVnaW4gPCBlbmQpIHtcbiAgICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplID0gZmxvb3IoKGVuZCAtIGJlZ2luKSAvIG4gKyBlcnIpICsgMVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpzdGVwLCBuKSBkb1xuICAgICAgICAleHtcbiAgICAgICAgICBjb2VyY2VTdGVwU2l6ZSgpO1xuICAgICAgICAgIHJldHVybiBlbnVtZXJhdG9yU2l6ZSgpO1xuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGBjb2VyY2VTdGVwU2l6ZSgpYFxuXG4gICAgaWYgYHNlbGYuYmVnaW4uJCRpc19udW1iZXIgJiYgc2VsZi5lbmQuJCRpc19udW1iZXJgXG4gICAgICBpID0gMFxuICAgICAgbG9vcCBkb1xuICAgICAgICBjdXJyZW50ID0gQGJlZ2luICsgaSAqIG5cbiAgICAgICAgaWYgQGV4Y2xcbiAgICAgICAgICBicmVhayBpZiBjdXJyZW50ID49IEBlbmRcbiAgICAgICAgZWxzaWYgY3VycmVudCA+IEBlbmRcbiAgICAgICAgICBicmVha1xuICAgICAgICBlbmRcbiAgICAgICAgeWllbGQoY3VycmVudClcbiAgICAgICAgaSArPSAxXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICAleHtcbiAgICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX3N0cmluZyAmJiAje0BlbmR9LiQkaXNfc3RyaW5nICYmIG4gJSAxICE9PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdubyBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIGZsb2F0IGZyb20gc3RyaW5nJ31cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWFjaF93aXRoX2luZGV4IGRvIHx2YWx1ZSwgaWR4fFxuICAgICAgICB5aWVsZCh2YWx1ZSkgaWYgaWR4ICUgbiA9PSAwXG4gICAgICBlbmRcbiAgICBlbmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmJzZWFyY2gpIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGlmIGBpc19pbmZpbml0ZShzZWxmKSAmJiAoc2VsZi5iZWdpbi4kJGlzX251bWJlciB8fCBzZWxmLmVuZC4kJGlzX251bWJlcilgXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBcIkNhbid0ICNic2VhcmNoIGFuIGluZmluaXRlIHJhbmdlXCJcbiAgICBlbmRcblxuICAgIHVubGVzcyBgc2VsZi5iZWdpbi4kJGlzX251bWJlciAmJiBzZWxmLmVuZC4kJGlzX251bWJlcmBcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBkbyBiaW5hcnkgc2VhcmNoIGZvciAje0BiZWdpbi5jbGFzc31cIlxuICAgIGVuZFxuXG4gICAgdG9fYS5ic2VhcmNoKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiN7QGJlZ2luIHx8ICcnfSN7QGV4Y2wgPyAnLi4uJyA6ICcuLid9I3tAZW5kIHx8ICcnfVwiXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIje0BiZWdpbiAmJiBAYmVnaW4uaW5zcGVjdH0je0BleGNsID8gJy4uLicgOiAnLi4nfSN7QGVuZCAmJiBAZW5kLmluc3BlY3R9XCJcbiAgZW5kXG5cbiAgZGVmIG1hcnNoYWxfbG9hZChhcmdzKVxuICAgIEBiZWdpbiA9IGFyZ3NbOmJlZ2luXVxuICAgIEBlbmQgPSBhcmdzWzplbmRdXG4gICAgQGV4Y2wgPSBhcmdzWzpleGNsXVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFtAYmVnaW4sIEBlbmQsIEBleGNsXS5oYXNoXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiaW5jbHVkZSIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkBiZWdpbiIsInJhaXNlIiwiJHJldF9vcl8xIiwiJHJldF9vcl8yIiwiZmlyc3QiLCI8PT4iLCJsYXN0IiwibmlsPyIsIkBlbmQiLCJAZXhjbCIsImV4Y2x1ZGUiLCI9PT0iLCJpbmNsdWRlPyIsInZhbHVlIiwiY291bnQiLCIkcmV0X29yXzMiLCJibG9ja19naXZlbj8iLCIhIiwidG9fYSIsImNvdmVyPyIsImJlZ19jbXAiLCIkcmV0X29yXzQiLCIkcmV0X29yXzUiLCIkcmV0X29yXzYiLCItMSIsImVuZF9jbXAiLCIkcmV0X29yXzciLCIkcmV0X29yXzgiLCIkcmV0X29yXzkiLCIkcmV0X29yXzEwIiwiJHJldF9vcl8xMSIsIiRyZXRfb3JfMTIiLCI8IiwiMCIsIiRyZXRfb3JfMTMiLCI8PSIsImVhY2giLCJlbnVtX2ZvciIsInNpemUiLCIxIiwidXB0byIsImJsb2NrIiwiY3VycmVudCIsInJlc3BvbmRfdG8/IiwiJHJldF9vcl8xNCIsInN1Y2MiLCIkcmV0X29yXzE1IiwiPT0iLCJzZWxmIiwiZXFsPyIsIm90aGVyIiwiJHJldF9vcl8xNiIsIiRyZXRfb3JfMTciLCJleGNsdWRlX2VuZD8iLCJiZWdpbiIsImVuZCIsIm4iLCJtYXgiLCIkcmV0X29yXzE4IiwiJHJldF9vcl8xOSIsIj4iLCIkcmV0X29yXzIwIiwibWluIiwiJHJldF9vcl8yMSIsIiRyZXRfb3JfMjIiLCIkcmV0X29yXzIzIiwiaW5maW5pdHkiLCIkcmV0X29yXzI0IiwiJHJldF9vcl8yNSIsIiRyZXRfb3JfMjYiLCItQCIsIiRyZXRfb3JfMjciLCJyYW5nZV9iZWdpbiIsInJhbmdlX2VuZCIsIi0iLCJ0b19pIiwic3RlcCIsImNvZXJjZV90byEiLCIvIiwiY2VpbCIsImkiLCJsb29wIiwiKyIsIioiLCI+PSIsImVhY2hfd2l0aF9pbmRleCIsImlkeCIsIiUiLCJic2VhcmNoIiwidG9fcyIsIiRyZXRfb3JfMjgiLCIkcmV0X29yXzI5IiwiaW5zcGVjdCIsIiRyZXRfb3JfMzAiLCIkcmV0X29yXzMxIiwibWFyc2hhbF9sb2FkIiwiYXJncyIsIltdIiwiaGFzaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsMEJBQVJBLENBQUE7QUFBQSxJQUVDLGtDQUZEO0FBQUEsUUFJQUMsYUFBQUEsQ0FBWSxTQUFRLEtBQXBCQSxDQUpBO0FBQUE7QUFNQUMsSUFBQUEsOEJBQUFBLHNCQUFBQSxzQkFBZSxLQUFELEVBQVEsSUFBUixFQUFjLE9BQTVCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFWRjtBQVU4QixNQUFBO0FBQUEsTUFBQSxZQUFVLEtBQVY7QUFBQSxNQUFBLENBVjlCO0FBQUEsTUFXSSxJQUFBLFFBQWdEQyxVQUFoRCxDQUFBO0FBQUEsWUFBQUMsT0FBQUEsQ0FBTSwyQkFBVywyQkFBakJBLENBQUEsQ0FYSjtBQUFBLE1BWUksSUFBQSxRQUFrRCxhQUFBLElBQUEsUUFadERDLENBQUFBLFlBWXNELGFBQUEsSUFBQSxRQVp0REMsQ0FBQUEsWUFZc0RDLEtBQUFDLFFBQUFBLENBQVVDLElBQVZELENBWnRERixDQVlzRCxDQUFBO0FBQUEsUUFadEQsT0FBQTtBQVlzRCxNQUFBO0FB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QWxSekRzRixDQWtSeUQsQ0FBQTtBQUFBLFFBQVEsT0FBQXRGLFFBQUFvRixTQUFBQSxDQUFBQTtBQUFSLE1BQUE7QUFBQSxRQWxSekQsT0FBQTtBQWtSeUQsTUFBQSxDQUFBLGtCQUFyRDtBQURGQSxJQUFBQSxDQUFBQSwrQkFBQUEsQ0E3UUE7QUFBQTtBQWlSQUcsSUFBQUEsZ0NBQUFBLHlCQUFBQSx3QkFBaUIsSUFBakJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUEvRixhQUFTZ0csSUFBQUMsT0FBQUEsQ0FBSyxPQUFMQSxDQUFUO0FBQUEsTUFDQXpGLFdBQU93RixJQUFBQyxPQUFBQSxDQUFLLEtBQUxBLENBRFA7QUFBQSxNQUVBLE9BQUF4RixDQUFBQSxZQUFRdUYsSUFBQUMsT0FBQUEsQ0FBSyxNQUFMQSxDQUFSeEYsQ0FGQTtBQURGc0YsSUFBQUEsQ0FBQUEsb0NBQUFBLENBalJBO0FBQUEsSUF1UkEsT0FBQUcsQ0FBQUEsd0JBQUFBLGlCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxDQUFDbEcsVUFBRCxFQUFTUSxRQUFULEVBQWVDLFNBQWYsQ0FBQXlGLE1BQUFBLENBQUFBO0FBREZBLElBQUFBLENBQUFBLDRCQUFBQSxDQUFBQSxnQkF2UkE7QUFERnRHLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBRkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxODU1NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcHJvYy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHNsaWNlXG5cbmNsYXNzIFByb2MgPCBgRnVuY3Rpb25gXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX3Byb2MnLCB0cnVlKWBcbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfbGFtYmRhJywgZmFsc2UpYFxuXG4gIGRlZiBzZWxmLm5ldygmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY3JlYXRlIGEgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIGNhbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHNlbGYuJCRwID0gYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQsICRicmsgPSBzZWxmLiQkYnJrO1xuXG4gICAgICBpZiAoJGJyaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzZWxmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IE9wYWwueWllbGRYKHNlbGYsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciA9PT0gJGJyaykge1xuICAgICAgICAgICAgcmV0dXJuICRicmsuJHZcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSkge1xuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gT3BhbC55aWVsZFgoc2VsZiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIFtdIGNhbGxcbiAgYWxpYXMgPT09IGNhbGxcbiAgYWxpYXMgeWllbGQgY2FsbFxuXG4gIGRlZiA+PihvdGhlcilcbiAgICBwcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgb3V0ID0gY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICAgb3RoZXIuY2FsbChvdXQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PChvdGhlcilcbiAgICBwcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgb3V0ID0gb3RoZXIuY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICAgY2FsbChvdXQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGFtYmRhP1xuICAgICMgVGhpcyBtZXRob2Qgc2hvdWxkIHRlbGwgdGhlIHVzZXIgaWYgdGhlIHByb2MgdHJpY2tzIGFyZSB1bmF2YWlsYWJsZSxcbiAgICAjIChzZWUgUHJvYyNsYW1iZGE/IG9uIHJ1YnkgZG9jcyB0byBmaW5kIG91dCBtb3JlKS5cbiAgICBgISFzZWxmLiQkaXNfbGFtYmRhYFxuICBlbmRcblxuICBkZWYgYXJpdHlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkaXNfY3VycmllZCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGFyaXR5O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxuICAgIGBpZiAoc2VsZi4kJGlzX2N1cnJpZWQpIHsgcmV0dXJuIG5pbDsgfWBcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGJpbmRpbmdcbiAgICBgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJDYW4ndCBjcmVhdGUgQmluZGluZ1wifSB9YFxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVyc1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgIHJldHVybiAje1tbOnJlc3RdXX07XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuJCRwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuJCRwYXJhbWV0ZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi4kJHBhcmFtZXRlcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXIgPSBzZWxmLiQkcGFyYW1ldGVyc1tpXTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlclswXSA9PT0gJ3JlcScpIHtcbiAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgYXJndW1lbnRzIGFsd2F5cyBoYXZlIG5hbWVcbiAgICAgICAgICAgICAgcGFyYW1ldGVyID0gWydvcHQnLCBwYXJhbWV0ZXJbMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhbWV0ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjdXJyeShhcml0eSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyaXR5ID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYXJpdHkgPSAje09wYWwuY29lcmNlX3RvIShhcml0eSwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSAmJiBhcml0eSAhPT0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJpdHlgfSBmb3IgI3tgc2VsZi5sZW5ndGhgfSlcIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXJyaWVkICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+IGFyaXR5ICYmIHNlbGYuJCRpc19sYW1iZGEgJiYgIXNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGxlbmd0aGB9IGZvciAje2Bhcml0eWB9KVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiRjYWxsLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyaWVkLmFwcGx5KG51bGwsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdCgkc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LiQkaXNfbGFtYmRhID0gc2VsZi4kJGlzX2xhbWJkYTtcbiAgICAgICAgcmVzdWx0LiQkaXNfY3VycmllZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIGN1cnJpZWQuJCRpc19sYW1iZGEgPSBzZWxmLiQkaXNfbGFtYmRhO1xuICAgICAgY3VycmllZC4kJGlzX2N1cnJpZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGN1cnJpZWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWxfcHJvYyA9IHNlbGYuJCRvcmlnaW5hbF9wcm9jIHx8IHNlbGYsXG4gICAgICAgICAgcHJvYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbF9wcm9jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgcHJvY1twcm9wXSA9IHNlbGZbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb2M7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBjbG9uZSBkdXBcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwibmV3Iiwic2VsZiIsImJsb2NrIiwicmFpc2UiLCJjYWxsIiwiPj4iLCJwcm9jIiwib3V0IiwiYXJncyIsIm90aGVyIiwiPDwiLCJ0b19wcm9jIiwibGFtYmRhPyIsImFyaXR5Iiwic291cmNlX2xvY2F0aW9uIiwiYmluZGluZyIsInBhcmFtZXRlcnMiLCJjdXJyeSIsImNvZXJjZV90byEiLCJkdXAiXSwibWFwcGluZ3MiOiI7Ozs7O0VBRUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUMsd0RBQUQ7QUFBQSxJQUNDLDJEQUREO0FBQUEsSUFHQUMsVUFBSUMsSUFBSkQsVUFBQUEsY0FBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBUEY7QUFPZSxNQUFBLGtDQVBmO0FBQUEsTUFRSSxJQUFBLFFBQU9FLEtBQVAsQ0FBQTtBQUFBLE1BQUE7QUFBQSxZQUNFQyxPQUFBQSxDQUFNLCtCQUFlLCtDQUFyQkE7QUFERixNQUFBLENBUko7QUFBQSxNQVlJLE9BQUFELEtBWko7QUFPRUYsSUFBQUEsQ0FBQUEseUJBQUFBLENBSEE7QUFB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O0FBQ0E7QUFkRUEsSUFBQUEsQ0FBQUEsMEJBQUFBLENBdktBO0FBQUEsSUF3TEEsT0FBQSxpQkFBTSxPQUFOLEVBQVksS0FBWixDQXhMQTtBQURGcEIsRUFBQUEsR0FBQUEsV0FBQUEsRUFBYyxRQUFkQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE4ODA3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tZXRob2QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgTWV0aG9kXG4gIGF0dHJfcmVhZGVyIDpvd25lciwgOnJlY2VpdmVyLCA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKHJlY2VpdmVyLCBvd25lciwgbWV0aG9kLCBuYW1lKVxuICAgIEByZWNlaXZlciA9IHJlY2VpdmVyXG4gICAgQG93bmVyICAgID0gb3duZXJcbiAgICBAbmFtZSAgICAgPSBuYW1lXG4gICAgQG1ldGhvZCAgID0gbWV0aG9kXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgIEBtZXRob2QuYXJpdHlcbiAgZW5kXG5cbiAgZGVmIHBhcmFtZXRlcnNcbiAgICBgI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnNgXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VfbG9jYXRpb25cbiAgICBgI3tAbWV0aG9kfS4kJHNvdXJjZV9sb2NhdGlvbmAgfHwgWycoZXZhbCknLCAwXVxuICBlbmRcblxuICBkZWYgY29tbWVudHNcbiAgICBgI3tAbWV0aG9kfS4kJGNvbW1lbnRzYCB8fCBbXVxuICBlbmRcblxuICBkZWYgY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgI3tAbWV0aG9kfS4kJHAgPSBibG9jaztcblxuICAgICAgcmV0dXJuICN7QG1ldGhvZH0uYXBwbHkoI3tAcmVjZWl2ZXJ9LCBhcmdzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIFtdIGNhbGxcblxuICBkZWYgPj4ob3RoZXIpXG4gICAgQG1ldGhvZCA+PiBvdGhlclxuICBlbmRcblxuICBkZWYgPDwob3RoZXIpXG4gICAgQG1ldGhvZCA8PCBvdGhlclxuICBlbmRcblxuICBkZWYgdW5iaW5kXG4gICAgVW5ib3VuZE1ldGhvZC5uZXcoQHJlY2VpdmVyLmNsYXNzLCBAb3duZXIsIEBtZXRob2QsIEBuYW1lKVxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgICV4e1xuICAgICAgdmFyIHByb2MgPSBzZWxmLiRjYWxsLmJpbmQoc2VsZik7XG4gICAgICBwcm9jLiQkdW5ib3VuZCA9ICN7QG1ldGhvZH07XG4gICAgICBwcm9jLiQkaXNfbGFtYmRhID0gdHJ1ZTtcbiAgICAgIHByb2MuJCRhcml0eSA9ICN7QG1ldGhvZH0uJCRhcml0eTtcbiAgICAgIHByb2MuJCRwYXJhbWV0ZXJzID0gI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnM7XG4gICAgICByZXR1cm4gcHJvYztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPCN7c2VsZi5jbGFzc306ICN7QHJlY2VpdmVyLmNsYXNzfSMje0BuYW1lfSAoZGVmaW5lZCBpbiAje0Bvd25lcn0gaW4gI3tzb3VyY2VfbG9jYXRpb24uam9pbignOicpfSk+XCJcbiAgZW5kXG5lbmRcblxuY2xhc3MgVW5ib3VuZE1ldGhvZFxuICBhdHRyX3JlYWRlciA6c291cmNlLCA6b3duZXIsIDpuYW1lXG5cbiAgZGVmIGluaXRpYWxpemUoc291cmNlLCBvd25lciwgbWV0aG9kLCBuYW1lKVxuICAgIEBzb3VyY2UgPSBzb3VyY2VcbiAgICBAb3duZXIgID0gb3duZXJcbiAgICBAbWV0aG9kID0gbWV0aG9kXG4gICAgQG5hbWUgICA9IG5hbWVcbiAgZW5kXG5cbiAgZGVmIGFyaXR5XG4gICAgQG1ldGhvZC5hcml0eVxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVyc1xuICAgIGAje0BtZXRob2R9LiQkcGFyYW1ldGVyc2BcbiAgZW5kXG5cbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxuICAgIGAje0BtZXRob2R9LiQkc291cmNlX2xvY2F0aW9uYCB8fCBbJyhldmFsKScsIDBdXG4gIGVuZFxuXG4gIGRlZiBjb21tZW50c1xuICAgIGAje0BtZXRob2R9LiQkY29tbWVudHNgIHx8IFtdXG4gIGVuZFxuXG4gIGRlZiBiaW5kKG9iamVjdClcbiAgICAleHtcbiAgICAgIGlmICgje0Bvd25lcn0uJCRpc19tb2R1bGUgfHwgT3BhbC5pc19hKCN7b2JqZWN0fSwgI3tAb3duZXJ9KSkge1xuICAgICAgICByZXR1cm4gI3tNZXRob2QubmV3KG9iamVjdCwgQG93bmVyLCBAbWV0aG9kLCBAbmFtZSl9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGJpbmQgc2luZ2xldG9uIG1ldGhvZCB0byBhIGRpZmZlcmVudCBjbGFzcyAoZXhwZWN0ZWQgI3tvYmplY3R9LmtpbmRfb2Y/KCN7QG93bmVyfSB0byBiZSB0cnVlKVwifTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPCN7c2VsZi5jbGFzc306ICN7QHNvdXJjZX0jI3tAbmFtZX0gKGRlZmluZWQgaW4gI3tAb3duZXJ9IGluICN7c291cmNlX2xvY2F0aW9uLmpvaW4oJzonKX0pPlwiXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJAcmVjZWl2ZXIiLCJyZWNlaXZlciIsIkBvd25lciIsIm93bmVyIiwiQG5hbWUiLCJuYW1lIiwiQG1ldGhvZCIsIm1ldGhvZCIsImFyaXR5IiwicGFyYW1ldGVycyIsInNvdXJjZV9sb2NhdGlvbiIsIiRyZXRfb3JfMSIsIjAiLCJjb21tZW50cyIsIiRyZXRfb3JfMiIsImNhbGwiLCI+PiIsIm90aGVyIiwiPDwiLCJ1bmJpbmQiLCJuZXciLCJ0b19wcm9jIiwiaW5zcGVjdCIsInNlbGYiLCJqb2luIiwiQHNvdXJjZSIsInNvdXJjZSIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsImJpbmQiLCJvYmplY3QiLCJyYWlzZSJdLCJt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O0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsRUFBQSxHQUFBLElBQUEsR0FBQSxDQUFLQyxJQUFBMUIsT0FBQUEsQ0FBQUEsQ0FBTCxDQUFBLEdBQUEsSUFBQSxHQUFBLENBQW9CNEIsV0FBcEIsQ0FBQSxHQUFBLEdBQUEsR0FBQSxDQUErQnJCLFNBQS9CLENBQUEsR0FBQSxlQUFBLEdBQUEsQ0FBb0RGLFVBQXBELENBQUEsR0FBQSxNQUFBLEdBQUEsS0FBaUVRLGlCQUFBQSxDQUFBQSxDQUFBYyxNQUFBQSxDQUFxQixHQUFyQkEsQ0FBakUsQ0FBQSxHQUFBO0FBREZGLElBQUFBLENBQUFBLHVDQUFBQSxDQUFBQSxtQkFwQ0E7QUFERnpCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBaEVBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTg5OTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3ZhcmlhYmxlcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIHJlZ2V4cCBtYXRjaGVzXG4leHskZ3ZhcnNbJyYnXSA9ICRndmFyc1snfiddID0gJGd2YXJzWydgJ10gPSAkZ3ZhcnNbXCInXCJdID0gbmlsfVxuXG4jIHJlcXVpcmVzXG4kTE9BREVEX0ZFQVRVUkVTID0gJFwiID0gYE9wYWwubG9hZGVkX2ZlYXR1cmVzYFxuJExPQURfUEFUSCAgICAgICA9ICQ6ID0gW11cblxuIyBzcGxpdCBsaW5lc1xuJC8gPSBcIlxcblwiXG4kLCA9IG5pbFxuXG5BUkdWID0gW11cbkFSR0YgPSBPYmplY3QubmV3XG5FTlYgID0ge31cblxuJFZFUkJPU0UgPSBmYWxzZVxuJERFQlVHICAgPSBmYWxzZVxuJFNBRkUgICAgPSAwXG4iXSwibmFtZXMiOlsiJExPQURFRF9GRUFUVVJFUyIsIiRcIiIsIiRMT0FEX1BBVEgiLCIkOiIsIiQvIiwiJCwiLCJuZXciLCIkVkVSQk9TRSIsIiRERUJVRyIsIiRTQUZFIiwiMCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsRUFBRywyREFBSDtBQUFBLEVBR0FBLHlCQUFtQkMsQ0FBQUEsZUFBTSxvQkFBTkEsQ0FIbkI7QUFBQSxFQUlBQyxtQkFBbUJDLENBQUFBLGNBQUssRUFBTEEsQ0FKbkI7QUFBQSxFQU9BQyxjQUFLLElBUEw7QUFBQSxFQVFBQyxjQUFLLEdBUkw7QUFBQSxFQVVBLG9DQUFPLEVBQVAsQ0FWQTtBQUFBLEVBV0Esb0NBQU8sc0JBQUFDLEtBQUFBLENBQUFBLENBQVAsQ0FYQTtBQUFBLEVBWUEsbUNBQU8sWUFBQSxFQUFQLENBWkE7QUFBQSxFQWNBQyxpQkFBVyxLQWRYO0FBQUEsRUFlQUMsZUFBVyxLQWZYO0FBQUEsRUFnQkEsT0FBQUMsQ0FBQUEsY0FBV0MsQ0FBWEQsQ0FoQkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxOTAwOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvaW8ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgSU9cbiAgU0VFS19TRVQgPSAwXG4gIFNFRUtfQ1VSID0gMVxuICBTRUVLX0VORCA9IDJcblxuICBkZWYgdHR5P1xuICAgIEB0dHlcbiAgZW5kXG5cbiAgZGVmIGNsb3NlZD9cbiAgICBAY2xvc2VkXG4gIGVuZFxuXG4gIGF0dHJfYWNjZXNzb3IgOndyaXRlX3Byb2NcblxuICBkZWYgd3JpdGUoc3RyaW5nKVxuICAgIGBzZWxmLndyaXRlX3Byb2Moc3RyaW5nKWBcbiAgICBzdHJpbmcuc2l6ZVxuICBlbmRcblxuICBhdHRyX2FjY2Vzc29yIDpzeW5jLCA6dHR5XG5cbiAgZGVmIGZsdXNoXG4gICAgIyBub29wXG4gIGVuZFxuXG4gIG1vZHVsZSBXcml0YWJsZVxuICAgIGRlZiA8PChzdHJpbmcpXG4gICAgICB3cml0ZShzdHJpbmcpXG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgcHJpbnQoKmFyZ3MpXG4gICAgICAleHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9ICN7U3RyaW5nKGBhcmdzW2ldYCl9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi4kd3JpdGUoYXJncy5qb2luKCN7JCx9KSk7XG4gICAgICB9XG4gICAgICBuaWxcbiAgICBlbmRcblxuICAgIGRlZiBwdXRzKCphcmdzKVxuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyZ3MubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSAje1N0cmluZyhgYXJnc1tpXWApLmNob21wfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuJHdyaXRlKGFyZ3MuY29uY2F0KFtuaWxdKS5qb2luKCN7JC99KSk7XG4gICAgICB9XG4gICAgICBuaWxcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIFJlYWRhYmxlXG4gICAgZGVmIHJlYWRieXRlXG4gICAgICBnZXRieXRlXG4gICAgZW5kXG5cbiAgICBkZWYgcmVhZGNoYXJcbiAgICAgIGdldGNcbiAgICBlbmRcblxuICAgIGRlZiByZWFkbGluZShzZXAgPSAkLylcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3JcbiAgICBlbmRcblxuICAgIGRlZiByZWFkcGFydGlhbChpbnRlZ2VyLCBvdXRidWYgPSBuaWwpXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cblNUREVSUiA9ICRzdGRlcnIgPSBJTy5uZXdcblNURElOICA9ICRzdGRpbiAgPSBJTy5uZXdcblNURE9VVCA9ICRzdGRvdXQgPSBJTy5uZXdcblxuYHZhciBjb25zb2xlID0gT3BhbC5nbG9iYWwuY29uc29sZWBcblNURE9VVC53cml0ZV9wcm9jID0gYHR5cGVvZihwcm9jZXNzKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mKHByb2Nlc3Muc3Rkb3V0KSA9PT0gJ29iamVjdCcgPyBmdW5jdGlvbihzKXtwcm9jZXNzLnN0ZG91dC53cml0ZShzKX0gOiBmdW5jdGlvbihzKXtjb25zb2xlLmxvZyhzKX1gXG5TVERFUlIud3JpdGVfcHJvYyA9IGB0eXBlb2YocHJvY2VzcykgPT09ICdvYmplY3QnICYmIHR5cGVvZihwcm9jZXNzLnN0ZGVycikgPT09ICdvYmplY3QnID8gZnVuY3Rpb24ocyl7cHJvY2Vzcy5zdGRlcnIud3JpdGUocyl9IDogZnVuY3Rpb24ocyl7Y29uc29sZS53YXJuKHMpfWBcblxuU1RET1VULmV4dGVuZChJTzo6V3JpdGFibGUpXG5TVERFUlIuZXh0ZW5kKElPOjpXcml0YWJsZSlcbiJdLCJuYW1lcyI6WyJjbGFzcyIsIjAiLCIxIiwiMiIsInR0eT8iLCJAdHR5IiwiY2xvc2VkPyIsIkBjbG9zZWQiLCJhdHRyX2FjY2Vzc29yIiwid3JpdGUiLCJzdHJpbmciLCJzaXplIiwiZmx1c2giLCJtb2R1bGUiLCI8PCIsInNlbGYiLCJwcmludCIsIlN0cmluZyIsIiQsIiwicHV0cyIsImNob21wIiwiJC8iLCJyZWFkYnl0ZSIsImdldGJ5dGUiLCJyZWFkY2hhciIsImdldGMiLCJyZWFkbGluZSIsInJhaXNlIiwicmVhZHBhcnRpYWwiLCIkc3RkZXJyIiwibmV3IiwiJHN0ZGluIiwiJHN0ZG91dCIsIiR3cml0ZXIiLCJ3cml0ZV9wcm9jPSIsIi0iLCJleHRlbmQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLEVBQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxJQUFBLHdDQUFXQyxDQUFYLENBQUE7QUFBQSxJQUNBLHdDQUFXQyxDQUFYLENBREE7QUFBQSxJQUVBLHdDQUFXQyxDQUFYLENBRkE7QUFBQTtBQUlBQyxJQUFBQSx3QkFBQUEsaUJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFDO0FBREZELElBQUFBLENBQUFBLDRCQUFBQSxDQUpBO0FBQUE7QUFRQUUsSUFBQUEsMkJBQUFBLG9CQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFB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V0FBQUEsV0FwREE7QUFERmIsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FBQTtBQUFBLEVBd0VBLHNDQUFTNkIsQ0FBQUEsZ0JBQVUsa0JBQUFDLEtBQUFBLENBQUFBLENBQVZELENBQVQsQ0F4RUE7QUFBQSxFQXlFQSxxQ0FBU0UsQ0FBQUEsZUFBVSxrQkFBQUQsS0FBQUEsQ0FBQUEsQ0FBVkMsQ0FBVCxDQXpFQTtBQUFBLEVBMEVBLHNDQUFTQyxDQUFBQSxnQkFBVSxrQkFBQUYsS0FBQUEsQ0FBQUEsQ0FBVkUsQ0FBVCxDQTFFQTtBQUFBLEVBNEVDLGlDQTVFRDtBQUFBO0FBREEsRUFBQUMsVUFBQSxDQThFcUIsd0lBOUVyQixDQUFBO0FBQUEsRUE4RUFDLE1BQUEsc0JBQUFBLGVBQUFBLEVBOUVBLFVBQUFELE9BQUEsQ0E4RUFDLENBOUVBO0FBQUEsRUFBQUQsT0FBQSxDQUFBRSxVQUFBRixPQUFBLENBQUEsUUFBQSxDQUFBRSxFQUFBakMsQ0FBQWlDLENBQUEsQ0FBQSxDQUNBO0FBQUE7QUFEQSxFQUFBRixVQUFBLENBK0VxQix5SUEvRXJCLENBQUE7QUFBQSxFQStFQUMsTUFBQSxzQkFBQUEsZUFBQUEsRUEvRUEsVUFBQUQsT0FBQSxDQStFQUMsQ0EvRUE7QUFBQSxFQUFBRCxPQUFBLENBQUFFLFVBQUFGLE9BQUEsQ0FBQSxRQUFBLENBQUFFLEVBQUFqQyxDQUFBaUMsQ0FBQSxDQUFBLENBQ0E7QUFBQSxFQWdGQSxzQkFBQUMsUUFBQUEsQ0FBYyxJQUFBLGtCQUFBLGFBQWRBLENBaEZBO0FBQUEsRUFpRkEsT0FBQSxzQkFBQUEsUUFBQUEsQ0FBYyxJQUFBLGtCQUFBLGFBQWRBLENBakZBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTkxNjQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL3JlZ2V4cF9hbmNob3JzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlXG5cbm1vZHVsZSBPcGFsXG4gIFJFR0VYUF9TVEFSVCA9IFJVQllfRU5HSU5FID09ICdvcGFsJyA/ICdeJyA6ICdcXEEnXG4gIFJFR0VYUF9FTkQgPSBSVUJZX0VOR0lORSA9PSAnb3BhbCcgPyAnJCcgOiAnXFx6J1xuXG4gICMgVW5pY29kZSBjaGFyYWN0ZXJzIGluIHJhbmdlc1xuICAjIFxcdTAwMDEgLSBcXHUwMDJGIChibGFuayB1bmljb2RlIGNoYXJhY3RlcnMgKyBzcGFjZSArICFcIiMkJSYnKCkqKywtLi8gY2hhcnMpXG4gICMgXFx1MDAzQSAtIFxcdTAwNDAgKDo7PD0+P0AgY2hhcnMpXG4gICMgXFx1MDA1QiAtIFxcdTAwNUUgKFtcXF1eIGNoYXJzKVxuICAjIFxcdTAwNjAgICAgICAgICAgKGAgY2hhcilcbiAgIyBcXHUwMDdCIC0gXFx1MDA3RiAoe3x9fiBjaGFyc30pXG4gICMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gaWRlbnRpZmllciBpbiB0aGUgYmVnZ2luaW5nIG9yIG1pZGRsZSBvZiBpdHMgbmFtZVxuICBGT1JCSURERU5fU1RBUlRJTkdfSURFTlRJRklFUl9DSEFSUyA9ICdcXHUwMDAxLVxcdTAwMkZcXHUwMDNBLVxcdTAwNDBcXHUwMDVCLVxcdTAwNUVcXHUwMDYwXFx1MDA3Qi1cXHUwMDdGJ1xuXG4gICMgVW5pY29kZSBjaGFyYWN0ZXJzIGluIHJhbmdlc1xuICAjIFxcdTAwMDEgLSBcXHUwMDIwIChibGFuayB1bmljb2RlIGNoYXJhY3RlcnMgKyBzcGFjZSlcbiAgIyBcXHUwMDIyIC0gXFx1MDAyRiAoXCIjJCUmJygpKissLS4vIGNoYXJzKVxuICAjIFxcdTAwM0EgLSBcXHUwMDNFICg6Ozw9PiBjaGFycylcbiAgIyBcXHUwMDQwICAgICAgICAgIChAIGNoYXIpXG4gICMgXFx1MDA1QiAtIFxcdTAwNUUgKFtcXF1eIGNoYXJzKVxuICAjIFxcdTAwNjAgICAgICAgICAgKGAgY2hhcilcbiAgIyBcXHUwMDdCIC0gXFx1MDA3RiAoe3x9fiBjaGFyc30pXG4gICMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gaWRlbnRpZmllciBpbiB0aGUgZW5kIG9mIGl0cyBuYW1lXG4gICMgSW4gZmFjdCwgRk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlMgPSBGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlMgKyBcXHUwMDIxICgnPycpICsgXFx1MDAzRiAoJyEnKVxuICBGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlMgICA9ICdcXHUwMDAxLVxcdTAwMjBcXHUwMDIyLVxcdTAwMkZcXHUwMDNBLVxcdTAwM0VcXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcbiAgSU5MSU5FX0lERU5USUZJRVJfUkVHRVhQID0gUmVnZXhwLm5ldyhcIlteI3tGT1JCSURERU5fU1RBUlRJTkdfSURFTlRJRklFUl9DSEFSU31dKlteI3tGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlN9XVwiKVxuXG4gICMgRm9yIGNvbnN0YW50cyBydWxlcyBhcmUgcHJldHR5IG11Y2ggdGhlIHNhbWUsIGJ1dCAnOicgaXMgYWxsb3dlZCBhbmQgJz8hJyBhcmUgbm90LlxuICAjIFBsdXMgaXQgbWF5IHN0YXJ0IHdpdGggYSAnOjonIHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZSBjb25zdGFudCBjb21lcyBmcm9tIHRvcGxldmVsLlxuICBGT1JCSURERU5fQ09OU1RfTkFNRV9DSEFSUyA9ICdcXHUwMDAxLVxcdTAwMjBcXHUwMDIxLVxcdTAwMkZcXHUwMDNCLVxcdTAwM0ZcXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcbiAgQ09OU1RfTkFNRV9SRUdFWFAgPSBSZWdleHAubmV3KFwiI3tSRUdFWFBfU1RBUlR9KDo6KT9bQS1aXVteI3tGT1JCSURERU5fQ09OU1RfTkFNRV9DSEFSU31dKiN7UkVHRVhQX0VORH1cIilcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsIm5ldyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFFQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQSw0Q0FBdUMsR0FBdkMsQ0FBQTtBQUFBLElBQ0EsMENBQXFDLEdBQXJDLENBREE7QUFBQSxJQVVBLG1FQUFzQyxxRUFBdEMsQ0FWQTtBQUFBLElBc0JBLGlFQUFzQywyRkFBdEMsQ0F0QkE7QUFBQSxJQXVCQSx3REFBMkIsc0JBQUFDLEtBQUFBLENBQVcsRUFBQSxHQUFBLElBQUEsR0FBQSxDQUFLLG1EQUFMLENBQUEsR0FBQSxNQUFBLEdBQUEsQ0FBK0MsaURBQS9DLENBQUEsR0FBQSxHQUFYQSxDQUEzQixDQXZCQTtBQUFBLElBMkJBLDBEQUE2QiwyRkFBN0IsQ0EzQkE7QUFBQSxJQTRCQSxPQUFBLGlEQUFvQixzQkFBQUEsS0FBQUEsQ0FBVyxFQUFBLEdBQUEsQ0FBRyw0QkFBSCxDQUFBLEdBQUEsY0FBQSxHQUFBLENBQThCLDBDQUE5QixDQUFBLEdBQUEsSUFBQSxHQUFBLENBQTZELDBCQUE3RCxDQUFYQSxDQUFwQixDQTVCQTtBQURGRCxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5MTg1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9taW5pLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ29wYWwvYmFzZSdcblxucmVxdWlyZSAnY29yZWxpYi9uaWwnXG5yZXF1aXJlICdjb3JlbGliL2Jvb2xlYW4nXG5yZXF1aXJlICdjb3JlbGliL3N0cmluZydcbnJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYXRvcidcbnJlcXVpcmUgJ2NvcmVsaWIvYXJyYXknXG5yZXF1aXJlICdjb3JlbGliL2hhc2gnXG5yZXF1aXJlICdjb3JlbGliL251bWJlcidcbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZ2UnXG5yZXF1aXJlICdjb3JlbGliL3Byb2MnXG5yZXF1aXJlICdjb3JlbGliL21ldGhvZCdcbnJlcXVpcmUgJ2NvcmVsaWIvcmVnZXhwJ1xucmVxdWlyZSAnY29yZWxpYi92YXJpYWJsZXMnXG5yZXF1aXJlICdjb3JlbGliL2lvJ1xucmVxdWlyZSAnb3BhbC9yZWdleHBfYW5jaG9ycydcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLFdBQVJBLENBQUE7QUFBQSxNQUVBQSxTQUFBQSxDQUFRLGFBQVJBLENBRkE7QUFBQSxNQUdBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQUhBO0FBQUEsTUFJQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FKQTtBQUFBLE1BS0FBLFNBQUFBLENBQVEsb0JBQVJBLENBTEE7QUFBQSxNQU1BQSxTQUFBQSxDQUFRLG9CQUFSQSxDQU5BO0FBQUEsTUFPQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FQQTtBQUFBLE1BUUFBLFNBQUFBLENBQVEsZUFBUkEsQ0FSQTtBQUFBLE1BU0FBLFNBQUFBLENBQVEsY0FBUkEsQ0FUQTtBQUFBLE1BVUFBLFNBQUFBLENBQVEsZ0JBQVJBLENBVkE7QUFBQSxNQVdBQSxTQUFBQSxDQUFRLGVBQVJBLENBWEE7QUFBQSxNQVlBQSxTQUFBQSxDQUFRLGNBQVJBLENBWkE7QUFBQSxNQWFBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQWJBO0FBQUEsTUFjQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FkQTtBQUFBLE1BZUFBLFNBQUFBLENBQVEsbUJBQVJBLENBZkE7QUFBQSxNQWdCQUEsU0FBQUEsQ0FBUSxZQUFSQSxDQWhCQTtBQUFBLEVBaUJBLFdBQUFBLFNBQUFBLENBQVEscUJBQVJBLENBakJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTkyMTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2tlcm5lbC9mb3JtYXQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBjb2VyY2VfdG9cblxubW9kdWxlIEtlcm5lbFxuICBkZWYgZm9ybWF0KGZvcm1hdF9zdHJpbmcsICphcmdzKVxuICAgIGlmIGFyZ3MubGVuZ3RoID09IDEgJiYgYXJnc1swXS5yZXNwb25kX3RvPyg6dG9fYXJ5KVxuICAgICAgYXJ5ID0gT3BhbC5jb2VyY2VfdG8/KGFyZ3NbMF0sIEFycmF5LCA6dG9fYXJ5KVxuICAgICAgYXJncyA9IGFyeS50b19hIHVubGVzcyBhcnkubmlsP1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgLy91c2VkIGZvciBzbGljaW5nOlxuICAgICAgICAgIGJlZ2luX3NsaWNlID0gMCxcbiAgICAgICAgICBlbmRfc2xpY2UsXG4gICAgICAgICAgLy91c2VkIGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgZm9ybWF0IHN0cmluZzpcbiAgICAgICAgICBpLFxuICAgICAgICAgIGxlbiA9IGZvcm1hdF9zdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyBmaWVsZCB2YWx1ZXM6XG4gICAgICAgICAgYXJnLFxuICAgICAgICAgIHN0cixcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJWcgYW5kICVHIGZpZWxkczpcbiAgICAgICAgICBleHBvbmVudCxcbiAgICAgICAgICAvL3VzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2Ygd2lkdGggYW5kIHByZWNpc2lvbjpcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgICAgLy91c2VkIGZvciBob2xkaW5nIHRlbXBvcmFyeSB2YWx1ZXM6XG4gICAgICAgICAgdG1wX251bSxcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJXt9IGFuZCAlPD4gZmlsZWRzOlxuICAgICAgICAgIGhhc2hfcGFyYW1ldGVyX2tleSxcbiAgICAgICAgICBjbG9zaW5nX2JyYWNlX2NoYXIsXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nICViLCAlQiwgJW8sICV4LCBhbmQgJVggZmllbGRzOlxuICAgICAgICAgIGJhc2VfbnVtYmVyLFxuICAgICAgICAgIGJhc2VfcHJlZml4LFxuICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXgsXG4gICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCxcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgIG5leHRfYXJnLFxuICAgICAgICAgIHNlcV9hcmdfbnVtID0gMSxcbiAgICAgICAgICBwb3NfYXJnX251bSA9IDAsXG4gICAgICAgICAgLy91c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIGZsYWdzOlxuICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgIEZOT05FICA9IDAsXG4gICAgICAgICAgRlNIQVJQID0gMSxcbiAgICAgICAgICBGTUlOVVMgPSAyLFxuICAgICAgICAgIEZQTFVTICA9IDQsXG4gICAgICAgICAgRlpFUk8gID0gOCxcbiAgICAgICAgICBGU1BBQ0UgPSAxNixcbiAgICAgICAgICBGV0lEVEggPSAzMixcbiAgICAgICAgICBGUFJFQyAgPSA2NCxcbiAgICAgICAgICBGUFJFQzAgPSAxMjg7XG5cbiAgICAgIGZ1bmN0aW9uIENIRUNLX0ZPUl9GTEFHUygpIHtcbiAgICAgICAgaWYgKGZsYWdzJkZXSURUSCkgeyAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdmbGFnIGFmdGVyIHdpZHRoJ30gfVxuICAgICAgICBpZiAoZmxhZ3MmRlBSRUMwKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2ZsYWcgYWZ0ZXIgcHJlY2lzaW9uJ30gfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBDSEVDS19GT1JfV0lEVEgoKSB7XG4gICAgICAgIGlmIChmbGFncyZGV0lEVEgpIHsgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd2lkdGggZ2l2ZW4gdHdpY2UnfSB9XG4gICAgICAgIGlmIChmbGFncyZGUFJFQzApIHsgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd2lkdGggYWZ0ZXIgcHJlY2lzaW9uJ30gfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfTlRIX0FSRyhudW0pIHtcbiAgICAgICAgaWYgKG51bSA+PSBhcmdzLmxlbmd0aCkgeyAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd0b28gZmV3IGFyZ3VtZW50cyd9IH1cbiAgICAgICAgcmV0dXJuIGFyZ3NbbnVtXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gR0VUX05FWFRfQVJHKCkge1xuICAgICAgICBzd2l0Y2ggKHBvc19hcmdfbnVtKSB7XG4gICAgICAgIGNhc2UgLTE6ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bm51bWJlcmVkKCN7YHNlcV9hcmdfbnVtYH0pIG1peGVkIHdpdGggbnVtYmVyZWRcIn1cbiAgICAgICAgY2FzZSAtMjogI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInVubnVtYmVyZWQoI3tgc2VxX2FyZ19udW1gfSkgbWl4ZWQgd2l0aCBuYW1lZFwifVxuICAgICAgICB9XG4gICAgICAgIHBvc19hcmdfbnVtID0gc2VxX2FyZ19udW0rKztcbiAgICAgICAgcmV0dXJuIEdFVF9OVEhfQVJHKHBvc19hcmdfbnVtIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9QT1NfQVJHKG51bSkge1xuICAgICAgICBpZiAocG9zX2FyZ19udW0gPiAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm51bWJlcmVkKCN7YG51bWB9KSBhZnRlciB1bm51bWJlcmVkKCN7YHBvc19hcmdfbnVtYH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc19hcmdfbnVtID09PSAtMikge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJudW1iZXJlZCgje2BudW1gfSkgYWZ0ZXIgbmFtZWRcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtIDwgMSkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGluZGV4IC0gI3tgbnVtYH0kXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcG9zX2FyZ19udW0gPSAtMTtcbiAgICAgICAgcmV0dXJuIEdFVF9OVEhfQVJHKG51bSAtIDEpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfQVJHKCkge1xuICAgICAgICByZXR1cm4gKG5leHRfYXJnID09PSB1bmRlZmluZWQgPyBHRVRfTkVYVF9BUkcoKSA6IG5leHRfYXJnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gUkVBRF9OVU0obGFiZWwpIHtcbiAgICAgICAgdmFyIG51bSwgc3RyID0gJyc7XG4gICAgICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPT09IGxlbikge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbWFsZm9ybWVkIGZvcm1hdCBzdHJpbmcgLSAlKlswLTldJ31cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckNvZGVBdChpKSA8IDQ4IHx8IGZvcm1hdF9zdHJpbmcuY2hhckNvZGVBdChpKSA+IDU3KSB7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgICBudW0gPSBwYXJzZUludChzdHIsIDEwKSB8fCAwO1xuICAgICAgICAgICAgaWYgKG51bSA+IDIxNDc0ODM2NDcpIHtcbiAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIiN7YGxhYmVsYH0gdG9vIGJpZ1wifVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyICs9IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFJFQURfTlVNX0FGVEVSX0FTVEVSKGxhYmVsKSB7XG4gICAgICAgIHZhciBhcmcsIG51bSA9IFJFQURfTlVNKGxhYmVsKTtcbiAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkgKyAxKSA9PT0gJyQnKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGFyZyA9IEdFVF9QT1NfQVJHKG51bSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJnID0gR0VUX05FWFRfQVJHKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICN7YGFyZ2AudG9faW50fTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gZm9ybWF0X3N0cmluZy5pbmRleE9mKCclJyk7IGkgIT09IC0xOyBpID0gZm9ybWF0X3N0cmluZy5pbmRleE9mKCclJywgaSkpIHtcbiAgICAgICAgc3RyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGZsYWdzID0gRk5PTkU7XG4gICAgICAgIHdpZHRoID0gLTE7XG4gICAgICAgIHByZWNpc2lvbiA9IC0xO1xuICAgICAgICBuZXh0X2FyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICBlbmRfc2xpY2UgPSBpO1xuXG4gICAgICAgIGkrKztcblxuICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgIGJlZ2luX3NsaWNlID0gaTtcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgY2FzZSAnXFwwJzpcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXRfc2VxdWVuY2U6IGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG5cbiAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlNQQUNFO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZTSEFSUDtcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGUExVUztcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGTUlOVVM7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlpFUk87XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICBjYXNlICcyJzpcbiAgICAgICAgICBjYXNlICczJzpcbiAgICAgICAgICBjYXNlICc0JzpcbiAgICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgICBjYXNlICc2JzpcbiAgICAgICAgICBjYXNlICc3JzpcbiAgICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgICBjYXNlICc5JzpcbiAgICAgICAgICAgIHRtcF9udW0gPSBSRUFEX05VTSgnd2lkdGgnKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpICsgMSkgPT09ICckJykge1xuICAgICAgICAgICAgICBpZiAoaSArIDIgPT09IGxlbikge1xuICAgICAgICAgICAgICAgIHN0ciA9ICclJztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuZXh0X2FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInZhbHVlIGdpdmVuIHR3aWNlIC0gJSN7YHRtcF9udW1gfSRcIn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXh0X2FyZyA9IEdFVF9QT1NfQVJHKHRtcF9udW0pO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBDSEVDS19GT1JfV0lEVEgoKTtcbiAgICAgICAgICAgICAgZmxhZ3MgfD0gRldJRFRIO1xuICAgICAgICAgICAgICB3aWR0aCA9IHRtcF9udW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXNlICdcXHsnOlxuICAgICAgICAgICAgY2xvc2luZ19icmFjZV9jaGFyID0gKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSAnPCcgPyAnPicgOiAnXFx9Jyk7XG4gICAgICAgICAgICBoYXNoX3BhcmFtZXRlcl9rZXkgPSAnJztcblxuICAgICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgICBmb3IgKDs7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbWFsZm9ybWVkIG5hbWUgLSB1bm1hdGNoZWQgcGFyZW50aGVzaXMnfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gY2xvc2luZ19icmFjZV9jaGFyKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zX2FyZ19udW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibmFtZWQgI3tgaGFzaF9wYXJhbWV0ZXJfa2V5YH0gYWZ0ZXIgdW5udW1iZXJlZCgje2Bwb3NfYXJnX251bWB9KVwifVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zX2FyZ19udW0gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibmFtZWQgI3tgaGFzaF9wYXJhbWV0ZXJfa2V5YH0gYWZ0ZXIgbnVtYmVyZWRcIn1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zX2FyZ19udW0gPSAtMjtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdID09PSB1bmRlZmluZWQgfHwgIWFyZ3NbMF0uJCRpc19oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdvbmUgaGFzaCByZXF1aXJlZCd9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV4dF9hcmcgPSAje2BhcmdzWzBdYC5mZXRjaChgaGFzaF9wYXJhbWV0ZXJfa2V5YCl9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGNsb3NpbmdfYnJhY2VfY2hhciA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ciA9IG5leHRfYXJnLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAtMSkgeyBzdHIgPSBzdHIuc2xpY2UoMCwgcHJlY2lzaW9uKTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5ICs9IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBDSEVDS19GT1JfV0lEVEgoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZXSURUSDtcbiAgICAgICAgICAgIHdpZHRoID0gUkVBRF9OVU1fQUZURVJfQVNURVIoJ3dpZHRoJyk7XG4gICAgICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICAgIGZsYWdzIHw9IEZNSU5VUztcbiAgICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIGlmIChmbGFncyZGUFJFQzApIHtcbiAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAncHJlY2lzaW9uIGdpdmVuIHR3aWNlJ31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZsYWdzIHw9IEZQUkVDfEZQUkVDMDtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IDA7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09ICcqJykge1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIHByZWNpc2lvbiA9IFJFQURfTlVNX0FGVEVSX0FTVEVSKCdwcmVjaXNpb24nKTtcbiAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbiA8IDApIHtcbiAgICAgICAgICAgICAgICBmbGFncyAmPSB+RlBSRUM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlY2lzaW9uID0gUkVBRF9OVU0oJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICBhcmcgPSAje0ludGVnZXIoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCkge1xuICAgICAgICAgICAgICBzdHIgPSBhcmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gKChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpID8gMSA6IDApKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSAyO1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcwYic7XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXggPSAvXjErLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICcxJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSA4O1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcwJztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCA9IC9eMz83Ky87XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fZGlnaXQgPSAnNyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSAxNjtcbiAgICAgICAgICAgICAgYmFzZV9wcmVmaXggPSAnMHgnO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4ID0gL15mKy87XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fZGlnaXQgPSAnZic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnID0gI3tJbnRlZ2VyKGBHRVRfQVJHKClgKX07XG4gICAgICAgICAgICBpZiAoYXJnID49IDApIHtcbiAgICAgICAgICAgICAgc3RyID0gYXJnLnRvU3RyaW5nKGJhc2VfbnVtYmVyKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkgLSAoKGZsYWdzJkZTSEFSUCAmJiBhcmcgIT09IDApID8gYmFzZV9wcmVmaXgubGVuZ3RoIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvU3RyaW5nKGJhc2VfbnVtYmVyKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSAtIChmbGFncyZGU0hBUlAgPyAyIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciA9IChhcmcgPj4+IDApLnRvU3RyaW5nKGJhc2VfbnVtYmVyKS5yZXBsYWNlKGJhc2VfbmVnX3plcm9fcmVnZXgsIGJhc2VfbmVnX3plcm9fZGlnaXQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uIC0gMikgeyBzdHIgPSBiYXNlX25lZ196ZXJvX2RpZ2l0ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAyIC0gKGZsYWdzJkZTSEFSUCA/IGJhc2VfcHJlZml4Lmxlbmd0aCA6IDApKSB7IHN0ciA9IGJhc2VfbmVnX3plcm9fZGlnaXQgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgIHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICBhcmcgPSAje0Zsb2F0KGBHRVRfQVJHKClgKX07XG4gICAgICAgICAgICBpZiAoYXJnID49IDAgfHwgaXNOYU4oYXJnKSkge1xuICAgICAgICAgICAgICBpZiAoYXJnID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHN0ciA9ICdJbmYnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b0ZpeGVkKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gYXJnLnRvRXhwb25lbnRpYWwocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9FeHBvbmVudGlhbCgpO1xuICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBwYXJzZUludChzdHIuc3BsaXQoJ2UnKVsxXSwgMTApO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoZXhwb25lbnQgPCAtNCB8fCBleHBvbmVudCA+PSAocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9QcmVjaXNpb24ocHJlY2lzaW9uID09PSAtMSA/IChmbGFncyZGU0hBUlAgPyA2IDogdW5kZWZpbmVkKSA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIGFyZyAhPT0gSW5maW5pdHkgJiYgIWlzTmFOKGFyZykpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJ0luZic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvRml4ZWQocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9FeHBvbmVudGlhbChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b0V4cG9uZW50aWFsKCk7XG4gICAgICAgICAgICAgICAgICBleHBvbmVudCA9IHBhcnNlSW50KHN0ci5zcGxpdCgnZScpWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShleHBvbmVudCA8IC00IHx8IGV4cG9uZW50ID49IChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b1ByZWNpc2lvbihwcmVjaXNpb24gPT09IC0xID8gKGZsYWdzJkZTSEFSUCA/IDYgOiB1bmRlZmluZWQpIDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIGFyZyAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkudG9VcHBlckNhc2UoKSAmJiBhcmcgIT09IEluZmluaXR5ICYmIGFyZyAhPT0gLUluZmluaXR5ICYmICFpc05hTihhcmcpKSB7XG4gICAgICAgICAgICAgIHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhbZUVdWy0rXT8pKFswLTldKSQvLCAnJDEwJDInKTtcbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgLy8gTm90IGltcGxlbWVudGVkIGJlY2F1c2UgdGhlcmUgYXJlIG5vIHNwZWNzIGZvciB0aGlzIGZpZWxkIHR5cGUuXG4gICAgICAgICAgICAje3JhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdgQWAgYW5kIGBhYCBmb3JtYXQgZmllbGQgdHlwZXMgYXJlIG5vdCBpbXBsZW1lbnRlZCBpbiBPcGFsIHlldCd9XG5cbiAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIGFyZyA9IEdFVF9BUkcoKTtcbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19hcnkpfSkgeyBhcmcgPSAje2BhcmdgLnRvX2FyeX1bMF07IH1cbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19zdHIpfSkge1xuICAgICAgICAgICAgICBzdHIgPSAje2BhcmdgLnRvX3N0cn07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCRjb2VyY2VfdG8oYXJnLCAje0ludGVnZXJ9LCAndG9faW50JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnJWMgcmVxdWlyZXMgYSBjaGFyYWN0ZXInfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgc3RyID0gI3tgR0VUX0FSRygpYC5pbnNwZWN0fTtcbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24gIT09IC0xKSB7IHN0ciA9IHN0ci5zbGljZSgwLCBwcmVjaXNpb24pOyB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBzdHIgPSAje2BHRVRfQVJHKClgLnRvX3N9O1xuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gLTEpIHsgc3RyID0gc3RyLnNsaWNlKDAsIHByZWNpc2lvbik7IH1cbiAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm1hbGZvcm1lZCBmb3JtYXQgc3RyaW5nIC0gJSN7YGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpYH1cIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdtYWxmb3JtZWQgZm9ybWF0IHN0cmluZyAtICUnfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ICs9IGZvcm1hdF9zdHJpbmcuc2xpY2UoYmVnaW5fc2xpY2UsIGVuZF9zbGljZSkgKyBzdHI7XG4gICAgICAgIGJlZ2luX3NsaWNlID0gaSArIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICgjeyRERUJVR30gJiYgcG9zX2FyZ19udW0gPj0gMCAmJiBzZXFfYXJnX251bSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3RvbyBtYW55IGFyZ3VtZW50cyBmb3IgZm9ybWF0IHN0cmluZyd9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQgKyBmb3JtYXRfc3RyaW5nLnNsaWNlKGJlZ2luX3NsaWNlKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNwcmludGYgZm9ybWF0XG5lbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJmb3JtYXQiLCIkcmV0X29yXzEiLCJhcmdzIiwibGVuZ3RoIiwiPT0iLCIxIiwiW10iLCIwIiwicmVzcG9uZF90bz8iLCJhcnkiLCJjb2VyY2VfdG8/IiwibmlsPyIsInRvX2EiLCJyYWlzZSIsInRvX2ludCIsImZldGNoIiwiSW50ZWdlciIsIkZsb2F0IiwidG9fYXJ5IiwidG9fc3RyIiwiaW5zcGVjdCIsInRvX3MiLCIkREVCVUciXSwibWFwcGluZ3MiOiI7Ozs7O0VBRUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFO0FBQUFDLElBQUFBLDBCQUFBQSxtQkFBQUEsa0JBQVcsYUFBRCxFQUpaLEVBSUVBO0FBQUFBLE1BQUFBO0FBQUFBOztBQUFBQTtBQUpGO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBSTRCLE1BQUEsa0JBSjVCO0FBQUEsTUFLSSxJQUFBLFFBQUcsYUFBQSxJQUFBLFFBTFBDLENBQUFBLFlBS09DLElBQUFDLFFBQUFBLENBQUFBLENBQUFDLE9BQUFBLENBQWVDLENBQWZELENBTFBILENBS08sQ0FBQTtBQUFBLFFBQW9CLE9BQUFDLElBQUFJLE9BQUFBLENBQUtDLENBQUxELENBQUFFLGdCQUFBQSxDQUFvQixRQUFwQkE7QUFBcEIsTUFBQTtBQUFBLFFBTFAsT0FBQTtBQUtPLE1BQUEsQ0FBQSxrQkFBSCxDQUFBO0FBQUE7QUFDRSxRQUFBQyxNQUFNLG9CQUFBQyxlQUFBQSxDQUFnQlIsSUFBQUksT0FBQUEsQ0FBS0MsQ0FBTEQsR0FBUyx1QkFBTyxRQUFoQ0ksQ0FBTjtBQUFBLFFBQ0EsSUFBQSxRQUF1QkQsR0FBQUUsU0FBQUEsQ0FBQUEsQ0FBdkIsQ0FBQTtBQUFBLFFBQUE7QUFBQSxVQUFBVCxPQUFPTyxHQUFBRyxNQUFBQSxDQUFBQTtBQUFQLFFBQUEsQ0FEQSxDQURGLENBTEo7QUFBQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQThCQyxPQUFBQSxDQUFNLCtCQUFlLGtCQUFyQkEsQ0FBd0M7QUFDdEUsZ0NBQThCQSxPQUFBQSxDQUFNLCtCQUFlLHNCQUFyQkEsQ0FBNEM7QUFDMUU7O0FBRUE7QUFDQSxnQ0FBOEJBLE9BQUFBLENBQU0sK0JBQWUsbUJBQXJCQSxDQUF5QztBQUN2RSxnQ0FBOEJBLE9BQUFBLENBQU0sK0JBQWUsdUJBQXJCQSxDQUE2QztBQUMzRTs7QUFFQTtBQUNBLHNDQUFvQ0EsT0FBQUEsQ0FBTSwrQkFBZSxtQkFBckJBLENBQXlDO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFtQkEsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsYUFBQSxHQUFBLENBQWUsV0FBZixDQUFBLEdBQUEsdUJBQXJCQTtBQUNuQixxQkFBbUJBLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLGFBQUEsR0FBQSxDQUFlLFdBQWYsQ0FBQSxHQUFBLG9CQUFyQkE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQVlBLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLFdBQUEsR0FBQSxDQUFhLEdBQWIsQ0FBQSxHQUFBLHFCQUFBLEdBQUEsQ0FBd0MsV0FBeEMsQ0FBQSxHQUFBLEdBQXJCQTtBQUNaO0FBQ0E7QUFDQSxjQUFZQSxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSxXQUFBLEdBQUEsQ0FBYSxHQUFiLENBQUEsR0FBQSxlQUFyQkE7QUFDWjtBQUNBO0FBQ0EsY0FBWUEsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsa0JBQUEsR0FBQSxDQUFvQixHQUFwQixDQUFBLEdBQUEsR0FBckJBO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWNBLE9BQUFBLENBQU0sK0JBQWUsbUNBQXJCQTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZ0JBLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLENBQUksS0FBSixDQUFBLEdBQUEsVUFBckJBO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBaUIsQ0FBQyxHQUFELENBQUFDLFFBQUFBLENBQUFBLENBQWE7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQWtCRCxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSx1QkFBQSxHQUFBLENBQXlCLE9BQXpCLENBQUEsR0FBQSxHQUFyQkE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBa0JBLE9BQUFBLENBQU0sK0JBQWUsd0NBQXJCQTtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esc0JBQW9CQSxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSxRQUFBLEdBQUEsQ0FBVSxrQkFBVixDQUFBLEdBQUEsb0JBQUEsR0FBQSxDQUFtRCxXQUFuRCxDQUFBLEdBQUEsR0FBckJBO0FBQ3BCO0FBQ0E7QUFDQSxzQkFBb0JBLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLFFBQUEsR0FBQSxDQUFVLGtCQUFWLENBQUEsR0FBQSxpQkFBckJBO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBb0JBLE9BQUFBLENBQU0sK0JBQWUsbUJBQXJCQTtBQUNwQjs7QUFFQSwyQkFBNkIsQ0FBQyxPQUFELENBQUFFLE9BQUFBLENBQWlCLGtCQUFqQkEsQ0FBc0M7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWdCRixPQUFBQSxDQUFNLCtCQUFlLHVCQUFyQkE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBb0JHLFNBQUFBLENBQVMsU0FBVEEsQ0FBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBb0JBLFNBQUFBLENBQVMsU0FBVEEsQ0FBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFvQkMsT0FBQUEsQ0FBTyxTQUFQQSxDQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFjSixPQUFBQSxDQUFNLHFDQUFxQixnRUFBM0JBOztBQUVkO0FBQ0E7QUFDQSxnQkFBa0IsQ0FBQyxHQUFELENBQUFMLGdCQUFBQSxDQUFrQixRQUFsQkEsQ0FBMkIsVUFBWSxDQUFDLEdBQUQsQ0FBQVUsUUFBQUEsQ0FBQUEsQ0FBYTtBQUN0RSxnQkFBa0IsQ0FBQyxHQUFELENBQUFWLGdCQUFBQSxDQUFrQixRQUFsQkEsQ0FBMkI7QUFDN0Msb0JBQXNCLENBQUMsR0FBRCxDQUFBVyxRQUFBQSxDQUFBQSxDQUFhO0FBQ25DO0FBQ0Esd0RBQTBELHVCQUFRO0FBQ2xFO0FBQ0E7QUFDQSxrQkFBZ0JOLE9BQUFBLENBQU0sK0JBQWUseUJBQXJCQTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFvQixDQUFDLFNBQUQsQ0FBQU8sU0FBQUEsQ0FBQUEsQ0FBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBb0IsQ0FBQyxTQUFELENBQUFDLE1BQUFBLENBQUFBLENBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWNSLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLDZCQUFBLEdBQUEsQ0FBK0IsdUJBQS9CLENBQXJCQTtBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFZQSxPQUFBQSxDQUFNLCtCQUFlLDZCQUFyQkE7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBWVMsWUFBTztBQUNuQixZQUFVVCxPQUFBQSxDQUFNLCtCQUFlLHNDQUFyQkE7QUFDVjs7QUFFQTtBQUNBLElBOWhCQTtBQUlFYixJQUFBQSxDQUFBQSwrQkFBQUEsQ0FBQTtBQUFBLElBNmhCQSxPQUFBLGlCQUFNLFNBQU4sRUFBYyxRQUFkLENBN2hCQTtBQURGRCxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5NzgwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9zdHJpbmcnXG5cbmNsYXNzIEVuY29kaW5nXG4gIGRlZiBzZWxmLnJlZ2lzdGVyKG5hbWUsIG9wdGlvbnMgPSB7fSwgJmJsb2NrKVxuICAgIG5hbWVzID0gW25hbWVdICsgKG9wdGlvbnNbOmFsaWFzZXNdIHx8IFtdKVxuICAgIGFzY2lpID0gb3B0aW9uc1s6YXNjaWldIHx8IGZhbHNlXG4gICAgZHVtbXkgPSBvcHRpb25zWzpkdW1teV0gfHwgZmFsc2VcblxuICAgIGlmIG9wdGlvbnNbOmluaGVyaXRzXVxuICAgICAgZW5jb2RpbmcgPSBvcHRpb25zWzppbmhlcml0c10uY2xvbmVcbiAgICAgIGVuY29kaW5nLmluaXRpYWxpemUobmFtZSwgbmFtZXMsIGFzY2lpLCBkdW1teSlcbiAgICBlbHNlXG4gICAgICBlbmNvZGluZyA9IG5ldyhuYW1lLCBuYW1lcywgYXNjaWksIGR1bW15KVxuICAgIGVuZFxuICAgIGVuY29kaW5nLmluc3RhbmNlX2V2YWwoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cblxuICAgIHJlZ2lzdGVyID0gYE9wYWwuZW5jb2RpbmdzYFxuICAgIG5hbWVzLmVhY2ggZG8gfGVuY29kaW5nX25hbWV8XG4gICAgICBjb25zdF9zZXQgZW5jb2RpbmdfbmFtZS50cignLScsICdfJyksIGVuY29kaW5nXG4gICAgICByZWdpc3Rlci5KU1tlbmNvZGluZ19uYW1lXSA9IGVuY29kaW5nXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmZpbmQobmFtZSlcbiAgICByZXR1cm4gZGVmYXVsdF9leHRlcm5hbCBpZiBuYW1lID09IDpkZWZhdWx0X2V4dGVybmFsXG4gICAgYHJldHVybiBPcGFsLmZpbmRfZW5jb2RpbmcobmFtZSlgXG4gIGVuZFxuXG4gIHNpbmdsZXRvbl9jbGFzcy5hdHRyX2FjY2Vzc29yIDpkZWZhdWx0X2V4dGVybmFsXG5cbiAgYXR0cl9yZWFkZXIgOm5hbWUsIDpuYW1lc1xuXG4gIGRlZiBpbml0aWFsaXplKG5hbWUsIG5hbWVzLCBhc2NpaSwgZHVtbXkpXG4gICAgQG5hbWUgID0gbmFtZVxuICAgIEBuYW1lcyA9IG5hbWVzXG4gICAgQGFzY2lpID0gYXNjaWlcbiAgICBAZHVtbXkgPSBkdW1teVxuICBlbmRcblxuICBkZWYgYXNjaWlfY29tcGF0aWJsZT9cbiAgICBAYXNjaWlcbiAgZW5kXG5cbiAgZGVmIGR1bW15P1xuICAgIEBkdW1teVxuICBlbmRcblxuICBkZWYgYmluYXJ5P1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgQG5hbWVcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8RW5jb2Rpbmc6I3tAbmFtZX0jeycgKGR1bW15KScgaWYgQGR1bW15fT5cIlxuICBlbmRcblxuICAjIG1ldGhvZHMgdG8gaW1wbGVtZW50IHBlciBlbmNvZGluZ1xuICBkZWYgY2hhcnNpemUoc3RyaW5nKVxuICAgICV4e1xuICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoIShjaGFyY29kZSA+PSAweEQ4MDAgJiYgY2hhcmNvZGUgPD0gMHhEQkZGKSkge1xuICAgICAgICAgIGxlbisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfY2hhcihzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBsb3dfc3Vycm9nYXRlID0gXCJcIjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBjaHIgPSBzdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICBpZiAoY2hhcmNvZGUgPj0gMHhEQzAwICYmIGNoYXJjb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgIGxvd19zdXJyb2dhdGUgPSBjaHI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhcmNvZGUgPj0gMHhEODAwICYmIGNoYXJjb2RlIDw9IDB4REJGRikge1xuICAgICAgICAgIGNociA9IGxvd19zdXJyb2dhdGUgKyBjaHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmluZy5lbmNvZGluZy5uYW1lICE9IFwiVVRGLThcIikge1xuICAgICAgICAgIGNociA9IG5ldyBTdHJpbmcoY2hyKTtcbiAgICAgICAgICBjaHIuZW5jb2RpbmcgPSBzdHJpbmcuZW5jb2Rpbmc7XG4gICAgICAgIH1cbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIGNocik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9ieXRlKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gIGNsYXNzIEVuY29kaW5nRXJyb3IgPCBTdGFuZGFyZEVycm9yOyBlbmRcbiAgY2xhc3MgQ29tcGF0aWJpbGl0eUVycm9yIDwgRW5jb2RpbmdFcnJvcjsgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VURi04JywgYWxpYXNlczogWydDUDY1MDAxJ10sIGFzY2lpOiB0cnVlIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAvLyBUYWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iL2Y1MmRmZmQ5ZGYwNDQ1YjkzYzBjOTA2NWMyZjhmMGY0NmIyYzcyOWEvaW5kZXguanMjTDE5NTQtTDIwMzJcbiAgICAgIHZhciB1bml0cyA9IEluZmluaXR5XG4gICAgICB2YXIgY29kZVBvaW50XG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICAgICAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgICAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhFRmB9O1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4QkZgfTtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkge1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4RUZgfTtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEJGYH07XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICN7eWllbGQgYDB4RUZgfTtcbiAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgICAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAje3lpZWxkIGAweEJGYH07XG4gICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgICAgICAvLyBlbmNvZGUgdXRmOFxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4NiB8IDB4QzBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCAmIDB4M0YgfCAweDgwYH07XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEludmFsaWQgY29kZSBwb2ludFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIHN0cmluZy5ieXRlcy5sZW5ndGhcbiAgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0xNkxFJyBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgPj4gOGB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBgc3RyaW5nLmxlbmd0aCAqIDJgXG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtMTZCRScsIGluaGVyaXRzOiBFbmNvZGluZzo6VVRGXzE2TEUgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtMzJMRScgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIGBjb2RlICYgMHhmZmB9O1xuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgICAgI3t5aWVsZCAwfTtcbiAgICAgICAgI3t5aWVsZCAwfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZShzdHJpbmcpXG4gICAgYHN0cmluZy5sZW5ndGggKiA0YFxuICBlbmRcbmVuZFxuXG5FbmNvZGluZy5yZWdpc3RlciAnVVRGLTMyQkUnLCBpbmhlcml0czogRW5jb2Rpbmc6OlVURl8zMkxFIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgI3t5aWVsZCAwfTtcbiAgICAgICAgI3t5aWVsZCAwfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcbmVuZFxuXG5FbmNvZGluZy5yZWdpc3RlciAnQVNDSUktOEJJVCcsIGFsaWFzZXM6IFsnQklOQVJZJ10sIGFzY2lpOiB0cnVlIGRvXG4gIGRlZiBlYWNoX2NoYXIoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaHIgPSBuZXcgU3RyaW5nKHN0cmluZy5jaGFyQXQoaSkpO1xuICAgICAgICBjaHIuZW5jb2RpbmcgPSBzdHJpbmcuZW5jb2Rpbmc7XG4gICAgICAgICN7eWllbGQgYGNocmB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNoYXJzaXplKHN0cmluZylcbiAgICBgc3RyaW5nLmxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZShzdHJpbmcpXG4gICAgYHN0cmluZy5sZW5ndGhgXG4gIGVuZFxuXG4gIGRlZiBiaW5hcnk/XG4gICAgdHJ1ZVxuICBlbmRcbmVuZFxuXG5FbmNvZGluZy5yZWdpc3RlciAnSVNPLTg4NTktMScsIGFsaWFzZXM6IFsnSVNPODg1OS0xJ10sIGFzY2lpOiB0cnVlLCBpbmhlcml0czogRW5jb2Rpbmc6OkFTQ0lJXzhCSVRcbkVuY29kaW5nLnJlZ2lzdGVyICdVUy1BU0NJSScsIGFsaWFzZXM6IFsnQVNDSUknXSwgYXNjaWk6IHRydWUsIGluaGVyaXRzOiBFbmNvZGluZzo6QVNDSUlfOEJJVFxuXG5jbGFzcyBTdHJpbmdcbiAgYXR0cl9yZWFkZXIgOmVuY29kaW5nXG4gIGF0dHJfcmVhZGVyIDppbnRlcm5hbF9lbmNvZGluZ1xuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCAnYnl0ZXMnLCBuaWwpYFxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCAnZW5jb2RpbmcnLCAje0VuY29kaW5nOjpVVEZfOH0pYFxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCAnaW50ZXJuYWxfZW5jb2RpbmcnLCAje0VuY29kaW5nOjpVVEZfOH0pYFxuXG4gIGRlZiBiXG4gICAgZHVwLmZvcmNlX2VuY29kaW5nKCdiaW5hcnknKVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemVcbiAgICBAaW50ZXJuYWxfZW5jb2RpbmcuYnl0ZXNpemUoc2VsZilcbiAgZW5kXG5cbiAgZGVmIGVhY2hfYnl0ZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2J5dGUpIHsgYnl0ZXNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBAaW50ZXJuYWxfZW5jb2RpbmcuZWFjaF9ieXRlKHNlbGYsICZibG9jaylcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzXG4gICAgIyBSRU1JTkQ6IHJlcXVpcmVkIHdoZW4gcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgb3RoZXJ3aXNlIHRoZSBmb2xsb3dpbmcgZXJyb3Igd2lsbCBiZSB0aHJvd246XG4gICAgIyBDYW5ub3QgY3JlYXRlIHByb3BlcnR5ICdieXRlcycgb24gc3RyaW5nICdhYmMnXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIHNlbGYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAje2BuZXcgU3RyaW5nKHNlbGYpYC5lYWNoX2J5dGUudG9fYX07XG4gICAgICB9XG4gICAgfVxuXG4gICAgQGJ5dGVzIHx8PSBlYWNoX2J5dGUudG9fYVxuICAgIEBieXRlcy5kdXBcbiAgZW5kXG5cbiAgZGVmIGVhY2hfY2hhcigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2NoYXIpIHsgbGVuZ3RoIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgQGVuY29kaW5nLmVhY2hfY2hhcihzZWxmLCAmYmxvY2spXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjaGFycygmYmxvY2spXG4gICAgcmV0dXJuIGVhY2hfY2hhci50b19hIHVubGVzcyBibG9ja1xuXG4gICAgZWFjaF9jaGFyKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGVhY2hfY29kZXBvaW50KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfY29kZXBvaW50IHVubGVzcyBibG9ja19naXZlbj9cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICN7eWllbGQgYHNlbGYuY29kZVBvaW50QXQoaSlgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY29kZXBvaW50cygmYmxvY2spXG4gICAgIyBJZiBhIGJsb2NrIGlzIGdpdmVuLCB3aGljaCBpcyBhIGRlcHJlY2F0ZWQgZm9ybSwgd29ya3MgdGhlIHNhbWUgYXMgZWFjaF9jb2RlcG9pbnQuXG4gICAgcmV0dXJuIGVhY2hfY29kZXBvaW50KCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgZWFjaF9jb2RlcG9pbnQudG9fYVxuICBlbmRcblxuICBkZWYgZW5jb2RlKGVuY29kaW5nKVxuICAgIGBPcGFsLmVuYyhzZWxmLCBlbmNvZGluZylgXG4gIGVuZFxuXG4gIGRlZiBmb3JjZV9lbmNvZGluZyhlbmNvZGluZylcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBzZWxmO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHN0ci5lbmNvZGluZykgeyByZXR1cm4gc3RyOyB9XG5cbiAgICAgIGVuY29kaW5nID0gI3tPcGFsLmNvZXJjZV90byEoZW5jb2RpbmcsIFN0cmluZywgOnRvX3MpfTtcbiAgICAgIGVuY29kaW5nID0gI3tFbmNvZGluZy5maW5kKGVuY29kaW5nKX07XG5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gc3RyLmVuY29kaW5nKSB7IHJldHVybiBzdHI7IH1cblxuICAgICAgc3RyID0gT3BhbC5zZXRfZW5jb2Rpbmcoc3RyLCBlbmNvZGluZyk7XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2V0Ynl0ZShpZHgpXG4gICAgc3RyaW5nX2J5dGVzID0gYnl0ZXNcbiAgICBpZHggPSBPcGFsLmNvZXJjZV90byEoaWR4LCBJbnRlZ2VyLCA6dG9faW50KVxuICAgIHJldHVybiBpZiBzdHJpbmdfYnl0ZXMubGVuZ3RoIDwgaWR4XG5cbiAgICBzdHJpbmdfYnl0ZXNbaWR4XVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxuICAgICV7XG4gICAgICBzZWxmLmVuY29kaW5nID0gb3RoZXIuZW5jb2Rpbmc7XG4gICAgICBzZWxmLmludGVybmFsX2VuY29kaW5nID0gb3RoZXIuaW50ZXJuYWxfZW5jb2Rpbmc7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYHNlbGYubGVuZ3RoYFxuICBlbmRcblxuICBhbGlhcyBzaXplIGxlbmd0aFxuXG4gICMgc3R1YlxuICBkZWYgdmFsaWRfZW5jb2Rpbmc/XG4gICAgdHJ1ZVxuICBlbmRcbmVuZFxuXG5FbmNvZGluZy5kZWZhdWx0X2V4dGVybmFsID0gX19FTkNPRElOR19fXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwicmVnaXN0ZXIiLCJzZWxmIiwibmFtZXMiLCIrIiwibmFtZSIsIiRyZXRfb3JfMSIsIm9wdGlvbnMiLCJbXSIsImFzY2lpIiwiJHJldF9vcl8yIiwiZHVtbXkiLCIkcmV0X29yXzMiLCJlbmNvZGluZyIsImNsb25lIiwiaW5pdGlhbGl6ZSIsIm5ldyIsImJsb2NrX2dpdmVuPyIsImluc3RhbmNlX2V2YWwiLCJibG9jayIsImVhY2giLCJjb25zdF9zZXQiLCJlbmNvZGluZ19uYW1lIiwidHIiLCJmaW5kIiwiPT0iLCJkZWZhdWx0X2V4dGVybmFsIiwic2luZ2xldG9uX2NsYXNzIiwiYXR0cl9hY2Nlc3NvciIsImF0dHJfcmVhZGVyIiwiQG5hbWUiLCJAbmFtZXMiLCJAYXNjaWkiLCJAZHVtbXkiLCJhc2NpaV9jb21wYXRpYmxlPyIsImR1bW15PyIsImJpbmFyeT8iLCJ0b19zIiwiaW5zcGVjdCIsImNoYXJzaXplIiwiZWFjaF9jaGFyIiwiZWFjaF9ieXRlIiwicmFpc2UiLCJieXRlc2l6ZSIsInN0cmluZyIsImJ5dGVzIiwibGVuZ3RoIiwiMCIsImIiLCJkdXAiLCJmb3JjZV9lbmNvZGluZyIsIkBpbnRlcm5hbF9lbmNvZGluZyIsImVudW1fZm9yIiwidG9fYSIsIkBieXRlcyIsIiRyZXRfb3JfNCIsIkBlbmNvZGluZyIsImNoYXJzIiwiZWFjaF9jb2RlcG9pbnQiLCJjb2RlcG9pbnRzIiwiZW5jb2RlIiwiY29lcmNlX3RvISIsImdldGJ5dGUiLCJzdHJpbmdfYnl0ZXMiLCJpZHgiLCI8IiwiaW5pdGlhbGl6ZV9jb3B5IiwidmFsaWRfZW5jb2Rpbmc/IiwiJHdyaXRlciIsImRlZmF1bHRfZXh0ZXJuYWw9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Im1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL21hdGgucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0eXBlX2Vycm9yXG5cbm1vZHVsZSBNYXRoXG4gIEUgID0gYE1hdGguRWBcbiAgUEkgPSBgTWF0aC5QSWBcblxuICBEb21haW5FcnJvciA9IENsYXNzLm5ldyhTdGFuZGFyZEVycm9yKVxuXG4gIGRlZiBzZWxmLmNoZWNrZWQobWV0aG9kLCAqYXJncylcbiAgICAleHtcbiAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCAoYXJncy5sZW5ndGggPT0gMiAmJiBpc05hTihhcmdzWzFdKSkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IE1hdGhbbWV0aG9kXS5hcHBseShudWxsLCBhcmdzKTtcblxuICAgICAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgI3tyYWlzZSBEb21haW5FcnJvciwgXCJOdW1lcmljYWwgYXJndW1lbnQgaXMgb3V0IG9mIGRvbWFpbiAtIFxcXCIje21ldGhvZH1cXFwiXCJ9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuZmxvYXQhKHZhbHVlKVxuICAgIEZsb2F0KHZhbHVlKVxuICByZXNjdWUgQXJndW1lbnRFcnJvclxuICAgIHJhaXNlIGAkdHlwZV9lcnJvcih2YWx1ZSwgI3tGbG9hdH0pYFxuICBlbmRcblxuICBkZWYgc2VsZi5pbnRlZ2VyISh2YWx1ZSlcbiAgICBJbnRlZ2VyKHZhbHVlKVxuICByZXNjdWUgQXJndW1lbnRFcnJvclxuICAgIHJhaXNlIGAkdHlwZV9lcnJvcih2YWx1ZSwgI3tJbnRlZ2VyfSlgXG4gIGVuZFxuXG4gIG1vZHVsZV9mdW5jdGlvblxuXG4gIGRlZiBhY29zKHgpXG4gICAgTWF0aC5jaGVja2VkIDphY29zLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguYWNvc2hgKVxuICAgICV4e1xuICAgICAgTWF0aC5hY29zaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKHggKyBNYXRoLnNxcnQoeCAqIHggLSAxKSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYWNvc2goeClcbiAgICBNYXRoLmNoZWNrZWQgOmFjb3NoLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgYXNpbih4KVxuICAgIE1hdGguY2hlY2tlZCA6YXNpbiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmFzaW5oYClcbiAgICAleHtcbiAgICAgIE1hdGguYXNpbmggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpXG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXNpbmgoeClcbiAgICBNYXRoLmNoZWNrZWQgOmFzaW5oLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgYXRhbih4KVxuICAgIE1hdGguY2hlY2tlZCA6YXRhbiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGF0YW4yKHksIHgpXG4gICAgTWF0aC5jaGVja2VkIDphdGFuMiwgTWF0aC5mbG9hdCEoeSksIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5hdGFuaGApXG4gICAgJXh7XG4gICAgICBNYXRoLmF0YW5oID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gMC41ICogTWF0aC5sb2coKDEgKyB4KSAvICgxIC0geCkpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGF0YW5oKHgpXG4gICAgTWF0aC5jaGVja2VkIDphdGFuaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmNicnRgKVxuICAgICV4e1xuICAgICAgTWF0aC5jYnJ0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoeCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gLU1hdGguY2JydCgteCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgciAgPSB4LFxuICAgICAgICAgICAgZXggPSAwO1xuXG4gICAgICAgIHdoaWxlIChyIDwgMC4xMjUpIHtcbiAgICAgICAgICByICo9IDg7XG4gICAgICAgICAgZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChyID4gMS4wKSB7XG4gICAgICAgICAgciAqPSAwLjEyNTtcbiAgICAgICAgICBleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgciA9ICgtMC40Njk0NjExNiAqIHIgKyAxLjA3MjMwMikgKiByICsgMC4zODEyNTEzO1xuXG4gICAgICAgIHdoaWxlIChleCA8IDApIHtcbiAgICAgICAgICByICo9IDAuNTtcbiAgICAgICAgICBleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGV4ID4gMCkge1xuICAgICAgICAgIHIgKj0gMjtcbiAgICAgICAgICBleC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgciA9ICgyLjAgLyAzLjApICogciArICgxLjAgLyAzLjApICogeCAvIChyICogcik7XG4gICAgICAgIHIgPSAoMi4wIC8gMy4wKSAqIHIgKyAoMS4wIC8gMy4wKSAqIHggLyAociAqIHIpO1xuICAgICAgICByID0gKDIuMCAvIDMuMCkgKiByICsgKDEuMCAvIDMuMCkgKiB4IC8gKHIgKiByKTtcbiAgICAgICAgciA9ICgyLjAgLyAzLjApICogciArICgxLjAgLyAzLjApICogeCAvIChyICogcik7XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2JydCh4KVxuICAgIE1hdGguY2hlY2tlZCA6Y2JydCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGNvcyh4KVxuICAgIE1hdGguY2hlY2tlZCA6Y29zLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguY29zaGApXG4gICAgJXh7XG4gICAgICBNYXRoLmNvc2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb3NoKHgpXG4gICAgTWF0aC5jaGVja2VkIDpjb3NoLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguZXJmYClcbiAgICAleHtcbiAgICAgIE9wYWwuZGVmaW5lUHJvcGVydHkoTWF0aCwgJ2VyZicsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIEExID0gIDAuMjU0ODI5NTkyLFxuICAgICAgICAgICAgQTIgPSAtMC4yODQ0OTY3MzYsXG4gICAgICAgICAgICBBMyA9ICAxLjQyMTQxMzc0MSxcbiAgICAgICAgICAgIEE0ID0gLTEuNDUzMTUyMDI3LFxuICAgICAgICAgICAgQTUgPSAgMS4wNjE0MDU0MjksXG4gICAgICAgICAgICBQICA9ICAwLjMyNzU5MTE7XG5cbiAgICAgICAgdmFyIHNpZ24gPSAxO1xuXG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgeCA9IE1hdGguYWJzKHgpO1xuXG4gICAgICAgIHZhciB0ID0gMS4wIC8gKDEuMCArIFAgKiB4KTtcbiAgICAgICAgdmFyIHkgPSAxLjAgLSAoKCgoKEE1ICogdCArIEE0KSAqIHQpICsgQTMpICogdCArIEEyKSAqIHQgKyBBMSkgKiB0ICogTWF0aC5leHAoLXggKiB4KTtcblxuICAgICAgICByZXR1cm4gc2lnbiAqIHk7XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlcmYoeClcbiAgICBNYXRoLmNoZWNrZWQgOmVyZiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmVyZmNgKVxuICAgICV4e1xuICAgICAgT3BhbC5kZWZpbmVQcm9wZXJ0eShNYXRoLCAnZXJmYycsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIHogPSBNYXRoLmFicyh4KSxcbiAgICAgICAgICAgIHQgPSAxLjAgLyAoMC41ICogeiArIDEuMCk7XG5cbiAgICAgICAgdmFyIEExID0gdCAqIDAuMTcwODcyNzcgKyAtMC44MjIxNTIyMyxcbiAgICAgICAgICAgIEEyID0gdCAqIEExICsgMS40ODg1MTU4NyxcbiAgICAgICAgICAgIEEzID0gdCAqIEEyICsgLTEuMTM1MjAzOTgsXG4gICAgICAgICAgICBBNCA9IHQgKiBBMyArIDAuMjc4ODY4MDcsXG4gICAgICAgICAgICBBNSA9IHQgKiBBNCArIC0wLjE4NjI4ODA2LFxuICAgICAgICAgICAgQTYgPSB0ICogQTUgKyAwLjA5Njc4NDE4LFxuICAgICAgICAgICAgQTcgPSB0ICogQTYgKyAwLjM3NDA5MTk2LFxuICAgICAgICAgICAgQTggPSB0ICogQTcgKyAxLjAwMDAyMzY4LFxuICAgICAgICAgICAgQTkgPSB0ICogQTgsXG4gICAgICAgICAgICBBMTAgPSAteiAqIHogLSAxLjI2NTUxMjIzICsgQTk7XG5cbiAgICAgICAgdmFyIGEgPSB0ICogTWF0aC5leHAoQTEwKTtcblxuICAgICAgICBpZiAoeCA8IDAuMCkge1xuICAgICAgICAgIHJldHVybiAyLjAgLSBhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlcmZjKHgpXG4gICAgTWF0aC5jaGVja2VkIDplcmZjLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgZXhwKHgpXG4gICAgTWF0aC5jaGVja2VkIDpleHAsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBmcmV4cCh4KVxuICAgIHggPSBNYXRoLmZsb2F0ISh4KVxuXG4gICAgJXh7XG4gICAgICBpZiAoaXNOYU4oeCkpIHtcbiAgICAgICAgcmV0dXJuIFtOYU4sIDBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXggICA9IE1hdGguZmxvb3IoTWF0aC5sb2coTWF0aC5hYnMoeCkpIC8gTWF0aC5sb2coMikpICsgMSxcbiAgICAgICAgICBmcmFjID0geCAvIE1hdGgucG93KDIsIGV4KTtcblxuICAgICAgcmV0dXJuIFtmcmFjLCBleF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2FtbWEobilcbiAgICBuID0gTWF0aC5mbG9hdCEobilcblxuICAgICV4e1xuICAgICAgdmFyIGksIHQsIHgsIHZhbHVlLCByZXN1bHQsIHR3b04sIHRocmVlTiwgZm91ck4sIGZpdmVOO1xuXG4gICAgICB2YXIgRyA9IDQuNzQyMTg3NTtcblxuICAgICAgdmFyIFAgPSBbXG4gICAgICAgICAwLjk5OTk5OTk5OTk5OTk5NzA5MTgyLFxuICAgICAgICAgNTcuMTU2MjM1NjY1ODYyOTIzNTE3LFxuICAgICAgICAtNTkuNTk3OTYwMzU1NDc1NDkxMjQ4LFxuICAgICAgICAgMTQuMTM2MDk3OTc0NzQxNzQ3MTc0LFxuICAgICAgICAtMC40OTE5MTM4MTYwOTc2MjAxOTk3OCxcbiAgICAgICAgIDAuMzM5OTQ2NDk5ODQ4MTE4ODg2OTllLTQsXG4gICAgICAgICAwLjQ2NTIzNjI4OTI3MDQ4NTc1NjY1ZS00LFxuICAgICAgICAtMC45ODM3NDQ3NTMwNDg3OTU2NDY3N2UtNCxcbiAgICAgICAgIDAuMTU4MDg4NzAzMjI0OTEyNDg4ODRlLTMsXG4gICAgICAgIC0wLjIxMDI2NDQ0MTcyNDEwNDg4MzE5ZS0zLFxuICAgICAgICAgMC4yMTc0Mzk2MTgxMTUyMTI2NDMyMGUtMyxcbiAgICAgICAgLTAuMTY0MzE4MTA2NTM2NzYzODkwMjJlLTMsXG4gICAgICAgICAwLjg0NDE4MjIzOTgzODUyNzQzMjkzZS00LFxuICAgICAgICAtMC4yNjE5MDgzODQwMTU4MTQwODY3MGUtNCxcbiAgICAgICAgIDAuMzY4OTkxODI2NTk1MzE2MjI3MDRlLTVcbiAgICAgIF07XG5cblxuICAgICAgaWYgKGlzTmFOKG4pKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG5cbiAgICAgIGlmIChuID09PSAwICYmIDEgLyBuIDwgMCkge1xuICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAobiA9PT0gLTEgfHwgbiA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICN7cmFpc2UgRG9tYWluRXJyb3IsICdOdW1lcmljYWwgYXJndW1lbnQgaXMgb3V0IG9mIGRvbWFpbiAtIFwiZ2FtbWFcIid9O1xuICAgICAgfVxuXG4gICAgICBpZiAoI3tJbnRlZ2VyID09PSBufSkge1xuICAgICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGlzRmluaXRlKG4pID8gSW5maW5pdHkgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobiA+IDE3MSkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlICA9IG4gLSAyO1xuICAgICAgICByZXN1bHQgPSBuIC0gMTtcblxuICAgICAgICB3aGlsZSAodmFsdWUgPiAxKSB7XG4gICAgICAgICAgcmVzdWx0ICo9IHZhbHVlO1xuICAgICAgICAgIHZhbHVlLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0ID09IDApIHtcbiAgICAgICAgICByZXN1bHQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPCAwLjUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgLyAoTWF0aC5zaW4oTWF0aC5QSSAqIG4pICogI3tNYXRoLmdhbW1hKDEgLSBuKX0pO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA+PSAxNzEuMzUpIHtcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAobiA+IDg1LjApIHtcbiAgICAgICAgdHdvTiAgID0gbiAqIG47XG4gICAgICAgIHRocmVlTiA9IHR3b04gKiBuO1xuICAgICAgICBmb3VyTiAgPSB0aHJlZU4gKiBuO1xuICAgICAgICBmaXZlTiAgPSBmb3VyTiAqIG47XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgyICogTWF0aC5QSSAvIG4pICogTWF0aC5wb3coKG4gLyBNYXRoLkUpLCBuKSAqXG4gICAgICAgICAgKDEgKyAxIC8gKDEyICogbikgKyAxIC8gKDI4OCAqIHR3b04pIC0gMTM5IC8gKDUxODQwICogdGhyZWVOKSAtXG4gICAgICAgICAgNTcxIC8gKDI0ODgzMjAgKiBmb3VyTikgKyAxNjM4NzkgLyAoMjA5MDE4ODgwICogZml2ZU4pICtcbiAgICAgICAgICA1MjQ2ODE5IC8gKDc1MjQ2Nzk2ODAwICogZml2ZU4gKiBuKSk7XG4gICAgICB9XG5cbiAgICAgIG4gLT0gMTtcbiAgICAgIHggID0gUFswXTtcblxuICAgICAgZm9yIChpID0gMTsgaSA8IFAubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeCArPSBQW2ldIC8gKG4gKyBpKTtcbiAgICAgIH1cblxuICAgICAgdCA9IG4gKyBHICsgMC41O1xuXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJKSAqIE1hdGgucG93KHQsIG4gKyAwLjUpICogTWF0aC5leHAoLXQpICogeDtcbiAgICB9XG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5oeXBvdGApXG4gICAgJXh7XG4gICAgICBNYXRoLmh5cG90ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpXG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaHlwb3QoeCwgeSlcbiAgICBNYXRoLmNoZWNrZWQgOmh5cG90LCBNYXRoLmZsb2F0ISh4KSwgTWF0aC5mbG9hdCEoeSlcbiAgZW5kXG5cbiAgZGVmIGxkZXhwKG1hbnRpc3NhLCBleHBvbmVudClcbiAgICBtYW50aXNzYSA9IE1hdGguZmxvYXQhKG1hbnRpc3NhKVxuICAgIGV4cG9uZW50ID0gTWF0aC5pbnRlZ2VyIShleHBvbmVudClcblxuICAgICV4e1xuICAgICAgaWYgKGlzTmFOKGV4cG9uZW50KSkge1xuICAgICAgICAje3JhaXNlIFJhbmdlRXJyb3IsICdmbG9hdCBOYU4gb3V0IG9mIHJhbmdlIG9mIGludGVnZXInfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hbnRpc3NhICogTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxnYW1tYShuKVxuICAgICV4e1xuICAgICAgaWYgKG4gPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFtJbmZpbml0eSwgMV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtNYXRoLmxvZyhNYXRoLmFicygje01hdGguZ2FtbWEobil9KSksICN7TWF0aC5nYW1tYShuKX0gPCAwID8gLTEgOiAxXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsb2coeCwgYmFzZSA9IHVuZGVmaW5lZClcbiAgICBpZiBTdHJpbmcgPT09IHhcbiAgICAgIHJhaXNlIGAkdHlwZV9lcnJvcih4LCAje0Zsb2F0fSlgXG4gICAgZW5kXG5cbiAgICBpZiBgYmFzZSA9PSBudWxsYFxuICAgICAgTWF0aC5jaGVja2VkIDpsb2csIE1hdGguZmxvYXQhKHgpXG4gICAgZWxzZVxuICAgICAgaWYgU3RyaW5nID09PSBiYXNlXG4gICAgICAgIHJhaXNlIGAkdHlwZV9lcnJvcihiYXNlLCAje0Zsb2F0fSlgXG4gICAgICBlbmRcblxuICAgICAgTWF0aC5jaGVja2VkKDpsb2csIE1hdGguZmxvYXQhKHgpKSAvIE1hdGguY2hlY2tlZCg6bG9nLCBNYXRoLmZsb2F0IShiYXNlKSlcbiAgICBlbmRcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmxvZzEwYClcbiAgICAleHtcbiAgICAgIE1hdGgubG9nMTAgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsb2cxMCh4KVxuICAgIGlmIFN0cmluZyA9PT0geFxuICAgICAgcmFpc2UgYCR0eXBlX2Vycm9yKHgsICN7RmxvYXR9KWBcbiAgICBlbmRcblxuICAgIE1hdGguY2hlY2tlZCA6bG9nMTAsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5sb2cyYClcbiAgICAleHtcbiAgICAgIE1hdGgubG9nMiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjI7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbG9nMih4KVxuICAgIGlmIFN0cmluZyA9PT0geFxuICAgICAgcmFpc2UgYCR0eXBlX2Vycm9yKHgsICN7RmxvYXR9KWBcbiAgICBlbmRcblxuICAgIE1hdGguY2hlY2tlZCA6bG9nMiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIHNpbih4KVxuICAgIE1hdGguY2hlY2tlZCA6c2luLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguc2luaGApXG4gICAgJXh7XG4gICAgICBNYXRoLnNpbmggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaW5oKHgpXG4gICAgTWF0aC5jaGVja2VkIDpzaW5oLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgc3FydCh4KVxuICAgIE1hdGguY2hlY2tlZCA6c3FydCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIHRhbih4KVxuICAgIHggPSBNYXRoLmZsb2F0ISh4KVxuXG4gICAgaWYgeC5pbmZpbml0ZT9cbiAgICAgIHJldHVybiBGbG9hdDo6TkFOXG4gICAgZW5kXG5cbiAgICBNYXRoLmNoZWNrZWQgOnRhbiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLnRhbmhgKVxuICAgICV4e1xuICAgICAgTWF0aC50YW5oID0gZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoeCA9PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHggPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpIC8gKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRhbmgoeClcbiAgICBNYXRoLmNoZWNrZWQgOnRhbmgsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwibmV3IiwiY2hlY2tlZCIsInNlbGYiLCJyYWlzZSIsIm1ldGhvZCIsImZsb2F0ISIsIkZsb2F0IiwidmFsdWUiLCJpbnRlZ2VyISIsIkludGVnZXIiLCJtb2R1bGVfZnVuY3Rpb24iLCJhY29zIiwieCIsImFjb3NoIiwiYXNpbiIsImFzaW5oIiwiYXRhbiIsImF0YW4yIiwieSIsImF0YW5oIiwiY2JydCIsImNvcyIsImNvc2giLCJlcmYiLCJlcmZjIiwiZXhwIiwiZnJleHAiLCJnYW1tYSIsIm4iLCI9PT0iLCItIiwiMSIsImh5cG90IiwibGRleHAiLCJtYW50aXNzYSIsImV4cG9uZW50IiwibGdhbW1hIiwibG9nIiwiYmFzZSIsIi8iLCJsb2cxMCIsImxvZzIiLCJzaW4iLCJzaW5oIiwic3FydCIsInRhbiIs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiRSxJQUFBLENBN2JBO0FBQUEsSUE2Y0EsT0FBQUUsQ0FBQUEsd0JBQUFBLGdCQUFBQSxnQkFBUyxDQUFUQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLG9CQUFBOUMsU0FBQUEsQ0FBYSxRQUFPLG9CQUFBSSxXQUFBQSxDQUFZTyxDQUFaUCxDQUFwQko7QUFERjhDLElBQUFBLENBQUFBLDJCQUFBQSxDQUFBQSxnQkE3Y0E7QUFERmhELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjA5NTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbXBsZXgucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyBDb21wbGV4IDwgTnVtZXJpY1xuICBkZWYgc2VsZi5yZWN0KHJlYWwsIGltYWcgPSAwKVxuICAgIHVubGVzcyBOdW1lcmljID09PSByZWFsICYmIHJlYWwucmVhbD8gJiYgTnVtZXJpYyA9PT0gaW1hZyAmJiBpbWFnLnJlYWw/XG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdub3QgYSByZWFsJ1xuICAgIGVuZFxuXG4gICAgbmV3KHJlYWwsIGltYWcpXG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnBvbGFyKHIsIHRoZXRhID0gMClcbiAgICB1bmxlc3MgTnVtZXJpYyA9PT0gciAmJiByLnJlYWw/ICYmIE51bWVyaWMgPT09IHRoZXRhICYmIHRoZXRhLnJlYWw/XG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdub3QgYSByZWFsJ1xuICAgIGVuZFxuXG4gICAgbmV3KHIgKiBNYXRoLmNvcyh0aGV0YSksIHIgKiBNYXRoLnNpbih0aGV0YSkpXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpyZWFsLCA6aW1hZ1xuXG4gIGRlZiBpbml0aWFsaXplKHJlYWwsIGltYWcgPSAwKVxuICAgIEByZWFsID0gcmVhbFxuICAgIEBpbWFnID0gaW1hZ1xuICBlbmRcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBbb3RoZXIsIHNlbGZdXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIFtDb21wbGV4Lm5ldyhvdGhlciwgMCksIHNlbGZdXG4gICAgZWxzZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7b3RoZXIuY2xhc3N9IGNhbid0IGJlIGNvZXJjZWQgaW50byBDb21wbGV4XCJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBAcmVhbCA9PSBvdGhlci5yZWFsICYmIEBpbWFnID09IG90aGVyLmltYWdcbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQHJlYWwgPT0gb3RoZXIgJiYgQGltYWcgPT0gMFxuICAgIGVsc2VcbiAgICAgIG90aGVyID09IHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgQ29tcGxleCgtQHJlYWwsIC1AaW1hZylcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgaWYgQ29tcGxleCA9PT0gb3RoZXJcbiAgICAgIENvbXBsZXgoQHJlYWwgKyBvdGhlci5yZWFsLCBAaW1hZyArIG90aGVyLmltYWcpXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIENvbXBsZXgoQHJlYWwgKyBvdGhlciwgQGltYWcpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOissIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBDb21wbGV4KEByZWFsIC0gb3RoZXIucmVhbCwgQGltYWcgLSBvdGhlci5pbWFnKVxuICAgIGVsc2lmIE51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICBDb21wbGV4KEByZWFsIC0gb3RoZXIsIEBpbWFnKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDotLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgQ29tcGxleChAcmVhbCAqIG90aGVyLnJlYWwgLSBAaW1hZyAqIG90aGVyLmltYWcsXG4gICAgICAgIEByZWFsICogb3RoZXIuaW1hZyArIEBpbWFnICogb3RoZXIucmVhbCxcbiAgICAgIClcbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQ29tcGxleChAcmVhbCAqIG90aGVyLCBAaW1hZyAqIG90aGVyKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLyhvdGhlcilcbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgaWYgKE51bWJlciA9PT0gQHJlYWwgJiYgQHJlYWwubmFuPykgfHwgKE51bWJlciA9PT0gQGltYWcgJiYgQGltYWcubmFuPykgfHxcbiAgICAgICAgIChOdW1iZXIgPT09IG90aGVyLnJlYWwgJiYgb3RoZXIucmVhbC5uYW4/KSB8fCAoTnVtYmVyID09PSBvdGhlci5pbWFnICYmIG90aGVyLmltYWcubmFuPylcbiAgICAgICAgQ29tcGxleC5uZXcoRmxvYXQ6Ok5BTiwgRmxvYXQ6Ok5BTilcbiAgICAgIGVsc2VcbiAgICAgICAgc2VsZiAqIG90aGVyLmNvbmogLyBvdGhlci5hYnMyXG4gICAgICBlbmRcbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQ29tcGxleChAcmVhbC5xdW8ob3RoZXIpLCBAaW1hZy5xdW8ob3RoZXIpKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDovLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgaWYgb3RoZXIgPT0gMFxuICAgICAgcmV0dXJuIENvbXBsZXgubmV3KDEsIDApXG4gICAgZW5kXG5cbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgciwgdGhldGEgPSBwb2xhclxuICAgICAgb3JlICAgICAgPSBvdGhlci5yZWFsXG4gICAgICBvaW0gICAgICA9IG90aGVyLmltYWdcbiAgICAgIG5yICAgICAgID0gTWF0aC5leHAob3JlICogTWF0aC5sb2cocikgLSBvaW0gKiB0aGV0YSlcbiAgICAgIG50aGV0YSAgID0gdGhldGEgKiBvcmUgKyBvaW0gKiBNYXRoLmxvZyhyKVxuXG4gICAgICBDb21wbGV4LnBvbGFyKG5yLCBudGhldGEpXG4gICAgZWxzaWYgSW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIGlmIG90aGVyID4gMFxuICAgICAgICB4ID0gc2VsZlxuICAgICAgICB6ID0geFxuICAgICAgICBuID0gb3RoZXIgLSAxXG5cbiAgICAgICAgd2hpbGUgbiAhPSAwXG4gICAgICAgICAgZGl2LCBtb2QgPSBuLmRpdm1vZCgyKVxuICAgICAgICAgIHdoaWxlIG1vZCA9PSAwXG4gICAgICAgICAgICB4ID0gQ29tcGxleCh4LnJlYWwgKiB4LnJlYWwgLSB4LmltYWcgKiB4LmltYWcsIDIgKiB4LnJlYWwgKiB4LmltYWcpXG4gICAgICAgICAgICBuID0gZGl2XG4gICAgICAgICAgICBkaXYsIG1vZCA9IG4uZGl2bW9kKDIpXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgICB6ICo9IHhcbiAgICAgICAgICBuIC09IDFcbiAgICAgICAgZW5kXG5cbiAgICAgICAgelxuICAgICAgZWxzZVxuICAgICAgICAoUmF0aW9uYWwubmV3KDEsIDEpIC8gc2VsZikqKi1vdGhlclxuICAgICAgZW5kXG4gICAgZWxzaWYgRmxvYXQgPT09IG90aGVyIHx8IFJhdGlvbmFsID09PSBvdGhlclxuICAgICAgciwgdGhldGEgPSBwb2xhclxuXG4gICAgICBDb21wbGV4LnBvbGFyKHIqKm90aGVyLCB0aGV0YSAqIG90aGVyKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqKiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGFic1xuICAgIE1hdGguaHlwb3QoQHJlYWwsIEBpbWFnKVxuICBlbmRcblxuICBkZWYgYWJzMlxuICAgIEByZWFsICogQHJlYWwgKyBAaW1hZyAqIEBpbWFnXG4gIGVuZFxuXG4gIGRlZiBhbmdsZVxuICAgIE1hdGguYXRhbjIoQGltYWcsIEByZWFsKVxuICBlbmRcblxuICBhbGlhcyBhcmcgYW5nbGVcblxuICBkZWYgY29ualxuICAgIENvbXBsZXgoQHJlYWwsIC1AaW1hZylcbiAgZW5kXG5cbiAgYWxpYXMgY29uanVnYXRlIGNvbmpcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBAcmVhbC5kZW5vbWluYXRvci5sY20oQGltYWcuZGVub21pbmF0b3IpXG4gIGVuZFxuXG4gIGFsaWFzIGRpdmlkZSAvXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgQ29tcGxleCA9PT0gb3RoZXIgJiYgQHJlYWwuY2xhc3MgPT0gQGltYWcuY2xhc3MgJiYgc2VsZiA9PSBvdGhlclxuICBlbmRcblxuICBkZWYgZmRpdihvdGhlcilcbiAgICB1bmxlc3MgTnVtZXJpYyA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje290aGVyLmNsYXNzfSBjYW4ndCBiZSBjb2VyY2VkIGludG8gQ29tcGxleFwiXG4gICAgZW5kXG5cbiAgICBzZWxmIC8gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGZpbml0ZT9cbiAgICBAcmVhbC5maW5pdGU/ICYmIEBpbWFnLmZpbml0ZT9cbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBcIkNvbXBsZXg6I3tAcmVhbH06I3tAaW1hZ31cIlxuICBlbmRcblxuICBhbGlhcyBpbWFnaW5hcnkgaW1hZ1xuXG4gIGRlZiBpbmZpbml0ZT9cbiAgICBAcmVhbC5pbmZpbml0ZT8gfHwgQGltYWcuaW5maW5pdGU/XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIoI3tzZWxmfSlcIlxuICBlbmRcblxuICBhbGlhcyBtYWduaXR1ZGUgYWJzXG5cbiAgdW5kZWYgbmVnYXRpdmU/XG5cbiAgZGVmIG51bWVyYXRvclxuICAgIGQgPSBkZW5vbWluYXRvclxuXG4gICAgQ29tcGxleChAcmVhbC5udW1lcmF0b3IgKiAoZCAvIEByZWFsLmRlbm9taW5hdG9yKSxcbiAgICAgIEBpbWFnLm51bWVyYXRvciAqIChkIC8gQGltYWcuZGVub21pbmF0b3IpLFxuICAgIClcbiAgZW5kXG5cbiAgYWxpYXMgcGhhc2UgYXJnXG5cbiAgZGVmIHBvbGFyXG4gICAgW2FicywgYXJnXVxuICBlbmRcblxuICB1bmRlZiBwb3NpdGl2ZT9cblxuICBhbGlhcyBxdW8gL1xuXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMSlcIn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgQGltYWcgIT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCcgY29udmVydCAje3NlbGZ9IGludG8gUmF0aW9uYWxcIlxuICAgIGVuZFxuXG4gICAgcmVhbC5yYXRpb25hbGl6ZShlcHMpXG4gIGVuZFxuXG4gIGRlZiByZWFsP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiByZWN0XG4gICAgW0ByZWFsLCBAaW1hZ11cbiAgZW5kXG5cbiAgYWxpYXMgcmVjdGFuZ3VsYXIgcmVjdFxuXG4gIHVuZGVmIHN0ZXBcblxuICBkZWYgdG9fZlxuICAgIHVubGVzcyBAaW1hZyA9PSAwXG4gICAgICByYWlzZSBSYW5nZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWxmfSBpbnRvIEZsb2F0XCJcbiAgICBlbmRcblxuICAgIEByZWFsLnRvX2ZcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBJbnRlZ2VyXCJcbiAgICBlbmRcblxuICAgIEByZWFsLnRvX2lcbiAgZW5kXG5cbiAgZGVmIHRvX3JcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBSYXRpb25hbFwiXG4gICAgZW5kXG5cbiAgICBAcmVhbC50b19yXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgcmVzdWx0ID0gQHJlYWwuaW5zcGVjdFxuXG4gICAgcmVzdWx0ICs9XG4gICAgICBpZiAoTnVtYmVyID09PSBAaW1hZyAmJiBAaW1hZy5uYW4/KSB8fCBAaW1hZy5wb3NpdGl2ZT8gfHwgQGltYWcuemVybz9cbiAgICAgICAgJysnXG4gICAgICBlbHNlXG4gICAgICAgICctJ1xuICAgICAgZW5kXG5cbiAgICByZXN1bHQgKz0gQGltYWcuYWJzLmluc3BlY3RcblxuICAgIGlmIE51bWJlciA9PT0gQGltYWcgJiYgKEBpbWFnLm5hbj8gfHwgQGltYWcuaW5maW5pdGU/KVxuICAgICAgcmVzdWx0ICs9ICcqJ1xuICAgIGVuZFxuXG4gICAgcmVzdWx0ICsgJ2knXG4gIGVuZFxuXG4gIEkgPSBuZXcoMCwgMSlcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBDb21wbGV4KHJlYWwsIGltYWcgPSBuaWwpXG4gICAgaWYgaW1hZ1xuICAgICAgQ29tcGxleC5uZXcocmVhbCwgaW1hZylcbiAgICBlbHNlXG4gICAgICBDb21wbGV4Lm5ldyhyZWFsLCAwKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHJpbmdcbiAgZGVmIHRvX2NcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBzZWxmLFxuICAgICAgICAgIHJlID0gL1srLV0/W1xcZF9dKyhcXC5bXFxkX10rKT8oZVxcZCspPy8sXG4gICAgICAgICAgbWF0Y2ggPSBzdHIubWF0Y2gocmUpLFxuICAgICAgICAgIHJlYWwsIGltYWcsIGRlbm9taW5hdG9yO1xuXG4gICAgICBmdW5jdGlvbiBpc0Zsb2F0KCkge1xuICAgICAgICByZXR1cm4gcmUudGVzdChzdHIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXRGbG9hdCgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlKTtcbiAgICAgICAgdmFyIG51bWJlciA9IG1hdGNoWzBdO1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UobnVtYmVyLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBudW1iZXIucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZXMgYm90aCBmbG9hdHMgYW5kIHJhdGlvbmFsc1xuICAgICAgZnVuY3Rpb24gY3V0TnVtYmVyKCkge1xuICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgICAgdmFyIG51bWVyYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG5cbiAgICAgICAgICBpZiAoc3RyWzBdID09PSAnLycpIHtcbiAgICAgICAgICAgIC8vIHJhdGlvbmFsIHJlYWwgcGFydFxuICAgICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuXG4gICAgICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG4gICAgICAgICAgICAgIHJldHVybiAje1JhdGlvbmFsKGBudW1lcmF0b3JgLCBgZGVub21pbmF0b3JgKX07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZXZlcnRpbmcgJy8nXG4gICAgICAgICAgICAgIHN0ciA9ICcvJyArIHN0cjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bWVyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZmxvYXQgcmVhbCBwYXJ0LCBubyBkZW5vbWluYXRvclxuICAgICAgICAgICAgcmV0dXJuIG51bWVyYXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVhbCA9IGN1dE51bWJlcigpO1xuXG4gICAgICBpZiAoIXJlYWwpIHtcbiAgICAgICAgaWYgKHN0clswXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gaSA9PiBDb21wbGV4KDAsIDEpXG4gICAgICAgICAgcmV0dXJuICN7Q29tcGxleCgwLCAxKX07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJy0nICYmIHN0clsxXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gLWkgPT4gQ29tcGxleCgwLCAtMSlcbiAgICAgICAgICByZXR1cm4gI3tDb21wbGV4KDAsIC0xKX07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJysnICYmIHN0clsxXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gK2kgPT4gQ29tcGxleCgwLCAxKVxuICAgICAgICAgIHJldHVybiAje0NvbXBsZXgoMCwgMSl9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFueXRoaW5nID0+IENvbXBsZXgoMCwgMClcbiAgICAgICAgcmV0dXJuICN7Q29tcGxleCgwLCAwKX07XG4gICAgICB9XG5cbiAgICAgIGltYWcgPSBjdXROdW1iZXIoKTtcbiAgICAgIGlmICghaW1hZykge1xuICAgICAgICBpZiAoc3RyWzBdID09PSAnaScpIHtcbiAgICAgICAgICAvLyAzaSA9PiBDb21wbGV4KDAsIDMpXG4gICAgICAgICAgcmV0dXJuICN7Q29tcGxleCgwLCBgcmVhbGApfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAzID0+IENvbXBsZXgoMywgMClcbiAgICAgICAgICByZXR1cm4gI3tDb21wbGV4KGByZWFsYCwgMCl9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAzKzJpID0+IENvbXBsZXgoMywgMilcbiAgICAgICAgcmV0dXJuICN7Q29tcGxleChgcmVhbGAsIGBpbWFnYCl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJyZWN0Iiwic2VsZiIsIjAiLCIkcmV0X29yXzEiLCIkcmV0X29yXzIiLCIkcmV0X29yXzMiLCI9PT0iLCJyZWFsIiwicmVhbD8iLCJpbWFnIiwicmFpc2UiLCJuZXciLCJwb2xhciIsIiRyZXRfb3JfNCIsIiRyZXRfb3JfNSIsIiRyZXRfb3JfNiIsInIiLCJ0aGV0YSIsIioiLCJjb3MiLCJzaW4iLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJAcmVhbCIsIkBpbWFnIiwiY29lcmNlIiwib3RoZXIiLCIkcmV0X29yXzciLCI9PSIsIiRyZXRfb3JfOCIsIiRyZXRfb3JfOSIsIiRyZXRfb3JfMTAiLCItQCIsIkNvbXBsZXgiLCIrIiwiJHJldF9vcl8xMSIsIl9fY29lcmNlZF9fIiwiLSIsIiRyZXRfb3JfMTIiLCIkcmV0X29yXzEzIiwiLyIsIiRyZXRfb3JfMTQiLCIkcmV0X29yXzE1IiwiJHJldF9vcl8xNiIsIiRyZXRfb3JfMTciLCJuYW4/IiwiJHJldF9vcl8xOCIsIiRyZXRfb3JfMTkiLCIkcmV0X29yXzIwIiwiY29uaiIsImFiczIiLCIkcmV0X29yXzIxIiwicXVvIiwiKioiLCIxIiwib3JlIiwib2ltIiwibnIiLCJleHAiLCJsb2ciLCJudGhldGEiLCI+IiwieCIsInoiLCJuIiwiIT0iLCJkaXZtb2QiLCIyIiwiZGl2IiwibW9kIiwiJHJldF9vcl8yMiIsImFicyIsImh5cG90IiwiYW5nbGUiLCJhdGFuMiIsImRlbm9taW5hdG9yIiwibGNtIiwiZXFsPyIsIiRyZXRfb3JfMjMiLCIkcmV0X29yXzI0IiwiZmRpdiIsImZpbml0ZT8iLCIkcmV0X29yXzI1IiwiaGFzaCIsImluZmluaXRlPyIsIiRyZXRfb3JfMjYiLCJpbnNwZWN0IiwibnVtZXJhdG9yIiwiZCIsImFyZyIsInJhdGlvbmFsaXplIiwiZXBzIiwidG9fZiIsInRvX2kiLCJ0b19yIiwidG9fcyIsInJlc3VsdCIsIiRyZXRfb3JfMjciLCIkcmV0X29yXzI4IiwiJHJldF9vcl8yOSIsInBvc2l0aXZlPyIsInplcm8/IiwiJHJldF9vcl8zMCIsIiRyZXRfb3JfMzEiLCJtb2R1bGUiLCJ0b19jIiwiUmF0aW9uYWwiLCItMSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxpQkFBUkEsQ0FBQTtBQUFBLEVBRUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxJQUFBQyxVQUFJQyxJQUFKRCxXQUFBQSxrQkFBQUEsZ0JBQWMsSUFBRCxFQUFPLElBQXBCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFKRjtBQUlzQixNQUFBO0FBQUEsTUFBQSxTQUFPRSxDQUFQO0FBQUEsTUFBQSxDQUp0QjtBQUFBLE1BS0ksSUFBQSxRQUFPLGFBQUEsSUFBQSxRQUxYQyxDQUFBQSxZQUtXLGFBQUEsSUFBQSxRQUxYQyxDQUFBQSxZQUtXLGFBQUEsSUFBQSxRQUxYQyxDQUFBQSxZQUtXLHVCQUFBQyxRQUFBQSxDQUFZQyxJQUFaRCxDQUxYRCxDQUtXLENBQUE7QUFBQSxRQUFvQixPQUFBRSxJQUFBQyxVQUFBQSxDQUFBQTtBQUFwQixNQUFBO0FBQUEsUUFMWCxPQUFBO0FBS1csTUFBQSxDQUFBLGtCQUxYSixDQUtXLENBQUE7QUFBQSxRQUFrQyxPQUFBLHVCQUFBRSxRQUFBQSxDQUFZRyxJQUFaSDtBQUFsQyxNQUFBO0FBQUEsUUFMWCxPQUFBO0FBS1csTUFBQSxDQUFBLGtCQUxYSCxDQUtXLENBQUE7QUFBQSxRQUFzRCxP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QSxFQUFBQSxJQUFBQSxXQWpUQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIxNTcyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYXRpb25hbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL251bWVyaWMnXG5cbmNsYXNzIFJhdGlvbmFsIDwgTnVtZXJpY1xuICBkZWYgc2VsZi5yZWR1Y2UobnVtLCBkZW4pXG4gICAgbnVtID0gbnVtLnRvX2lcbiAgICBkZW4gPSBkZW4udG9faVxuXG4gICAgaWYgZGVuID09IDBcbiAgICAgIHJhaXNlIFplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ1xuICAgIGVsc2lmIGRlbiA8IDBcbiAgICAgIG51bSA9IC1udW1cbiAgICAgIGRlbiA9IC1kZW5cbiAgICBlbHNpZiBkZW4gPT0gMVxuICAgICAgcmV0dXJuIG5ldyhudW0sIGRlbilcbiAgICBlbmRcblxuICAgIGdjZCA9IG51bS5nY2QoZGVuKVxuXG4gICAgbmV3KG51bSAvIGdjZCwgZGVuIC8gZ2NkKVxuICBlbmRcblxuICBkZWYgc2VsZi5jb252ZXJ0KG51bSwgZGVuKVxuICAgIGlmIG51bS5uaWw/IHx8IGRlbi5uaWw/XG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdjYW5ub3QgY29udmVydCBuaWwgaW50byBSYXRpb25hbCdcbiAgICBlbmRcblxuICAgIGlmIEludGVnZXIgPT09IG51bSAmJiBJbnRlZ2VyID09PSBkZW5cbiAgICAgIHJldHVybiByZWR1Y2UobnVtLCBkZW4pXG4gICAgZW5kXG5cbiAgICBpZiBGbG9hdCA9PT0gbnVtIHx8IFN0cmluZyA9PT0gbnVtIHx8IENvbXBsZXggPT09IG51bVxuICAgICAgbnVtID0gbnVtLnRvX3JcbiAgICBlbmRcblxuICAgIGlmIEZsb2F0ID09PSBkZW4gfHwgU3RyaW5nID09PSBkZW4gfHwgQ29tcGxleCA9PT0gZGVuXG4gICAgICBkZW4gPSBkZW4udG9fclxuICAgIGVuZFxuXG4gICAgaWYgZGVuLmVxdWFsPygxKSAmJiAhKEludGVnZXIgPT09IG51bSlcbiAgICAgIE9wYWwuY29lcmNlX3RvIShudW0sIFJhdGlvbmFsLCA6dG9fcilcbiAgICBlbHNpZiBOdW1lcmljID09PSBudW0gJiYgTnVtZXJpYyA9PT0gZGVuXG4gICAgICBudW0gLyBkZW5cbiAgICBlbHNlXG4gICAgICByZWR1Y2UobnVtLCBkZW4pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKG51bSwgZGVuKVxuICAgIEBudW0gPSBudW1cbiAgICBAZGVuID0gZGVuXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICBAbnVtXG4gIGVuZFxuXG4gIGRlZiBkZW5vbWluYXRvclxuICAgIEBkZW5cbiAgZW5kXG5cbiAgZGVmIGNvZXJjZShvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgW290aGVyLCBzZWxmXVxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBbb3RoZXIudG9fciwgc2VsZl1cblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIFtvdGhlciwgdG9fZl1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBAbnVtID09IG90aGVyLm51bWVyYXRvciAmJiBAZGVuID09IG90aGVyLmRlbm9taW5hdG9yXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIEBudW0gPT0gb3RoZXIgJiYgQGRlbiA9PSAxXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICB0b19mID09IG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBvdGhlciA9PSBzZWxmXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIEBudW0gKiBvdGhlci5kZW5vbWluYXRvciAtIEBkZW4gKiBvdGhlci5udW1lcmF0b3IgPD0+IDBcblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgQG51bSAtIEBkZW4gKiBvdGhlciA8PT4gMFxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZiA8PT4gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDo8PT4sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIuZGVub21pbmF0b3IgKyBAZGVuICogb3RoZXIubnVtZXJhdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIuZGVub21pbmF0b3JcblxuICAgICAgUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIFJhdGlvbmFsKEBudW0gKyBvdGhlciAqIEBkZW4sIEBkZW4pXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICB0b19mICsgb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDorLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLmRlbm9taW5hdG9yIC0gQGRlbiAqIG90aGVyLm51bWVyYXRvclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLmRlbm9taW5hdG9yXG5cbiAgICAgIFJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBSYXRpb25hbChAbnVtIC0gb3RoZXIgKiBAZGVuLCBAZGVuKVxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZiAtIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6LSwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIG51bSA9IEBudW0gKiBvdGhlci5udW1lcmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgICBSYXRpb25hbChudW0sIGRlbilcblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgUmF0aW9uYWwoQG51bSAqIG90aGVyLCBAZGVuKVxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZiAqIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Kiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC8ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIG51bSA9IEBudW0gKiBvdGhlci5kZW5vbWluYXRvclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLm51bWVyYXRvclxuXG4gICAgICBSYXRpb25hbChudW0sIGRlbilcblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgaWYgb3RoZXIgPT0gMFxuICAgICAgICB0b19mIC8gMC4wXG4gICAgICBlbHNlXG4gICAgICAgIFJhdGlvbmFsKEBudW0sIEBkZW4gKiBvdGhlcilcbiAgICAgIGVuZFxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZiAvIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Lywgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICoqKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIEludGVnZXJcbiAgICAgIGlmIHNlbGYgPT0gMCAmJiBvdGhlciA8IDBcbiAgICAgICAgRmxvYXQ6OklORklOSVRZXG4gICAgICBlbHNpZiBvdGhlciA+IDBcbiAgICAgICAgUmF0aW9uYWwoQG51bSoqb3RoZXIsIEBkZW4qKm90aGVyKVxuICAgICAgZWxzaWYgb3RoZXIgPCAwXG4gICAgICAgIFJhdGlvbmFsKEBkZW4qKi1vdGhlciwgQG51bSoqLW90aGVyKVxuICAgICAgZWxzZVxuICAgICAgICBSYXRpb25hbCgxLCAxKVxuICAgICAgZW5kXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICB0b19mKipvdGhlclxuXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgaWYgb3RoZXIgPT0gMFxuICAgICAgICBSYXRpb25hbCgxLCAxKVxuICAgICAgZWxzaWYgb3RoZXIuZGVub21pbmF0b3IgPT0gMVxuICAgICAgICBpZiBvdGhlciA8IDBcbiAgICAgICAgICBSYXRpb25hbChAZGVuKipvdGhlci5udW1lcmF0b3IuYWJzLCBAbnVtKipvdGhlci5udW1lcmF0b3IuYWJzKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgUmF0aW9uYWwoQG51bSoqb3RoZXIubnVtZXJhdG9yLCBAZGVuKipvdGhlci5udW1lcmF0b3IpXG4gICAgICAgIGVuZFxuICAgICAgZWxzaWYgc2VsZiA9PSAwICYmIG90aGVyIDwgMFxuICAgICAgICByYWlzZSBaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCdcbiAgICAgIGVsc2VcbiAgICAgICAgdG9fZioqb3RoZXJcbiAgICAgIGVuZFxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOioqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgUmF0aW9uYWwoQG51bS5hYnMsIEBkZW4uYWJzKVxuICBlbmRcblxuICBkZWYgY2VpbChwcmVjaXNpb24gPSAwKVxuICAgIGlmIHByZWNpc2lvbiA9PSAwXG4gICAgICAoLSgtQG51bSAvIEBkZW4pKS5jZWlsXG4gICAgZWxzZVxuICAgICAgd2l0aF9wcmVjaXNpb24oOmNlaWwsIHByZWNpc2lvbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgZGl2aWRlIC9cblxuICBkZWYgZmxvb3IocHJlY2lzaW9uID0gMClcbiAgICBpZiBwcmVjaXNpb24gPT0gMFxuICAgICAgKC0oLUBudW0gLyBAZGVuKSkuZmxvb3JcbiAgICBlbHNlXG4gICAgICB3aXRoX3ByZWNpc2lvbig6Zmxvb3IsIHByZWNpc2lvbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBcIlJhdGlvbmFsOiN7QG51bX06I3tAZGVufVwiXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIoI3tzZWxmfSlcIlxuICBlbmRcblxuICBhbGlhcyBxdW8gL1xuXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMSlcIn07XG4gICAgICB9XG5cbiAgICAgIGlmIChlcHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGUgPSAje2Vwcy5hYnN9LFxuICAgICAgICAgIGEgPSAje3NlbGYgLSBgZWB9LFxuICAgICAgICAgIGIgPSAje3NlbGYgKyBgZWB9O1xuXG4gICAgICB2YXIgcDAgPSAwLFxuICAgICAgICAgIHAxID0gMSxcbiAgICAgICAgICBxMCA9IDEsXG4gICAgICAgICAgcTEgPSAwLFxuICAgICAgICAgIHAyLCBxMjtcblxuICAgICAgdmFyIGMsIGssIHQ7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGMgPSAje2BhYC5jZWlsfTtcblxuICAgICAgICBpZiAoI3tgY2AgPD0gYGJgfSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgayAgPSBjIC0gMTtcbiAgICAgICAgcDIgPSBrICogcDEgKyBwMDtcbiAgICAgICAgcTIgPSBrICogcTEgKyBxMDtcbiAgICAgICAgdCAgPSAjezEgLyAoYGJgIC0gYGtgKX07XG4gICAgICAgIGIgID0gI3sxIC8gKGBhYCAtIGBrYCl9O1xuICAgICAgICBhICA9IHQ7XG5cbiAgICAgICAgcDAgPSBwMTtcbiAgICAgICAgcTAgPSBxMTtcbiAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgcTEgPSBxMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7UmF0aW9uYWwoYGMgKiBwMSArIHAwYCwgYGMgKiBxMSArIHEwYCl9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdW5kKHByZWNpc2lvbiA9IDApXG4gICAgcmV0dXJuIHdpdGhfcHJlY2lzaW9uKDpyb3VuZCwgcHJlY2lzaW9uKSB1bmxlc3MgcHJlY2lzaW9uID09IDBcbiAgICByZXR1cm4gMCBpZiBAbnVtID09IDBcbiAgICByZXR1cm4gQG51bSBpZiBAZGVuID09IDFcblxuICAgIG51bSA9IEBudW0uYWJzICogMiArIEBkZW5cbiAgICBkZW4gPSBAZGVuICogMlxuXG4gICAgYXBwcm94ID0gKG51bSAvIGRlbikudHJ1bmNhdGVcblxuICAgIGlmIEBudW0gPCAwXG4gICAgICAtYXBwcm94XG4gICAgZWxzZVxuICAgICAgYXBwcm94XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgQG51bSAvIEBkZW5cbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICB0cnVuY2F0ZVxuICBlbmRcblxuICBkZWYgdG9fclxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiN7QG51bX0vI3tAZGVufVwiXG4gIGVuZFxuXG4gIGRlZiB0cnVuY2F0ZShwcmVjaXNpb24gPSAwKVxuICAgIGlmIHByZWNpc2lvbiA9PSAwXG4gICAgICBAbnVtIDwgMCA/IGNlaWwgOiBmbG9vclxuICAgIGVsc2VcbiAgICAgIHdpdGhfcHJlY2lzaW9uKDp0cnVuY2F0ZSwgcHJlY2lzaW9uKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgd2l0aF9wcmVjaXNpb24obWV0aG9kLCBwcmVjaXNpb24pXG4gICAgcmFpc2UgVHlwZUVycm9yLCAnbm90IGFuIEludGVnZXInIHVubGVzcyBJbnRlZ2VyID09PSBwcmVjaXNpb25cblxuICAgIHAgPSAxMCoqcHJlY2lzaW9uXG4gICAgcyA9IHNlbGYgKiBwXG5cbiAgICBpZiBwcmVjaXNpb24gPCAxXG4gICAgICAocy5zZW5kKG1ldGhvZCkgLyBwKS50b19pXG4gICAgZWxzZVxuICAgICAgUmF0aW9uYWwocy5zZW5kKG1ldGhvZCksIHApXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgZGVmIFJhdGlvbmFsKG51bWVyYXRvciwgZGVub21pbmF0b3IgPSAxKVxuICAgIFJhdGlvbmFsLmNvbnZlcnQobnVtZXJhdG9yLCBkZW5vbWluYXRvcilcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RyaW5nXG4gIGRlZiB0b19yXG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gc2VsZi50cmltTGVmdCgpLFxuICAgICAgICAgIHJlID0gL15bKy1dP1tcXGRfXSsoXFwuW1xcZF9dKyk/LyxcbiAgICAgICAgICBtYXRjaCA9IHN0ci5tYXRjaChyZSksXG4gICAgICAgICAgbnVtZXJhdG9yLCBkZW5vbWluYXRvcjtcblxuICAgICAgZnVuY3Rpb24gaXNGbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHJlLnRlc3Qoc3RyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3V0RmxvYXQoKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZSk7XG4gICAgICAgIHZhciBudW1iZXIgPSBtYXRjaFswXTtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKG51bWJlci5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbnVtYmVyLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgIG51bWVyYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG5cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJy8nKSB7XG4gICAgICAgICAgLy8gcmF0aW9uYWwgcmVhbCBwYXJ0XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuXG4gICAgICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICAgICAgZGVub21pbmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuICAgICAgICAgICAgcmV0dXJuICN7UmF0aW9uYWwoYG51bWVyYXRvcmAsIGBkZW5vbWluYXRvcmApfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICN7UmF0aW9uYWwoYG51bWVyYXRvcmAsIDEpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICN7UmF0aW9uYWwoYG51bWVyYXRvcmAsIDEpfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7UmF0aW9uYWwoMCwgMSl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJyZWR1Y2UiLCJzZWxmIiwibnVtIiwidG9faSIsImRlbiIsIj09IiwiMCIsInJhaXNlIiwiPCIsIi1AIiwiMSIsIm5ldyIsImdjZCIsIi8iLCJjb252ZXJ0IiwiJHJldF9vcl8xIiwibmlsPyIsIiRyZXRfb3JfMiIsIj09PSIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsInRvX3IiLCIkcmV0X29yXzUiLCIkcmV0X29yXzYiLCIkcmV0X29yXzciLCJlcXVhbD8iLCIhIiwiY29lcmNlX3RvISIsIiRyZXRfb3JfOCIsImluaXRpYWxpemUiLCJAbnVtIiwiQGRlbiIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwiY29lcmNlIiwib3RoZXIiLCJ0b19mIiwiJHJldF9vcl85IiwiJHJldF9vcl8xMCIsIjw9PiIsIi0iLCIqIiwiX19jb2VyY2VkX18iLCIrIiwiUmF0aW9uYWwiLCIqKiIsIiRyZXRfb3JfMTEiLCI+IiwiYWJzIiwiJHJldF9vcl8xMiIsImNlaWwiLCJwcmVjaXNpb24iLCJ3aXRoX3ByZWNpc2lvbiIsImZsb29yIiwiaGFzaCIsImluc3BlY3QiLCJyYXRpb25hbGl6ZSIsImVwcyIsIjw9Iiwicm91bmQiLCIyIiwiYXBwcm94IiwidHJ1bmNhdGUiLCJ0b19zIiwicCIsIjEwIiwicyIsInNlbmQiLCJtZXRob2QiLCJtb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsaUJBQVJBLENBQUE7QUFBQSxFQUVBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsSUFBQUMsVUFBSUMsSUFBSkQsYUFBQUEscUJBQUFBLGtCQUFnQixHQUFELEVBQU0sR0FBckJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFFLE1BQU1BLEdBQUFDLE1BQUFBLENBQUFBLENBQU47QUFBQSxNQUNBQyxNQUFNQSxHQUFBRCxNQUFBQSxDQUFBQSxDQUROO0FBQUEsTUFHQSxJQUFHQyxHQUFBQyxPQUFBQSxDQUFPQyxDQUFQRCxDQUFIO0FBQUEsWUFDRUUsT0FBQUEsQ0FBTSxtQ0FBbUIsY0FBekJBO0FBREYsTUFBQSxPQUVBLElBQUEsUUFBTUMsT0FBQUosR0FBQUksRUFBTUYsQ0FBTkUsQ0FBTixDQUFBO0FBQUE7QUFDRSxRQUFBTixNQUFPQSxHQUFETyxPQUFBQSxDQUFBQSxDQUFOO0FBQUEsUUFDQUwsTUFBT0EsR0FBREssT0FBQUEsQ0FBQUEsQ0FETjtBQURGLE1BQUEsT0FHQSxJQUFNTCxHQUFBQyxPQUFBQSxDQUFPSyxDQUFQTCxDQUFOO0FBQUEsUUFDRSxXQUFPTSxLQUFBQSxDQUFJVCxLQUFLRSxHQUFUTyxDQURULENBUkE7QUFBQSxNQVlBQyxNQUFNVixHQUFBVSxLQUFBQSxDQUFRUixHQUFSUSxDQVpOO0FBQUEsTUFjQSxXQUFBRCxLQUFBQSxDQUFJRSxXQUFBWCxHQUFBVyxFQUFNRCxHQUFOQyxHQUFXQSxXQUFBVCxHQUFBUyxFQUFNRCxHQUFOQyxDQUFmRixDQWRBO0FBREZYLElBQUFBLENBQUFBLGdDQUFBQSxDQUFBO0FBQUEsSUFrQkFjLFVBQUliLElBQUphLGNBQUFBLHNCQUFBQSxtQkFBaUIsR0FBRCxFQUFNLEdBQXRCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBLElBQUEsUUFBRyxhQUFBLElBQUEsUUF2QlBDLENBQUFBLFlBdUJPYixHQUFBYyxTQUFBQSxDQUFBQSxDQXZCUEQsQ0F1Qk8sQ0FBQTtBQUFBLFFBdkJQLE9BQUE7QUF1Qk8sTUFBQTtBQUFBLFFBQVksT0FBQVgsR0FBQVksU0FBQUEsQ0FBQUE7QUFBWixNQUFBLENBQUEsa0JBQUgsQ0FBQTtBQUFBLFlBQ0VULE9BQUFBLENBQU0sMkJBQVcsa0NBQWpCQSxDQURGLENBQUE7QUFBQSxNQUlBLElBQUEsUUFBRyxhQUFBLElBQUEsUUEzQlBVLENBQUFBLFlBMkJPLHVCQUFBQyxRQUFBQSxDQUFZaEIsR0FBWmdCLENBM0JQRCxDQTJCTyxDQUFBO0FBQUEsUUFBbUIsT0FBQSx1QkFBQUMsUUFBQUEsQ0FBWWQsR0FBWmM7QUFBbkIsTUFBQTtBQUFBLFFBM0JQLE9BQUE7QUEyQk8sTUFBQSxDQUFBLGtCQUFILENBQUE7QUFBQSxRQUNFLFdBQU9sQixRQUFBQSxDQUFPRSxLQUFLRSxHQUFaSixDQURULENBSkE7QUFBQSxNQVFBLElBQUEsUUFBRyxhQUFBLElBQUEsUUEvQlBtQixDQUFBQSxZQStCTyxhQUFBLElBQUEsUUEvQlBDLENBQUFBLFlBK0JPLHFCQUFBRixRQUFBQSxDQUFVaEIsR0FBVmdCLENBL0JQRSxDQStCTyxDQUFBO0FBQUEsUUEvQlAsT0FBQTtBQStCTyxNQUFBO0FBQUEsUUFBaUIsT0FBQSxzQkFBQUYsUUFBQUEsQ0FBV2hCLEdBQVhnQjtBQUFqQixNQUFBLENBQUEsa0JBL0JQQyxDQStCTyxDQUFBO0FBQUEsUUEvQlAsT0FBQTtBQStCTyxNQUFBO0FBQUEsUUFBbUMsT0FBQSx1QkFBQUQsUUFBQUEsQ0FBWWhCLEdBQVpnQjtBQUFuQyxNQUFBLENBQUEsa0JBQUgsQ0FBQTtBQUFBLFFBQ0VoQixNQUFNQSxHQUFBbUIsTUFBQUEsQ0FBQUEsQ0FEUixDQVJBO0FBQUEsTUFZQSxJQUFBLFFBQUcsYUFBQSxJQUFBLFFBbkNQQyxDQUFBQSxZQW1DTyxhQUFBLElBQUEsUUFuQ1BDLENBQUFBLFlBbUNPLHFCQUFBTCxRQUFBQSxDQUFVZCxHQUFWYyxDQW5DUEssQ0FtQ08sQ0FBQTtBQUFBLFFBbkNQLE9BQUE7QUFtQ08sTUFBQTtBQUFBLFFBQWlCLE9BQUEsc0JBQUFMLFFBQUFBLENBQVdkLEdBQVhjO0FBQWpCLE1BQUEsQ0FBQSxrQkFuQ1BJLENBbUNPLENBQUE7QUFBQSxRQW5DUCxPQUFBO0FBbUNPLE1BQUE7QUFBQSxRQUFtQyxPQUFBLHVCQUFBSixRQUFBQSxDQUFZZCxHQUFaYztBQUFuQyxNQUFBLENBQUEsa0JBQUgsQ0FBQTtBQUFBLFFBQ0VkLE1BQU1BLEdBQUFpQixNQUFBQSxDQUFBQSxDQURSLENBWkE7QUFBQSxNQWdCQSxJQUFBLFFBQUcsYUFBQSxJQUFBLFFBdkNQRyxDQUFBQSxZQXVDT3BCLEdBQUFxQixXQUFBQSxDQUFXZixDQUFYZSxDQXZDUEQsQ0F1Q08sQ0FBQTtBQUFBLFFBQWlCLE9BQUUsdUJBQUFOLFFBQUFBLENBQVloQixHQUFaZ0IsQ0FBRlEsTUFBQUEsQ0FBQUE7QUFBakIsTUFBQTtBQUFBLFFBdkNQLE9BQUE7QUF1Q08sTUFBQSxDQUFBLGtCQUFILENBQUE7QUFBQSxRQUNFLE9BQUEsb0JBQUFDLGVBQUFBLENBQWdCekIsS0FBSywwQkFBVSxNQUEvQnlCO0FBREYsTUFBQSxPQUVBLElBQUEsUUFBTSxhQUFBLElBQUEsUUF6Q1ZDLENBQUFBLFlBeUNVLHVCQUFBVixRQUFBQSxDQUFZaEIsR0FBWmdCLENBekNWVSxDQXlDVSxDQUFBO0FBQUEsUUFBbUIsT0FBQSx1QkFBQVYsUUFBQUEsQ0FBWWQsR0FBWmM7QUFBbkIsTUFBQTtBQUFBLFFBekNWLE9BQUE7QUF5Q1UsTUFBQSxDQUFBLGtCQUFOLENBQUE7QUFBQSxRQUNFLE9BQUFMLFdBQUFYLEdBQUFXLEVBQU1ULEdBQU5TO0FBREYsTUFBQTtBQUFBLFFBR0UsV0FBQWIsUUFBQUEsQ0FBT0UsS0FBS0UsR0FBWko7QUFIRixNQUFBLENBbEJBO0FBREZjLElBQUFBLENBQUFBLGlDQUFBQSxDQWxCQTtBQUFBO0FBNENBZSxJQUFBQSw4QkFBQUEseUJBQUFBLHNCQUFlLEdBQUQsRUFBTSxHQUFwQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQUMsV0FBTzVCLEdBQVA7QUFBQSxNQUNBLE9BQUE2QixDQUFBQSxXQUFPM0IsR0FBUDJCLENBREE7QUFERkYsSUFBQUEsQ0FBQUEsb0NBQUFBLENBNUNBO0FBQUE7QUFpREFHLElBQUFBLDZCQUFBQSx3QkFBQUEscUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFGO0FBREZFLElBQUFBLENBQUFBLG1DQUFBQSxDQWpEQTtBQUFBO0FBcURBQyxJQUFBQSwrQkFBQUEsMEJBQUFBLHVCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBRjtBQURGRSxJQUFBQSxDQUFBQSxxQ0FBQUEsQ0FyREE7QUFBQTtBQXlEQUMsSUFBQUEsMEJBQUFBLHFCQUFBQSxrQkFBVyxLQUFYQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLGFBQUEsUUFBS0MsS0FBTDtBQUFBLE1BQ0EsSUFBSyx1Q0FBTCxHQUNFLE9BQUEsQ0FBQ0EsS0FBRCxFQUFRbEMsSUFBUixDQURGO0FBREEsTUFBQSxLQUlBLElBQUssc0NBQUwsR0FDRSxPQUFBLENBQUNrQyxLQUFBZCxNQUFBQSxDQUFBQSxDQUFELEVBQWFwQixJQUFiLENBREY7QUFKQSxNQUFBLEtBT0EsSUFBSyxvQ0FBTCxHQUNFLE9BQUEsQ0FBQ2tDLEtBQUQsTUFBUUMsTUFBQUEsQ0FBQUEsQ0FBUixDQURGO0FBUEEsTUFBQSxtQkFBQTtBQURGRixJQUFBQSxDQUFBQSxnQ0FBQUEsQ0F6REE7QUFBQTtBQXNFQTdCLElBQUFBLHNCQUFBQSxxQkFBQUEsU0FBTyxLQUFQQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLGFBQUEsUUFBSzhCLEtBQUw7QUFBQSxNQUNBLElBQUssdUNBQUwsR0FDRSxJQUFBLFFBN0VORSxDQUFBQSxZQTZFTVAsUUFBQXpCLE9BQUFBLENBQVE4QixLQUFBSCxXQUFBQSxDQUFBQSxDQUFSM0IsQ0E3RU5nQyxDQTZFTSxDQUFBO0FBQUEsUUFBMkIsT0FBQU4sUUFBQTFCLE9BQUFBLENBQVE4QixLQUFBRixhQUFBQSxDQUFBQSxDQUFSNUI7QUFBM0IsTUFBQTtBQUFBLFFBN0VOLE9BQUE7QUE2RU0sTUFBQSxDQURGO0FBREEsTUFBQSxLQUlBLElBQUssc0NBQUwsR0FDRSxJQUFBLFFBaEZOaUMsQ0FBQUEsYUFnRk1SLFFBQUF6QixPQUFBQSxDQUFROEIsS0FBUjlCLENBaEZOaUMsQ0FnRk0sQ0FBQTtBQUFBLFFBQWlCLE9BQUFQLFFBQUExQixPQUFBQSxDQUFRSyxDQUFSTDtBQUFqQixNQUFBO0FBQUEsUUFoRk4sT0FBQTtBQWdGTSxNQUFBLENBREY7QUFKQSxNQUFBLEtBT0EsSUFBSyxvQ0FBTCxHQUNFLFdBQUErQixNQUFBQSxDQUFBQSxDQUFBL0IsT0FBQUEsQ0FBUThCLEtBQVI5QixDQURGO0FBUEEsTUFBQSxNQVdFLE9BQUE4QixLQUFBOUIsT0FBQUEsQ0FBU0osSUFBVEksQ0FYRixDQUFBO0FBREZBLElBQUFBLENBQUFBLGdDQUFBQSxDQXRFQTtBQUFBO0FBc0ZBa0MsSUFBQUEsdUJBQUFBLHdCQUFBQSxTQUFRLEtBQVJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsYUFBQSxRQUFLSixLQUFMO0FBQUEsTUFDQSxJQUFLLHVDQUFMLEdBQ0UsT0FBQUssVUFBQUMsVUFBQVgsUUFBQVcsRUFBT04sS0FBQUYsYUFBQUEsQ0FBQUEsQ0FBUFEsQ0FBQUQsRUFBMkJDLFVBQUFWLFFBQUFVLEVBQU9OLEtBQUFILFdBQUFBLENBQUFBLENBQVBTLENBQTNCRCxDQUFBRCxRQUFBQSxDQUFzRGpDLENBQXREaUMsQ0FERjtBQURBLE1BQUEsS0FJQSxJQUFLLHNDQUFMLEdBQ0UsT0FBQUMsVUFBQVYsUUFBQVUsRUFBT0MsVUFBQVYsUUFBQVUsRUFBT04sS0FBUE0sQ0FBUEQsQ0FBQUQsUUFBQUEsQ0FBd0JqQyxDQUF4QmlDLENBREY7QUFKQSxNQUFBLEtBT0EsSUFBSyxvQ0FBTCxHQUNFLFdBQUFILE1BQUFBLENBQUFBLENBQUFHLFFBQUFBLENBQVNKLEtBQVRJLENBREY7QUFQQSxNQUFBLE1BV0UsV0FBQUcsYUFBQUEsQ0FBWSxPQUFNUCxLQUFsQk8sQ0FYRixDQUFBO0FBREZILElBQUFBLENBQUFBLG1DQUFBQSxDQXRGQTtBQUFBO0FBc0dBSSxJQUFBQSxxQkFBQUEsb0JBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxhQUFBLFFBQUtSLEtBQUw7QUFBQSxNQUNBLElBQUssdUNBQUw7QUFDRSxNQUFBakMsTUFBTXlDLFNBQUFGLFVBQUFYLFFBQUFXLEVBQU9OLEtBQUFGLGFBQUFBLENBQUFBLENBQVBRLENBQUFFLEVBQTJCRixVQUFBVixRQUFBVSxFQUFPTixLQUFBSCxXQUFBQSxDQUFBQSxDQUFQUyxDQUEzQkUsQ0FBTjtBQUFBLE1BQ0F2QyxNQUFNcUMsVUFBQVYsUUFBQVUsRUFBT04sS0FBQUYsYUFBQUEsQ0FBQUEsQ0FBUFEsQ0FETjtBQUFBLE1BR0EsV0FBQUcsVUFBQUEsQ0FBUzFDLEtBQUtFLEdBQWR3QyxDQUhBLENBREY7QUFEQSxNQUFBLEtBT0EsSUFBSyxzQ0FBTCxHQUNFLFdBQUFBLFVBQUFBLENBQVNELFNBQUFiLFFBQUFhLEVBQU9GLFVBQUFOLEtBQUFNLEVBQVFWLFFBQVJVLENBQVBFLEdBQXFCWixRQUE5QmEsQ0FERjtBQVBBLE1BQUEsS0FVQSxJQUFLLG9DQUFMLEdBQ0UsT0FBQUQsYUFBQVAsTUFBQUEsQ0FBQUEsQ0FBQU8sRUFBT1IsS0FBUFEsQ0FERjtBQVZBLE1BQUEsTUFjRSxXQUFBRCxhQUFBQSxDQUFZLEtBQUlQLEtBQWhCTyxDQWRGLENBQUE7QUFERkMsSUFBQUEsQ0FBQUEsK0JBQUFBLENBdEdBO0FBQUE7QUF5SEFILElBQUFBLHFCQUFBQSxzQkFBQUEsU0FBTSxLQUFOQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLGFBQUEsUUFBS0wsS0FBTDtBQUFBLE1BQ0EsSUFBSyx1Q0FBTDtBQUNFLE1BQUFqQyxNQUFNc0MsVUFBQUMsVUFBQVgsUUFBQVcsRUFBT04sS0FBQUYsYUFBQUEsQ0FBQUEsQ0FBUFEsQ0FBQUQsRUFBMkJDLFVBQUFWLFFBQUFVLEVBQU9OLEtBQUFILFdBQUFBLENBQUFBLENBQVBTLENBQTNCRCxDQUFOO0FBQUEsTUFDQXBDLE1BQU1xQyxVQUFBVixRQUFBVSxFQUFPTixLQUFBRixhQUFBQSxDQUFBQSxDQUFQUSxDQUROO0FBQUEsTUFHQSxXQUFBRyxVQUFBQSxDQUFTMUMsS0FBS0UsR0FBZHdDLENBSEEsQ0FERjtBQURBLE1BQUEsS0FPQSxJQUFLLHNDQUFMLEdBQ0UsV0FBQUEsVUFBQUEsQ0FBU0osVUFBQVYsUUFBQVUsRUFBT0MsVUFBQU4sS0FBQU0sRUFBUVYsUUFBUlUsQ0FBUEQsR0FBcUJULFFBQTlCYSxDQURGO0FBUEEsTUFBQSxLQVVBLElBQUssb0NBQUwsR0FDRSxPQUFBSixjQUFBSixNQUFBQSxDQUFBQSxDQUFBSSxFQUFPTCxLQUFQSyxDQURGO0FBVkEsTUFBQSxNQWNFLFdBQUFFLGFBQUFBLENBQVksS0FBSVAsS0FBaEJPLENBZEYsQ0FBQTtBQURGRixJQUFBQSxDQUFBQSxpQ0FBQUEsQ0F6SEE7QUFBQTtBQTRJQUMsSUFBQUEscUJBQUFBLGlCQUFBQSxTQUFNLEtBQU5BO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsYUFBQSxRQUFLTixLQUFMO0FBQUEsTUFDQSxJQUFLLHVDQUFMO0FBQ0UsTUFBQWpDLE1BQU11QyxVQUFBWCxRQUFBVyxFQUFPTixLQUFBSCxXQUFBQSxDQUFBQSxDQUFQUyxDQUFOO0FBQUEsTUFDQXJDLE1BQU1xQyxVQUFBVixRQUFBVSxFQUFPTixLQUFBRixhQUFBQSxDQUFBQSxDQUFQUSxDQUROO0FBQUEsTUFHQSxXQUFBRyxVQUFBQSxDQUFTMUMsS0FBS0UsR0FBZHdDLENBSEEsQ0FERjtBQURBLE1BQUEsS0FPQSxJQUFLLHNDQUFMLEdBQ0UsV0FBQUEsVUFBQUEsQ0FBU0gsVUFBQVgsUUFBQVcsRUFBT04sS0FBUE0sR0FBY1YsUUFBdkJhLENBREY7QUFQQSxNQUFBLEtBVUEsSUFBSyxvQ0FBTCxHQUNFLE9BQUFILGNBQUFMLE1BQUFBLENBQUFBLENBQUFLLEVBQU9OLEtBQVBNLENBREY7QUFWQSxNQUFBLE1BY0UsV0FBQUMsYUFBQUEsQ0FBWSxLQUFJUCxLQUFoQk8sQ0FkRixDQUFBO0FBREZELElBQUFBLENBQUFBLDRCQUFBQSxDQTVJQTtBQUFBO0FBK0pBNUIsSUFBQUEscUJBQUFBLHNCQUFBQSxTQUFNLEtBQU5BO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsYUFBQSxRQUFLc0IsS0FBTDtBQUFBLE1BQ0EsSUFBSyx1Q0FBTDtBQUNFLE1BQUFqQyxNQUFNdUMsVUFBQVgsUUFBQVcsRUFBT04sS0FBQUYsYUFBQUEsQ0FBQUEsQ0FBUFEsQ0FBTjtBQUFBLE1BQ0FyQyxNQUFNcUMsVUFBQVYsUUFBQVUsRUFBT04sS0FBQUgsV0FBQUEsQ0FBQUEsQ0FBUFMsQ0FETjtBQUFBLE1BR0EsV0FBQUcsVUFBQUEsQ0FBUzFDLEtBQUtFLEdBQWR3QyxDQUhBLENBREY7QUFEQSxNQUFBLEtBT0EsSUFBSyxzQ0FBTCxHQUNFLElBQUdULEtBQUE5QixPQUFBQSxDQUFTQyxDQUFURCxDQUFIO0FBQUEsUUFDRSxPQUFBUSxlQUFBdUIsTUFBQUEsQ0FBQUEsQ0FBQXZCLEVBQU8sR0FBUEE7QUFERixNQUFBO0FBQUEsUUFHRSxXQUFBK0IsVUFBQUEsQ0FBU2QsVUFBTVcsVUFBQVYsUUFBQVUsRUFBT04sS0FBUE0sQ0FBZkc7QUFIRixNQUFBLENBREY7QUFQQSxNQUFBLEtBY0EsSUFBSyxvQ0FBTCxHQUNFLE9BQUEvQixlQUFBdUIsTUFBQUEsQ0FBQUEsQ0FBQXZCLEVBQU9zQixLQUFQdEIsQ0FERjtBQWRBLE1BQUEsTUFrQkUsV0FBQTZCLGFBQUFBLENBQVksS0FBSVAsS0FBaEJPLENBbEJGLENBQUE7QUFERjdCLElBQUFBLENBQUFBLGlDQUFBQSxDQS9KQTtBQUFBO0FBc0xBZ0MsSUFBQUEsc0JBQUFBLGtCQUFBQSxTQUFPLEtBQVBBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsYUFBQSxRQUFLVixLQUFMO0FBQUEsTUFDQSxJQUFLLHNDQUFMLEdBQ0UsSUFBQSxRQUFHLGFBQUEsSUFBQSxRQTdMVFcsQ0FBQUEsYUE2TFM3QyxJQUFBSSxPQUFBQSxDQUFRQyxDQUFSRCxDQTdMVHlDLENBNkxTLENBQUE7QUFBQSxRQUFhLE9BQUF0QyxPQUFBMkIsS0FBQTNCLEVBQVFGLENBQVJFO0FBQWIsTUFBQTtBQUFBLFFBN0xULE9BQUE7QUE2TFMsTUFBQSxDQUFBLGtCQUFILENBQUE7QUFBQSxRQUNFLE9BQUEsSUFBQSxxQkFBQTtBQURGLE1BQUEsT0FFQSxJQUFBLFFBQU11QyxPQUFBWixLQUFBWSxFQUFRekMsQ0FBUnlDLENBQU4sQ0FBQTtBQUFBLFFBQ0UsV0FBQUgsVUFBQUEsQ0FBU2QsUUFBQWUsT0FBQUEsQ0FBTVYsS0FBTlUsR0FBYWQsUUFBQWMsT0FBQUEsQ0FBTVYsS0FBTlUsQ0FBdEJEO0FBREYsTUFBQSxPQUVBLElBQUEsUUFBTXBDLE9BQUEyQixLQUFBM0IsRUFBUUYsQ0FBUkUsQ0FBTixDQUFBO0FBQUEsUUFDRSxXQUFBb0MsVUFBQUEsQ0FBU2IsUUFBQWMsT0FBQUEsQ0FBT1YsS0FBRDFCLE9BQUFBLENBQUFBLENBQU5vQyxHQUFjZixRQUFBZSxPQUFBQSxDQUFPVixLQUFEMUIsT0FBQUEsQ0FBQUEsQ0FBTm9DLENBQXZCRDtBQURGLE1BQUE7QUFBQSxRQUdFLFdBQUFBLFVBQUFBLENBQVNsQyxHQUFHQSxDQUFaa0M7QUFIRixNQUFBLENBTEY7QUFEQSxNQUFBLEtBWUEsSUFBSyxvQ0FBTCxHQUNFLFdBQUFSLE1BQUFBLENBQUFBLENBQUFTLE9BQUFBLENBQU1WLEtBQU5VLENBREY7QUFaQSxNQUFBLEtBZUEsSUFBSyx1Q0FBTCxHQUNFLElBQUdWLEtBQUE5QixPQUFBQSxDQUFTQyxDQUFURCxDQUFIO0FBQUEsUUFDRSxXQUFBdUMsVUFBQUEsQ0FBU2xDLEdBQUdBLENBQVprQztBQURGLE1BQUEsT0FFQSxJQUFNVCxLQUFBRixhQUFBQSxDQUFBQSxDQUFBNUIsT0FBQUEsQ0FBcUJLLENBQXJCTCxDQUFOO0FBQUEsUUFDRSxJQUFBLFFBQUdHLE9BQUEyQixLQUFBM0IsRUFBUUYsQ0FBUkUsQ0FBSCxDQUFBO0FBQUEsVUFDRSxXQUFBb0MsVUFBQUEsQ0FBU2IsUUFBQWMsT0FBQUEsQ0FBTVYsS0FBQUgsV0FBQUEsQ0FBQUEsQ0FBQWdCLEtBQUFBLENBQUFBLENBQU5ILEdBQTJCZixRQUFBZSxPQUFBQSxDQUFNVixLQUFBSCxXQUFBQSxDQUFBQSxDQUFBZ0IsS0FBQUEsQ0FBQUEsQ0FBTkgsQ0FBcENEO0FBREYsUUFBQTtBQUFBLFVBR0UsV0FBQUEsVUFBQUEsQ0FBU2QsUUFBQWUsT0FBQUEsQ0FBTVYsS0FBQUgsV0FBQUEsQ0FBQUEsQ0FBTmEsR0FBdUJkLFFBQUFjLE9BQUFBLENBQU1WLEtBQUFILFdBQUFBLENBQUFBLENBQU5hLENBQWhDRDtBQUhGLFFBQUE7QUFERixNQUFBLE9BTUEsSUFBQSxRQUFNLGFBQUEsSUFBQSxRQW5OWkssQ0FBQUEsYUFtTlloRCxJQUFBSSxPQUFBQSxDQUFRQyxDQUFSRCxDQW5OWjRDLENBbU5ZLENBQUE7QUFBQSxRQUFhLE9BQUF6QyxPQUFBMkIsS0FBQTNCLEVBQVFGLENBQVJFO0FBQWIsTUFBQTtBQUFBLFFBbk5aLE9BQUE7QUFtTlksTUFBQSxDQUFBLGtCQUFOLENBQUE7QUFBQSxRQUNFLFdBQUFELE9BQUFBLENBQU0sbUNBQW1CLGNBQXpCQTtBQURGLE1BQUE7QUFBQSxRQUdFLFdBQUE2QixNQUFBQSxDQUFBQSxDQUFBUyxPQUFBQSxDQUFNVixLQUFOVTtBQUhGLE1BQUEsQ0FURjtBQWZBLE1BQUEsTUErQkUsV0FBQUgsYUFBQUEsQ0FBWSxNQUFLUCxLQUFqQk8sQ0EvQkYsQ0FBQTtBQURGRyxJQUFBQSxDQUFBQSw2QkFBQUEsQ0F0TEE7QUFBQTtBQTBOQUcsSUFBQUEsdUJBQUFBLG1CQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBSixVQUFBQSxDQUFTZCxRQUFBa0IsS0FBQUEsQ0FBQUEsR0FBVWpCLFFBQUFpQixLQUFBQSxDQUFBQSxDQUFuQko7QUFERkksSUFBQUEsQ0FBQUEsOEJBQUFBLENBMU5BO0FBQUE7QUE4TkFFLElBQUFBLHdCQUFBQSxvQkFBQUEsZ0JBQVMsU0FBVEE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBbE9GO0FBa09XLE1BQUE7QUFBQSxNQUFBLGNBQVk1QyxDQUFaO0FBQUEsTUFBQSxDQWxPWDtBQUFBLE1BbU9JLElBQUc2QyxTQUFBOUMsT0FBQUEsQ0FBYUMsQ0FBYkQsQ0FBSDtBQUFBLFFBQ0UsT0FBR1EsV0FBQ2lCLFFBQURyQixPQUFBQSxDQUFBQSxDQUFBSSxFQUFRa0IsUUFBUmxCLENBQUZKLE9BQUFBLENBQUFBLENBQUR5QyxNQUFBQSxDQUFBQTtBQURGLE1BQUE7QUFBQSxRQUdFLFdBQUFFLGdCQUFBQSxDQUFlLFFBQU9ELFNBQXRCQztBQUhGLE1BQUEsQ0FuT0o7QUFrT0VGLElBQUFBLENBQUFBLGdDQUFBQSxDQTlOQTtBQUFBLElBc09BLGlCQUFNLFFBQU4sRUFBYSxHQUFiLENBdE9BO0FBQUE7QUF3T0FHLElBQUFBLHlCQUFBQSxxQkFBQUEsaUJBQVUsU0FBVkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBNU9GO0FBNE9ZLE1BQUE7QUFBQSxNQUFBLGNBQVkvQyxDQUFaO0FBQUEsTUFBQSxDQTVPWjtBQUFBLE1BNk9JLElBQUc2QyxTQUFBOUMsT0FBQUEsQ0FBYUMsQ0FBYkQsQ0FBSDtBQUFBLFFBQ0UsT0FBR1EsV0FBQ2lCLFFBQURyQixPQUFBQSxDQUFBQSxDQUFBSSxFQUFRa0IsUUFBUmxCLENBQUZKLE9BQUFBLENBQUFBLENBQUQ0QyxPQUFBQSxDQUFBQTtBQURGLE1BQUE7QUFBQSxRQUdFLFdBQUFELGdCQUFBQSxDQUFlLFNBQVFELFNBQXZCQztBQUhGLE1BQUEsQ0E3T0o7QUE0T0VDLElBQUFBLENBQUFBLGlDQUFBQSxDQXhPQTtBQUFBO0FBZ1BBQyxJQUFBQSx3QkFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLEVBQUEsR0FBQSxXQUFBLEdBQUEsQ0FBWXhCLFFBQVosQ0FBQSxHQUFBLEdBQUEsR0FBQSxDQUFvQkMsUUFBcEI7QUFERnVCLElBQUFBLENBQUFBLCtCQUFBQSxDQWhQQTtBQUFBO0FBb1BBQyxJQUFBQSwyQkFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLEVBQUEsR0FBQSxHQUFBLEdBQUEsQ0FBSXRELElBQUosQ0FBQSxHQUFBO0FBREZzRCxJQUFBQSxDQUFBQSxrQ0FBQUEsQ0FwUEE7QUFBQSxJQXdQQSxpQkFBTSxLQUFOLEVBQVUsR0FBVixDQXhQQTtBQUFBO0FBMFBBQyxJQUFBQSwrQkFBQUEsMkJBQUFBLHVCQUFnQixHQUFoQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBOVBGLE1BQUE7QUFBQTtBQWdRQTtBQUNBLFlBQVVqRCxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSw2QkFBQSxHQUFBLENBQStCLGdCQUEvQixDQUFBLEdBQUEsWUFBckJBLENBQWtGO0FBQzVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFnQmtELEdBQUFULEtBQUFBLENBQUFBLENBQVE7QUFDeEIsY0FBZ0JSLFVBQUF2QyxJQUFBdUMsRUFBUSxDQUFSQSxDQUFXO0FBQzNCLGNBQWdCRyxTQUFBMUMsSUFBQTBDLEVBQVEsQ0FBUkEsQ0FBVzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQWMsQ0FBQyxDQUFELENBQUFPLE1BQUFBLENBQUFBLENBQVM7O0FBRXZCLFlBQWNRLE9BQUMsQ0FBREEsRUFBUSxDQUFSQSxDQUFXO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBZTdDLFdBQUFILENBQUFHLEVBQUsyQixVQUFDLENBQURBLEVBQU8sQ0FBUEEsQ0FBTDNCLENBQWdCO0FBQy9CLGFBQWVBLFdBQUFILENBQUFHLEVBQUsyQixVQUFDLENBQURBLEVBQU8sQ0FBUEEsQ0FBTDNCLENBQWdCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWUrQixVQUFBQSxDQUFVLGFBQWUsV0FBekJBLENBQXVDO0FBQ3RELElBelNBO0FBOFBFWSxJQUFBQSxDQUFBQSx1Q0FBQUEsQ0ExUEE7QUFBQTtBQXdTQUcsSUFBQUEseUJBQUFBLHFCQUFBQSxpQkFBVSxTQUFWQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE1U0Y7QUE0U1ksTUFBQTtBQUFBLE1BQUEsY0FBWXJELENBQVo7QUFBQSxNQUFBLENBNVNaO0FBQUEsTUE2U0ksSUFBZ0Q2QyxTQUFBOUMsT0FBQUEsQ0FBYUMsQ0FBYkQsQ0FBaEQ7QUFBQSxNQUFBO0FBQUEsUUFBQSxXQUFPK0MsZ0JBQUFBLENBQWUsU0FBUUQsU0FBdkJDO0FBQVAsTUFBQSxDQTdTSjtBQUFBLE1BOFNJLElBQVl0QixRQUFBekIsT0FBQUEsQ0FBUUMsQ0FBUkQsQ0FBWjtBQUFBLFFBQUEsT0FBT0MsQ0FBUCxDQTlTSjtBQUFBLE1BK1NJLElBQWV5QixRQUFBMUIsT0FBQUEsQ0FBUUssQ0FBUkwsQ0FBZjtBQUFBLFFBQUEsT0FBT3lCLFFBQVAsQ0EvU0o7QUFBQSxNQWlUSTVCLE1BQU15QyxTQUFBRixVQUFBWCxRQUFBa0IsS0FBQUEsQ0FBQUEsQ0FBQVAsRUFBV21CLENBQVhuQixDQUFBRSxFQUFlWixRQUFmWSxDQWpUVjtBQUFBLE1Ba1RJdkMsTUFBTXFDLFVBQUFWLFFBQUFVLEVBQU9tQixDQUFQbkIsQ0FsVFY7QUFBQSxNQW9USW9CLFNBQVVoRCxXQUFBWCxHQUFBVyxFQUFNVCxHQUFOUyxDQUFEaUQsVUFBQUEsQ0FBQUEsQ0FwVGI7QUFBQSxNQXNUSSxJQUFBLFFBQUd0RCxPQUFBc0IsUUFBQXRCLEVBQU9GLENBQVBFLENBQUgsQ0FBQTtBQUFBLFFBQ0UsT0FBQ3FELE1BQURwRCxPQUFBQSxDQUFBQTtBQURGLE1BQUE7QUFBQSxRQUdFLE9BQUFvRDtBQUhGLE1BQUEsQ0F0VEo7QUE0U0VGLElBQUFBLENBQUFBLGlDQUFBQSxDQXhTQTtBQUFBO0FBeVRBdkIsSUFBQUEsd0JBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQXZCLFdBQUFpQixRQUFBakIsRUFBT2tCLFFBQVBsQjtBQURGdUIsSUFBQUEsQ0FBQUEsK0JBQUFBLENBelRBO0FBQUE7QUE2VEFqQyxJQUFBQSx3QkFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBMkQsVUFBQUEsQ0FBQUE7QUFERjNELElBQUFBLENBQUFBLCtCQUFBQSxDQTdUQTtBQUFBO0FBaVVBa0IsSUFBQUEsd0JBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQXBCO0FBREZvQixJQUFBQSxDQUFBQSwrQkFBQUEsQ0FqVUE7QUFBQTtBQXFVQTBDLElBQUFBLHdCQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsRUFBQSxHQUFBLENBQUdqQyxRQUFILENBQUEsR0FBQSxHQUFBLEdBQUEsQ0FBV0MsUUFBWDtBQURGZ0MsSUFBQUEsQ0FBQUEsK0JBQUFBLENBclVBO0FBQUE7QUF5VUFELElBQUFBLDRCQUFBQSx3QkFBQUEsb0JBQWEsU0FBYkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBN1VGO0FBNlVlLE1BQUE7QUFBQSxNQUFBLGNBQVl4RCxDQUFaO0FBQUEsTUFBQSxDQTdVZjtBQUFBLE1BOFVJLElBQUc2QyxTQUFBOUMsT0FBQUEsQ0FBYUMsQ0FBYkQsQ0FBSDtBQUFBLFFBQ0UsSUFBQSxRQUFBRyxPQUFBc0IsUUFBQXRCLEVBQU9GLENBQVBFLENBQUEsQ0FBQTtBQUFBLFVBQVcsV0FBQTBDLE1BQUFBLENBQUFBO0FBQVgsUUFBQTtBQUFBLFVBQWtCLFdBQUFHLE9BQUFBLENBQUFBO0FBQWxCLFFBQUE7QUFERixNQUFBO0FBQUEsUUFHRSxXQUFBRCxnQkFBQUEsQ0FBZSxZQUFXRCxTQUExQkM7QUFIRixNQUFBLENBOVVKO0FBNlVFVSxJQUFBQSxDQUFBQSxvQ0FBQUEsQ0F6VUE7QUFBQSxJQWlWQSxPQUFBVixDQUFBQSxrQ0FBQUEsOEJBQUFBLDBCQUFtQixNQUFELEVBQVMsU0FBM0JBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUEsSUFBQSxRQUF5Qyx1QkFBQWxDLFFBQUFBLENBQVlpQyxTQUFaakMsQ0FBekMsQ0FBQTtBQUFBLE1BQUE7QUFBQSxZQUFBWCxPQUFBQSxDQUFNLDJCQUFXLGdCQUFqQkE7QUFBQSxNQUFBLENBQUE7QUFBQSxNQUVBeUQsSUFBSUMsQ0FBQUEsRUFBQUEsQ0FBQXBCLE9BQUFBLENBQUlNLFNBQUpOLENBRko7QUFBQSxNQUdBcUIsSUFBSXpCLFVBQUF4QyxJQUFBd0MsRUFBT3VCLENBQVB2QixDQUhKO0FBQUEsTUFLQSxJQUFBLFFBQUdqQyxPQUFBMkMsU0FBQTNDLEVBQVlFLENBQVpGLENBQUgsQ0FBQTtBQUFBLFFBQ0UsT0FBQ0ssV0FBQXFELENBQUFDLE1BQUFBLENBQU9DLE1BQVBELENBQUF0RCxFQUFpQm1ELENBQWpCbkQsQ0FBRFYsTUFBQUEsQ0FBQUE7QUFERixNQUFBO0FBQUEsUUFHRSxXQUFBeUMsVUFBQUEsQ0FBU3NCLENBQUFDLE1BQUFBLENBQU9DLE1BQVBELEdBQWdCSCxDQUF6QnBCO0FBSEYsTUFBQSxDQUxBO0FBREZRLElBQUFBLENBQUFBLHlDQUFBQSxDQUFBQSwwQkFqVkE7QUFERnJELEVBQUFBLEdBQUFBLFdBQUFBLEVBQWlCLHVCQUFqQkEsV0FGQTtBQUFBLEVBa1dBc0U7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUF6QixDQUFBQSw0QkFBQUEsc0JBQUFBLG9CQUFhLFNBQUQsRUFBWSxXQUF4QkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBcFdGO0FBb1cwQixNQUFBO0FBQUEsTUFBQSxnQkFBY2xDLENBQWQ7QUFBQSxNQUFBLENBcFcxQjtBQUFBLE1BcVdJLE9BQUEsd0JBQUFJLFNBQUFBLENBQWlCa0IsV0FBV0MsV0FBNUJuQixDQXJXSjtBQW9XRThCLElBQUFBLENBQUFBLGtDQUFBQSxDQUFBQTtBQURGeUIsRUFBQUEsR0FBQUEsV0FBQUEsV0FsV0E7QUFBQSxFQXdXQSxPQUFBdEU7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUFzQixDQUFBQSx3QkFBQUEsa0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBcUJ1QixVQUFBQSxDQUFVLFdBQWEsV0FBdkJBLENBQXFDO0FBQzFEO0FBQ0EsdUJBQXFCQSxVQUFBQSxDQUFVLFdBQVlsQyxDQUF0QmtDLENBQXlCO0FBQzlDO0FBQ0E7QUFDQSxxQkFBbUJBLFVBQUFBLENBQVUsV0FBWWxDLENBQXRCa0MsQ0FBeUI7QUFDNUM7QUFDQTtBQUNBLG1CQUFpQkEsVUFBQUEsQ0FBU3RDLEdBQUdJLENBQVprQyxDQUFlO0FBQ2hDO0FBQ0E7QUFyQ0V2QixJQUFBQSxDQUFBQSw2QkFBQUEsQ0FBQUE7QUFERnRCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBeFdBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjIwNzksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3RpbWUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBzbGljZVxuXG5yZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnXG5cbmNsYXNzIFRpbWUgPCBgRGF0ZWBcbiAgaW5jbHVkZSBDb21wYXJhYmxlXG5cbiAgJXh7XG4gICAgdmFyIGRheXNfb2Zfd2VlayA9ICN7JXdbU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXkgU3VuZGF5XX0sXG4gICAgICAgIHNob3J0X2RheXMgICA9ICN7JXdbU3VuIE1vbiBUdWUgV2VkIFRodSBGcmkgU2F0XX0sXG4gICAgICAgIHNob3J0X21vbnRocyA9ICN7JXdbSmFuIEZlYiBNYXIgQXByIE1heSBKdW4gSnVsIEF1ZyBTZXAgT2N0IE5vdiBEZWNdfSxcbiAgICAgICAgbG9uZ19tb250aHMgID0gI3sld1tKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXX07XG4gIH1cblxuICBkZWYgc2VsZi5hdChzZWNvbmRzLCBmcmFjID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKCN7VGltZSA9PT0gc2Vjb25kc30pIHtcbiAgICAgICAgaWYgKGZyYWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgVGltZSBpbnRvIGFuIGV4YWN0IG51bWJlclwifVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKHNlY29uZHMuZ2V0VGltZSgpKTtcbiAgICAgICAgcmVzdWx0LmlzX3V0YyA9IHNlY29uZHMuaXNfdXRjO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlY29uZHMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgc2Vjb25kcyA9ICN7T3BhbC5jb2VyY2VfdG8hKHNlY29uZHMsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyYWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoc2Vjb25kcyAqIDEwMDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZyYWMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgZnJhYyA9ICN7T3BhbC5jb2VyY2VfdG8hKGZyYWMsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEYXRlKHNlY29uZHMgKiAxMDAwICsgKGZyYWMgLyAxMDAwKSk7XG4gICAgfVxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYykge1xuICAgICAgaWYgKHllYXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgeWVhciA9IHBhcnNlSW50KHllYXIsIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHllYXIgPSAje09wYWwuY29lcmNlX3RvIShgeWVhcmAsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vbnRoID09PSBuaWwpIHtcbiAgICAgICAgbW9udGggPSAxO1xuICAgICAgfSBlbHNlIGlmICghbW9udGguJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKCN7YG1vbnRoYC5yZXNwb25kX3RvPyg6dG9fc3RyKX0pIHtcbiAgICAgICAgICBtb250aCA9ICN7YG1vbnRoYC50b19zdHJ9O1xuICAgICAgICAgIHN3aXRjaCAobW9udGgudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGNhc2UgJ2phbic6IG1vbnRoID0gIDE7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2ZlYic6IG1vbnRoID0gIDI7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21hcic6IG1vbnRoID0gIDM7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Fwcic6IG1vbnRoID0gIDQ7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21heSc6IG1vbnRoID0gIDU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2p1bic6IG1vbnRoID0gIDY7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2p1bCc6IG1vbnRoID0gIDc7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2F1Zyc6IG1vbnRoID0gIDg7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NlcCc6IG1vbnRoID0gIDk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ29jdCc6IG1vbnRoID0gMTA7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ25vdic6IG1vbnRoID0gMTE7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2RlYyc6IG1vbnRoID0gMTI7IGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IG1vbnRoID0gI3tgbW9udGhgLnRvX2l9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb250aCA9ICN7T3BhbC5jb2VyY2VfdG8hKGBtb250aGAsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm1vbnRoIG91dCBvZiByYW5nZTogI3tgbW9udGhgfVwifVxuICAgICAgfVxuICAgICAgbW9udGggPSBtb250aCAtIDE7XG5cbiAgICAgIGlmIChkYXkgPT09IG5pbCkge1xuICAgICAgICBkYXkgPSAxO1xuICAgICAgfSBlbHNlIGlmIChkYXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgZGF5ID0gcGFyc2VJbnQoZGF5LCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXkgPSAje09wYWwuY29lcmNlX3RvIShgZGF5YCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF5IDwgMSB8fCBkYXkgPiAzMSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiZGF5IG91dCBvZiByYW5nZTogI3tgZGF5YH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKGhvdXIgPT09IG5pbCkge1xuICAgICAgICBob3VyID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoaG91ci4kJGlzX3N0cmluZykge1xuICAgICAgICBob3VyID0gcGFyc2VJbnQoaG91ciwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG91ciA9ICN7T3BhbC5jb2VyY2VfdG8hKGBob3VyYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoaG91ciA8IDAgfHwgaG91ciA+IDI0KSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJob3VyIG91dCBvZiByYW5nZTogI3tgaG91cmB9XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW4gPT09IG5pbCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfSBlbHNlIGlmIChtaW4uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgbWluID0gcGFyc2VJbnQobWluLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW4gPSAje09wYWwuY29lcmNlX3RvIShgbWluYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAobWluIDwgMCB8fCBtaW4gPiA1OSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibWluIG91dCBvZiByYW5nZTogI3tgbWluYH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYyA9PT0gbmlsKSB7XG4gICAgICAgIHNlYyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKCFzZWMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKHNlYy4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHNlYyA9IHBhcnNlSW50KHNlYywgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlYyA9ICN7T3BhbC5jb2VyY2VfdG8hKGBzZWNgLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYyA8IDAgfHwgc2VjID4gNjApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInNlYyBvdXQgb2YgcmFuZ2U6ICN7YHNlY2B9XCJ9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWNdO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBzZWxmLm5ldyh5ZWFyID0gdW5kZWZpbmVkLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgdXRjX29mZnNldCA9IG5pbClcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQ7XG5cbiAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGNfb2Zmc2V0ICE9PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnT3BhbCBkb2VzIG5vdCBzdXBwb3J0IGV4cGxpY2l0bHkgc3BlY2lmeWluZyBVVEMgb2Zmc2V0IGZvciBUaW1lJ31cbiAgICAgIH1cblxuICAgICAgYXJncyAgPSB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYyk7XG4gICAgICB5ZWFyICA9IGFyZ3NbMF07XG4gICAgICBtb250aCA9IGFyZ3NbMV07XG4gICAgICBkYXkgICA9IGFyZ3NbMl07XG4gICAgICBob3VyICA9IGFyZ3NbM107XG4gICAgICBtaW4gICA9IGFyZ3NbNF07XG4gICAgICBzZWMgICA9IGFyZ3NbNV07XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgMCwgc2VjICogMTAwMCk7XG4gICAgICBpZiAoeWVhciA8IDEwMCkge1xuICAgICAgICByZXN1bHQuc2V0RnVsbFllYXIoeWVhcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYubG9jYWwoeWVhciwgbW9udGggPSBuaWwsIGRheSA9IG5pbCwgaG91ciA9IG5pbCwgbWluID0gbmlsLCBzZWMgPSBuaWwsIG1pbGxpc2Vjb25kID0gbmlsLCBfZHVtbXkxID0gbmlsLCBfZHVtbXkyID0gbmlsLCBfZHVtbXkzID0gbmlsKVxuICAgICMgVGhlIF9kdW1teSBhcmdzIGFyZSB0aGVyZSBvbmx5IGJlY2F1c2UgdGhlIE1SSSB2ZXJzaW9uIGFjY2VwdHMgdXAgdG8gMTAgYXJndW1lbnRzXG4gICAgJXh7XG4gICAgICB2YXIgYXJncywgcmVzdWx0O1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgICAgYXJncyAgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB5ZWFyICA9IGFyZ3NbNV07XG4gICAgICAgIG1vbnRoID0gYXJnc1s0XTtcbiAgICAgICAgZGF5ICAgPSBhcmdzWzNdO1xuICAgICAgICBob3VyICA9IGFyZ3NbMl07XG4gICAgICAgIG1pbiAgID0gYXJnc1sxXTtcbiAgICAgICAgc2VjICAgPSBhcmdzWzBdO1xuICAgICAgfVxuXG4gICAgICBhcmdzICA9IHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKTtcbiAgICAgIHllYXIgID0gYXJnc1swXTtcbiAgICAgIG1vbnRoID0gYXJnc1sxXTtcbiAgICAgIGRheSAgID0gYXJnc1syXTtcbiAgICAgIGhvdXIgID0gYXJnc1szXTtcbiAgICAgIG1pbiAgID0gYXJnc1s0XTtcbiAgICAgIHNlYyAgID0gYXJnc1s1XTtcblxuICAgICAgcmVzdWx0ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKTtcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XG4gICAgICAgIHJlc3VsdC5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5nbSh5ZWFyLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgbWlsbGlzZWNvbmQgPSBuaWwsIF9kdW1teTEgPSBuaWwsIF9kdW1teTIgPSBuaWwsIF9kdW1teTMgPSBuaWwpXG4gICAgIyBUaGUgX2R1bW15IGFyZ3MgYXJlIHRoZXJlIG9ubHkgYmVjYXVzZSB0aGUgTVJJIHZlcnNpb24gYWNjZXB0cyB1cCB0byAxMCBhcmd1bWVudHNcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQ7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxMCkge1xuICAgICAgICBhcmdzICA9ICRzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHllYXIgID0gYXJnc1s1XTtcbiAgICAgICAgbW9udGggPSBhcmdzWzRdO1xuICAgICAgICBkYXkgICA9IGFyZ3NbM107XG4gICAgICAgIGhvdXIgID0gYXJnc1syXTtcbiAgICAgICAgbWluICAgPSBhcmdzWzFdO1xuICAgICAgICBzZWMgICA9IGFyZ3NbMF07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgID0gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpO1xuICAgICAgeWVhciAgPSBhcmdzWzBdO1xuICAgICAgbW9udGggPSBhcmdzWzFdO1xuICAgICAgZGF5ICAgPSBhcmdzWzJdO1xuICAgICAgaG91ciAgPSBhcmdzWzNdO1xuICAgICAgbWluICAgPSBhcmdzWzRdO1xuICAgICAgc2VjICAgPSBhcmdzWzVdO1xuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApKTtcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XG4gICAgICAgIHJlc3VsdC5zZXRVVENGdWxsWWVhcih5ZWFyKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5pc191dGMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhbGlhcyBta3RpbWUgbG9jYWxcbiAgICBhbGlhcyB1dGMgZ21cbiAgZW5kXG5cbiAgZGVmIHNlbGYubm93XG4gICAgbmV3XG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIGlmIFRpbWUgPT09IG90aGVyXG4gICAgICByYWlzZSBUeXBlRXJyb3IsICd0aW1lICsgdGltZT8nXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgb3RoZXIgPSAje09wYWwuY29lcmNlX3RvIShvdGhlciwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpICsgKG90aGVyICogMTAwMCkpO1xuICAgICAgcmVzdWx0LmlzX3V0YyA9IHNlbGYuaXNfdXRjO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIGlmIFRpbWUgPT09IG90aGVyXG4gICAgICByZXR1cm4gYChzZWxmLmdldFRpbWUoKSAtIG90aGVyLmdldFRpbWUoKSkgLyAxMDAwYFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoIW90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIG90aGVyID0gI3tPcGFsLmNvZXJjZV90byEob3RoZXIsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSAtIChvdGhlciAqIDEwMDApKTtcbiAgICAgIHJlc3VsdC5pc191dGMgPSBzZWxmLmlzX3V0YztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGlmIFRpbWUgPT09IG90aGVyXG4gICAgICB0b19mIDw9PiBvdGhlci50b19mXG4gICAgZWxzZVxuICAgICAgciA9IG90aGVyIDw9PiBzZWxmXG4gICAgICBpZiByLm5pbD9cbiAgICAgICAgbmlsXG4gICAgICBlbHNpZiByID4gMFxuICAgICAgICAtMVxuICAgICAgZWxzaWYgciA8IDBcbiAgICAgICAgMVxuICAgICAgZWxzZVxuICAgICAgICAwXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIFRpbWUgPT09IG90aGVyICYmIGAje3RvX2Z9ID09PSAje290aGVyLnRvX2Z9YFxuICBlbmRcblxuICBkZWYgYXNjdGltZVxuICAgIHN0cmZ0aW1lICclYSAlYiAlZSAlSDolTTolUyAlWSdcbiAgZW5kXG5cbiAgYWxpYXMgY3RpbWUgYXNjdGltZVxuXG4gIGRlZiBkYXlcbiAgICBgc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ0RhdGUoKSA6IHNlbGYuZ2V0RGF0ZSgpYFxuICBlbmRcblxuICBkZWYgeWRheVxuICAgICMgaHR0cDovL2phdmFzY3JpcHQuYWJvdXQuY29tL2xpYnJhcnkvYmxkYXl5ZWFyLmh0bVxuICAgICMgYWxzbyBzZWUgbW9tZW50LmpzIGltcGxlbWVudGF0aW9uOiBodHRwOi8vZ2l0LmlvL3ZDS05FXG5cbiAgICBzdGFydF9vZl95ZWFyID0gVGltZS5uZXcoeWVhcikudG9faVxuICAgIHN0YXJ0X29mX2RheSAgPSBUaW1lLm5ldyh5ZWFyLCBtb250aCwgZGF5KS50b19pXG4gICAgb25lX2RheSAgICAgICA9IDg2XzQwMFxuXG4gICAgKChzdGFydF9vZl9kYXkgLSBzdGFydF9vZl95ZWFyKSAvIG9uZV9kYXkpLnJvdW5kICsgMVxuICBlbmRcblxuICBkZWYgaXNkc3RcbiAgICAleHtcbiAgICAgIHZhciBqYW4gPSBuZXcgRGF0ZShzZWxmLmdldEZ1bGxZZWFyKCksIDAsIDEpLFxuICAgICAgICAgIGp1bCA9IG5ldyBEYXRlKHNlbGYuZ2V0RnVsbFllYXIoKSwgNiwgMSk7XG4gICAgICByZXR1cm4gc2VsZi5nZXRUaW1lem9uZU9mZnNldCgpIDwgTWF0aC5tYXgoamFuLmdldFRpbWV6b25lT2Zmc2V0KCksIGp1bC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGRzdD8gaXNkc3RcblxuICBkZWYgZHVwXG4gICAgY29weSA9IGBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSlgXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2R1cChzZWxmKVxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICBvdGhlci5pc19hPyhUaW1lKSAmJiAoc2VsZiA8PT4gb3RoZXIpLnplcm8/XG4gIGVuZFxuXG4gIGRlZiBmcmlkYXk/XG4gICAgYCN7d2RheX0gPT0gNWBcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBgJ1RpbWU6JyArIHNlbGYuZ2V0VGltZSgpYFxuICBlbmRcblxuICBkZWYgaG91clxuICAgIGBzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDSG91cnMoKSA6IHNlbGYuZ2V0SG91cnMoKWBcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBpZiB1dGM/XG4gICAgICBzdHJmdGltZSAnJVktJW0tJWQgJUg6JU06JVMgVVRDJ1xuICAgIGVsc2VcbiAgICAgIHN0cmZ0aW1lICclWS0lbS0lZCAlSDolTTolUyAleidcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgbWRheSBkYXlcblxuICBkZWYgbWluXG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENNaW51dGVzKCkgOiBzZWxmLmdldE1pbnV0ZXMoKWBcbiAgZW5kXG5cbiAgZGVmIG1vblxuICAgIGAoc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ01vbnRoKCkgOiBzZWxmLmdldE1vbnRoKCkpICsgMWBcbiAgZW5kXG5cbiAgZGVmIG1vbmRheT9cbiAgICBgI3t3ZGF5fSA9PSAxYFxuICBlbmRcblxuICBhbGlhcyBtb250aCBtb25cblxuICBkZWYgc2F0dXJkYXk/XG4gICAgYCN7d2RheX0gPT0gNmBcbiAgZW5kXG5cbiAgZGVmIHNlY1xuICAgIGBzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDU2Vjb25kcygpIDogc2VsZi5nZXRTZWNvbmRzKClgXG4gIGVuZFxuXG4gIGRlZiBzdWNjXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgKyAxMDAwKTtcbiAgICAgIHJlc3VsdC5pc191dGMgPSBzZWxmLmlzX3V0YztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdXNlY1xuICAgIGBzZWxmLmdldE1pbGxpc2Vjb25kcygpICogMTAwMGBcbiAgZW5kXG5cbiAgZGVmIHpvbmVcbiAgICAleHtcbiAgICAgIHZhciBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCksXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJygnKSA9PSAtMSkge1xuICAgICAgICByZXN1bHQgPSBzdHJpbmcubWF0Y2goL1tBLVpdezMsNH0vKVswXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBzdHJpbmcubWF0Y2goL1xcKCguKylcXCkoPzpcXHN8JCkvKVsxXVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0ID09IFwiR01UXCIgJiYgLyhHTVRcXFcqXFxkezR9KS8udGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBSZWdFeHAuJDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnZXRnbVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpKTtcbiAgICAgIHJlc3VsdC5pc191dGMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGdldHV0YyBnZXRnbVxuXG4gIGRlZiBnbXRpbWVcbiAgICAleHtcbiAgICAgIHNlbGYuaXNfdXRjID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgdXRjIGdtdGltZVxuXG4gIGRlZiBnbXQ/XG4gICAgYHNlbGYuaXNfdXRjID09PSB0cnVlYFxuICBlbmRcblxuICBkZWYgZ210X29mZnNldFxuICAgIGBzZWxmLmlzX3V0YyA/IDAgOiAtc2VsZi5nZXRUaW1lem9uZU9mZnNldCgpICogNjBgXG4gIGVuZFxuXG4gIGRlZiBzdHJmdGltZShmb3JtYXQpXG4gICAgJXh7XG4gICAgICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoLyUoW1xcLV8jXjBdKjp7MCwyfSkoXFxkKyk/KFtFT10qKSguKS9nLCBmdW5jdGlvbihmdWxsLCBmbGFncywgd2lkdGgsIF8sIGNvbnYpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCIsXG4gICAgICAgICAgICB6ZXJvICAgPSBmbGFncy5pbmRleE9mKCcwJykgIT09IC0xLFxuICAgICAgICAgICAgcGFkICAgID0gZmxhZ3MuaW5kZXhPZignLScpID09PSAtMSxcbiAgICAgICAgICAgIGJsYW5rICA9IGZsYWdzLmluZGV4T2YoJ18nKSAhPT0gLTEsXG4gICAgICAgICAgICB1cGNhc2UgPSBmbGFncy5pbmRleE9mKCdeJykgIT09IC0xLFxuICAgICAgICAgICAgaW52ZXJ0ID0gZmxhZ3MuaW5kZXhPZignIycpICE9PSAtMSxcbiAgICAgICAgICAgIGNvbG9ucyA9IChmbGFncy5tYXRjaCgnOicpIHx8IFtdKS5sZW5ndGg7XG5cbiAgICAgICAgd2lkdGggPSBwYXJzZUludCh3aWR0aCwgMTApO1xuXG4gICAgICAgIGlmICh6ZXJvICYmIGJsYW5rKSB7XG4gICAgICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJzAnKSA8IGZsYWdzLmluZGV4T2YoJ18nKSkge1xuICAgICAgICAgICAgemVybyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsYW5rID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChjb252KSB7XG4gICAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t5ZWFyfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE1hdGgucm91bmQoI3t5ZWFyfSAvIDEwMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3t5ZWFyfSAlIDEwMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAje21vbn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgcmVzdWx0ICs9IGxvbmdfbW9udGhzWyN7bW9ufSAtIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVybztcbiAgICAgICAgICAgIHJlc3VsdCArPSBzaG9ydF9tb250aHNbI3ttb259IC0gMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFua1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm9cbiAgICAgICAgICAgIHJlc3VsdCArPSAje2RheX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2onOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyAzIDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t5ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7aG91cn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2snOlxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7aG91cn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0knOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSAlIDEyIHx8IDEyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm87XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gJSAxMiB8fCAxMik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICgje2hvdXJ9ID49IDEyID8gXCJwbVwiIDogXCJhbVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gPj0gMTIgPyBcIlBNXCIgOiBcIkFNXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3ttaW59O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzZWN9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyAzIDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gc2VsZi5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICB3aWR0aCAgID0gaXNOYU4od2lkdGgpID8gOSA6IHdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7YHNlbGYuZ2V0TWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKWAucmp1c3QoMywgJzAnKX07XG4gICAgICAgICAgICByZXN1bHQgID0gI3tgcmVzdWx0YC5sanVzdChgd2lkdGhgLCAnMCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ICA9IHNlbGYuZ2V0VGltZXpvbmVPZmZzZXQoKSxcbiAgICAgICAgICAgICAgICBob3VycyAgID0gTWF0aC5mbG9vcihNYXRoLmFicyhvZmZzZXQpIC8gNjApLFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLmFicyhvZmZzZXQpICUgNjA7XG5cbiAgICAgICAgICAgIHJlc3VsdCArPSBvZmZzZXQgPCAwID8gXCIrXCIgOiBcIi1cIjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBob3VycyA8IDEwID8gXCIwXCIgOiBcIlwiO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGhvdXJzO1xuXG4gICAgICAgICAgICBpZiAoY29sb25zID4gMCkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gXCI6XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCArPSBtaW51dGVzIDwgMTAgPyBcIjBcIiA6IFwiXCI7XG4gICAgICAgICAgICByZXN1bHQgKz0gbWludXRlcztcblxuICAgICAgICAgICAgaWYgKGNvbG9ucyA+IDEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiOjAwXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t6b25lfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gZGF5c19vZl93ZWVrWyN7d2RheX1dO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBzaG9ydF9kYXlzWyN7d2RheX1dO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3t3ZGF5fSArIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3dkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2N3ZWVrX2N5ZWFyWzBdLnRvX3Mucmp1c3QoMiwgJzAnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7Y3dlZWtfY3llYXJbMV19O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2N3ZWVrX2N5ZWFyWzFdWy0yLi4tMV19O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3RvX2l9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcdFwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJWEgJWIgJWUgJVQgJVknKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVtLyVkLyV5Jyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdGJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclWS0lbS0lZCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJWUtJV5iLSU0WScpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJUk6JU06JVMgJXAnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1InOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVIOiVNJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclSDolTTolUycpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmdWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwY2FzZSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludmVydCkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9bQS1aXS8sIGZ1bmN0aW9uKGMpIHsgYy50b0xvd2VyQ2FzZSgpIH0pLlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlKC9bYS16XS8sIGZ1bmN0aW9uKGMpIHsgYy50b1VwcGVyQ2FzZSgpIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhZCAmJiAoemVybyB8fCBibGFuaykpIHtcbiAgICAgICAgICByZXN1bHQgPSAje2ByZXN1bHRgLnJqdXN0KGBpc05hTih3aWR0aCkgPyAyIDogd2lkdGhgLCBgYmxhbmsgPyBcIiBcIiA6IFwiMFwiYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN1bmRheT9cbiAgICBgI3t3ZGF5fSA9PSAwYFxuICBlbmRcblxuICBkZWYgdGh1cnNkYXk/XG4gICAgYCN7d2RheX0gPT0gNGBcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBbc2VjLCBtaW4sIGhvdXIsIGRheSwgbW9udGgsIHllYXIsIHdkYXksIHlkYXksIGlzZHN0LCB6b25lXVxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIGBzZWxmLmdldFRpbWUoKSAvIDEwMDBgXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgYHBhcnNlSW50KHNlbGYuZ2V0VGltZSgpIC8gMTAwMCwgMTApYFxuICBlbmRcblxuICBhbGlhcyB0b19zIGluc3BlY3RcblxuICBkZWYgdHVlc2RheT9cbiAgICBgI3t3ZGF5fSA9PSAyYFxuICBlbmRcblxuICBhbGlhcyB0dl9zZWMgdG9faVxuXG4gIGFsaWFzIHR2X3VzZWMgdXNlY1xuXG4gIGFsaWFzIHV0Yz8gZ210P1xuXG4gIGFsaWFzIGdtdG9mZiBnbXRfb2Zmc2V0XG4gIGFsaWFzIHV0Y19vZmZzZXQgZ210X29mZnNldFxuXG4gIGRlZiB3ZGF5XG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENEYXkoKSA6IHNlbGYuZ2V0RGF5KClgXG4gIGVuZFxuXG4gIGRlZiB3ZWRuZXNkYXk/XG4gICAgYCN7d2RheX0gPT0gM2BcbiAgZW5kXG5cbiAgZGVmIHllYXJcbiAgICBgc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ0Z1bGxZZWFyKCkgOiBzZWxmLmdldEZ1bGxZZWFyKClgXG4gIGVuZFxuXG4gIGRlZiBjd2Vla19jeWVhclxuICAgIGphbjAxID0gVGltZS5uZXcoeWVhciwgMSwgMSlcbiAgICBqYW4wMV93ZGF5ID0gamFuMDEud2RheVxuICAgIGZpcnN0X21vbmRheSA9IDBcbiAgICB5ZWFyID0gc2VsZi55ZWFyXG4gICAgaWYgamFuMDFfd2RheSA8PSA0ICYmIGphbjAxX3dkYXkgIT0gMFxuICAgICAgIyBKYW4gMDEgaXMgaW4gdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXJcbiAgICAgIG9mZnNldCA9IGphbjAxX3dkYXkgLSAxXG4gICAgZWxzZVxuICAgICAgIyBKYW4gMDEgaXMgaW4gdGhlIGxhc3Qgd2VlayBvZiB0aGUgcHJldmlvdXMgeWVhclxuICAgICAgb2Zmc2V0ID0gamFuMDFfd2RheSAtIDcgLSAxXG4gICAgICBvZmZzZXQgPSAtMSBpZiBvZmZzZXQgPT0gLTggIyBBZGp1c3QgaWYgSmFuIDAxIGlzIGEgU3VuZGF5XG4gICAgZW5kXG5cbiAgICB3ZWVrID0gKCh5ZGF5ICsgb2Zmc2V0KSAvIDcuMDApLmNlaWxcblxuICAgIGlmIHdlZWsgPD0gMFxuICAgICAgIyBHZXQgdGhlIGxhc3Qgd2VlayBvZiB0aGUgcHJldmlvdXMgeWVhclxuICAgICAgcmV0dXJuIFRpbWUubmV3KHNlbGYueWVhciAtIDEsIDEyLCAzMSkuY3dlZWtfY3llYXJcbiAgICBlbHNpZiB3ZWVrID09IDUzXG4gICAgICAjIEZpbmQgb3V0IHdoZXRoZXIgdGhpcyBpcyBhY3R1YWxseSB3ZWVrIDUzIG9yIGFscmVhZHkgd2VlayAwMSBvZiB0aGUgZm9sbG93aW5nIHllYXJcbiAgICAgIGRlYzMxID0gVGltZS5uZXcoc2VsZi55ZWFyLCAxMiwgMzEpXG4gICAgICBkZWMzMV93ZGF5ID0gZGVjMzEud2RheVxuICAgICAgaWYgZGVjMzFfd2RheSA8PSAzICYmIGRlYzMxX3dkYXkgIT0gMFxuICAgICAgICB3ZWVrID0gMVxuICAgICAgICB5ZWFyICs9IDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgW3dlZWssIHllYXJdXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiaW5jbHVkZSIsImF0Iiwic2VsZiIsIj09PSIsInNlY29uZHMiLCJyYWlzZSIsImNvZXJjZV90byEiLCJmcmFjIiwicmVzcG9uZF90bz8iLCJ0b19zdHIiLCJ0b19pIiwibmV3IiwibG9jYWwiLCJnbSIsIm5vdyIsIisiLCJvdGhlciIsIi0iLCI8PT4iLCJ0b19mIiwiciIsIm5pbD8iLCI+IiwiMCIsIi0xIiwiPCIsIjEiLCI9PSIsIiRyZXRfb3JfMSIsImFzY3RpbWUiLCJzdHJmdGltZSIsImRheSIsInlkYXkiLCJzdGFydF9vZl95ZWFyIiwieWVhciIsInN0YXJ0X29mX2RheSIsIm1vbnRoIiwib25lX2RheSIsIjg2NDAwIiwiLyIsInJvdW5kIiwiaXNkc3QiLCJkdXAiLCJjb3B5IiwiY29weV9pbnN0YW5jZV92YXJpYWJsZXMiLCJpbml0aWFsaXplX2R1cCIsImVxbD8iLCIkcmV0X29yXzIiLCJpc19hPyIsInplcm8/IiwiZnJpZGF5PyIsIndkYXkiLCJoYXNoIiwiaG91ciIsImluc3BlY3QiLCJ1dGM/IiwibWluIiwibW9uIiwibW9uZGF5PyIsInNhdHVyZGF5PyIsInNlYyIsInN1Y2MiLCJ1c2VjIiwiem9uZSIsImdldGdtIiwiZ210aW1lIiwiZ210PyIsImdtdF9vZmZzZXQiLCJyanVzdCIsIjMiLCJsanVzdCIsImN3ZWVrX2N5ZWFyIiwiW10iLCJ0b19zIiwiMiIsIi0yIiwic3VuZGF5PyIsInRodXJzZGF5PyIsInRvX2EiLCJ0dWVzZGF5PyIsIndlZG5lc2RheT8iLCJqYW4wMSIsImphbjAxX3dkYXkiLCJmaXJzdF9tb25kYXkiLCIkcmV0X29yXzMiLCI8PSIsIjQiLCIhPSIsIm9mZnNldCIsIjciLCItOCIsIndlZWsiLCJjZWlsIiwiMTIiLCIzMSIsIjUzIiwiZGVjMzEiLCJkZWMzMV93ZGF5IiwiJHJldF9vcl80Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxNQUFBQSxTQUFBQSxDQUFRLG9CQUFSQSxDQUFBO0FBQUEsRUFFQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FBQTtBQUFBO0FBR0YsdUJBQXlCLENBQUcsUUFBSCxFQUFVLFFBQVYsRUFBaUIsU0FBakIsRUFBeUIsV0FBekIsRUFBbUMsVUFBbkMsRUFBNEMsUUFBNUMsRUFBbUQsVUFBbkQsRUFBNEQsUUFBNUQsQ0FBb0U7QUFDN0YsdUJBQXlCLENBQUcsS0FBSCxFQUFPLEtBQVAsRUFBVyxLQUFYLEVBQWUsS0FBZixFQUFtQixLQUFuQixFQUF1QixLQUF2QixFQUEyQixLQUEzQixDQUFnQztBQUN6RCx1QkFBeUIsQ0FBRyxLQUFILEVBQU8sS0FBUCxFQUFXLEtBQVgsRUFBZSxLQUFmLEVBQW1CLEtBQW5CLEVBQXVCLEtBQXZCLEVBQTJCLEtBQTNCLEVBQStCLEtBQS9CLEVBQW1DLEtBQW5DLEVBQXVDLEtBQXZDLEVBQTJDLEtBQTNDLEVBQStDLEtBQS9DLENBQW9EO0FBQzdFLHVCQUF5QixDQUFHLFNBQUgsRUFBVyxVQUFYLEVBQW9CLE9BQXBCLEVBQTBCLE9BQTFCLEVBQWdDLEtBQWhDLEVBQW9DLE1BQXBDLEVBQXlDLE1BQXpDLEVBQThDLFFBQTlDLEVBQXFELFdBQXJELEVBQStELFNBQS9ELEVBQXVFLFVBQXZFLEVBQWdGLFVBQWhGLENBQTBGO0FBQ25ILEVBUEU7QUFBQSxJQVNBQyxVQUFJQyxJQUFKRCxTQUFBQSxhQUFB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T0FBTyxvQkFBQTFFLEtBQUFBLENBQVNNLFVBQUFmLElBQUFnQyxNQUFBQSxDQUFBQSxDQUFBakIsRUFBWVMsQ0FBWlQsR0FBZTRFLElBQUlDLEVBQTVCbkYsQ0FBQTRELGFBQUFBLENBQUFBO0FBRlQsTUFBQSxPQUdBLElBQU1vQixJQUFBaEUsT0FBQUEsQ0FBUW9FLEVBQVJwRSxDQUFOO0FBQUE7QUFFRSxRQUFBcUUsUUFBUSxvQkFBQXJGLEtBQUFBLENBQVNULElBQUFnQyxNQUFBQSxDQUFBQSxHQUFXMkQsSUFBSUMsRUFBeEJuRixDQUFSO0FBQUEsUUFDQXNGLGFBQWFELEtBQUE3QyxNQUFBQSxDQUFBQSxDQURiO0FBQUEsUUFFQSxJQUFBLFFBQUcsYUFBQSxJQUFBLFFBenVCVCtDLENBQUFBLFlBeXVCU2IsT0FBQVksVUFBQVosRUFBY2hCLENBQWRnQixDQXp1QlRhLENBeXVCUyxDQUFBO0FBQUEsVUFBbUIsT0FBQUQsVUFBQVYsT0FBQUEsQ0FBY2hFLENBQWRnRTtBQUFuQixRQUFBO0FBQUEsVUF6dUJULE9BQUE7QUF5dUJTLFFBQUEsQ0FBQSxrQkFBSCxDQUFBO0FBQUE7QUFDRSxVQUFBSSxPQUFPakUsQ0FBUDtBQUFBLFVBQ0FRLE9BM3VCUm5CLFNBMnVCUW1CLElBM3VCUm5CLEVBMnVCZ0JXLENBM3VCaEJYLENBMHVCUSxDQURGLENBRkEsQ0FGRixDQWxCQTtBQUFBLE1BNEJBLE9BQUEsQ0FBQzRFLElBQUQsRUFBT3pELElBQVAsQ0E1QkE7QUFERnFDLElBQUFBLENBQUFBLGtDQUFBQSxDQUFBQSx1QkE1c0JBO0FBREZ4RSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFjLElBQWRBLFdBRkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzAzNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvc3RydWN0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuY2xhc3MgU3RydWN0XG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gIGRlZiBzZWxmLm5ldyhjb25zdF9uYW1lLCAqYXJncywga2V5d29yZF9pbml0OiBmYWxzZSwgJmJsb2NrKVxuICAgIGlmIGNvbnN0X25hbWVcbiAgICAgIGJlZ2luXG4gICAgICAgIGNvbnN0X25hbWUgPSBPcGFsLmNvbnN0X25hbWUhKGNvbnN0X25hbWUpXG4gICAgICByZXNjdWUgVHlwZUVycm9yLCBOYW1lRXJyb3JcbiAgICAgICAgYXJncy51bnNoaWZ0KGNvbnN0X25hbWUpXG4gICAgICAgIGNvbnN0X25hbWUgPSBuaWxcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYXJncy5tYXAgZG8gfGFyZ3xcbiAgICAgIE9wYWwuY29lcmNlX3RvIShhcmcsIFN0cmluZywgOnRvX3N0cilcbiAgICBlbmRcblxuICAgIGtsYXNzID0gQ2xhc3MubmV3KHNlbGYpIGRvXG4gICAgICBhcmdzLmVhY2ggeyB8YXJnfCBkZWZpbmVfc3RydWN0X2F0dHJpYnV0ZShhcmcpIH1cblxuICAgICAgY2xhc3MgPDwgc2VsZlxuICAgICAgICBkZWYgbmV3KCphcmdzKVxuICAgICAgICAgIGluc3RhbmNlID0gYWxsb2NhdGVcbiAgICAgICAgICBgI3tpbnN0YW5jZX0uJCRkYXRhID0ge31gXG4gICAgICAgICAgaW5zdGFuY2UuaW5pdGlhbGl6ZSgqYXJncylcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICBlbmRcblxuICAgICAgICBhbGlhc19tZXRob2QgOltdLCA6bmV3XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGtsYXNzLm1vZHVsZV9ldmFsKCZibG9jaykgaWYgYmxvY2tcbiAgICBga2xhc3MuJCRrZXl3b3JkX2luaXQgPSBrZXl3b3JkX2luaXRgXG5cbiAgICBpZiBjb25zdF9uYW1lXG4gICAgICBTdHJ1Y3QuY29uc3Rfc2V0KGNvbnN0X25hbWUsIGtsYXNzKVxuICAgIGVuZFxuXG4gICAga2xhc3NcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUobmFtZSlcbiAgICBpZiBzZWxmID09IFN0cnVjdFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3lvdSBjYW5ub3QgZGVmaW5lIGF0dHJpYnV0ZXMgdG8gdGhlIFN0cnVjdCBjbGFzcydcbiAgICBlbmRcblxuICAgIG1lbWJlcnMgPDwgbmFtZVxuXG4gICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvXG4gICAgICBgc2VsZi4kJGRhdGFbbmFtZV1gXG4gICAgZW5kXG5cbiAgICBkZWZpbmVfbWV0aG9kIFwiI3tuYW1lfT1cIiBkbyB8dmFsdWV8XG4gICAgICBgc2VsZi4kJGRhdGFbbmFtZV0gPSB2YWx1ZWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYubWVtYmVyc1xuICAgIGlmIHNlbGYgPT0gU3RydWN0XG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndGhlIFN0cnVjdCBjbGFzcyBoYXMgbm8gbWVtYmVycydcbiAgICBlbmRcblxuICAgIEBtZW1iZXJzIHx8PSBbXVxuICBlbmRcblxuICBkZWYgc2VsZi5pbmhlcml0ZWQoa2xhc3MpXG4gICAgbWVtYmVycyA9IEBtZW1iZXJzXG5cbiAgICBrbGFzcy5pbnN0YW5jZV9ldmFsIGRvXG4gICAgICBAbWVtYmVycyA9IG1lbWJlcnNcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoKmFyZ3MpXG4gICAgaWYgYCN7c2VsZi5jbGFzc30uJCRrZXl3b3JkX2luaXRgXG4gICAgICBrd2FyZ3MgPSBhcmdzLmxhc3QgfHwge31cblxuICAgICAgaWYgYXJncy5sZW5ndGggPiAxIHx8IGAoYXJncy5sZW5ndGggPT09IDEgJiYgIWt3YXJncy4kJGlzX2hhc2gpYFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuICN7YXJncy5sZW5ndGh9LCBleHBlY3RlZCAwKVwiXG4gICAgICBlbmRcblxuICAgICAgZXh0cmEgPSBrd2FyZ3Mua2V5cyAtIHNlbGYuY2xhc3MubWVtYmVyc1xuICAgICAgaWYgZXh0cmEuYW55P1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcInVua25vd24ga2V5d29yZHM6ICN7ZXh0cmEuam9pbignLCAnKX1cIlxuICAgICAgZW5kXG5cbiAgICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIGRvIHxuYW1lfFxuICAgICAgICBzZWxmW25hbWVdID0ga3dhcmdzW25hbWVdXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBpZiBhcmdzLmxlbmd0aCA+IHNlbGYuY2xhc3MubWVtYmVycy5sZW5ndGhcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3N0cnVjdCBzaXplIGRpZmZlcnMnXG4gICAgICBlbmRcblxuICAgICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2hfd2l0aF9pbmRleCBkbyB8bmFtZSwgaW5kZXh8XG4gICAgICAgIHNlbGZbbmFtZV0gPSBhcmdzW2luZGV4XVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkoZnJvbSlcbiAgICAleHtcbiAgICAgIHNlbGYuJCRkYXRhID0ge31cbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbS4kJGRhdGEpLCBpLCBtYXgsIG5hbWU7XG4gICAgICBmb3IgKGkgPSAwLCBtYXggPSBrZXlzLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBrZXlzW2ldO1xuICAgICAgICBzZWxmLiQkZGF0YVtuYW1lXSA9IGZyb20uJCRkYXRhW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1lbWJlcnNcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnNcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBIYXNoLm5ldyhgc2VsZi4kJGRhdGFgKS5oYXNoXG4gIGVuZFxuXG4gIGRlZiBbXShuYW1lKVxuICAgIGlmIEludGVnZXIgPT09IG5hbWVcbiAgICAgIHJhaXNlIEluZGV4RXJyb3IsIFwib2Zmc2V0ICN7bmFtZX0gdG9vIHNtYWxsIGZvciBzdHJ1Y3Qoc2l6ZToje3NlbGYuY2xhc3MubWVtYmVycy5zaXplfSlcIiBpZiBuYW1lIDwgLXNlbGYuY2xhc3MubWVtYmVycy5zaXplXG4gICAgICByYWlzZSBJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBsYXJnZSBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA+PSBzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuXG4gICAgICBuYW1lID0gc2VsZi5jbGFzcy5tZW1iZXJzW25hbWVdXG4gICAgZWxzaWYgU3RyaW5nID09PSBuYW1lXG4gICAgICAleHtcbiAgICAgICAgaWYoIXNlbGYuJCRkYXRhLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgI3tyYWlzZSBOYW1lRXJyb3IubmV3KFwibm8gbWVtYmVyICcje25hbWV9JyBpbiBzdHJ1Y3RcIiwgbmFtZSl9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje25hbWUuY2xhc3N9IGludG8gSW50ZWdlclwiXG4gICAgZW5kXG5cbiAgICBuYW1lID0gT3BhbC5jb2VyY2VfdG8hKG5hbWUsIFN0cmluZywgOnRvX3N0cilcbiAgICBgc2VsZi4kJGRhdGFbbmFtZV1gXG4gIGVuZFxuXG4gIGRlZiBbXT0obmFtZSwgdmFsdWUpXG4gICAgaWYgSW50ZWdlciA9PT0gbmFtZVxuICAgICAgcmFpc2UgSW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gc21hbGwgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPCAtc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcbiAgICAgIHJhaXNlIEluZGV4RXJyb3IsIFwib2Zmc2V0ICN7bmFtZX0gdG9vIGxhcmdlIGZvciBzdHJ1Y3Qoc2l6ZToje3NlbGYuY2xhc3MubWVtYmVycy5zaXplfSlcIiBpZiBuYW1lID49IHNlbGYuY2xhc3MubWVtYmVycy5zaXplXG5cbiAgICAgIG5hbWUgPSBzZWxmLmNsYXNzLm1lbWJlcnNbbmFtZV1cbiAgICBlbHNpZiBTdHJpbmcgPT09IG5hbWVcbiAgICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJubyBtZW1iZXIgJyN7bmFtZX0nIGluIHN0cnVjdFwiLCBuYW1lKSB1bmxlc3Mgc2VsZi5jbGFzcy5tZW1iZXJzLmluY2x1ZGU/KG5hbWUudG9fc3ltKVxuICAgIGVsc2VcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mICN7bmFtZS5jbGFzc30gaW50byBJbnRlZ2VyXCJcbiAgICBlbmRcblxuICAgIG5hbWUgPSBPcGFsLmNvZXJjZV90byEobmFtZSwgU3RyaW5nLCA6dG9fc3RyKVxuICAgIGBzZWxmLiQkZGF0YVtuYW1lXSA9IHZhbHVlYFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pbnN0YW5jZV9vZj8oc2VsZi5jbGFzcylcblxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkMSA9IHt9LCByZWN1cnNlZDIgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxZXEoc3RydWN0LCBvdGhlcikge1xuICAgICAgICB2YXIga2V5LCBhLCBiO1xuXG4gICAgICAgIHJlY3Vyc2VkMVsje2BzdHJ1Y3RgLl9faWRfX31dID0gdHJ1ZTtcbiAgICAgICAgcmVjdXJzZWQyWyN7YG90aGVyYC5fX2lkX199XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gc3RydWN0LiQkZGF0YSkge1xuICAgICAgICAgIGEgPSBzdHJ1Y3QuJCRkYXRhW2tleV07XG4gICAgICAgICAgYiA9IG90aGVyLiQkZGF0YVtrZXldO1xuXG4gICAgICAgICAgaWYgKCN7U3RydWN0ID09PSBgYWB9KSB7XG4gICAgICAgICAgICBpZiAoIXJlY3Vyc2VkMS5oYXNPd25Qcm9wZXJ0eSgje2BhYC5fX2lkX199KSB8fCAhcmVjdXJzZWQyLmhhc093blByb3BlcnR5KCN7YGJgLl9faWRfX30pKSB7XG4gICAgICAgICAgICAgIGlmICghX2VxZXEoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEje2BhYCA9PSBgYmB9KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9lcWVxKHNlbGYsIG90aGVyKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3Mgb3RoZXIuaW5zdGFuY2Vfb2Y/KHNlbGYuY2xhc3MpXG5cbiAgICAleHtcbiAgICAgIHZhciByZWN1cnNlZDEgPSB7fSwgcmVjdXJzZWQyID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIF9lcWVxKHN0cnVjdCwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGtleSwgYSwgYjtcblxuICAgICAgICByZWN1cnNlZDFbI3tgc3RydWN0YC5fX2lkX199XSA9IHRydWU7XG4gICAgICAgIHJlY3Vyc2VkMlsje2BvdGhlcmAuX19pZF9ffV0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAoa2V5IGluIHN0cnVjdC4kJGRhdGEpIHtcbiAgICAgICAgICBhID0gc3RydWN0LiQkZGF0YVtrZXldO1xuICAgICAgICAgIGIgPSBvdGhlci4kJGRhdGFba2V5XTtcblxuICAgICAgICAgIGlmICgje1N0cnVjdCA9PT0gYGFgfSkge1xuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZDEuaGFzT3duUHJvcGVydHkoI3tgYWAuX19pZF9ffSkgfHwgIXJlY3Vyc2VkMi5oYXNPd25Qcm9wZXJ0eSgje2BiYC5fX2lkX199KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWVxKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghI3tgYWAuZXFsPyhgYmApfSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXFlcShzZWxmLCBvdGhlcik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaFxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2ggeyB8bmFtZXwgeWllbGQgc2VsZltuYW1lXSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9wYWlyXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3BhaXIpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIHsgfG5hbWV8IHlpZWxkIFtuYW1lLCBzZWxmW25hbWVdXSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLmxlbmd0aFxuICBlbmRcblxuICBhbGlhcyBzaXplIGxlbmd0aFxuXG4gIGRlZiB0b19hXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLm1hcCB7IHxuYW1lfCBzZWxmW25hbWVdIH1cbiAgZW5kXG5cbiAgYWxpYXMgdmFsdWVzIHRvX2FcblxuICBkZWYgaW5zcGVjdFxuICAgIHJlc3VsdCA9ICcjPHN0cnVjdCAnXG5cbiAgICBpZiBTdHJ1Y3QgPT09IHNlbGYgJiYgc2VsZi5jbGFzcy5uYW1lXG4gICAgICByZXN1bHQgKz0gXCIje3NlbGYuY2xhc3N9IFwiXG4gICAgZW5kXG5cbiAgICByZXN1bHQgKz0gZWFjaF9wYWlyLm1hcCBkbyB8bmFtZSwgdmFsdWV8XG4gICAgICBcIiN7bmFtZX09I3t2YWx1ZS5pbnNwZWN0fVwiXG4gICAgZW5kLmpvaW4gJywgJ1xuXG4gICAgcmVzdWx0ICs9ICc+J1xuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxuXG4gIGRlZiB0b19oKCZibG9jaylcbiAgICByZXR1cm4gbWFwKCZibG9jaykudG9faCgqYXJncykgaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaF93aXRoX29iamVjdCh7fSkgeyB8bmFtZSwgaHwgaFtuYW1lXSA9IHNlbGZbbmFtZV0gfVxuICBlbmRcblxuICBkZWYgdmFsdWVzX2F0KCphcmdzKVxuICAgIGFyZ3MgPSBhcmdzLm1hcCB7IHxhcmd8IGBhcmcuJCRpc19yYW5nZSA/ICN7YXJnLnRvX2F9IDogYXJnYCB9LmZsYXR0ZW5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghYXJnc1tpXS4kJGlzX251bWJlcikge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tgYXJnc1tpXWAuY2xhc3N9IGludG8gSW50ZWdlclwifVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKCN7c2VsZltgYXJnc1tpXWBdfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRpZyhrZXksICprZXlzKVxuICAgIGl0ZW0gPSBpZiBga2V5LiQkaXNfc3RyaW5nICYmIHNlbGYuJCRkYXRhLmhhc093blByb3BlcnR5KGtleSlgXG4gICAgICAgICAgICAgYHNlbGYuJCRkYXRhW2tleV0gfHwgbmlsYFxuICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqa2V5cylcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwibmV3Iiwic2VsZiIsImNvbnN0X25hbWUiLCJjb25zdF9uYW1lISIsImFyZ3MiLCJ1bnNoaWZ0IiwibWFwIiwiY29lcmNlX3RvISIsImFyZyIsImtsYXNzIiwiZWFjaCIsImRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwiaW5zdGFuY2UiLCJhbGxvY2F0ZSIsImluaXRpYWxpemUiLCJhbGlhc19tZXRob2QiLCJibG9jayIsIm1vZHVsZV9ldmFsIiwiY29uc3Rfc2V0IiwiPT0iLCJyYWlzZSIsIm1lbWJlcnMiLCI8PCIsIm5hbWUiLCJkZWZpbmVfbWV0aG9kIiwiQG1lbWJlcnMiLCIkcmV0X29yXzEiLCJpbmhlcml0ZWQiLCJpbnN0YW5jZV9ldmFsIiwia3dhcmdzIiwiJHJldF9vcl8yIiwibGFzdCIsIiRyZXRfb3JfMyIsIj4iLCJsZW5ndGgiLCIxIiwiZXh0cmEiLCItIiwia2V5cyIsImFueT8iLCJqb2luIiwiJHdyaXRlciIsIltdIiwiW109IiwiZWFjaF93aXRoX2luZGV4IiwiaW5kZXgiLCJpbml0aWFsaXplX2NvcHkiLCJoYXNoIiwiPT09IiwiPCIsInNpemUiLCItQCIsIj49IiwiaW5jbHVkZT8iLCJ0b19zeW0iLCJvdGhlciIsImluc3RhbmNlX29mPyIsIl9faWRfXyIsImVxbD8iLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImVhY2hfcGFpciIsInRvX2EiLCJpbnNwZWN0IiwicmVzdWx0IiwiJHJldF9vcl80IiwiKyIsInZhbHVlIiwidG9faCIsImVhY2hfd2l0aF9vYmplY3QiLCJoIiwidmFsdWVzX2F0IiwiZmxhdHRlbiIsImRpZyIsIml0ZW0iLCJyZXNwb25kX3RvPyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsMEJBQVJBLENBQUE7QUFBQSxJQUVBQyxVQUFJQyxJQUFKRCxVQUFBQSxnQkFBQUEsU0FBYSxVQUFELEVBTmQsRUFNYyxFQU5kLEVBTUVBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQU5GO0FBTXVELE1BQUEsb0NBTnZEO0FBQUE7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUFBQSxNQUFBLHlDQUFBO0FBQUE7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxDQUFBO0FBQUE7QUFNMkIsTUFBQSxrQkFOM0I7QUFBQTtBQU1rQyxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUEsaUJBQWM7QUFBZCxNQUFBLENBTmxDO0FBQUEsTUFPSSxJQUFBLFFBQUdFLFVBQUgsQ0FBQTtBQUFBO0FBQ0UsUUFDRTtBQUFBLFVBQUFBLGFBQWEsb0JBQUFDLGdCQUFBQSxDQUFpQkQsVUFBakJDO0FBQWIsUUFBQTtBQUFBLFVBQ0Ysc0JBQU8sQ0FBQSx5QkFBQSxFQUFXLHlCQUFYLENBQVA7QUFBQSxZQUFBO0FBQUE7QUFDRSxjQUFBQyxJQUFBQyxTQUFBQSxDQUFhSCxVQUFiRyxDQUFBO0FBQUEsY0FDQUgsYUFBYSxHQURiO0FBREYsWUFBQTtBQUFBLFVBQUEsQ0FERTtBQUFBLFFBQUEsQ0FERixDQURGLENBUEo7QUFBQSxNQWdCSUksTUFB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QUF1U2UsTUFBQSxrQkF2U2Y7QUFBQSxNQXdTSUMsT0FBTyxhQUFBLElBQUEsUUFBSSxrREFBSixDQUFBO0FBQUEsUUFDRSxPQUFDLHVCQUFEO0FBREYsTUFBQTtBQUFBO0FBQUEsTUFBQSxDQUFBLGtCQXhTWDtBQUFBO0FBNlNBO0FBQ0E7QUFDQTtBQUNBLElBaFRBO0FBQUEsTUFrVEksSUFBQSxRQUFPQSxJQUFBQyxnQkFBQUEsQ0FBaUIsS0FBakJBLENBQVAsQ0FBQTtBQUFBLE1BQUE7QUFBQSxZQUNFdkQsT0FBQUEsQ0FBTSwyQkFBVyxFQUFBLEdBQUEsQ0FBR3NELElBQUE1RSxPQUFBQSxDQUFBQSxDQUFILENBQUEsR0FBQSw0QkFBakJzQjtBQURGLE1BQUEsQ0FsVEo7QUFBQSxNQXNUSSxPQUFBcUQsTUFBQUMsSUFBQUQsT0FBQUEsRUFBUyxVQUFDbkMsSUFBRCxDQUFUbUMsQ0F0VEo7QUF1U0VBLElBQUFBLENBQUFBLDZCQUFBQSxDQUFBQSxlQW5TQTtBQURGM0UsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzNTcwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tYWluLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImRlZiBzZWxmLnRvX3NcbiAgJ21haW4nXG5lbmRcblxuZGVmIHNlbGYuaW5jbHVkZShtb2QpXG4gIE9iamVjdC5pbmNsdWRlIG1vZFxuZW5kXG4iXSwibmFtZXMiOlsidG9fcyIsInNlbGYiLCJpbmNsdWRlIiwibW9kIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxFQUFBQSxVQUFJQyxJQUFKRCxXQUFBQSxVQUFBQSxnQkFBQUE7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsT0FBQTtBQURGQSxFQUFBQSxDQUFBQSxxQkFBQUEsQ0FBQTtBQUFBLEVBSUEsT0FBQUUsQ0FBQUEsVUFBSUQsSUFBSkMsY0FBQUEsYUFBQUEsbUJBQWlCLEdBQWpCQTtBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRSxPQUFBLHNCQUFBQSxTQUFBQSxDQUFlQyxHQUFmRDtBQURGQSxFQUFBQSxDQUFBQSx3QkFBQUEsQ0FBQUEsbUJBSkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzU4OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZGlyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIERpclxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGNoZGlyKGRpcilcbiAgICAgIHByZXZfY3dkID0gYE9wYWwuY3VycmVudF9kaXJgXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciA9ICN7ZGlyfWBcbiAgICAgIHlpZWxkXG4gICAgZW5zdXJlXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciA9ICN7cHJldl9jd2R9YFxuICAgIGVuZFxuXG4gICAgZGVmIHB3ZFxuICAgICAgYE9wYWwuY3VycmVudF9kaXIgfHwgJy4nYFxuICAgIGVuZFxuICAgIGFsaWFzIGdldHdkIHB3ZFxuXG4gICAgZGVmIGhvbWVcbiAgICAgIEVOVlsnSE9NRSddIHx8ICcuJ1xuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiY2hkaXIiLCJwcmV2X2N3ZCIsImRpciIsInB3ZCIsImhvbWUiLCIkcmV0X29yXzEiLCJbXSIsInNlbGYiXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUE7QUFBQSxNQUFBOztBQUFBO0FBQ0U7QUFBQUMsTUFBQUEseUJBQUFBLFdBQUFBLGlCQUFVLEdBQVZBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUFBQTtBQUFBQSxlQUNFLGNBQUE7QUFBQTtBQUFBLFFBQUFDLFdBQVksZ0JBQVo7QUFBQSxRQUNDLG1CQUFxQkMsR0FEdEI7QUFBQSxRQUVBLE9BQUEscUJBQUEsRUFBQSxDQUZBO0FBQUEsUUFBQTtBQUFBLFVBSUMsbUJBQXFCRDtBQUp0QixRQUFBLENBQUE7QUFERkQsTUFBQUEsQ0FBQUEsc0JBQUFBLENBQUE7QUFBQTtBQVFBRyxNQUFBQSx1QkFBQUEsU0FBQUEsZUFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQ0UsT0FBQyx1QkFBRDtBQURGQSxNQUFBQSxDQUFBQSxvQkFBQUEsQ0FSQTtBQUFBLE1BV0EsaUJBQU0sT0FBTixFQUFZLEtBQVosQ0FYQTtBQUFBLE1BYUEsT0FBQUMsQ0FBQUEsd0JBQUFBLFVBQUFBLGdCQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxJQUFBLFFBakJOQyxDQUFBQSxZQWlCTSxtQkFBQUMsT0FBQUEsQ0FBSSxNQUFKQSxDQWpCTkQsQ0FpQk0sQ0FBQTtBQUFBLFVBakJOLE9BQUE7QUFpQk0sUUFBQTtBQUFBLFVBQWUsT0FBQTtBQUFmLFFBQUE7QUFERkQsTUFBQUEsQ0FBQUEscUJBQUFBLENBQUFBLGdCQWJBO0FBREYsSUFBQSw0QkFBU0csSUFBVDtBQURGUixFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzNjM2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9maWxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5XG5cbmNsYXNzIEZpbGUgPCBJT1xuICBTZXBhcmF0b3IgPSBTRVBBUkFUT1IgPSAnLydcbiAgQUxUX1NFUEFSQVRPUiA9IG5pbFxuICBQQVRIX1NFUEFSQVRPUiA9ICc6J1xuICAjIEFzc3VtaW5nIGNhc2UgaW5zZW5zdGl2ZSBmaWxlc3lzdGVtXG4gIEZOTV9TWVNDQVNFID0gMFxuICB3aW5kb3dzX3Jvb3RfcnggPSAlcnteW2EtekEtWl06KD86XFxcXHxcXC8pfVxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWJzb2x1dGVfcGF0aChwYXRoLCBiYXNlZGlyID0gbmlsKVxuICAgICAgc2VwID0gU0VQQVJBVE9SXG4gICAgICBzZXBfY2hhcnMgPSBgJHNlcF9jaGFycygpYFxuICAgICAgbmV3X3BhcnRzID0gW11cblxuICAgICAgcGF0aCA9IHBhdGgucmVzcG9uZF90bz8oOnRvX3BhdGgpID8gcGF0aC50b19wYXRoIDogcGF0aFxuICAgICAgYmFzZWRpciB8fD0gRGlyLnB3ZFxuICAgICAgcGF0aF9hYnMgICAgPSBgcGF0aC5zdWJzdHIoMCwgc2VwLmxlbmd0aCkgPT09IHNlcCB8fCB3aW5kb3dzX3Jvb3RfcngudGVzdChwYXRoKWBcbiAgICAgIGJhc2VkaXJfYWJzID0gYGJhc2VkaXIuc3Vic3RyKDAsIHNlcC5sZW5ndGgpID09PSBzZXAgfHwgd2luZG93c19yb290X3J4LnRlc3QoYmFzZWRpcilgXG5cbiAgICAgIGlmIHBhdGhfYWJzXG4gICAgICAgIHBhcnRzICAgICAgID0gcGF0aC5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKVxuICAgICAgICBsZWFkaW5nX3NlcCA9IGB3aW5kb3dzX3Jvb3RfcngudGVzdChwYXRoKSA/ICcnIDogI3twYXRoLnN1YigvXihbI3tzZXBfY2hhcnN9XSspLiokLywgJ1xcMScpfWBcbiAgICAgICAgYWJzICAgICAgICAgPSB0cnVlXG4gICAgICBlbHNlXG4gICAgICAgIHBhcnRzICAgICAgID0gYmFzZWRpci5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKSArIHBhdGguc3BsaXQoL1sje3NlcF9jaGFyc31dLylcbiAgICAgICAgbGVhZGluZ19zZXAgPSBgd2luZG93c19yb290X3J4LnRlc3QoYmFzZWRpcikgPyAnJyA6ICN7YmFzZWRpci5zdWIoL14oWyN7c2VwX2NoYXJzfV0rKS4qJC8sICdcXDEnKX1gXG4gICAgICAgIGFicyAgICAgICAgID0gYmFzZWRpcl9hYnNcbiAgICAgIGVuZFxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIHBhcnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocGFydCA9PT0gbmlsKSB8fFxuICAgICAgICAgICAgKHBhcnQgPT09ICcnICAmJiAoKG5ld19wYXJ0cy5sZW5ndGggPT09IDApIHx8IGFicykpIHx8XG4gICAgICAgICAgICAocGFydCA9PT0gJy4nICYmICgobmV3X3BhcnRzLmxlbmd0aCA9PT0gMCkgfHwgYWJzKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICAgICAgbmV3X3BhcnRzLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdfcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFicyAmJiBwYXJ0c1swXSAhPT0gJy4nKSB7XG4gICAgICAgICAgI3tuZXdfcGFydHMudW5zaGlmdCAnLid9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV3X3BhdGggPSBuZXdfcGFydHMuam9pbihzZXApXG4gICAgICBuZXdfcGF0aCA9IGxlYWRpbmdfc2VwICsgbmV3X3BhdGggaWYgYWJzXG4gICAgICBuZXdfcGF0aFxuICAgIGVuZFxuXG4gICAgZGVmIGV4cGFuZF9wYXRoKHBhdGgsIGJhc2VkaXIgPSBuaWwpXG4gICAgICBzZXAgPSBTRVBBUkFUT1JcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBpZiBgcGF0aFswXSA9PT0gJ34nIHx8IChiYXNlZGlyICYmIGJhc2VkaXJbMF0gPT09ICd+JylgXG4gICAgICAgIGhvbWUgPSBEaXIuaG9tZVxuICAgICAgICByYWlzZShBcmd1bWVudEVycm9yLCBcImNvdWxkbid0IGZpbmQgSE9NRSBlbnZpcm9ubWVudCAtLSBleHBhbmRpbmcgYH4nXCIpIHVubGVzcyBob21lXG4gICAgICAgIGxlYWRpbmdfc2VwID0gYHdpbmRvd3Nfcm9vdF9yeC50ZXN0KGhvbWUpID8gJycgOiAje2hvbWUuc3ViKC9eKFsje3NlcF9jaGFyc31dKykuKiQvLCAnXFwxJyl9YFxuICAgICAgICByYWlzZShBcmd1bWVudEVycm9yLCAnbm9uLWFic29sdXRlIGhvbWUnKSB1bmxlc3MgaG9tZS5zdGFydF93aXRoPyhsZWFkaW5nX3NlcClcblxuICAgICAgICBob21lICAgICAgICAgICAgKz0gc2VwXG4gICAgICAgIGhvbWVfcGF0aF9yZWdleHAgPSAvXlxcfig/OiN7c2VwfXwkKS9cbiAgICAgICAgcGF0aCAgICAgICAgICAgICA9IHBhdGguc3ViKGhvbWVfcGF0aF9yZWdleHAsIGhvbWUpXG4gICAgICAgIGJhc2VkaXIgICAgICAgICAgPSBiYXNlZGlyLnN1Yihob21lX3BhdGhfcmVnZXhwLCBob21lKSBpZiBiYXNlZGlyXG4gICAgICBlbmRcbiAgICAgIGFic29sdXRlX3BhdGgocGF0aCwgYmFzZWRpcilcbiAgICBlbmRcbiAgICBhbGlhcyByZWFscGF0aCBleHBhbmRfcGF0aFxuXG4gICAgJXh7XG4gICAgICAvLyBDb2VyY2UgYSBnaXZlbiBwYXRoIHRvIGEgcGF0aCBzdHJpbmcgdXNpbmcgI3RvX3BhdGggYW5kICN0b19zdHJcbiAgICAgIGZ1bmN0aW9uICRjb2VyY2VfdG9fcGF0aChwYXRoKSB7XG4gICAgICAgIGlmICgkdHJ1dGh5KCN7YHBhdGhgLnJlc3BvbmRfdG8/KDp0b19wYXRoKX0pKSB7XG4gICAgICAgICAgcGF0aCA9IHBhdGguJHRvX3BhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGggPSAje09wYWwuY29lcmNlX3RvIShgcGF0aGAsIFN0cmluZywgOnRvX3N0cil9O1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gYSBSZWdFeHAgY29tcGF0aWJsZSBjaGFyIGNsYXNzXG4gICAgICBmdW5jdGlvbiAkc2VwX2NoYXJzKCkge1xuICAgICAgICBpZiAoI3tBTFRfU0VQQVJBVE9SfSA9PT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuIE9wYWwuZXNjYXBlX3JlZ2V4cCgje1NFUEFSQVRPUn0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPcGFsLmVzY2FwZV9yZWdleHAoI3tTRVBBUkFUT1IgKyBBTFRfU0VQQVJBVE9SfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYgZGlybmFtZShwYXRoKVxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIHBhdGggPSBgJGNvZXJjZV90b19wYXRoKHBhdGgpYFxuICAgICAgJXh7XG4gICAgICAgIHZhciBhYnNvbHV0ZSA9IHBhdGgubWF0Y2gobmV3IFJlZ0V4cCgje1wiXlsje3NlcF9jaGFyc31dXCJ9KSk7XG5cbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJbI3tzZXBfY2hhcnN9XSskXCJ9KSwgJycpOyAvLyByZW1vdmUgdHJhaWxpbmcgc2VwYXJhdG9yc1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIlteI3tzZXBfY2hhcnN9XSskXCJ9KSwgJycpOyAvLyByZW1vdmUgdHJhaWxpbmcgYmFzZW5hbWVcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJbI3tzZXBfY2hhcnN9XSskXCJ9KSwgJycpOyAvLyByZW1vdmUgZmluYWwgdHJhaWxpbmcgc2VwYXJhdG9yc1xuXG4gICAgICAgIGlmIChwYXRoID09PSAnJykge1xuICAgICAgICAgIHJldHVybiBhYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGJhc2VuYW1lKG5hbWUsIHN1ZmZpeCA9IG5pbClcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBuYW1lID0gYCRjb2VyY2VfdG9fcGF0aChuYW1lKWBcbiAgICAgICV4e1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1ZmZpeCAhPT0gbmlsKSB7XG4gICAgICAgICAgc3VmZml4ID0gI3tPcGFsLmNvZXJjZV90byEoc3VmZml4LCBTdHJpbmcsIDp0b19zdHIpfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1ZmZpeCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIiguKVsje3NlcF9jaGFyc31dKiRcIn0pLCAnJDEnKTtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJeKD86LipbI3tzZXBfY2hhcnN9XSk/KFteI3tzZXBfY2hhcnN9XSspJFwifSksICckMScpO1xuXG4gICAgICAgIGlmIChzdWZmaXggPT09IFwiLipcIikge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1xcLlteXFwuXSskLywgJycpO1xuICAgICAgICB9IGVsc2UgaWYoc3VmZml4ICE9PSBudWxsKSB7XG4gICAgICAgICAgc3VmZml4ID0gT3BhbC5lc2NhcGVfcmVnZXhwKHN1ZmZpeCk7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCIje3N1ZmZpeH0kXCJ9KSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgZXh0bmFtZShwYXRoKVxuICAgICAgYHBhdGggPSAkY29lcmNlX3RvX3BhdGgocGF0aClgXG4gICAgICBmaWxlbmFtZSA9IGJhc2VuYW1lKHBhdGgpXG4gICAgICByZXR1cm4gJycgaWYgZmlsZW5hbWUuZW1wdHk/XG4gICAgICBsYXN0X2RvdF9pZHggPSBmaWxlbmFtZVsxLi4tMV0ucmluZGV4KCcuJylcbiAgICAgICMgZXh0ZW5zaW9uIG5hbWUgbXVzdCBjb250YWlucyBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIC4oc29tZXRoaW5nKVxuICAgICAgbGFzdF9kb3RfaWR4Lm5pbD8gfHwgbGFzdF9kb3RfaWR4ICsgMSA9PSBmaWxlbmFtZS5sZW5ndGggLSAxID8gJycgOiBmaWxlbmFtZVsobGFzdF9kb3RfaWR4ICsgMSkuLi0xXVxuICAgIGVuZFxuXG4gICAgZGVmIGV4aXN0PyhwYXRoKVxuICAgICAgYE9wYWwubW9kdWxlc1sje3BhdGh9XSAhPSBudWxsYFxuICAgIGVuZFxuICAgIGFsaWFzIGV4aXN0cz8gZXhpc3Q/XG5cbiAgICBkZWYgZGlyZWN0b3J5PyhwYXRoKVxuICAgICAgZmlsZXMgPSBbXVxuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPcGFsLm1vZHVsZXMpIHtcbiAgICAgICAgICAje2ZpbGVzfS5wdXNoKGtleSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGF0aCA9IHBhdGguZ3N1YigvKF4uI3tTRVBBUkFUT1J9K3wje1NFUEFSQVRPUn0rJCkvKVxuICAgICAgZmlsZSA9IGZpbGVzLmZpbmQgeyB8ZnwgZiA9fiAvXiN7cGF0aH0vIH1cbiAgICAgIGZpbGVcbiAgICBlbmRcblxuICAgIGRlZiBqb2luKCpwYXRocylcbiAgICAgIGlmIHBhdGhzLmVtcHR5P1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIGVuZFxuICAgICAgcmVzdWx0ID0gJydcbiAgICAgIHBhdGhzID0gcGF0aHMuZmxhdHRlbi5lYWNoX3dpdGhfaW5kZXgubWFwIGRvIHxpdGVtLCBpbmRleHxcbiAgICAgICAgaWYgaW5kZXggPT0gMCAmJiBpdGVtLmVtcHR5P1xuICAgICAgICAgIFNFUEFSQVRPUlxuICAgICAgICBlbHNpZiBwYXRocy5sZW5ndGggPT0gaW5kZXggKyAxICYmIGl0ZW0uZW1wdHk/XG4gICAgICAgICAgU0VQQVJBVE9SXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpdGVtXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBwYXRocyA9IHBhdGhzLnJlamVjdCgmOmVtcHR5PylcbiAgICAgIHBhdGhzLmVhY2hfd2l0aF9pbmRleCBkbyB8aXRlbSwgaW5kZXh8XG4gICAgICAgIG5leHRfaXRlbSA9IHBhdGhzW2luZGV4ICsgMV1cbiAgICAgICAgaWYgbmV4dF9pdGVtLm5pbD9cbiAgICAgICAgICByZXN1bHQgPSBcIiN7cmVzdWx0fSN7aXRlbX1cIlxuICAgICAgICBlbHNlXG4gICAgICAgICAgaWYgaXRlbS5lbmRfd2l0aD8oU0VQQVJBVE9SKSAmJiBuZXh0X2l0ZW0uc3RhcnRfd2l0aD8oU0VQQVJBVE9SKVxuICAgICAgICAgICAgaXRlbSA9IGl0ZW0uc3ViKC8je1NFUEFSQVRPUn0rJC8sICcnKVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIHJlc3VsdCA9IGlmIGl0ZW0uZW5kX3dpdGg/KFNFUEFSQVRPUikgfHwgbmV4dF9pdGVtLnN0YXJ0X3dpdGg/KFNFUEFSQVRPUilcbiAgICAgICAgICAgICAgICAgICAgIFwiI3tyZXN1bHR9I3tpdGVtfVwiXG4gICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgXCIje3Jlc3VsdH0je2l0ZW19I3tTRVBBUkFUT1J9XCJcbiAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuXG4gICAgZGVmIHNwbGl0KHBhdGgpXG4gICAgICBwYXRoLnNwbGl0KFNFUEFSQVRPUilcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsIjAiLCJ3aW5kb3dzX3Jvb3RfcngiLCJhYnNvbHV0ZV9wYXRoIiwic2VwIiwic2VwX2NoYXJzIiwibmV3X3BhcnRzIiwicGF0aCIsInJlc3BvbmRfdG8/IiwidG9fcGF0aCIsImJhc2VkaXIiLCIkcmV0X29yXzEiLCJwd2QiLCJwYXRoX2FicyIsImJhc2VkaXJfYWJzIiwicGFydHMiLCJzcGxpdCIsImxlYWRpbmdfc2VwIiwic3ViIiwiYWJzIiwiKyIsInVuc2hpZnQiLCJuZXdfcGF0aCIsImpvaW4iLCJleHBhbmRfcGF0aCIsImhvbWUiLCJyYWlzZSIsInN0YXJ0X3dpdGg/IiwiaG9tZV9wYXRoX3JlZ2V4cCIsImNvZXJjZV90byEiLCJkaXJuYW1lIiwiYmFzZW5hbWUiLCJuYW1lIiwic3VmZml4IiwiZXh0bmFtZSIsImZpbGVuYW1lIiwiZW1wdHk/IiwibGFzdF9kb3RfaWR4IiwiW10iLCIxIiwiLTEiLCJyaW5kZXgiLCIkcmV0X29yXzIiLCJuaWw/IiwiPT0iLCItIiwibGVuZ3RoIiwiZXhpc3Q/IiwiZGlyZWN0b3J5PyIsImZpbGVzIiwiZ3N1YiIsImZpbGUiLCJmaW5kIiwiZiIsIj1+IiwicGF0aHMiLCJyZXN1bHQiLCJtYXAiLCJmbGF0dGVuIiwiZWFjaF93aXRoX2luZGV4IiwiJHJldF9vcl8zIiwiaW5kZXgiLCJpdGVtIiwiJHJldF9vcl80IiwicmVqZWN0IiwibmV4dF9pdGVtIiwiJHJldF9vcl81IiwiZW5kX3dpdGg/IiwiJHJldF9vcl82Iiwic2VsZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7RUFFQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQSx5Q0FBWSx5Q0FBWSxHQUFaLENBQVosQ0FBQTtBQUFBLElBQ0EsNkNBQWdCLEdBQWhCLENBREE7QUFBQSxJQUVBLDhDQUFpQixHQUFqQixDQUZBO0FBQUEsSUFJQSwyQ0FBY0MsQ0FBZCxDQUpBO0FBQUEsSUFLQUMsa0JBQWtCLHFCQUxsQjtBQUFBLElBT0EsT0FBQTtBQUFBLE1BQUE7O0FBQUE7QUFDRTtBQUFBQyxNQUFBQSxpQ0FBQUEsbUJBQUFBLHlCQUFrQixJQUFELEVBQU8sT0FBeEJBO0FBQUFBLFFBQUFBOztBQUFBQTtBQVpKO0FBWTRCLFFBQUE7QUFBQSxRQUFBLFlBQVUsR0FBVjtBQUFBLFFBQUEsQ0FaNUI7QUFBQSxRQWFNQyxNQUFNLHlCQWJaO0FBQUEsUUFjTUMsWUFBYSxZ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QUFTcUQsSUFBVCxZQVBBO0FBREZyRSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFhLGtCQUFiQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzOTY0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9wcm9jZXNzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFByb2Nlc3NcbiAgQF9fY2xvY2tzX18gPSBbXVxuICBkZWYgc2VsZi5fX3JlZ2lzdGVyX2Nsb2NrX18obmFtZSwgZnVuYylcbiAgICBjb25zdF9zZXQgbmFtZSwgQF9fY2xvY2tzX18uc2l6ZVxuICAgIEBfX2Nsb2Nrc19fIDw8IGZ1bmNcbiAgZW5kXG5cbiAgX19yZWdpc3Rlcl9jbG9ja19fIDpDTE9DS19SRUFMVElNRSwgYGZ1bmN0aW9uKCkgeyByZXR1cm4gRGF0ZS5ub3coKSB9YFxuXG4gIG1vbm90b25pYyA9IGZhbHNlXG5cbiAgJXh7XG4gICAgaWYgKE9wYWwuZ2xvYmFsLnBlcmZvcm1hbmNlKSB7XG4gICAgICBtb25vdG9uaWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChPcGFsLmdsb2JhbC5wcm9jZXNzICYmIHByb2Nlc3MuaHJ0aW1lKSB7XG4gICAgICAvLyBsZXQgbm93IGJlIHRoZSBiYXNlIHRvIGdldCBzbWFsbGVyIG51bWJlcnNcbiAgICAgIHZhciBocnRpbWVfYmFzZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XG5cbiAgICAgIG1vbm90b25pYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWUoaHJ0aW1lX2Jhc2UpO1xuICAgICAgICB2YXIgdXMgPSAoaHJ0aW1lWzFdIC8gMTAwMCkgfCAwOyAvLyBjdXQgYmVsb3cgbWljcm9zZWNzO1xuICAgICAgICByZXR1cm4gKChocnRpbWVbMF0gKiAxMDAwKSArICh1cyAvIDEwMDApKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgX19yZWdpc3Rlcl9jbG9ja19fKDpDTE9DS19NT05PVE9OSUMsIG1vbm90b25pYykgaWYgbW9ub3RvbmljXG5cbiAgZGVmIHNlbGYucGlkXG4gICAgMFxuICBlbmRcblxuICBkZWYgc2VsZi50aW1lc1xuICAgIHQgPSBUaW1lLm5vdy50b19mXG4gICAgQmVuY2htYXJrOjpUbXMubmV3KHQsIHQsIHQsIHQsIHQpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNsb2NrX2dldHRpbWUoY2xvY2tfaWQsIHVuaXQgPSA6ZmxvYXRfc2Vjb25kKVxuICAgIChjbG9jayA9IEBfX2Nsb2Nrc19fW2Nsb2NrX2lkXSkgfHwgcmFpc2UoRXJybm86OkVJTlZBTCwgXCJjbG9ja19nZXR0aW1lKCN7Y2xvY2tfaWR9KSAje0BfX2Nsb2Nrc19fW2Nsb2NrX2lkXX1cIilcbiAgICAleHtcbiAgICAgIHZhciBtcyA9IGNsb2NrKCk7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSAnZmxvYXRfc2Vjb25kJzogICAgICByZXR1cm4gIChtcyAvIDEwMDApOyAgICAgICAgIC8vIG51bWJlciBvZiBzZWNvbmRzIGFzIGEgZmxvYXQgKGRlZmF1bHQpXG4gICAgICAgIGNhc2UgJ2Zsb2F0X21pbGxpc2Vjb25kJzogcmV0dXJuICAobXMgLyAxKTsgICAgICAgICAgICAvLyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFzIGEgZmxvYXRcbiAgICAgICAgY2FzZSAnZmxvYXRfbWljcm9zZWNvbmQnOiByZXR1cm4gIChtcyAqIDEwMDApOyAgICAgICAgIC8vIG51bWJlciBvZiBtaWNyb3NlY29uZHMgYXMgYSBmbG9hdFxuICAgICAgICBjYXNlICdzZWNvbmQnOiAgICAgICAgICAgIHJldHVybiAoKG1zIC8gMTAwMCkgICAgfCAwKTsgLy8gbnVtYmVyIG9mIHNlY29uZHMgYXMgYW4gaW50ZWdlclxuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6ICAgICAgIHJldHVybiAoKG1zIC8gMSkgICAgICAgfCAwKTsgLy8gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGNhc2UgJ21pY3Jvc2Vjb25kJzogICAgICAgcmV0dXJuICgobXMgKiAxMDAwKSAgICB8IDApOyAvLyBudW1iZXIgb2YgbWljcm9zZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgY2FzZSAnbmFub3NlY29uZCc6ICAgICAgICByZXR1cm4gKChtcyAqIDEwMDAwMDApIHwgMCk7IC8vIG51bWJlciBvZiBuYW5vc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGRlZmF1bHQ6ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bmV4cGVjdGVkIHVuaXQ6ICN7dW5pdH1cIn1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG5cbmNsYXNzIFNpZ25hbFxuICBkZWYgc2VsZi50cmFwKCopXG4gIGVuZFxuZW5kXG5cbmNsYXNzIEdDXG4gIGRlZiBzZWxmLnN0YXJ0XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJAX19jbG9ja3NfXyIsIl9fcmVnaXN0ZXJfY2xvY2tfXyIsInNlbGYiLCJjb25zdF9zZXQiLCJuYW1lIiwic2l6ZSIsIjw8IiwiZnVuYyIsIm1vbm90b25pYyIsInBpZCIsIjAiLCJ0aW1lcyIsInQiLCJub3ciLCJ0b19mIiwibmV3IiwiY2xvY2tfZ2V0dGltZSIsIiRyZXRfb3JfMSIsImNsb2NrIiwiW10iLCJjbG9ja19pZCIsInJhaXNlIiwidW5pdCIsInRyYXAiLCJzdGFydCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUFDLGtCQUFjLEVBQWQ7QUFBQSxJQUNBQyxVQUFJQyxJQUFKRCx5QkFBQUEsZ0NBQUFBLDhCQUE0QixJQUFELEVBQU8sSUFBbENBO0FBQUFBLE1BQUFBO0FBQUFBOztBQUFBQTtBQUNFLFVBQUFFLFdBQUFBLENBQVVDLE1BQU1KLGVBQUFL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NDA3NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZG9tL2Zvcm1hdHRlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBSYW5kb21cbiAgbW9kdWxlIEZvcm1hdHRlclxuICAgIGRlZiBoZXgoY291bnQgPSBuaWwpXG4gICAgICBjb3VudCA9IFJhbmRvbS5fdmVyaWZ5X2NvdW50KGNvdW50KVxuICAgICAgJXh7XG4gICAgICAgIHZhciBieXRlcyA9ICN7Ynl0ZXMoY291bnQpfTtcbiAgICAgICAgdmFyIG91dCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgI3tjb3VudH07IGkrKykge1xuICAgICAgICAgIG91dCArPSBieXRlcy5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAje2BvdXRgLmVuY29kZSgnVVMtQVNDSUknKX07XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgcmFuZG9tX2J5dGVzKGNvdW50ID0gbmlsKVxuICAgICAgYnl0ZXMoY291bnQpXG4gICAgZW5kXG5cbiAgICBkZWYgYmFzZTY0KGNvdW50ID0gbmlsKVxuICAgICAgQmFzZTY0LnN0cmljdF9lbmNvZGU2NChyYW5kb21fYnl0ZXMoY291bnQpKS5lbmNvZGUoJ1VTLUFTQ0lJJylcbiAgICBlbmRcblxuICAgIGRlZiB1cmxzYWZlX2Jhc2U2NChjb3VudCA9IG5pbCwgcGFkZGluZyA9IGZhbHNlKVxuICAgICAgQmFzZTY0LnVybHNhZmVfZW5jb2RlNjQocmFuZG9tX2J5dGVzKGNvdW50KSwgcGFkZGluZykuZW5jb2RlKCdVUy1BU0NJSScpXG4gICAgZW5kXG5cbiAgICBkZWYgdXVpZFxuICAgICAgc3RyID0gaGV4KDE2KS5zcGxpdCgnJylcbiAgICAgIHN0clsxMl0gPSAnNCdcbiAgICAgIHN0clsxNl0gPSBgKHBhcnNlSW50KCN7c3RyWzE2XX0sIDE2KSAmIDMgfCA4KS50b1N0cmluZygxNilgXG4gICAgICBzdHIgPSBbc3RyWzAuLi44XSwgc3RyWzguLi4xMl0sIHN0clsxMi4uLjE2XSwgc3RyWzE2Li4uMjBdLCBzdHJbMjAuLi4zMl1dXG4gICAgICBzdHIgPSBzdHIubWFwKCY6am9pbilcbiAgICAgIHN0ci5qb2luKCctJylcbiAgICBlbmRcblxuICAgICMgSW1wbGVtZW50ZWQgaW4gdGVybXMgb2YgYCNieXRlc2AgZm9yIFNlY3VyZVJhbmRvbSwgYnV0IFJhbmRvbSBvdmVycmlkZXMgdGhpc1xuICAgICMgbWV0aG9kIHRvIGltcGxlbWVudCBgI2J5dGVzYCBpbiB0ZXJtcyBvZiBgI3JhbmRvbV9mbG9hdGAuIE5vdCBwYXJ0IG9mIHN0YW5kYXJkXG4gICAgIyBSdWJ5IGludGVyZmFjZSAtIHVzZSByYW5kb21fbnVtYmVyIGZvciBwb3J0YWJpbGl0eS5cbiAgICBkZWYgcmFuZG9tX2Zsb2F0XG4gICAgICBicyA9IGJ5dGVzKDQpXG4gICAgICBudW0gPSAwXG4gICAgICA0LnRpbWVzIGRvIHxpfFxuICAgICAgICBudW0gPDw9IDhcbiAgICAgICAgbnVtIHw9IGJzW2ldLm9yZFxuICAgICAgZW5kXG4gICAgICBudW0uYWJzIC8gMHg3ZmZmZmZmZlxuICAgIGVuZFxuXG4gICAgZGVmIHJhbmRvbV9udW1iZXIobGltaXQgPSB1bmRlZmluZWQpXG4gICAgICAleHtcbiAgICAgICAgZnVuY3Rpb24gcmFuZG9tRmxvYXQoKSB7XG4gICAgICAgICAgcmV0dXJuICN7cmFuZG9tX2Zsb2F0fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbUludChtYXgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihyYW5kb21GbG9hdCgpICogbWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbVJhbmdlKCkge1xuICAgICAgICAgIHZhciBtaW4gPSBsaW1pdC5iZWdpbixcbiAgICAgICAgICAgICAgbWF4ID0gbGltaXQuZW5kO1xuXG4gICAgICAgICAgaWYgKG1pbiA9PT0gbmlsIHx8IG1heCA9PT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsZW5ndGggPSBtYXggLSBtaW47XG5cbiAgICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXggJSAxID09PSAwICYmIG1pbiAlIDEgPT09IDAgJiYgIWxpbWl0LmV4Y2wpIHtcbiAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByYW5kb21JbnQobGVuZ3RoKSArIG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmRvbUZsb2F0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGltaXQuJCRpc19yYW5nZSkge1xuICAgICAgICAgIHJldHVybiByYW5kb21SYW5nZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbWl0LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGltaXQgJSAxID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxpbWl0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmRvbUZsb2F0KCkgKiBsaW1pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGltaXQgPSAje09wYWwuY29lcmNlX3RvIShsaW1pdCwgSW50ZWdlciwgOnRvX2ludCl9O1xuXG4gICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGFscGhhbnVtZXJpYyhjb3VudCA9IG5pbClcbiAgICAgIGNvdW50ID0gUmFuZG9tLl92ZXJpZnlfY291bnQoY291bnQpXG4gICAgICBtYXAgPSBbJzAnLi4nOScsICdhJy4uJ3onLCAnQScuLidaJ10ubWFwKCY6dG9fYSkuZmxhdHRlblxuICAgICAgQXJyYXkubmV3KGNvdW50KSBkbyB8aXxcbiAgICAgICAgbWFwW3JhbmRvbV9udW1iZXIobWFwLmxlbmd0aCldXG4gICAgICBlbmQuam9pblxuICAgIGVuZFxuICBlbmRcblxuICBpbmNsdWRlIFJhbmRvbTo6Rm9ybWF0dGVyXG4gIGV4dGVuZCBSYW5kb206OkZvcm1hdHRlclxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJtb2R1bGUiLCJoZXgiLCJjb3VudCIsIl92ZXJpZnlfY291bnQiLCJieXRlcyIsImVuY29kZSIsInJhbmRvbV9ieXRlcyIsImJhc2U2NCIsInN0cmljdF9lbmNvZGU2NCIsInVybHNhZmVfYmFzZTY0IiwidXJsc2FmZV9lbmNvZGU2NCIsInBhZGRpbmciLCJ1dWlkIiwic3RyIiwiMTYiLCJzcGxpdCIsIiR3cml0ZXIiLCIxMiIsIltdPSIsIi0iLCIxIiwiW10iLCIwIiwiOCIsIjIwIiwiMzIiLCJtYXAiLCJqb2luIiwicmFuZG9tX2Zsb2F0IiwiYnMiLCI0IiwibnVtIiwidGltZXMiLCI8PCIsInwiLCJpIiwib3JkIiwiLyIsImFicyIsIjIxNDc0ODM2NDciLCJyYW5kb21fbnVtYmVyIiwicmFpc2UiLCJsaW1pdCIsImNvZXJjZV90byEiLCJhbHBoYW51bWVyaWMiLCJmbGF0dGVuIiwibmV3IiwibGVuZ3RoIiwiaW5jbHVkZSIsImV4dGVuZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQUM7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFO0FBQUFDLE1BQUFBLHVCQUFBQSxtQkFBQUEsZUFBUSxLQUFSQTtBQUFBQSxRQUFBQTs7QUFBQUE7QUFISjtBQUdZLFFBQUE7QUFBQSxRQUFBLFVBQVEsR0FBUjtBQUFBLFFBQUEsQ0FIWjtBQUFBLFFBSU1DLFFBQVEsc0JBQUFDLGVBQUFBLENBQXFCRCxLQUFyQkMsQ0FKZDtBQUFBO0FBTUEsd0JBQXNCQyxPQUFBQSxDQUFNRixLQUFORSxDQUFhO0FBQ25DO0FBQ0EsNEJBQThCRixLQUFNO0FBQ3BDO0FBQ0E7QUFDQSxlQUFpQixDQUFDLEdBQUQsQ0FBQUcsUUFBQUEsQ0FBYSxVQUFiQSxDQUF5QjtBQUMxQyxNQVpBO0FBR0lKLE1BQUFBLENBQUFBLCtCQUFBQSxDQUFBO0FBQUE7QUFZQUssTUFBQUEsZ0NBQUFBLDRCQUFBQSx3QkFBaUIsS0FBakJBO0FBQUFBLFFBQUFBOztBQUFBQTtBQWZKO0FBZXFCLFFBQUE7QUFBQSxRQUFBLFVBQVEsR0FBUjtBQUFBLFFBQUEsQ0FmckI7QUFBQSxRQWdCTSxXQUFBRixPQUFBQSxDQUFNRixLQUFORSxDQWhCTjtBQWVJRSxNQUFBQSxDQUFBQSx3Q0FBQUEsQ0FaQTtBQUFBO0FBZ0JBQyxNQUFBQSwwQkFBQUEsc0JBQUFBLGtCQUFXLEtBQVhBO0FBQUFBLFFBQUFBOztBQUFBQTtBQW5CSjtBQW1CZSxRQUFBO0FBQUEsUUFBQSxVQUFRLEdBQVI7QUFBQSxRQUFBLENBbkJmO0FBQUEsUUFvQk0sT0FBQSxzQkFBQUMsaUJBQUFBLEtBQXVCRixjQUFBQSxDQUFhSixL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LEVBQUssR0FBTCxRQUFELEVBQVcsT0FBQSxHQUFBLEVBQUssR0FBTCxRQUFYLEVBQXFCLE9BQUEsR0FBQSxFQUFLLEdBQUwsUUFBckIsQ0FBQUEsT0FBQUEsRUFBQUEsRUFBQUEsRUFBb0MsaUJBQXBDQSxDQUFBbUIsU0FBQUEsQ0FBQUEsQ0FqSFo7QUFBQSxRQWtITSxPQUFBQyxNQUFBLHFCQUFBQSxPQUFBQSxFQUFBQSxDQUFVNUMsS0FBVjRDLENBQUFBLEVBbEhOLGlCQWtIMkIsQ0FsSDNCLEVBQUE7O0FBQUE7QUFBQTtBQWtIMkIsVUFBQTtBQUFBLFVBQUE7QUFBQSxVQUFBLENBbEgzQjtBQUFBLFVBbUhRLE9BQUFwQixHQUFBTCxPQUFBQSxLQUFJbUIsZUFBQUEsQ0FBY2QsR0FBQXFCLFFBQUFBLENBQUFBLENBQWRQLENBQUpuQixDQW5IUixDQUFBLG1CQUFBLGtCQUFBLE1Ba0hNeUIsQ0FBQW5CLE1BQUFBLENBQUFBLENBbEhOO0FBK0dJaUIsTUFBQUEsQ0FBQUEsd0NBQUFBLENBQUFBLHdCQTVHQTtBQURGNUMsSUFBQUEsR0FBQUEsV0FBQUEsV0FBQTtBQUFBLFFBc0hBZ0QsU0FBQUEsQ0FBUSxJQUFBLHNCQUFBLGNBQVJBLENBdEhBO0FBQUEsSUF1SEEsV0FBQUMsUUFBQUEsQ0FBTyxJQUFBLHNCQUFBLGNBQVBBLENBdkhBO0FBREZsRCxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0MjgxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYW5kb20ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBmYWxzeVxuXG5jbGFzcyBSYW5kb21cbiAgYXR0cl9yZWFkZXIgOnNlZWQsIDpzdGF0ZVxuXG4gIGRlZiBzZWxmLl92ZXJpZnlfY291bnQoY291bnQpXG4gICAgJXh7XG4gICAgICBpZiAoJGZhbHN5KGNvdW50KSkgY291bnQgPSAxNjtcbiAgICAgIGlmICh0eXBlb2YgY291bnQgIT09IFwibnVtYmVyXCIpIGNvdW50ID0gI3tgY291bnRgLnRvX2ludH07XG4gICAgICBpZiAoY291bnQgPCAwKSAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBzdHJpbmcgc2l6ZSAob3Igc2l6ZSB0b28gYmlnKSd9O1xuICAgICAgY291bnQgPSBNYXRoLmZsb29yKGNvdW50KTtcbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKHNlZWQgPSBSYW5kb20ubmV3X3NlZWQpXG4gICAgc2VlZCA9IE9wYWwuY29lcmNlX3RvIShzZWVkLCBJbnRlZ2VyLCA6dG9faW50KVxuICAgIEBzdGF0ZSA9IHNlZWRcbiAgICByZXNlZWQoc2VlZClcbiAgZW5kXG5cbiAgZGVmIHJlc2VlZChzZWVkKVxuICAgIEBzZWVkID0gc2VlZFxuICAgIGBzZWxmLiRybmcgPSBPcGFsLiQkcmFuZC5yZXNlZWQoc2VlZClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5ld19zZWVkXG4gICAgYE9wYWwuJCRyYW5kLm5ld19zZWVkKClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnJhbmQobGltaXQgPSB1bmRlZmluZWQpXG4gICAgREVGQVVMVC5yYW5kKGxpbWl0KVxuICBlbmRcblxuICBkZWYgc2VsZi5zcmFuZChuID0gUmFuZG9tLm5ld19zZWVkKVxuICAgIG4gPSBPcGFsLmNvZXJjZV90byEobiwgSW50ZWdlciwgOnRvX2ludClcblxuICAgIHByZXZpb3VzX3NlZWQgPSBERUZBVUxULnNlZWRcbiAgICBERUZBVUxULnJlc2VlZChuKVxuICAgIHByZXZpb3VzX3NlZWRcbiAgZW5kXG5cbiAgZGVmIHNlbGYudXJhbmRvbShzaXplKVxuICAgIDo6U2VjdXJlUmFuZG9tLmJ5dGVzKHNpemUpXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIFJhbmRvbSA9PT0gb3RoZXJcblxuICAgIHNlZWQgPT0gb3RoZXIuc2VlZCAmJiBzdGF0ZSA9PSBvdGhlci5zdGF0ZVxuICBlbmRcblxuICBkZWYgYnl0ZXMobGVuZ3RoKVxuICAgIGxlbmd0aCA9IFJhbmRvbS5fdmVyaWZ5X2NvdW50KGxlbmd0aClcblxuICAgIEFycmF5Lm5ldyhsZW5ndGgpIHsgcmFuZCgyNTUpLmNociB9LmpvaW4uZW5jb2RlKCdBU0NJSS04QklUJylcbiAgZW5kXG5cbiAgZGVmIHNlbGYuYnl0ZXMobGVuZ3RoKVxuICAgIERFRkFVTFQuYnl0ZXMobGVuZ3RoKVxuICBlbmRcblxuICBkZWYgcmFuZChsaW1pdCA9IHVuZGVmaW5lZClcbiAgICByYW5kb21fbnVtYmVyKGxpbWl0KVxuICBlbmRcblxuICAjIE5vdCBwYXJ0IG9mIHRoZSBSdWJ5IGludGVyZmFjZSAodXNlICNyYW5kb21fbnVtYmVyIGZvciBwb3J0YWJpbGl0eSksIGJ1dFxuICAjIHVzZWQgYnkgUmFuZG9tOjpGb3JtYXR0ZXIgYXMgYSBzaG9ydGN1dCwgYXMgZm9yIFJhbmRvbSBpbnRlcmZhY2UgdGhlIGZsb2F0XG4gICMgUk5HIGlzIHByaW1hcnkuXG4gIGRlZiByYW5kb21fZmxvYXRcbiAgICAleHtcbiAgICAgIHNlbGYuc3RhdGUrKztcbiAgICAgIHJldHVybiBPcGFsLiQkcmFuZC5yYW5kKHNlbGYuJHJuZyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5yYW5kb21fZmxvYXRcbiAgICBERUZBVUxULnJhbmRvbV9mbG9hdFxuICBlbmRcblxuICBkZWYgc2VsZi5nZW5lcmF0b3I9KGdlbmVyYXRvcilcbiAgICBgT3BhbC4kJHJhbmQgPSAje2dlbmVyYXRvcn1gXG5cbiAgICBpZiBjb25zdF9kZWZpbmVkPyA6REVGQVVMVFxuICAgICAgREVGQVVMVC5yZXNlZWRcbiAgICBlbHNlXG4gICAgICBjb25zdF9zZXQgOkRFRkFVTFQsIG5ldyhuZXdfc2VlZClcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsImF0dHJfcmVhZGVyIiwiX3ZlcmlmeV9jb3VudCIsInNlbGYiLCJ0b19pbnQiLCJyYWlzZSIsImluaXRpYWxpemUiLCJuZXdfc2VlZCIsInNlZWQiLCJjb2VyY2VfdG8hIiwiQHN0YXRlIiwicmVzZWVkIiwiQHNlZWQiLCJyYW5kIiwibGltaXQiLCJzcmFuZCIsIm4iLCJwcmV2aW91c19zZWVkIiwidXJhbmRvbSIsImJ5dGVzIiwic2l6ZSIsIj09IiwiPT09Iiwib3RoZXIiLCIkcmV0X29yXzEiLCJzdGF0ZSIsImxlbmd0aCIsIm5ldyIsIjI1NSIsImNociIsImpvaW4iLCJlbmNvZGUiLCJyYW5kb21fbnVtYmVyIiwicmFuZG9tX2Zsb2F0IiwiZ2VuZXJhdG9yPSIsImdlbmVyYXRvciIsImNvbnN0X2RlZmluZWQ/IiwiY29uc3Rfc2V0Il0sIm1hcHBpbmdzIjoiOzs7OztFQUVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxhQUFBQSxDQUFZLFFBQU8sT0FBbkJBLENBQUE7QUFBQSxJQUVBQyxVQUFJQyxJQUFKRCxvQkFBQUEsMEJBQUFBLHlCQUF1QixLQUF2QkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQSw2Q0FBK0MsQ0FBQyxLQUFELENBQUFFLFFBQUFBLENBQUFBLENBQWU7QUFDOUQseUJBQXVCQyxPQUFBQSxDQUFNLCtCQUFlLHdDQUFyQkEsQ0FBOEQ7QUFDckY7QUFDQTtBQUNBO0FBUEVILElBQUFBLENBQUFBLHFDQUFBQSxDQUZBO0FBQUE7QUFZQUksSUFBQUEsOEJBQUFBLHVCQUFBQSxzQkFBZSxJQUFmQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFoQkY7QUFnQmlCLE1BQUE7QUFBQSxNQUFBLFNBQU8sc0JBQUFDLFVBQUFBLENBQUFBLENBQVA7QUFBQSxNQUFBLENBaEJqQjtBQUFBLE1BaUJJQyxPQUFPLG9CQUFBQyxlQUFBQSxDQUFnQkQsTUFBTSx5QkFBUyxRQUEvQkMsQ0FqQlg7QUFBQSxNQWtCSUMsYUFBU0YsSUFsQmI7QUFBQSxNQW1CSSxXQUFBRyxRQUFBQSxDQUFPSCxJQUFQRyxDQW5C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QUFkUDtBQURGQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0F2REE7QUFBQTtBQTJEQU4sSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkFBUyxLQUFUQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUEvREYsTUFBQTtBQUFBLE1BZ0VJLFdBQUFtQixlQUFBQSxDQUFjbEIsS0FBZGtCLENBaEVKO0FBK0RFbkIsSUFBQUEsQ0FBQUEsOEJBQUFBLENBM0RBO0FBQUE7QUFrRUFvQixJQUFBQSxnQ0FBQUEsMEJBQUFBLHdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7QUFKRUEsSUFBQUEsQ0FBQUEscUNBQUFBLENBbEVBO0FBQUEsSUF5RUFBLFVBQUk5QixJQUFKOEIsbUJBQUFBLDBCQUFBQSx3QkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSx1QkFBQUEsY0FBQUEsQ0FBQUE7QUFERkEsSUFBQUEsQ0FBQUEscUNBQUFBLENBekVBO0FBQUEsSUE2RUEsT0FBQUMsQ0FBQUEsVUFBSS9CLElBQUorQixpQkFBQUEsMEJBQUFBLFNBQW9CLFNBQXBCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFDLGNBQWdCQyxTQUFqQjtBQUFBLE1BRUEsSUFBQSxZQUFHQyxtQkFBQUEsQ0FBZSxTQUFmQSxDQUFILENBQUE7QUFBQSxRQUNFLE9BQUEsdUJBQUF6QixRQUFBQSxDQUFBQTtBQURGLE1BQUE7QUFBQSxRQUdFLFdBQUEwQixXQUFBQSxDQUFVLGVBQVVWLEtBQUFBLEtBQUlwQixVQUFBQSxDQUFBQSxDQUFKb0IsQ0FBcEJVO0FBSEYsTUFBQSxDQUZBO0FBREZILElBQUFBLENBQUFBLHFDQUFBQSxDQUFBQSxzQkE3RUE7QUFERmxDLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ0MjEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhbmRvbS9tZXJzZW5uZV90d2lzdGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgVGhpcyBpcyBiYXNlZCBvbiBhbiBhZGFwdGF0aW9uIG9mIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEncyBjb2RlXG4jIGRvbmUgYnkgU2VhbiBNY0N1bGxvdWdoIDxiYW5rc2VhbkBnbWFpbC5jb20+IGFuZCBEYXZlIEhlaXR6bWFuXG4jIDxkYXZlaGVpdHptYW5AeWFob28uY29tPiwgc3Vic2VxdWVudGx5IHJlYWRhcHRlZCBmcm9tIGFuIHVwZGF0ZWQgdmVyc2lvbiBvZlxuIyBydWJ5J3MgcmFuZG9tLmMgKHJldiBjMzhhMTgzMDMyYTc4MjZkZjFhZGFiZDhhYTA3MjVjNzEzZDUzZTFjKS5cbiNcbiMgVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBub3RpY2UgZnJvbSByYW5kb20uYyBmb2xsb3dzLlxuI1xuIyAgIFRoaXMgaXMgYmFzZWQgb24gdHJpbW1lZCB2ZXJzaW9uIG9mIE1UMTk5MzcuICBUbyBnZXQgdGhlIG9yaWdpbmFsIHZlcnNpb24sXG4jICAgY29udGFjdCA8aHR0cDovL3d3dy5tYXRoLnNjaS5oaXJvc2hpbWEtdS5hYy5qcC9+bS1tYXQvTVQvZW10Lmh0bWw+LlxuI1xuIyAgIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgbm90aWNlIGZvbGxvd3MuXG4jXG4jICAgICAgQSBDLXByb2dyYW0gZm9yIE1UMTk5MzcsIHdpdGggaW5pdGlhbGl6YXRpb24gaW1wcm92ZWQgMjAwMi8yLzEwLlxuIyAgICAgIENvZGVkIGJ5IFRha3VqaSBOaXNoaW11cmEgYW5kIE1ha290byBNYXRzdW1vdG8uXG4jICAgICAgVGhpcyBpcyBhIGZhc3RlciB2ZXJzaW9uIGJ5IHRha2luZyBTaGF3biBDb2t1cydzIG9wdGltaXphdGlvbixcbiMgICAgICBNYXR0aGUgQmVsbGV3J3Mgc2ltcGxpZmljYXRpb24sIElzYWt1IFdhZGEncyByZWFsIHZlcnNpb24uXG4jXG4jICAgICAgQmVmb3JlIHVzaW5nLCBpbml0aWFsaXplIHRoZSBzdGF0ZSBieSB1c2luZyBpbml0X2dlbnJhbmQobXQsIHNlZWQpXG4jICAgICAgb3IgaW5pdF9ieV9hcnJheShtdCwgaW5pdF9rZXksIGtleV9sZW5ndGgpLlxuI1xuIyAgICAgIENvcHlyaWdodCAoQykgMTk5NyAtIDIwMDIsIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEsXG4jICAgICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiNcbiMgICAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiMgICAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiMgICAgICBhcmUgbWV0OlxuI1xuIyAgICAgICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiMgICAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiNcbiMgICAgICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4jICAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4jICAgICAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuI1xuIyAgICAgICAgMy4gVGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZVxuIyAgICAgICAgICAgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuXG4jICAgICAgICAgICBwZXJtaXNzaW9uLlxuI1xuIyAgICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiMgICAgICBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4jICAgICAgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4jICAgICAgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXG4jICAgICAgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4jICAgICAgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuIyAgICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuIyAgICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiMgICAgICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuIyAgICAgIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuIyAgICAgIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuI1xuI1xuIyAgICAgIEFueSBmZWVkYmFjayBpcyB2ZXJ5IHdlbGNvbWUuXG4jICAgICAgaHR0cDovL3d3dy5tYXRoLmtlaW8uYWMuanAvbWF0dW1vdG8vZW10Lmh0bWxcbiMgICAgICBlbWFpbDogbWF0dW1vdG9AbWF0aC5rZWlvLmFjLmpwXG5tZXJzZW5uZV90d2lzdGVyID0gJXh7KGZ1bmN0aW9uKCkge1xuICAvKiBQZXJpb2QgcGFyYW1ldGVycyAqL1xuICB2YXIgTiA9IDYyNDtcbiAgdmFyIE0gPSAzOTc7XG4gIHZhciBNQVRSSVhfQSA9IDB4OTkwOGIwZGY7ICAgICAgLyogY29uc3RhbnQgdmVjdG9yIGEgKi9cbiAgdmFyIFVNQVNLID0gMHg4MDAwMDAwMDsgICAgICAgICAvKiBtb3N0IHNpZ25pZmljYW50IHctciBiaXRzICovXG4gIHZhciBMTUFTSyA9IDB4N2ZmZmZmZmY7ICAgICAgICAgLyogbGVhc3Qgc2lnbmlmaWNhbnQgciBiaXRzICovXG4gIHZhciBNSVhCSVRTID0gZnVuY3Rpb24odSx2KSB7IHJldHVybiAoICgodSkgJiBVTUFTSykgfCAoKHYpICYgTE1BU0spICk7IH07XG4gIHZhciBUV0lTVCA9IGZ1bmN0aW9uKHUsdikgeyByZXR1cm4gKE1JWEJJVFMoKHUpLCh2KSkgPj4+IDEpIF4gKCh2ICYgMHgxKSA/IE1BVFJJWF9BIDogMHgwKTsgfTtcblxuICBmdW5jdGlvbiBpbml0KHMpIHtcbiAgICB2YXIgbXQgPSB7bGVmdDogMCwgbmV4dDogTiwgc3RhdGU6IG5ldyBBcnJheShOKX07XG4gICAgaW5pdF9nZW5yYW5kKG10LCBzKTtcbiAgICByZXR1cm4gbXQ7XG4gIH1cblxuICAvKiBpbml0aWFsaXplcyBtdFtOXSB3aXRoIGEgc2VlZCAqL1xuICBmdW5jdGlvbiBpbml0X2dlbnJhbmQobXQsIHMpIHtcbiAgICB2YXIgaiwgaTtcbiAgICBtdC5zdGF0ZVswXSA9IHMgPj4+IDA7XG4gICAgZm9yIChqPTE7IGo8TjsgaisrKSB7XG4gICAgICBtdC5zdGF0ZVtqXSA9ICgxODEyNDMzMjUzICogKChtdC5zdGF0ZVtqLTFdIF4gKG10LnN0YXRlW2otMV0gPj4gMzApID4+PiAwKSkgKyBqKTtcbiAgICAgIC8qIFNlZSBLbnV0aCBUQU9DUCBWb2wyLiAzcmQgRWQuIFAuMTA2IGZvciBtdWx0aXBsaWVyLiAqL1xuICAgICAgLyogSW4gdGhlIHByZXZpb3VzIHZlcnNpb25zLCBNU0JzIG9mIHRoZSBzZWVkIGFmZmVjdCAgICovXG4gICAgICAvKiBvbmx5IE1TQnMgb2YgdGhlIGFycmF5IHN0YXRlW10uICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgIC8qIDIwMDIvMDEvMDkgbW9kaWZpZWQgYnkgTWFrb3RvIE1hdHN1bW90byAgICAgICAgICAgICAqL1xuICAgICAgbXQuc3RhdGVbal0gJj0gMHhmZmZmZmZmZjsgIC8qIGZvciA+MzIgYml0IG1hY2hpbmVzICovXG4gICAgfVxuICAgIG10LmxlZnQgPSAxO1xuICAgIG10Lm5leHQgPSBOO1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgTiB3b3JkcyBhdCBvbmUgdGltZSAqL1xuICBmdW5jdGlvbiBuZXh0X3N0YXRlKG10KSB7XG4gICAgdmFyIHAgPSAwLCBfcCA9IG10LnN0YXRlO1xuICAgIHZhciBqO1xuXG4gICAgbXQubGVmdCA9IE47XG4gICAgbXQubmV4dCA9IDA7XG5cbiAgICBmb3IgKGo9Ti1NKzE7IC0tajsgcCsrKVxuICAgICAgX3BbcF0gPSBfcFtwKyhNKV0gXiBUV0lTVChfcFtwKygwKV0sIF9wW3ArKDEpXSk7XG5cbiAgICBmb3IgKGo9TTsgLS1qOyBwKyspXG4gICAgICBfcFtwXSA9IF9wW3ArKE0tTildIF4gVFdJU1QoX3BbcCsoMCldLCBfcFtwKygxKV0pO1xuXG4gICAgX3BbcF0gPSBfcFtwKyhNLU4pXSBeIFRXSVNUKF9wW3ArKDApXSwgX3BbMF0pO1xuICB9XG5cbiAgLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwweGZmZmZmZmZmXS1pbnRlcnZhbCAqL1xuICBmdW5jdGlvbiBnZW5yYW5kX2ludDMyKG10KSB7XG4gICAgLyogbXQgbXVzdCBiZSBpbml0aWFsaXplZCAqL1xuICAgIHZhciB5O1xuXG4gICAgaWYgKC0tbXQubGVmdCA8PSAwKSBuZXh0X3N0YXRlKG10KTtcbiAgICB5ID0gbXQuc3RhdGVbbXQubmV4dCsrXTtcblxuICAgIC8qIFRlbXBlcmluZyAqL1xuICAgIHkgXj0gKHkgPj4+IDExKTtcbiAgICB5IF49ICh5IDw8IDcpICYgMHg5ZDJjNTY4MDtcbiAgICB5IF49ICh5IDw8IDE1KSAmIDB4ZWZjNjAwMDA7XG4gICAgeSBePSAoeSA+Pj4gMTgpO1xuXG4gICAgcmV0dXJuIHkgPj4+IDA7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRfcGFpcl90b19yZWFsX2V4Y2x1c2l2ZShhLCBiKSB7XG4gICAgYSA+Pj49IDU7XG4gICAgYiA+Pj49IDY7XG4gICAgcmV0dXJuKGEqNjcxMDg4NjQuMCtiKSooMS4wLzkwMDcxOTkyNTQ3NDA5OTIuMCk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDEpIHdpdGggNTMtYml0IHJlc29sdXRpb25cbiAgZnVuY3Rpb24gZ2VucmFuZF9yZWFsKG10KSB7XG4gICAgLyogbXQgbXVzdCBiZSBpbml0aWFsaXplZCAqL1xuICAgIHZhciBhID0gZ2VucmFuZF9pbnQzMihtdCksIGIgPSBnZW5yYW5kX2ludDMyKG10KTtcbiAgICByZXR1cm4gaW50X3BhaXJfdG9fcmVhbF9leGNsdXNpdmUoYSwgYik7XG4gIH1cblxuICByZXR1cm4geyBnZW5yYW5kX3JlYWw6IGdlbnJhbmRfcmVhbCwgaW5pdDogaW5pdCB9O1xufSkoKX1cblxuY2xhc3MgUmFuZG9tXG4gIGB2YXIgTUFYX0lOVCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IE1hdGgucG93KDIsIDUzKSAtIDFgXG5cbiAgTUVSU0VOTkVfVFdJU1RFUl9HRU5FUkFUT1IgPSBge1xuICAgIG5ld19zZWVkOiBmdW5jdGlvbigpIHsgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIE1BWF9JTlQpOyB9LFxuICAgIHJlc2VlZDogZnVuY3Rpb24oc2VlZCkgeyByZXR1cm4gbWVyc2VubmVfdHdpc3Rlci5pbml0KHNlZWQpOyB9LFxuICAgIHJhbmQ6IGZ1bmN0aW9uKG10KSB7IHJldHVybiBtZXJzZW5uZV90d2lzdGVyLmdlbnJhbmRfcmVhbChtdCk7IH1cbiAgfWBcblxuICBzZWxmLmdlbmVyYXRvciA9IE1FUlNFTk5FX1RXSVNURVJfR0VORVJBVE9SXG5lbmRcbiJdLCJuYW1lcyI6WyJtZXJzZW5uZV90d2lzdGVyIiwiY2xhc3MiLCIkd3JpdGVyIiwiZ2VuZXJhdG9yPSIsInNlbGYiLCItIiwiMSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBc0RBLEVBQUFBLG1CQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQWhGQTtBQUFBLEVBa0ZBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFDLDREQUFEO0FBQUEsSUFFQSwwREFBOEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsR0FKRSxDQUZBO0FBQUE7QUExSUYsSUFBQUMsVUFBQSxDQWtKbUIsMENBbEpuQixDQUFBO0FBQUEsSUFrSkVDLE1BQUFDLElBQUFELGNBQUFBLEVBbEpGLFVBQUFELE9BQUEsQ0FrSkVDLENBbEpGO0FBQUEsSUFBQSxPQUFBRCxPQUFBLENBQUFHLFVBQUFILE9BQUEsQ0FBQSxRQUFBLENBQUFHLEVBQUFDLENBQUFELENBQUEsQ0FBQSxDQTBJRTtBQURGSixFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQWxGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0NTMwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi91bnN1cHBvcnRlZC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIleHtcbiAgdmFyIHdhcm5pbmdzID0ge307XG5cbiAgZnVuY3Rpb24gaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUobWVzc2FnZSkge1xuICAgIHN3aXRjaCAoT3BhbC5jb25maWcudW5zdXBwb3J0ZWRfZmVhdHVyZXNfc2V2ZXJpdHkpIHtcbiAgICBjYXNlICdlcnJvcic6XG4gICAgICAje0tlcm5lbC5yYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgbWVzc2FnZWB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgIHdhcm4obWVzc2FnZSlcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIGlnbm9yZVxuICAgICAgLy8gbm9vcFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oc3RyaW5nKSB7XG4gICAgaWYgKHdhcm5pbmdzW3N0cmluZ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuaW5nc1tzdHJpbmddID0gdHJ1ZTtcbiAgICAje3dhcm4oYHN0cmluZ2ApfTtcbiAgfVxufVxuXG5jbGFzcyBTdHJpbmdcbiAgYHZhciBFUlJPUiA9IFwiU3RyaW5nIyVzIG5vdCBzdXBwb3J0ZWQuIE11dGFibGUgU3RyaW5nIG1ldGhvZHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gT3BhbC5cImBcblxuICBkZWYgPDwoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJzw8J1xuICBlbmRcblxuICBkZWYgY2FwaXRhbGl6ZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2NhcGl0YWxpemUhJ1xuICBlbmRcblxuICBkZWYgY2hvbXAhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdjaG9tcCEnXG4gIGVuZFxuXG4gIGRlZiBjaG9wISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnY2hvcCEnXG4gIGVuZFxuXG4gIGRlZiBkb3duY2FzZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2Rvd25jYXNlISdcbiAgZW5kXG5cbiAgZGVmIGdzdWIhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdnc3ViISdcbiAgZW5kXG5cbiAgZGVmIGxzdHJpcCEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2xzdHJpcCEnXG4gIGVuZFxuXG4gIGRlZiBuZXh0ISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnbmV4dCEnXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAncmV2ZXJzZSEnXG4gIGVuZFxuXG4gIGRlZiBzbGljZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3NsaWNlISdcbiAgZW5kXG5cbiAgZGVmIHNxdWVlemUhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdzcXVlZXplISdcbiAgZW5kXG5cbiAgZGVmIHN0cmlwISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3RyaXAhJ1xuICBlbmRcblxuICBkZWYgc3ViISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3ViISdcbiAgZW5kXG5cbiAgZGVmIHN1Y2MhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdzdWNjISdcbiAgZW5kXG5cbiAgZGVmIHN3YXBjYXNlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3dhcGNhc2UhJ1xuICBlbmRcblxuICBkZWYgdHIhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICd0ciEnXG4gIGVuZFxuXG4gIGRlZiB0cl9zISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAndHJfcyEnXG4gIGVuZFxuXG4gIGRlZiB1cGNhc2UhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICd1cGNhc2UhJ1xuICBlbmRcblxuICBkZWYgcHJlcGVuZCgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAncHJlcGVuZCdcbiAgZW5kXG5cbiAgZGVmIFtdPSgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnW109J1xuICBlbmRcblxuICBkZWYgY2xlYXIoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2NsZWFyJ1xuICBlbmRcblxuICBkZWYgZW5jb2RlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnZW5jb2RlISdcbiAgZW5kXG5cbiAgZGVmIHVuaWNvZGVfbm9ybWFsaXplISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAndW5pY29kZV9ub3JtYWxpemUhJ1xuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGB2YXIgRVJST1IgPSBcIk9iamVjdCBmcmVlemluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IE9wYWxcImBcblxuICBkZWYgZnJlZXplXG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmcm96ZW4/XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBmYWxzZVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGB2YXIgRVJST1IgPSBcIk9iamVjdCB0YWludGluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IE9wYWxcImBcblxuICBkZWYgdGFpbnRcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHVudGFpbnRcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRhaW50ZWQ/XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBmYWxzZVxuICBlbmRcbmVuZFxuXG5jbGFzcyBNb2R1bGVcbiAgZGVmIHB1YmxpYygqbWV0aG9kcylcbiAgICAleHtcbiAgICAgIGlmIChtZXRob2RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLiQkbW9kdWxlX2Z1bmN0aW9uID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBwcml2YXRlIHB1YmxpY1xuXG4gIGFsaWFzIHByb3RlY3RlZCBwdWJsaWNcblxuICBhbGlhcyBuZXN0aW5nIHB1YmxpY1xuXG4gIGRlZiBwcml2YXRlX2NsYXNzX21ldGhvZCgqKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgcHVibGljX2NsYXNzX21ldGhvZCBwcml2YXRlX2NsYXNzX21ldGhvZFxuXG4gIGRlZiBwcml2YXRlX21ldGhvZF9kZWZpbmVkPyhvYmopXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHByaXZhdGVfY29uc3RhbnQoKilcbiAgZW5kXG5cbiAgYWxpYXMgcHJvdGVjdGVkX21ldGhvZF9kZWZpbmVkPyBwcml2YXRlX21ldGhvZF9kZWZpbmVkP1xuXG4gIGFsaWFzIHB1YmxpY19pbnN0YW5jZV9tZXRob2RzIGluc3RhbmNlX21ldGhvZHNcblxuICBhbGlhcyBwdWJsaWNfaW5zdGFuY2VfbWV0aG9kIGluc3RhbmNlX21ldGhvZFxuXG4gIGFsaWFzIHB1YmxpY19tZXRob2RfZGVmaW5lZD8gbWV0aG9kX2RlZmluZWQ/XG5lbmRcblxubW9kdWxlIEtlcm5lbFxuICBkZWYgcHJpdmF0ZV9tZXRob2RzKCopXG4gICAgW11cbiAgZW5kXG5cbiAgYWxpYXMgcHJpdmF0ZV9pbnN0YW5jZV9tZXRob2RzIHByaXZhdGVfbWV0aG9kc1xuZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgZGVmIGV2YWwoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBcIlRvIHVzZSBLZXJuZWwjZXZhbCwgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnb3BhbC1wYXJzZXInLiBcIlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTZWUgaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9ibG9iLyN7UlVCWV9FTkdJTkVfVkVSU0lPTn0vZG9jcy9vcGFsX3BhcnNlci5tZCBmb3IgZGV0YWlscy5cIlxuICBlbmRcbmVuZFxuXG5kZWYgc2VsZi5wdWJsaWMoKilcbiAgIyBzdHViXG5lbmRcblxuZGVmIHNlbGYucHJpdmF0ZSgqKVxuICAjIHN0dWJcbmVuZFxuIl0sIm5hbWVzIjpbInJhaXNlIiwid2FybiIsImNsYXNzIiwiPDwiLCIlIiwiY2FwaXRhbGl6ZSEiLCJjaG9tcCEiLCJjaG9wISIsImRvd25jYXNlISIsImdzdWIhIiwibHN0cmlwISIsIm5leHQhIiwicmV2ZXJzZSEiLCJzbGljZSEiLCJzcXVlZXplISIsInN0cmlwISIsInN1YiEiLCJzdWNjISIsInN3YXBjYXNlISIsInRyISIsInRyX3MhIiwidXBjYXNlISIsInByZXBlbmQiLCJbXT0iLCJjbGVhciIsImVuY29kZSEiLCJ1bmljb2RlX25vcm1hbGl6ZSEiLCJtb2R1bGUiLCJmcmVlemUiLCJzZWxmIiwiZnJvemVuPyIsInRhaW50IiwidW50YWludCIsInRhaW50ZWQ/IiwicHVibGljIiwicHJpdmF0ZV9jbGFzc19tZXRob2QiLCJwcml2YXRlX21ldGhvZF9kZWZpbmVkPyIsInByaXZhdGVfY29uc3RhbnQiLCJwcml2YXRlX21ldGhvZHMiLCJldmFsIiwicHJpdmF0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFRLHNCQUFBQSxPQUFBQSxDQUFhLHFDQUFzQixPQUFuQ0E7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBTUMsTUFBQUEsQ0FBTSxNQUFOQSxDQUFlO0FBQ3JCO0FBdkJBO0FBQUEsRUEwQkFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFDLHdGQUFEO0FBQUE7QUFFQUMsSUFBQUEsc0JBQUFBLG1CQUFBQSxTQTlCRixFQThCRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBOUJGO0FBQUEsTUFBQSw0REFBQTtBQUFBLE1BQUE7QUFBQSxNQStCSSxXQUFBSCxPQUFBQSxDQUFNLHFDQUFxQixDQUFDLEtBQUQsQ0FBQUksTUFBQUEsQ0FBVSxJQUFWQSxDQUEzQkosQ0EvQko7QUE4QkVHLElBQUFBLENBQUFBLCtCQUFBQSxDQUZBO0FBQUE7QUFNQUUsSUFBQUEsK0JBQUFBLDRCQUFBQSxTQWxDRixFQWtDRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBbENGO0FBQUEsTUFBQSw0REFBQTtBQUFBLE1BQUE7QUFBQSxNQW1DSSxXQUFBTCxPQUFBQSxDQUFNLHFDQUFxQixDQUFDLEtBQUQsQ0FBQUksTUFBQUEsQ0FBVSxhQUFWQSxDQUEzQkosQ0FuQ0o7QUFrQ0VLLElBQUFBLENB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QUFBLENBQUFBLG1CQXJOQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0OTYzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9vcGFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ29wYWwvYmFzZSdcbnJlcXVpcmUgJ29wYWwvbWluaSdcblxucmVxdWlyZSAnY29yZWxpYi9rZXJuZWwvZm9ybWF0J1xucmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcnXG5yZXF1aXJlICdjb3JlbGliL21hdGgnXG5yZXF1aXJlICdjb3JlbGliL2NvbXBsZXgnXG5yZXF1aXJlICdjb3JlbGliL3JhdGlvbmFsJ1xucmVxdWlyZSAnY29yZWxpYi90aW1lJ1xucmVxdWlyZSAnY29yZWxpYi9zdHJ1Y3QnXG5yZXF1aXJlICdjb3JlbGliL2lvJ1xucmVxdWlyZSAnY29yZWxpYi9tYWluJ1xucmVxdWlyZSAnY29yZWxpYi9kaXInXG5yZXF1aXJlICdjb3JlbGliL2ZpbGUnXG5yZXF1aXJlICdjb3JlbGliL3Byb2Nlc3MnXG5yZXF1aXJlICdjb3JlbGliL3JhbmRvbS9mb3JtYXR0ZXInXG5yZXF1aXJlICdjb3JlbGliL3JhbmRvbSdcbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZG9tL21lcnNlbm5lX3R3aXN0ZXInXG5cbnJlcXVpcmUgJ2NvcmVsaWIvdW5zdXBwb3J0ZWQnXG4iXSwibmFtZXMiOlsicmVxdWlyZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxXQUFSQSxDQUFBO0FBQUEsTUFDQUEsU0FBQUEsQ0FBUSxXQUFSQSxDQURBO0FBQUEsTUFHQUEsU0FBQUEsQ0FBUSx1QkFBUkEsQ0FIQTtBQUFBLE1BSUFBLFNBQUFBLENBQVEseUJBQVJBLENBSkE7QUFBQSxNQUtBQSxTQUFBQSxDQUFRLGNBQVJBLENBTEE7QUFBQSxNQU1BQSxTQUFBQSxDQUFRLGlCQUFSQSxDQU5BO0FBQUEsTUFPQUEsU0FBQUEsQ0FBUSxrQkFBUkEsQ0FQQTtBQUFBLE1BUUFBLFNBQUFBLENBQVEsY0FBUkEsQ0FSQTtBQUFBLE1BU0FBLFNBQUFBLENBQVEsZ0JBQVJBLENBVEE7QUFBQSxNQVVBQSxTQUFBQSxDQUFRLFlBQVJBLENBVkE7QUFBQSxNQVdBQSxTQUFBQSxDQUFRLGNBQVJBLENBWEE7QUFBQSxNQVlBQSxTQUFBQSxDQUFRLGFBQVJBLENBWkE7QUFBQSxNQWFBQSxTQUFBQSxDQUFRLGNBQVJBLENBYkE7QUFBQSxNQWNBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQWRBO0FBQUEsTUFlQUEsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FmQTtBQUFBLE1BZ0JBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQWhCQTtBQUFBLE1BaUJBQSxTQUFBQSxDQUFRLGlDQUFSQSxDQWpCQTtBQUFBLEVBbUJBLFdBQUFBLFNBQUFBLENBQVEscUJBQVJBLENBbkJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ5ODksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL25hdGl2ZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIFByb3ZpZGVzIGEgY29tcGxldGUgc2V0IG9mIHRvb2xzIHRvIHdyYXAgbmF0aXZlIEphdmFTY3JpcHRcbiMgaW50byBuaWNlIFJ1Ynkgb2JqZWN0cy5cbiNcbiMgQGV4YW1wbGVcbiNcbiMgICAkJC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdwJykuY2xhc3NMaXN0LmFkZCgnYmx1ZScpXG4jICAgIyA9PiBhZGRzIFwiYmx1ZVwiIGNsYXNzIHRvIDxwPlxuI1xuIyAgICQkLmxvY2F0aW9uLmhyZWYgPSAnaHR0cHM6Ly9nb29nbGUuY29tJ1xuIyAgICMgPT4gY2hhbmdlcyBwYWdlIGxvY2F0aW9uXG4jXG4jICAgZG9fbGF0ZXIgPSAkJFs6c2V0VGltZW91dF0gIyBBY2Nlc3NpbmcgdGhlIFwic2V0VGltZW91dFwiIHByb3BlcnR5XG4jICAgZG9fbGF0ZXIuY2FsbCgtPnsgcHV0cyA6aGVsbG99LCA1MDApXG4jXG4jIGAkJGAgYW5kIGAkZ2xvYmFsYCB3cmFwIGBPcGFsLmdsb2JhbGAsIHdoaWNoIHRoZSBPcGFsIEpTIHJ1bnRpbWVcbiMgc2V0cyB0byB0aGUgZ2xvYmFsIGB0aGlzYCBvYmplY3QuXG4jXG5tb2R1bGUgTmF0aXZlXG4gIGRlZiBzZWxmLmlzX2E/KG9iamVjdCwga2xhc3MpXG4gICAgJXh7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gI3tvYmplY3R9IGluc3RhbmNlb2YgI3t0cnlfY29udmVydChrbGFzcyl9O1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQodmFsdWUsIGRlZmF1bHQgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoI3tuYXRpdmU/KHZhbHVlKX0pIHtcbiAgICAgICAgcmV0dXJuICN7dmFsdWV9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyA6dG9fbn0pIHtcbiAgICAgICAgcmV0dXJuICN7dmFsdWUudG9fbn07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7ZGVmYXVsdH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5jb252ZXJ0KHZhbHVlKVxuICAgICV4e1xuICAgICAgaWYgKCN7bmF0aXZlPyh2YWx1ZSl9KSB7XG4gICAgICAgIHJldHVybiAje3ZhbHVlfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7dmFsdWUucmVzcG9uZF90bz8gOnRvX259KSB7XG4gICAgICAgIHJldHVybiAje3ZhbHVlLnRvX259O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCIje3ZhbHVlLmluc3BlY3R9IGlzbid0IG5hdGl2ZVwifTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNhbGwob2JqLCBrZXksICphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcHJvcCA9ICN7b2JqfVsje2tleX1dO1xuXG4gICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBjb252ZXJ0ZWQgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGFyZ3NbaV0sXG4gICAgICAgICAgICAgIGNvbnYgPSAje3RyeV9jb252ZXJ0KGBpdGVtYCl9O1xuXG4gICAgICAgICAgY29udmVydGVkW2ldID0gY29udiA9PT0gbmlsID8gaXRlbSA6IGNvbnY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgIGNvbnZlcnRlZC5wdXNoKGJsb2NrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAje05hdGl2ZShgcHJvcC5hcHBseSgje29ian0sIGNvbnZlcnRlZClgKX07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7TmF0aXZlKGBwcm9wYCl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYucHJvYygmYmxvY2spXG4gICAgcmFpc2UgTG9jYWxKdW1wRXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICA6Oktlcm5lbC5wcm9jIHsgfCphcmdzfFxuICAgICAgYXJncy5tYXAhIHsgfGFyZ3wgTmF0aXZlKGFyZykgfVxuICAgICAgaW5zdGFuY2UgPSBOYXRpdmUoYHRoaXNgKVxuXG4gICAgICAleHtcbiAgICAgICAgLy8gaWYgZ2xvYmFsIGlzIGN1cnJlbnQgc2NvcGUsIHJ1biB0aGUgYmxvY2sgaW4gdGhlIHNjb3BlIGl0IHdhcyBkZWZpbmVkXG4gICAgICAgIGlmICh0aGlzID09PSBPcGFsLmdsb2JhbCkge1xuICAgICAgICAgIHJldHVybiBibG9jay5hcHBseShzZWxmLCAje2FyZ3N9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmXyA9IGJsb2NrLiQkcztcbiAgICAgICAgYmxvY2suJCRzID0gbnVsbDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBibG9jay5hcHBseSgje2luc3RhbmNlfSwgI3thcmdzfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgYmxvY2suJCRzID0gc2VsZl87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIG1vZHVsZSBIZWxwZXJzXG4gICAgIyBFeHBvc2VzIGEgbmF0aXZlIEphdmFTY3JpcHQgbWV0aG9kIHRvIFJ1YnlcbiAgICAjXG4gICAgI1xuICAgICMgQHBhcmFtIG5ldyBbU3RyaW5nXVxuICAgICMgICAgICAgVGhlIG5hbWUgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgbWV0aG9kLlxuICAgICNcbiAgICAjIEBwYXJhbSBvbGQgW1N0cmluZ11cbiAgICAjICAgICAgIFRoZSBuYW1lIG9mIHRoZSBuYXRpdmUgSmF2YVNjcmlwdCBtZXRob2QgdG8gYmUgZXhwb3NlZC5cbiAgICAjICAgICAgIElmIHRoZSBuYW1lIGVuZHMgd2l0aCBcIj1cIiAoZS5nLiBgZm9vPWApIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXNcbiAgICAjICAgICAgIGEgcHJvcGVydHkgc2V0dGVyLiAoZGVmYXVsdDogdGhlIHZhbHVlIG9mIFwibmV3XCIpXG4gICAgI1xuICAgICMgQHBhcmFtIGFzIFtDbGFzc11cbiAgICAjICAgICAgIElmIHByb3ZpZGVkIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIG9yaWdpbmFsIG1ldGhvZCB3aWxsIGJlXG4gICAgIyAgICAgICByZXR1cm5lZCBhcyBpbnN0YW5jZXMgb2YgdGhlIHBhc3NlZCBjbGFzcy4gVGhlIGNsYXNzIHBhc3NlZCB0byBcImFzXCJcbiAgICAjICAgICAgIGlzIGV4cGVjdGVkIHRvIGFjY2VwdCBhIG5hdGl2ZSBKYXZhU2NyaXB0IHZhbHVlLlxuICAgICNcbiAgICAjIEBleGFtcGxlXG4gICAgI1xuICAgICMgICBjbGFzcyBFbGVtZW50XG4gICAgIyAgICAgZXh0ZW5kIE5hdGl2ZTo6SGVscGVyc1xuICAgICNcbiAgICAjICAgICBhbGlhc19uYXRpdmUgOmFkZF9jbGFzcywgOmFkZENsYXNzXG4gICAgIyAgICAgYWxpYXNfbmF0aXZlIDpzaG93XG4gICAgIyAgICAgYWxpYXNfbmF0aXZlIDpoaWRlXG4gICAgI1xuICAgICMgICAgIGRlZiBpbml0aWFsaXplKHNlbGVjdG9yKVxuICAgICMgICAgICAgQG5hdGl2ZSA9IGAkKCN7c2VsZWN0b3J9KWBcbiAgICAjICAgICBlbmRcbiAgICAjICAgZW5kXG4gICAgI1xuICAgICMgICB0aXRsZXMgPSBFbGVtZW50Lm5ldygnaDEnKVxuICAgICMgICB0aXRsZXMuYWRkX2NsYXNzIDpmb29cbiAgICAjICAgdGl0bGVzLmhpZGVcbiAgICAjICAgdGl0bGVzLnNob3dcbiAgICAjXG4gICAgZGVmIGFsaWFzX25hdGl2ZShuZXcsIG9sZCA9IG5ldywgYXM6IG5pbClcbiAgICAgIGlmIG9sZC5lbmRfd2l0aD8gJz0nXG4gICAgICAgIGRlZmluZV9tZXRob2QgbmV3IGRvIHx2YWx1ZXxcbiAgICAgICAgICBgI3tAbmF0aXZlfVsje29sZFswLi4tMl19XSA9ICN7TmF0aXZlLmNvbnZlcnQodmFsdWUpfWBcblxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIGVuZFxuICAgICAgZWxzaWYgYXNcbiAgICAgICAgZGVmaW5lX21ldGhvZCBuZXcgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAgICAgdmFsdWUgPSBOYXRpdmUuY2FsbChAbmF0aXZlLCBvbGQsICphcmdzLCAmYmxvY2spXG4gICAgICAgICAgaWYgdmFsdWVcbiAgICAgICAgICAgIGFzLm5ldyh2YWx1ZS50b19uKVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZGVmaW5lX21ldGhvZCBuZXcgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAgICAgTmF0aXZlLmNhbGwoQG5hdGl2ZSwgb2xkLCAqYXJncywgJmJsb2NrKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIG5hdGl2ZV9yZWFkZXIoKm5hbWVzKVxuICAgICAgbmFtZXMuZWFjaCBkbyB8bmFtZXxcbiAgICAgICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvXG4gICAgICAgICAgTmF0aXZlKGAje0BuYXRpdmV9W25hbWVdYClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBuYXRpdmVfd3JpdGVyKCpuYW1lcylcbiAgICAgIG5hbWVzLmVhY2ggZG8gfG5hbWV8XG4gICAgICAgIGRlZmluZV9tZXRob2QgXCIje25hbWV9PVwiIGRvIHx2YWx1ZXxcbiAgICAgICAgICBOYXRpdmUoYCN7QG5hdGl2ZX1bbmFtZV0gPSB2YWx1ZWApXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgbmF0aXZlX2FjY2Vzc29yKCpuYW1lcylcbiAgICAgIG5hdGl2ZV9yZWFkZXIoKm5hbWVzKVxuICAgICAgbmF0aXZlX3dyaXRlcigqbmFtZXMpXG4gICAgZW5kXG4gIGVuZFxuXG4gIG1vZHVsZSBXcmFwcGVyXG4gICAgZGVmIGluaXRpYWxpemUobmF0aXZlKVxuICAgICAgdW5sZXNzIDo6S2VybmVsLm5hdGl2ZT8obmF0aXZlKVxuICAgICAgICA6Oktlcm5lbC5yYWlzZSBBcmd1bWVudEVycm9yLCBcIiN7bmF0aXZlLmluc3BlY3R9IGlzbid0IG5hdGl2ZVwiXG4gICAgICBlbmRcblxuICAgICAgQG5hdGl2ZSA9IG5hdGl2ZVxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBuYXRpdmUgSmF2YVNjcmlwdCB2YWx1ZVxuICAgIGRlZiB0b19uXG4gICAgICBAbmF0aXZlXG4gICAgZW5kXG5cbiAgICBkZWYgc2VsZi5pbmNsdWRlZChrbGFzcylcbiAgICAgIGtsYXNzLmV4dGVuZCBIZWxwZXJzXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmluY2x1ZGVkKGJhc2UpXG4gICAgd2FybiAnSW5jbHVkaW5nIDo6TmF0aXZlIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlciBpbnN0ZWFkLidcbiAgICBiYXNlLmluY2x1ZGUgV3JhcHBlclxuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBuYXRpdmU/KHZhbHVlKVxuICAgIGB2YWx1ZSA9PSBudWxsIHx8ICF2YWx1ZS4kJGNsYXNzYFxuICBlbmRcblxuICAjIFdyYXBzIGEgbmF0aXZlIEphdmFTY3JpcHQgd2l0aCBgTmF0aXZlOjpPYmplY3QubmV3YFxuICAjXG4gICMgQHJldHVybiBbTmF0aXZlOjpPYmplY3RdIFRoZSB3cmFwcGVkIG9iamVjdCBpZiBpdCBpcyBuYXRpdmVcbiAgIyBAcmV0dXJuIFtuaWxdIGZvciBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICMgQHJldHVybiBbb2JqXSBUaGUgb2JqZWN0IGl0c2VsZiBpZiBpdCdzIG5vdCBuYXRpdmVcbiAgZGVmIE5hdGl2ZShvYmopXG4gICAgaWYgYCN7b2JqfSA9PSBudWxsYFxuICAgICAgbmlsXG4gICAgZWxzaWYgbmF0aXZlPyhvYmopXG4gICAgICBOYXRpdmU6Ok9iamVjdC5uZXcob2JqKVxuICAgIGVsc2lmIG9iai5pc19hPyhBcnJheSlcbiAgICAgIG9iai5tYXAgZG8gfG98XG4gICAgICAgIE5hdGl2ZShvKVxuICAgICAgZW5kXG4gICAgZWxzaWYgb2JqLmlzX2E/KFByb2MpXG4gICAgICBwcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgICBOYXRpdmUob2JqLmNhbGwoKmFyZ3MsICZibG9jaykpXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBvYmpcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgX0FycmF5IEFycmF5XG5cbiAgIyBXcmFwcyBhcnJheS1saWtlIEphdmFTY3JpcHQgb2JqZWN0cyBpbiBOYXRpdmU6OkFycmF5XG4gIGRlZiBBcnJheShvYmplY3QsICphcmdzLCAmYmxvY2spXG4gICAgaWYgbmF0aXZlPyhvYmplY3QpXG4gICAgICByZXR1cm4gTmF0aXZlOjpBcnJheS5uZXcob2JqZWN0LCAqYXJncywgJmJsb2NrKS50b19hXG4gICAgZW5kXG4gICAgX0FycmF5KG9iamVjdClcbiAgZW5kXG5lbmRcblxuY2xhc3MgTmF0aXZlOjpPYmplY3QgPCBCYXNpY09iamVjdFxuICBpbmNsdWRlIDo6TmF0aXZlOjpXcmFwcGVyXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGAje0BuYXRpdmV9ID09PSAjezo6TmF0aXZlLnRyeV9jb252ZXJ0KG90aGVyKX1gXG4gIGVuZFxuXG4gIGRlZiBoYXNfa2V5PyhuYW1lKVxuICAgIGBPcGFsLmhhc093blByb3BlcnR5LmNhbGwoI3tAbmF0aXZlfSwgI3tuYW1lfSlgXG4gIGVuZFxuXG4gIGFsaWFzIGtleT8gaGFzX2tleT9cbiAgYWxpYXMgaW5jbHVkZT8gaGFzX2tleT9cbiAgYWxpYXMgbWVtYmVyPyBoYXNfa2V5P1xuXG4gIGRlZiBlYWNoKCphcmdzKVxuICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiAje0BuYXRpdmV9KSB7XG4gICAgICAgICAgI3t5aWVsZCBga2V5YCwgYCN7QG5hdGl2ZX1ba2V5XWB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZlxuICAgIGVsc2VcbiAgICAgIG1ldGhvZF9taXNzaW5nKDplYWNoLCAqYXJncylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIFtdKGtleSlcbiAgICAleHtcbiAgICAgIHZhciBwcm9wID0gI3tAbmF0aXZlfVtrZXldO1xuXG4gICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAjezo6TmF0aXZlLmNhbGwoQG5hdGl2ZSwga2V5KX1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0oa2V5LCB2YWx1ZSlcbiAgICBuYXRpdmUgPSA6Ok5hdGl2ZS50cnlfY29udmVydCh2YWx1ZSlcblxuICAgIGlmIGAje25hdGl2ZX0gPT09IG5pbGBcbiAgICAgIGAje0BuYXRpdmV9W2tleV0gPSAje3ZhbHVlfWBcbiAgICBlbHNlXG4gICAgICBgI3tAbmF0aXZlfVtrZXldID0gI3tuYXRpdmV9YFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbWVyZ2UhKG90aGVyKVxuICAgICV4e1xuICAgICAgb3RoZXIgPSAjezo6TmF0aXZlLmNvbnZlcnQob3RoZXIpfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvdGhlcikge1xuICAgICAgICAje0BuYXRpdmV9W3Byb3BdID0gb3RoZXJbcHJvcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90bz8obmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICA6Oktlcm5lbC5pbnN0YW5jZV9tZXRob2QoOnJlc3BvbmRfdG8/KS5iaW5kKHNlbGYpLmNhbGwobmFtZSwgaW5jbHVkZV9hbGwpXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG5hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgYE9wYWwuaGFzT3duUHJvcGVydHkuY2FsbCgje0BuYXRpdmV9LCAje25hbWV9KWBcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG1pZCwgKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChtaWQuY2hhckF0KG1pZC5sZW5ndGggLSAxKSA9PT0gJz0nKSB7XG4gICAgICAgIHJldHVybiAje3NlbGZbbWlkLnNsaWNlKDAsIG1pZC5sZW5ndGggLSAxKV0gPSBhcmdzWzBdfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3s6Ok5hdGl2ZS5jYWxsKEBuYXRpdmUsIG1pZCwgKmFyZ3MsICZibG9jayl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5pbD9cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgaXNfYT8oa2xhc3MpXG4gICAgYE9wYWwuaXNfYShzZWxmLCBrbGFzcylgXG4gIGVuZFxuXG4gIGFsaWFzIGtpbmRfb2Y/IGlzX2E/XG5cbiAgZGVmIGluc3RhbmNlX29mPyhrbGFzcylcbiAgICBgc2VsZi4kJGNsYXNzID09PSBrbGFzc2BcbiAgZW5kXG5cbiAgZGVmIGNsYXNzXG4gICAgYHNlbGYuJCRjbGFzc2BcbiAgZW5kXG5cbiAgZGVmIHRvX2Eob3B0aW9ucyA9IHt9LCAmYmxvY2spXG4gICAgOjpOYXRpdmU6OkFycmF5Lm5ldyhAbmF0aXZlLCBvcHRpb25zLCAmYmxvY2spLnRvX2FcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8TmF0aXZlOiN7YFN0cmluZygje0BuYXRpdmV9KWB9PlwiXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5hdGl2ZTo6QXJyYXlcbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcbiAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgZGVmIGluaXRpYWxpemUobmF0aXZlLCBvcHRpb25zID0ge30sICZibG9jaylcbiAgICBzdXBlcihuYXRpdmUpXG5cbiAgICBAZ2V0ICAgID0gb3B0aW9uc1s6Z2V0XSB8fCBvcHRpb25zWzphY2Nlc3NdXG4gICAgQG5hbWVkICA9IG9wdGlvbnNbOm5hbWVkXVxuICAgIEBzZXQgICAgPSBvcHRpb25zWzpzZXRdIHx8IG9wdGlvbnNbOmFjY2Vzc11cbiAgICBAbGVuZ3RoID0gb3B0aW9uc1s6bGVuZ3RoXSB8fCA6bGVuZ3RoXG4gICAgQGJsb2NrICA9IGJsb2NrXG5cbiAgICBpZiBgI3tsZW5ndGh9ID09IG51bGxgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gbGVuZ3RoIGZvdW5kIG9uIHRoZSBhcnJheS1saWtlIG9iamVjdCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICN7bGVuZ3RofTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCAje3NlbGZbYGlgXX0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIFtdKGluZGV4KVxuICAgIHJlc3VsdCA9IGNhc2UgaW5kZXhcbiAgICAgICAgICAgICB3aGVuIFN0cmluZywgU3ltYm9sXG4gICAgICAgICAgICAgICBAbmFtZWQgPyBgI3tAbmF0aXZlfVsje0BuYW1lZH1dKCN7aW5kZXh9KWAgOiBgI3tAbmF0aXZlfVsje2luZGV4fV1gXG4gICAgICAgICAgICAgd2hlbiBJbnRlZ2VyXG4gICAgICAgICAgICAgICBAZ2V0ID8gYCN7QG5hdGl2ZX1bI3tAZ2V0fV0oI3tpbmRleH0pYCA6IGAje0BuYXRpdmV9WyN7aW5kZXh9XWBcbiAgICAgICAgICAgICBlbmRcblxuICAgIGlmIHJlc3VsdFxuICAgICAgaWYgQGJsb2NrXG4gICAgICAgIEBibG9jay5jYWxsKHJlc3VsdClcbiAgICAgIGVsc2VcbiAgICAgICAgTmF0aXZlKHJlc3VsdClcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgW109KGluZGV4LCB2YWx1ZSlcbiAgICBpZiBAc2V0XG4gICAgICBgI3tAbmF0aXZlfVsje0BzZXR9XSgje2luZGV4fSwgI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9KWBcbiAgICBlbHNlXG4gICAgICBgI3tAbmF0aXZlfVsje2luZGV4fV0gPSAje05hdGl2ZS5jb252ZXJ0KHZhbHVlKX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBsYXN0KGNvdW50ID0gbmlsKVxuICAgIGlmIGNvdW50XG4gICAgICBpbmRleCAgPSBsZW5ndGggLSAxXG4gICAgICByZXN1bHQgPSBbXVxuXG4gICAgICB3aGlsZSBpbmRleCA+PSAwXG4gICAgICAgIHJlc3VsdCA8PCBzZWxmW2luZGV4XVxuICAgICAgICBpbmRleCAgLT0gMVxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdFxuICAgIGVsc2VcbiAgICAgIHNlbGZbbGVuZ3RoIC0gMV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGAje0BuYXRpdmV9WyN7QGxlbmd0aH1dYFxuICBlbmRcblxuICBhbGlhcyB0b19hcnkgdG9fYVxuXG4gIGRlZiBpbnNwZWN0XG4gICAgdG9fYS5pbnNwZWN0XG4gIGVuZFxuZW5kXG5cbmNsYXNzIE51bWVyaWNcbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBQcm9jXG4gICMgQHJldHVybiBpdHNlbGYgKGFuIGluc3RhbmNlIG9mIGBGdW5jdGlvbmApXG4gIGRlZiB0b19uXG4gICAgc2VsZlxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHJpbmdcbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBSZWdleHBcbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBNYXRjaERhdGFcbiAgIyBAcmV0dXJuIHRoZSBhcnJheSBvZiBtYXRjaGVzXG4gIGRlZiB0b19uXG4gICAgQG1hdGNoZXNcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RydWN0XG4gICMgQHJldHVybiBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhlIG1lbWJlcnMgYXMga2V5cyBhbmQgdGhlaXJcbiAgIyB2YWx1ZXMgYXMgdmFsdWVzLlxuICBkZWYgdG9fblxuICAgIHJlc3VsdCA9IGB7fWBcblxuICAgIGVhY2hfcGFpciBkbyB8bmFtZSwgdmFsdWV8XG4gICAgICBgI3tyZXN1bHR9WyN7bmFtZX1dID0gI3tOYXRpdmUudHJ5X2NvbnZlcnQodmFsdWUsIHZhbHVlKX1gXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5lbmRcblxuY2xhc3MgQXJyYXlcbiAgIyBSZXR1bnMgYSBjb3B5IG9mIGl0c2VsZiB0cnlpbmcgdG8gY2FsbCAjdG9fbiBvbiBlYWNoIG1lbWJlci5cbiAgZGVmIHRvX25cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IHNlbGZbaV07XG5cbiAgICAgICAgcmVzdWx0LnB1c2goI3tOYXRpdmUudHJ5X2NvbnZlcnQoYG9iamAsIGBvYmpgKX0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5lbmRcblxuY2xhc3MgQm9vbGVhblxuICAjIEByZXR1cm4gdGhlIGludGVybmFsIEphdmFTY3JpcHQgdmFsdWUgKHdpdGggYHZhbHVlT2ZgKS5cbiAgZGVmIHRvX25cbiAgICBgc2VsZi52YWx1ZU9mKClgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFRpbWVcbiAgIyBAcmV0dXJuIGl0c2VsZiAoYW4gaW5zdGFuY2Ugb2YgYERhdGVgKS5cbiAgZGVmIHRvX25cbiAgICBzZWxmXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5pbENsYXNzXG4gICMgQHJldHVybiB0aGUgY29ycmVzcG9uZGluZyBKYXZhU2NyaXB0IHZhbHVlIChgbnVsbGApLlxuICBkZWYgdG9fblxuICAgIGBudWxsYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBIYXNoXG4gIGFsaWFzIF9pbml0aWFsaXplIGluaXRpYWxpemVcblxuICBkZWYgaW5pdGlhbGl6ZShkZWZhdWx0cyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKGRlZmF1bHRzICE9IG51bGwgJiZcbiAgICAgICAgICAgKGRlZmF1bHRzLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICBkZWZhdWx0cy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSkge1xuICAgICAgICB2YXIgc21hcCA9IHNlbGYuJCRzbWFwLFxuICAgICAgICAgICAga2V5cyA9IHNlbGYuJCRrZXlzLFxuICAgICAgICAgICAga2V5LCB2YWx1ZTtcblxuICAgICAgICBmb3IgKGtleSBpbiBkZWZhdWx0cykge1xuICAgICAgICAgIHZhbHVlID0gZGVmYXVsdHNba2V5XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgICAgKHZhbHVlLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCkpIHtcbiAgICAgICAgICAgIHNtYXBba2V5XSA9ICN7SGFzaC5uZXcoYHZhbHVlYCl9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICBpZiAoaXRlbSAmJlxuICAgICAgICAgICAgICAgICAgIChpdGVtLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY29uc3RydWN0b3IgPT09IE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gI3tIYXNoLm5ldyhgaXRlbWApfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiAje05hdGl2ZShgaXRlbWApfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc21hcFtrZXldID0gdmFsdWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc21hcFtrZXldID0gI3tOYXRpdmUoYHZhbHVlYCl9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje19pbml0aWFsaXplKGRlZmF1bHRzLCAmYmxvY2spfTtcbiAgICB9XG4gIGVuZFxuXG4gICMgQHJldHVybiBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBidXQgY2FsbGluZyAjdG9fbiBvblxuICAjIGFsbCB2YWx1ZXMuXG4gIGRlZiB0b19uXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgICAga2V5cyA9IHNlbGYuJCRrZXlzLFxuICAgICAgICAgIHNtYXAgPSBzZWxmLiQkc21hcCxcbiAgICAgICAgICBrZXksIHZhbHVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0W2tleV0gPSAje05hdGl2ZS50cnlfY29udmVydChgdmFsdWVgLCBgdmFsdWVgKX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcbmVuZFxuXG5jbGFzcyBNb2R1bGVcbiAgIyBFeHBvc2VzIHRoZSBjdXJyZW50IG1vZHVsZSBhcyBhIHByb3BlcnR5IG9mXG4gICMgdGhlIGdsb2JhbCBvYmplY3QgKGUuZy4gYHdpbmRvd2ApLlxuICBkZWYgbmF0aXZlX21vZHVsZVxuICAgIGBPcGFsLmdsb2JhbFsje25hbWV9XSA9ICN7c2VsZn1gXG4gIGVuZFxuZW5kXG5cbmNsYXNzIENsYXNzXG4gIGRlZiBuYXRpdmVfYWxpYXMobmV3X2pzaWQsIGV4aXN0aW5nX21pZClcbiAgICAleHtcbiAgICAgIHZhciBhbGlhc2VkID0gI3tzZWxmfS5wcm90b3R5cGVbJyQnICsgI3tleGlzdGluZ19taWR9XTtcbiAgICAgIGlmICghYWxpYXNlZCkge1xuICAgICAgICAje3JhaXNlIE5hbWVFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje2V4aXN0aW5nX21pZH0nIGZvciBjbGFzcyBgI3tpbnNwZWN0fSdcIiwgZXhpc3RpbmdfbWlkKX07XG4gICAgICB9XG4gICAgICAje3NlbGZ9LnByb3RvdHlwZVsje25ld19qc2lkfV0gPSBhbGlhc2VkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5hdGl2ZV9jbGFzc1xuICAgIG5hdGl2ZV9tb2R1bGVcbiAgICBgc2VsZltcIm5ld1wiXSA9IHNlbGYuJG5ld2BcbiAgZW5kXG5lbmRcblxuIyBFeHBvc2VzIHRoZSBnbG9iYWwgdmFsdWUgKHdvdWxkIGJlIGB3aW5kb3dgIGluc2lkZSBhIGJyb3dzZXIpXG4kJCA9ICRnbG9iYWwgPSBOYXRpdmUoYE9wYWwuZ2xvYmFsYClcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJpc19hPyIsInNlbGYiLCJvYmplY3QiLCJ0cnlfY29udmVydCIsImtsYXNzIiwibmF0aXZlPyIsInZhbHVlIiwicmVzcG9uZF90bz8iLCJ0b19uIiwiZGVmYXVsdCQiLCJjb252ZXJ0IiwicmFpc2UiLCJpbnNwZWN0IiwiY2FsbCIsIm9iaiIsImtleSIsIk5hdGl2ZSIsInByb2MiLCJibG9jayIsIm1hcCEiLCJhcmdzIiwiYXJnIiwiaW5zdGFuY2UiLCJhbGlhc19uYXRpdmUiLCJuZXckIiwib2xkIiwiZW5kX3dpdGg/IiwiZGVmaW5lX21ldGhvZCIsIkBuYXRpdmUiLCJbXSIsIjAiLCItMiIsImFzIiwibmV3IiwibmF0aXZlX3JlYWRlciIsImVhY2giLCJuYW1lcyIsIm5hbWUiLCJuYXRpdmVfd3JpdGVyIiwibmF0aXZlX2FjY2Vzc29yIiwiaW5pdGlhbGl6ZSIsIm5hdGl2ZSQiLCJpbmNsdWRlZCIsImV4dGVuZCIsIndhcm4iLCJiYXNlIiwiaW5jbHVkZSIsIm1hcCIsIm8iLCJBcnJheSIsInRvX2EiLCJfQXJyYXkiLCJjbGFzcyIsIj09Iiwib3RoZXIiLCJoYXNfa2V5PyIsImJsb2NrX2dpdmVuPyIsIm1ldGhvZF9taXNzaW5nIiwiW109IiwibWVyZ2UhIiwiaW5zdGFuY2VfbWV0aG9kIiwiYmluZCIsImluY2x1ZGVfYWxsIiwicmVzcG9uZF90b19taXNzaW5nPyIsIiR3cml0ZXIiLCJtaWQiLCJzbGljZSIsIi0iLCJsZW5ndGgiLCIxIiwibmlsPyIsImluc3RhbmNlX29mPyIsIm9wdGlvbnMiLCJAZ2V0IiwiJHJldF9vcl8xIiwiQG5hbWVkIiwiQHNldCIsIiRyZXRfb3JfMiIsIkBsZW5ndGgiLCIkcmV0X29yXzMiLCJAYmxvY2siLCJlbnVtX2ZvciIsInJlc3VsdCIsImluZGV4IiwibGFzdCIsImNvdW50IiwiPj0iLCI8PCIsIkBtYXRjaGVzIiwiZWFjaF9wYWlyIiwiX2luaXRpYWxpemUiLCJkZWZhdWx0cyIsIm5hdGl2ZV9tb2R1bGUiLCJuYXRpdmVfYWxpYXMiLCJleGlzdGluZ19taWQiLCJuZXdfanNpZCIsIm5hdGl2ZV9jbGFzcyIsIiQkIiwiJGdsb2JhbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBaUJBLEVBQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFBQyxVQUFJQyxJQUFKRCxZQUFBQSxzQkFBQUEsU0FBZSxNQUFELEVBQVMsS0FBdkJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0EsZUFB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Q0FBQUEsb0NBQUFBLENBQUE7QUFBQSxJQVVBLE9BQUFHLENBQUFBLGdDQUFBQSx5QkFBQUEsd0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLFVBQUFKLGVBQUFBLENBQUFBLENBQUE7QUFBQSxNQUNBLE9BQUMsdUJBQUQsQ0FEQTtBQURGSSxJQUFBQSxDQUFBQSxvQ0FBQUEsQ0FBQUEsd0JBVkE7QUFERjVDLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBamxCQTtBQUFBLEVBbW1CQSxPQUFBNkMsQ0FBQUEsV0FBS0MsQ0FBQUEsb0JBQVVsRixRQUFBQSxDQUFRLFdBQVJBLENBQVZrRixDQUFMRCxDQW5tQkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTkzNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vY29uc29sZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICduYXRpdmUnXG5cbiMgTWFuaXB1bGF0ZSB0aGUgYnJvd3NlciBjb25zb2xlLlxuI1xuIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9jb25zb2xlXG5jbGFzcyBDb25zb2xlXG4gIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgIyBDbGVhciB0aGUgY29uc29sZS5cbiAgZGVmIGNsZWFyXG4gICAgYCN7QG5hdGl2ZX0uY2xlYXIoKWBcbiAgZW5kXG5cbiAgIyBQcmludCBhIHN0YWNrdHJhY2UgZnJvbSB0aGUgY2FsbCBzaXRlLlxuICBkZWYgdHJhY2VcbiAgICBgI3tAbmF0aXZlfS50cmFjZSgpYFxuICBlbmRcblxuICAjIExvZyB0aGUgcGFzc2VkIG9iamVjdHMgYmFzZWQgb24gYW4gb3B0aW9uYWwgaW5pdGlhbCBmb3JtYXQuXG4gIGRlZiBsb2coKmFyZ3MpXG4gICAgYCN7QG5hdGl2ZX0ubG9nLmFwcGx5KCN7QG5hdGl2ZX0sIGFyZ3MpYFxuICBlbmRcblxuICAjIExvZyB0aGUgcGFzc2VkIG9iamVjdHMgYmFzZWQgb24gYW4gb3B0aW9uYWwgaW5pdGlhbCBmb3JtYXQgYXMgaW5mb3JtYXRpb25hbFxuICAjIGxvZy5cbiAgZGVmIGluZm8oKmFyZ3MpXG4gICAgYCN7QG5hdGl2ZX0uaW5mby5hcHBseSgje0BuYXRpdmV9LCBhcmdzKWBcbiAgZW5kXG5cbiAgIyBMb2cgdGhlIHBhc3NlZCBvYmplY3RzIGJhc2VkIG9uIGFuIG9wdGlvbmFsIGluaXRpYWwgZm9ybWF0IGFzIHdhcm5pbmcuXG4gIGRlZiB3YXJuKCphcmdzKVxuICAgIGAje0BuYXRpdmV9Lndhcm4uYXBwbHkoI3tAbmF0aXZlfSwgYXJncylgXG4gIGVuZFxuXG4gICMgTG9nIHRoZSBwYXNzZWQgb2JqZWN0cyBiYXNlZCBvbiBhbiBvcHRpb25hbCBpbml0aWFsIGZvcm1hdCBhcyBlcnJvci5cbiAgZGVmIGVycm9yKCphcmdzKVxuICAgIGAje0BuYXRpdmV9LmVycm9yLmFwcGx5KCN7QG5hdGl2ZX0sIGFyZ3MpYFxuICBlbmRcblxuICAjIFRpbWUgdGhlIGdpdmVuIGJsb2NrIHdpdGggdGhlIGdpdmVuIGxhYmVsLlxuICBkZWYgdGltZShsYWJlbCwgJmJsb2NrKVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICBgI3tAbmF0aXZlfS50aW1lKGxhYmVsKWBcblxuICAgIGJlZ2luXG4gICAgICBpZiBibG9jay5hcml0eSA9PSAwXG4gICAgICAgIGluc3RhbmNlX2V4ZWMoJmJsb2NrKVxuICAgICAgZWxzZVxuICAgICAgICB5aWVsZChzZWxmKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBgI3tAbmF0aXZlfS50aW1lRW5kKClgXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgR3JvdXAgdGhlIGdpdmVuIGJsb2NrLlxuICBkZWYgZ3JvdXAoKmFyZ3MsICZibG9jaylcbiAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja1xuXG4gICAgYCN7QG5hdGl2ZX0uZ3JvdXAuYXBwbHkoI3tAbmF0aXZlfSwgYXJncylgXG5cbiAgICBiZWdpblxuICAgICAgaWYgYmxvY2suYXJpdHkgPT0gMFxuICAgICAgICBpbnN0YW5jZV9leGVjKCZibG9jaylcbiAgICAgIGVsc2VcbiAgICAgICAgeWllbGQoc2VsZilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgYCN7QG5hdGl2ZX0uZ3JvdXBFbmQoKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBHcm91cCB0aGUgZ2l2ZW4gYmxvY2sgYnV0IGNvbGxhcHNlIGl0LlxuICBkZWYgZ3JvdXAhKCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGAje0BuYXRpdmV9Lmdyb3VwQ29sbGFwc2VkLmFwcGx5KCN7QG5hdGl2ZX0sIGFyZ3MpYFxuXG4gICAgYmVnaW5cbiAgICAgIGlmIGJsb2NrLmFyaXR5ID09IDBcbiAgICAgICAgaW5zdGFuY2VfZXhlYygmYmxvY2spXG4gICAgICBlbHNlXG4gICAgICAgIHlpZWxkKHNlbGYpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGAje0BuYXRpdmV9Lmdyb3VwRW5kKClgXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmlmIGRlZmluZWQ/KGBPcGFsLmdsb2JhbC5jb25zb2xlYClcbiAgJGNvbnNvbGUgPSBDb25zb2xlLm5ldyhgT3BhbC5nbG9iYWwuY29uc29sZWApXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwiY2xlYXIiLCJAbmF0aXZlIiwidHJhY2UiLCJsb2ciLCJpbmZvIiwid2FybiIsImVycm9yIiwidGltZSIsImJsb2NrIiwicmFpc2UiLCJhcml0eSIsIj09IiwiMCIsImluc3RhbmNlX2V4ZWMiLCJzZWxmIiwiZ3JvdXAiLCJncm91cCEiLCJibG9ja19naXZlbj8iLCIkY29uc29sZSIsIm5ldyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFB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QUgsQ0FBQTtBQUFBLElBQ0UsT0FBQW9CLENBQUFBLGlCQUFXLHVCQUFBQyxLQUFBQSxDQUFhLG1CQUFiQSxDQUFYRDtBQURGLEVBQUE7QUFBQTtBQUFBLEVBQUEsQ0EzRkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjA5NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImR4b3BhbC9jb25zdGFudHMvY29sb3JzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBEWE9wYWxcbiAgbW9kdWxlIENvbnN0YW50c1xuICAgICMgUHJlLWRlZmluZWQgQVJHQiBjb2xvcnNcbiAgICBtb2R1bGUgQ29sb3JzXG4gICAgICBDX0JMQUNLICAgPSBbMjU1LCAwLCAwLCAwXVxuICAgICAgQ19SRUQgICAgID0gWzI1NSwgMjU1LCAwLCAwXVxuICAgICAgQ19HUkVFTiAgID0gWzI1NSwgMCwgMjU1LCAwXVxuICAgICAgQ19CTFVFICAgID0gWzI1NSwgMCwgMCwgMjU1XVxuICAgICAgQ19ZRUxMT1cgID0gWzI1NSwgMjU1LCAyNTUsIDBdXG4gICAgICBDX0NZQU4gICAgPSBbMjU1LCAwLCAyNTUsIDI1NV1cbiAgICAgIENfTUFHRU5UQSA9IFsyNTUsIDI1NSwgMCwgMjU1XVxuICAgICAgQ19XSElURSAgID0gWzI1NSwgMjU1LCAyNTUsIDI1NV1cbiAgICAgIENfREVGQVVMVCA9IFswLCAwLCAwLCAwXVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsIjI1NSIsIjAiXSwibWFwcGluZ3MiOiI7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsT0FBQUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUVFLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFDRSxRQUFBLHVDQUFZLENBQUNDLEdBQUQsRUFBTUMsQ0FBTixFQUFTQSxDQUFULEVBQVlBLENBQVosQ0FBWixDQUFBO0FBQUEsUUFDQSxxQ0FBWSxDQUFDRCxHQUFELEVBQU1BLEdBQU4sRUFBV0MsQ0FBWCxFQUFjQSxDQUFkLENBQVosQ0FEQTtBQUFBLFFBRUEsdUNBQVksQ0FBQ0QsR0FBRCxFQUFNQyxDQUFOLEVBQVNELEdBQVQsRUFBY0MsQ0FBZCxDQUFaLENBRkE7QUFBQSxRQUdBLHNDQUFZLENBQUNELEdBQUQsRUFBTUMsQ0FBTixFQUFTQSxDQUFULEVBQVlELEdBQVosQ0FBWixDQUhBO0FBQUEsUUFJQSx3Q0FBWSxDQUFDQSxHQUFELEVBQU1BLEdBQU4sRUFBV0EsR0FBWCxFQUFnQkMsQ0FBaEIsQ0FBWixDQUpBO0FBQUEsUUFLQSxzQ0FBWSxDQUFDRCxHQUFELEVBQU1DLENBQU4sRUFBU0QsR0FBVCxFQUFjQSxHQUFkLENBQVosQ0FMQTtBQUFBLFFBTUEseUNBQVksQ0FBQ0EsR0FBRCxFQUFNQSxHQUFOLEVBQVdDLENBQVgsRUFBY0QsR0FBZCxDQUFaLENBTkE7QUFBQSxRQU9BLHVDQUFZLENBQUNBLEdBQUQsRUFBTUEsR0FBTixFQUFXQSxHQUFYLEVBQWdCQSxHQUFoQixDQUFaLENBUEE7QUFBQSxRQVFBLE9BQUEseUNBQVksQ0FBQ0MsQ0FBRCxFQUFJQSxDQUFKLEVBQU9BLENBQVAsRUFBVUEsQ0FBVixDQUFaLENBUkE7QUFERkYsTUFBQUEsR0FBQUEsV0FBQUE7QUFGRkEsSUFBQUEsR0FBQUEsV0FBQUE7QUFERkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjEyOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImR4b3BhbC9mb250LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBEWE9wYWxcbiAgIyBSZXByZXNlbnRzIGEgZm9udFxuICAjIFVzZWQgYnkgV2luZG93LmRyYXdfZm9udCwgZXRjLlxuICBjbGFzcyBGb250XG4gICAgZGVmIHNlbGYuZGVmYXVsdDsgQEBkZWZhdWx0IHx8PSBGb250Lm5ldygyNCk7IGVuZFxuICAgIGRlZiBzZWxmLmRlZmF1bHQ9KGYpOyBAQGRlZmF1bHQgPSBmOyBlbmRcblxuICAgIGRlZiBpbml0aWFsaXplKHNpemUsIGZvbnRuYW1lPW5pbCwgb3B0aW9uPXt9KVxuICAgICAgQHNpemUgPSBzaXplXG4gICAgICBAb3JpZ19mb250bmFtZSA9IGZvbnRuYW1lXG4gICAgICBAZm9udG5hbWUgPSBmb250bmFtZSB8fCBcInNhbnMtc2VyaWZcIlxuICAgIGVuZFxuXG4gICAgZGVmIHNpemU7IEBzaXplOyBlbmRcbiAgICBkZWYgZm9udG5hbWU7IEBvcmlnX2ZvbnRuYW1lOyBlbmRcblxuICAgIGRlZiBnZXRfd2lkdGgoc3RyaW5nKVxuICAgICAgY2FudmFzID0gTmF0aXZlKGBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHhvcGFsLWNhbnZhcycpYClcbiAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGhcbiAgICBlbmRcblxuICAgICMgUmV0dXJuIGEgc3RyaW5nIGxpa2UgXCI0OHB4IHNlcmlmXCJcbiAgICBkZWYgX3NwZWNfc3RyXG4gICAgICBcIiN7QHNpemV9cHggI3tAZm9udG5hbWV9XCJcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsImRlZmF1bHQiLCJzZWxmIiwiQEBkZWZhdWx0IiwiJHJldF9vcl8xIiwibmV3IiwiMjQiLCJkZWZhdWx0PSIsImYiLCJpbml0aWFsaXplIiwiQHNpemUiLCJzaXplIiwiQG9yaWdfZm9udG5hbWUiLCJmb250bmFtZSIsIkBmb250bmFtZSIsIiRyZXRfb3JfMiIsImdldF93aWR0aCIsImNhbnZhcyIsIk5hdGl2ZSIsImdldENvbnRleHQiLCJtZWFzdXJlVGV4dCIsInN0cmluZyIsIndpZHRoIiwiX3NwZWNfc3RyIl0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFHRSxPQUFBQztBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsTUFBQUMsVUFBSUMsSUFBSkQsY0FBQUEsa0JBQUFBLFNBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUFrQixPQUFBRSw4Q0FMdEIsYUFBQSxJQUFBLFFBQUEsQ0FBQSxtREFBQSwwQkFBQSxDQUFBO0FBQUE7QUFBQSxVQUFBLElBQUEsUUFBQUMsQ0FBQUEsWUFLc0JELG9EQUx0QkMsQ0FBQSxDQUFBO0FBQUEsWUFBQSxPQUFBO0FBQUEsVUFBQTtBQUFBLFlBS29DLE9BQUEsb0JBQUFDLEtBQUFBLENBQVNDLEVBQVREO0FBTHBDLFVBQUEsQ0FBQTtBQUFBLFFBQUE7QUFBQSxVQUtvQyxPQUFBLG9CQUFBQSxLQUFBQSxDQUFTQyxFQUFURDtBQUxwQyxRQUFBLENBQUEsa0JBS3NCRjtBQUFsQkYsTUFBQUEsQ0FBQUEsNkJBQUFBLENBQUE7QUFBQSxNQUNBTSxVQUFJTCxJQUFKSyxlQUFBQSxxQkFBQUEsU0FBa0IsQ0FBbEJBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUFzQixPQUFBSiw4Q0FBWUssQ0FBWkw7QUFBdEJJLE1BQUFBLENBQUFBLGdDQUFBQSxDQURBO0FBQUE7QUFHQUUsTUFBQUEsOEJBQUFBLHFCQUFBQSxzQkFBZSxJQUFELEVBQU8sUUFBUCxFQUFxQixNQUFuQ0E7QUFBQUEsUUFBQUE7O0FBQUFBO0FBUko7QUFReUIsUUFBQTtBQUFBLFFBQUEsYUFBUyxHQUFUO0FBQUEsUUFBQSxDQVJ6QjtBQUFBO0FBUXVDLFFBQUE7QUFBQSxRQUFBLFdBQU8sWUFBQSxFQUFQO0FBQUEsUUFBQSxDQVJ2QztBQUFBLFFBU01DLFlBQVFDLElBVGQ7QUFBQSxRQVVNQyxxQkFBaUJDLFFBVnZCO0FBQUEsUUFXTSxPQUFBQyxDQUFBQSxnQkFBWSxhQUFBLElBQUEsUUFYbEJDLENBQUFBLFlBV2tCRixRQVhsQkUsQ0FXa0IsQ0FBQTtBQUFBLFVBWGxCLE9BQUE7QUFXa0IsUUFBQTtBQUFBLFVBQVksT0FBQTtBQUFaLFFBQUEsQ0FBQSxrQkFBWkQsQ0FYTjtBQVFJTCxNQUFBQSxDQUFBQSxpQ0FBQUEsQ0FIQTtBQUFBO0FBU0FFLE1BQUFBLHdCQUFBQSxlQUFBQSxnQkFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQVUsT0FBQUQ7QUFBVkMsTUFBQUEsQ0FBQUEsMEJBQUFBLENBVEE7QUFBQTtBQVVBRSxNQUFBQSw0QkFBQUEsbUJBQUFBLG9CQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFBYyxPQUFBRDtBQUFkQyxNQUFBQSxDQUFBQSw4QkFBQUEsQ0FWQTtBQUFBO0FBWUFHLE1BQUFBLDZCQUFBQSxvQkFBQUEscUJBQWMsTUFBZEE7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsYUFBU0MsUUFBQUEsQ0FBUSx3Q0FBUkEsQ0FBVDtBQUFBLFFBQ0EsT0FBQUQsTUFBQUUsWUFBQUEsQ0FBa0IsSUFBbEJBLENBQUFDLGFBQUFBLENBQW9DQyxNQUFwQ0QsQ0FBQUUsT0FBQUEsQ0FBQUEsQ0FEQTtBQURGTixNQUFBQSxDQUFBQSwrQkFBQUEsQ0FaQTtBQUFBLE1Ba0JBLE9BQUFPLENBQUFBLDZCQUFBQSxvQkFBQUEscUJBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLE9BQUEsRUFBQSxHQUFBLENBQUdiLFNBQUgsQ0FBQSxHQUFBLEtBQUEsR0FBQSxDQUFjSSxhQUFkO0FBREZTLE1BQUFBLENBQUFBLCtCQUFBQSxDQUFBQSxxQkFsQkE7QUFERnZCLElBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBSEZELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjYyMTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJkeG9wYWwvaW5wdXQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIERYT3BhbFxuICBtb2R1bGUgSW5wdXRcbiAgICBtb2R1bGUgTW91c2VDb2Rlc1xuICAgICAgTV9MQlVUVE9OID0gMVxuICAgICAgTV9SQlVUVE9OID0gMlxuICAgICAgTV9NQlVUVE9OID0gNFxuICAgICAgIyBEWE9wYWwgZXh0ZW50aW9uXG4gICAgICBNXzRUSF9CVVRUT04gPSA4XG4gICAgICBNXzVUSF9CVVRUT04gPSAxNlxuICAgIGVuZFxuXG4gICAgZGVmIHNlbGYuX3ByZXNzaW5nX2tleXM7IEBAcHJlc3Npbmdfa2V5czsgZW5kXG5cbiAgICAjIEludGVybmFsIHNldHVwIGZvciBJbnB1dCBjbGFzc1xuICAgIGRlZiBzZWxmLl9pbml0KGNhbnZhcylcbiAgICAgIEBAdGljayA9IDBcbiAgICAgIEBAcHJlc3Npbmdfa2V5cyA9IGBuZXcgT2JqZWN0KClgXG4gICAgICBAQG1vdXNlX2luZm8gPSBge3g6IDAsIHk6IDB9YFxuICAgICAgQEBwcmVzc2luZ19tb3VzZV9idXR0b25zID0gYG5ldyBPYmplY3QoKWBcbiAgICAgIEBAdG91Y2hfaW5mbyA9IGB7eDogMCwgeTogMH1gXG4gICAgICBAQHByZXNzaW5nX3RvdWNoID0gYG5ldyBPYmplY3QoKWBcblxuICAgICAgQEBjYW52YXMgPSBjYW52YXNcbiAgICAgIHJlY3QgPSBgY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpYFxuICAgICAgQEBjYW52YXNfeCA9IGByZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXRgXG4gICAgICBAQGNhbnZhc195ID0gYHJlY3QudG9wICArIHdpbmRvdy5wYWdlWU9mZnNldGBcblxuICAgICAgc2VsZi5faW5pdF9tb3VzZV9ldmVudHNcbiAgICAgIHNlbGYuX2luaXRfdG91Y2hfZXZlbnRzXG4gICAgICBzZWxmLmtleWV2ZW50X3RhcmdldCA9IGB3aW5kb3dgIHVubGVzcyBJbnB1dC5rZXlldmVudF90YXJnZXRcbiAgICBlbmRcbiAgICBcbiAgICAjIENhbGxlZCBvbiBldmVyeSBmcmFtZSBmcm9tIFdpbmRvd1xuICAgIGRlZiBzZWxmLl9vbl90aWNrXG4gICAgICBAQHRpY2sgKz0gMVxuICAgICAgc2VsZi5fdXBkYXRlX3RvdWNoX2luZm9cbiAgICBlbmRcblxuICAgICMgUmV0dXJuIDEgaWYgJ3JpZ2h0JywgLTEgaWYgJ2xlZnQnXG4gICAgZGVmIHNlbGYueChwYWRfbnVtYmVyPTApXG4gICAgICByZXQgPSAwXG4gICAgICByZXQgKz0gMSBpZiBrZXlfZG93bj8oS19SSUdIVClcbiAgICAgIHJldCAtPSAxIGlmIGtleV9kb3duPyhLX0xFRlQpXG4gICAgICByZXRcbiAgICBlbmRcblxuICAgICMgUmV0dXJuIDEgaWYgJ2Rvd24nLCAtMSBpZiAndXAnXG4gICAgZGVmIHNlbGYueShwYWRfbnVtYmVyPTApXG4gICAgICByZXQgPSAwXG4gICAgICByZXQgKz0gMSBpZiBrZXlfZG93bj8oS19ET1dOKVxuICAgICAgcmV0IC09IDEgaWYga2V5X2Rvd24/KEtfVVApXG4gICAgICByZXRcbiAgICBlbmRcblxuICAgICNcbiAgICAjIEtleWJvYXJkXG4gICAgI1xuXG4gICAgIyBSZXR1cm4gdHJ1ZSBpZiB0aGUga2V5IGlzIGJlaW5nIHByZXNzZWRcbiAgICBkZWYgc2VsZi5rZXlfZG93bj8oY29kZSlcbiAgICAgIHJldHVybiBgI3tAQHByZXNzaW5nX2tleXN9W2NvZGVdID4gMGBcbiAgICBlbmRcblxuICAgICMgUmV0dXJuIHRydWUgaWYgdGhlIGtleSBpcyBqdXN0IHByZXNzZWRcbiAgICBkZWYgc2VsZi5rZXlfcHVzaD8oY29kZSlcbiAgICAgIHJldHVybiBgI3tAQHByZXNzaW5nX2tleXN9W2NvZGVdID09ICN7QEB0aWNrfS0xYFxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm4gdHJ1ZSBpZiB0aGUga2V5IGlzIGp1c3QgcmVsZWFzZWRcbiAgICBkZWYgc2VsZi5rZXlfcmVsZWFzZT8oY29kZSlcbiAgICAgIHJldHVybiBgI3tAQHByZXNzaW5nX2tleXN9W2NvZGVdID09IC0oI3tAQHRpY2t9LTEpYFxuICAgIGVuZFxuXG4gICAgIyAocHJpdmF0ZSkgSlMga2V5ZG93biBldmVudCBoYW5kbGVyXG4gICAgT05fS0VZRE9XTl8gPSAleHtcbiAgICAgIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgI3tJbnB1dC5fcHJlc3Npbmdfa2V5c31bZXYuY29kZV0gPSAje0BAdGlja307XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICAjIChwcml2YXRlKSBKUyBrZXl1cCBldmVudCBoYW5kbGVyXG4gICAgT05fS0VZVVBfID0gJXh7XG4gICAgICBmdW5jdGlvbihldil7XG4gICAgICAgICN7SW5wdXQuX3ByZXNzaW5nX2tleXN9W2V2LmNvZGVdID0gLSN7QEB0aWNrfTtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgICMgU2V0IERPTSBlbGVtZW50IHRvIHJlY2VpdmUga2V5ZG93bi9rZXl1cCBldmVudFxuICAgICNcbiAgICAjIEJ5IGRlZmF1bHQsIGB3aW5kb3dgIGlzIHNldCB0byB0aGlzIChpLmUuIGFsbCBrZXkgZXZlbnRzIGFyZVxuICAgICMgc3RvbGVuIGJ5IERYT3BhbC4pIElmIGNhbnZhcyBlbGVtZW50IGlzIHNldCB0byB0aGlzLCBvbmx5IGtleSBldmVudHNcbiAgICAjIGhhcHBlbmQgb24gY2FudmFzIGFyZSBwcm9jZXNzZWQgYnkgRFhPcGFsLlxuICAgIGRlZiBzZWxmLmtleWV2ZW50X3RhcmdldD0odGFyZ2V0KVxuICAgICAgaWYga2V5ZXZlbnRfdGFyZ2V0XG4gICAgICAgICV4e1xuICAgICAgICAgICN7QEBrZXlldmVudF90YXJnZXR9LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAje09OX0tFWURPV05ffSk7XG4gICAgICAgICAgI3tAQGtleWV2ZW50X3RhcmdldH0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAje09OX0tFWVVQX30pO1xuICAgICAgICB9XG4gICAgICBlbmRcbiAgICAgIEBAa2V5ZXZlbnRfdGFyZ2V0ID0gdGFyZ2V0XG4gICAgICAleHtcbiAgICAgICAgaWYgKCN7QEBrZXlldmVudF90YXJnZXR9LnRhZ05hbWUgPT0gXCJDQU5WQVNcIikge1xuICAgICAgICAgICN7QEBrZXlldmVudF90YXJnZXR9LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcbiAgICAgICAgfVxuICAgICAgICAje0BAa2V5ZXZlbnRfdGFyZ2V0fS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgI3tPTl9LRVlET1dOX30pO1xuICAgICAgICAje0BAa2V5ZXZlbnRfdGFyZ2V0fS5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsICN7T05fS0VZVVBffSk7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICAjIFJldHVybiBET00gZWxlbWVudCBzZXQgYnkgYGtleWV2ZW50X3RhcmdldD1gXG4gICAgZGVmIHNlbGYua2V5ZXZlbnRfdGFyZ2V0XG4gICAgICByZXR1cm4gbmlsIHVubGVzcyBjbGFzc192YXJpYWJsZV9kZWZpbmVkPyg6QEBrZXlldmVudF90YXJnZXQpXG4gICAgICBAQGtleWV2ZW50X3RhcmdldFxuICAgIGVuZFxuXG4gICAgI1xuICAgICMgTW91c2VcbiAgICAjXG5cbiAgICAjIChpbnRlcm5hbCkgaW5pdGlhbGl6ZSBtb3VzZSBldmVudHNcbiAgICBkZWYgc2VsZi5faW5pdF9tb3VzZV9ldmVudHNcbiAgICAgICV4e1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbihldil7XG4gICAgICAgICAgI3tAQG1vdXNlX2luZm99LnggPSBldi5wYWdlWCAtICN7QEBjYW52YXNfeH07XG4gICAgICAgICAgI3tAQG1vdXNlX2luZm99LnkgPSBldi5wYWdlWSAtICN7QEBjYW52YXNfeX07XG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihldil7XG4gICAgICAgICAgI3tAQG1vdXNlX2luZm99LnggPSBldi5wYWdlWCAtICN7QEBjYW52YXNfeH07XG4gICAgICAgICAgI3tAQG1vdXNlX2luZm99LnkgPSBldi5wYWdlWSAtICN7QEBjYW52YXNfeX07XG4gICAgICAgICAgZm9yICh2YXIgaz0xOyBrPD0xNjsgazw8PTEpIHtcbiAgICAgICAgICAgIGlmIChldi5idXR0b25zICYgaykge1xuICAgICAgICAgICAgICAje0BAcHJlc3NpbmdfbW91c2VfYnV0dG9uc31ba10gPSAje0BAdGlja307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgICAje0BAbW91c2VfaW5mb30ueCA9IGV2LnBhZ2VYIC0gI3tAQGNhbnZhc194fTtcbiAgICAgICAgICAje0BAbW91c2VfaW5mb30ueSA9IGV2LnBhZ2VZIC0gI3tAQGNhbnZhc195fTtcbiAgICAgICAgICAvLyBldi5idXR0b24gPT4gZXYuYnV0dG9uc1xuICAgICAgICAgIHRhYmxlID0geyAwOiAxLCAxOiA0LCAyOiAyLCAzOiA4LCA0OiAxNiB9O1xuICAgICAgICAgIGZvciAodmFyIGs9MTsgazw9MTY7IGs8PD0xKSB7XG4gICAgICAgICAgICBpZiAoI3tAQHByZXNzaW5nX21vdXNlX2J1dHRvbnN9W2tdKSB7XG4gICAgICAgICAgICAgICN7QEBwcmVzc2luZ19tb3VzZV9idXR0b25zfVt0YWJsZVtldi5idXR0b25dXSA9IC0je0BAdGlja307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgICMgUmV0dXJuIHBvc2l0aW9uIG9mIG1vdXNlIGN1cnNvclxuICAgICMgKDAsIDApIGlzIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuICAgIGRlZiBzZWxmLm1vdXNlX3hcbiAgICAgIHJldHVybiBgI3tAQG1vdXNlX2luZm99LnhgXG4gICAgZW5kXG4gICAgZGVmIHNlbGYubW91c2VfeVxuICAgICAgcmV0dXJuIGAje0BAbW91c2VfaW5mb30ueWBcbiAgICBlbmRcbiAgICBjbGFzcyA8PCBzZWxmXG4gICAgICBhbGlhcyBtb3VzZV9wb3NfeCBtb3VzZV94XG4gICAgICBhbGlhcyBtb3VzZV9wb3NfeSBtb3VzZV95XG4gICAgZW5kXG5cbiAgICAjIFJldHVybiB0cnVlIGlmIHRoZSBtb3VzZSBidXR0b24gaXMgYmVpbmcgcHJlc3NlZFxuICAgIGRlZiBzZWxmLm1vdXNlX2Rvd24/KG1vdXNlX2NvZGUpXG4gICAgICByYWlzZSBcIm1pc3NpbmcgYXJndW1lbnQgb2YgYG1vdXNlX2Rvd24/J1wiIHVubGVzcyBtb3VzZV9jb2RlXG4gICAgICByZXR1cm4gYCN7QEBwcmVzc2luZ19tb3VzZV9idXR0b25zfVttb3VzZV9jb2RlXSA+IDBgXG4gICAgZW5kXG5cbiAgICAjIFJldHVybiB0cnVlIGlmIHRoZSBtb3VzZSBidXR0b24gaXMgcHJlc3NlZCBpbiB0aGUgbGFzdCB0aWNrXG4gICAgZGVmIHNlbGYubW91c2VfcHVzaD8obW91c2VfY29kZSlcbiAgICAgIHJhaXNlIFwibWlzc2luZyBhcmd1bWVudCBvZiBgbW91c2VfcHVzaD8nXCIgdW5sZXNzIG1vdXNlX2NvZGVcbiAgICAgIHJldHVybiBgI3tAQHByZXNzaW5nX21vdXNlX2J1dHRvbnN9W21vdXNlX2NvZGVdID09IC0oI3tAQHRpY2t9LTEpYFxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbW91c2UgYnV0dG9uIGlzIHJlbGVhc2VkIGluIHRoZSBsYXN0IHRpY2tcbiAgICBkZWYgc2VsZi5tb3VzZV9yZWxlYXNlPyhtb3VzZV9jb2RlKVxuICAgICAgcmFpc2UgXCJtaXNzaW5nIGFyZ3VtZW50IG9mIGBtb3VzZV9yZWxlYXNlPydcIiB1bmxlc3MgbW91c2VfY29kZVxuICAgICAgcmV0dXJuIGAje0BAcHJlc3NpbmdfbW91c2VfYnV0dG9uc31bbW91c2VfY29kZV0gPT0gLSgje0BAdGlja30tMSlgXG4gICAgZW5kXG5cbiAgICAjXG4gICAgIyBUb3VjaFxuICAgICNcblxuICAgICMgKGludGVybmFsKSBpbml0aWFsaXplIHRvdWNoIGV2ZW50c1xuICAgIGRlZiBzZWxmLl9pbml0X3RvdWNoX2V2ZW50c1xuICAgICAgQEB0b3VjaGVzID0ge31cbiAgICAgIEBAbmV3X3RvdWNoZXMgPSBbXVxuICAgICAgJXh7XG4gICAgICAgICN7QEBjYW52YXN9LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICN7QEB0b3VjaF9pbmZvfS54ID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSAje0BAY2FudmFzX3h9O1xuICAgICAgICAgICN7QEB0b3VjaF9pbmZvfS55ID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSAje0BAY2FudmFzX3l9O1xuICAgICAgICAgIGZvciAodmFyIHRvdWNoIG9mIGV2LmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgICAgICAgICBjb25zdCB4ID0gdG91Y2gucGFnZVggLSAje0BAY2FudmFzX3h9O1xuICAgICAgICAgICAgY29uc3QgeSA9IHRvdWNoLnBhZ2VZIC0gI3tAQGNhbnZhc195fTtcbiAgICAgICAgICAgICN7QEB0b3VjaGVzW2BpZGBdJi5fbW92ZShgeGAsIGB5YCl9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgI3tAQGNhbnZhc30uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICN7QEB0b3VjaF9pbmZvfS54ID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSAje0BAY2FudmFzX3h9O1xuICAgICAgICAgICN7QEB0b3VjaF9pbmZvfS55ID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSAje0BAY2FudmFzX3l9O1xuICAgICAgICAgICN7QEBwcmVzc2luZ190b3VjaH1bMF0gPSAje0BAdGlja307XG4gICAgICAgICAgZm9yICh2YXIgdG91Y2ggb2YgZXYuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdG91Y2guaWRlbnRpZmllcjtcbiAgICAgICAgICAgIGNvbnN0IHggPSB0b3VjaC5wYWdlWCAtICN7QEBjYW52YXNfeH07XG4gICAgICAgICAgICBjb25zdCB5ID0gdG91Y2gucGFnZVkgLSAje0BAY2FudmFzX3l9O1xuICAgICAgICAgICAgI3tcbiAgICAgICAgICAgICAgbmV3X3RvdWNoID0gVG91Y2gubmV3KGBpZGAsIGB4YCwgYHlgKVxuICAgICAgICAgICAgICBAQHRvdWNoZXNbYGlkYF0gPSBuZXdfdG91Y2hcbiAgICAgICAgICAgICAgQEBuZXdfdG91Y2hlcy5wdXNoKG5ld190b3VjaClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAje0BAY2FudmFzfS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGZ1bmN0aW9uKGV2KXtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICN7QEB0b3VjaF9pbmZvfS54ID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSAje0BAY2FudmFzX3h9O1xuICAgICAgICAgICN7QEB0b3VjaF9pbmZvfS55ID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSAje0BAY2FudmFzX3l9O1xuICAgICAgICAgICN7QEBwcmVzc2luZ190b3VjaH1bMF0gPSAtI3tAQHRpY2t9O1xuICAgICAgICAgIGZvciAodmFyIHRvdWNoIG9mIGV2LmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgICAgICAgICAje0BAdG91Y2hlc1tgaWRgXSYuX3JlbGVhc2VkKEBAdGljayl9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBzZWxmLl91cGRhdGVfdG91Y2hfaW5mb1xuICAgICAgIyBDbGVhciBvbGQgZGF0YVxuICAgICAgQEB0b3VjaGVzLmRlbGV0ZV9pZnt8aWQsIHR8IHQucmVsZWFzZWQ/ICYmIHQuX3JlbGVhc2VkX2F0IDwgQEB0aWNrLTF9XG4gICAgZW5kXG5cbiAgICAjXG4gICAgIyBTaW5nbGUgdG91Y2hcbiAgICAjXG5cbiAgICAjIFJldHVybiBwb3NpdGlvbiBvZiB0b3VjaFxuICAgICMgKDAsIDApIGlzIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuICAgIGRlZiBzZWxmLnRvdWNoX3hcbiAgICAgIHJldHVybiBgI3tAQHRvdWNoX2luZm99LnhgXG4gICAgZW5kXG4gICAgZGVmIHNlbGYudG91Y2hfeVxuICAgICAgcmV0dXJuIGAje0BAdG91Y2hfaW5mb30ueWBcbiAgICBlbmRcbiAgICBjbGFzcyA8PCBzZWxmXG4gICAgICBhbGlhcyB0b3VjaF9wb3NfeCB0b3VjaF94XG4gICAgICBhbGlhcyB0b3VjaF9wb3NfeSB0b3VjaF95XG4gICAgZW5kXG5cbiAgICAjIFJldHVybiB0cnVlIGlmIHRoZSB0b3VjaCBpcyBiZWluZyBwcmVzc2VkXG4gICAgZGVmIHNlbGYudG91Y2hfZG93bj9cbiAgICAgIHJldHVybiBgI3tAQHByZXNzaW5nX3RvdWNofVswXSA+IDBgXG4gICAgZW5kXG5cbiAgICAjIFJldHVybiB0cnVlIGlmIHRoZSB0b3VjaCBpcyBwcmVzc2VkIGluIHRoZSBsYXN0IHRpY2tcbiAgICBkZWYgc2VsZi50b3VjaF9wdXNoP1xuICAgICAgcmV0dXJuIGAje0BAcHJlc3NpbmdfdG91Y2h9WzBdID09IC0oI3tAQHRpY2t9LTEpYFxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm4gdHJ1ZSBpZiB0aGUgdG91Y2ggaXMgcmVsZWFzZWQgaW4gdGhlIGxhc3QgdGlja1xuICAgIGRlZiBzZWxmLnRvdWNoX3JlbGVhc2U/XG4gICAgICByZXR1cm4gYCN7QEBwcmVzc2luZ190b3VjaH1bMF0gPT0gLSgje0BAdGlja30tMSlgXG4gICAgZW5kXG5cbiAgICAjXG4gICAgIyBNdWx0aSB0b3VjaGVzXG4gICAgI1xuICAgIFxuICAgICMgUmVwcmVzZW50cyBhIHRvdWNoXG4gICAgY2xhc3MgVG91Y2hcbiAgICAgIGRlZiBpbml0aWFsaXplKGlkLCB4LCB5KVxuICAgICAgICBAaWQgPSBpZFxuICAgICAgICBfbW92ZSh4LCB5KVxuICAgICAgICBAX3JlbGVhc2VkX2F0ID0gbmlsXG4gICAgICAgIEBkYXRhID0ge31cbiAgICAgIGVuZFxuICAgICAgYXR0cl9yZWFkZXIgOmlkLCA6eCwgOnksIDpkYXRhLCA6X3JlbGVhc2VkX2F0XG5cbiAgICAgICMgUmV0dXJuIHRydWUgaWYgdGhpcyB0b3VjaCBpcyByZWxlYXNlZCBpbiB0aGUgbGFzdCB0aWNrXG4gICAgICBkZWYgcmVsZWFzZWQ/XG4gICAgICAgICEhQF9yZWxlYXNlZF9hdFxuICAgICAgZW5kXG5cbiAgICAgIGRlZiBpbnNwZWN0XG4gICAgICAgIHJlbCA9IChyZWxlYXNlZF9hdCA/IFwiIHJlbGVhc2VkX2F0PSN7cmVsZWFzZWRfYXR9XCIgOiBcIlwiKVxuICAgICAgICBcIiM8RFhPcGFsOjpUb3VjaCBpZD0je2lkfSB4PSN7eH0geT0je3l9IGRhdGE9I3tkYXRhLmluc3BlY3R9I3tyZWx9PlwiXG4gICAgICBlbmRcblxuICAgICAgZGVmIF9tb3ZlKHgsIHkpXG4gICAgICAgIEB4ID0geFxuICAgICAgICBAeSA9IHlcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgX3JlbGVhc2VkKHRpY2spXG4gICAgICAgIEBfcmVsZWFzZWRfYXQgPSB0aWNrXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICMgUmV0dXJucyBjdXJyZW50IHRvdWNoZXMgYXMgYW4gYXJyYXkgb2YgSW5wdXQ6OlRvdWNoXG4gICAgZGVmIHNlbGYudG91Y2hlc1xuICAgICAgQEB0b3VjaGVzLnZhbHVlc1xuICAgIGVuZFxuXG4gICAgIyBSZXR1cm5zIG5ld2x5IGNyZWF0ZWQgdG91Y2hlc1xuICAgIGRlZiBzZWxmLm5ld190b3VjaGVzXG4gICAgICByZXQgPSBAQG5ld190b3VjaGVzXG4gICAgICBAQG5ld190b3VjaGVzID0gW11cbiAgICAgIHJldFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsIjEiLCIyIiwiNCIsIjgiLCIxNiIsIl9wcmVzc2luZ19rZXlzIiwic2VsZiIsIkBAcHJlc3Npbmdfa2V5cyIsIl9pbml0IiwiQEB0aWNrIiwiMCIsIkBAbW91c2VfaW5mbyIsIkBAcHJlc3NpbmdfbW91c2VfYnV0dG9ucyIsIkBAdG91Y2hfaW5mbyIsIkBAcHJlc3NpbmdfdG91Y2giLCJAQGNhbnZhcyIsImNhbnZhcyIsInJlY3QiLCJAQGNhbnZhc194IiwiQEBjYW52YXNfeSIsIl9pbml0X21vdXNlX2V2ZW50cyIsIl9pbml0X3RvdWNoX2V2ZW50cyIsImtleWV2ZW50X3RhcmdldCIsIiR3cml0ZXIiLCJrZXlldmVudF90YXJnZXQ9IiwiLSIsIl9vbl90aWNrIiwiKyIsIl91cGRhdGVfdG91Y2hfaW5mbyIsIngiLCJyZXQiLCJrZXlfZG93bj8iLCJ5Iiwia2V5X3B1c2g/Iiwia2V5X3JlbGVhc2U/IiwiQEBrZXlldmVudF90YXJnZXQiLCJ0YXJnZXQiLCJjbGFzc192YXJpYWJsZV9kZWZpbmVkPyIsIm1vdXNlX3giLCJtb3VzZV95IiwibW91c2VfZG93bj8iLCJtb3VzZV9jb2RlIiwicmFpc2UiLCJtb3VzZV9wdXNoPyIsIm1vdXNlX3JlbGVhc2U/IiwiQEB0b3VjaGVzIiwiQEBuZXdfdG91Y2hlcyIsIltdIiwibmV3X3RvdWNoIiwibmV3IiwiW109IiwicHVzaCIsImRlbGV0ZV9pZiIsIiRyZXRfb3JfMSIsInQiLCJyZWxlYXNlZD8iLCI8IiwiX3JlbGVhc2VkX2F0IiwidG91Y2hfeCIsInRvdWNoX3kiLCJ0b3VjaF9kb3duPyIsInRvdWNoX3B1c2g/IiwidG91Y2hfcmVsZWFzZT8iLCJjbGFzcyIsImluaXRpYWxpemUiLCJAaWQiLCJpZCIsIl9tb3ZlIiwiQF9yZWxlYXNlZF9hdCIsIkBkYXRhIiwiYXR0cl9yZWFkZXIiLCIhIiwiaW5zcGVjdCIsInJlbCIsInJlbGVhc2VkX2F0IiwiZGF0YSIsIkB4IiwiQHkiLCJfcmVsZWFzZWQiLCJ0aWNrIiwidG91Y2hlcyIsInZhbHVlcyIsIm5ld190b3VjaGVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRSxPQUFBQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUEseUNBQVlDLENBQVosQ0FBQTtBQUFBLFFBQ0EseUNBQVlDLENBQVosQ0FEQTtBQUFBLFFBRUEseUNBQVlDLENBQVosQ0FGQTtBQUFBLFFBSUEsNENBQWVDLENBQWYsQ0FKQTtBQUFBLFFBS0EsT0FBQSw0Q0FBZUMsRUFBZixDQUxBO0FBREZMLE1BQUFBLEdBQUFBLFdBQUFBLFdBQUE7QUFBQSxNQVNBTSxVQUFJQyxJQUFKRCxxQkFBQUEsMEJBQUFBLDBCQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFBeUIsT0FBQUU7QUFBekJGLE1BQUFBLENBQUFBLHFDQUFBQSxDQVRBO0FBQUEsTUFZQUcsVUFBSUYsSUFBSkUsWUFBQUEsaUJBQUFBLGlCQUFlLE1BQWZBO0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUFDLDJDQUFTQyxDQUFURCxDQUFBO0FBQUEsUUFDQUYsb0RBQW1CLFlBQW5CQSxDQURBO0FBQUEsUUFFQUksaURBQWdC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V0FsUkE7QUFBQSxNQWdUQWlCLFVBQUkxRSxJQUFKMEUsY0FBQUEsb0JBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxPQUFBbkMsb0RBQUFvQyxRQUFBQSxDQUFBQTtBQURGRCxNQUFBQSxDQUFBQSwrQkFBQUEsQ0FoVEE7QUFBQSxNQXFUQSxPQUFBRSxDQUFBQSxVQUFJNUUsSUFBSjRFLGtCQUFBQSx3QkFBQUEsdUJBQUFBO0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUFwRCxNQUFNZ0Isd0RBQU47QUFBQSxRQUNBQSxrREFBZ0IsRUFBaEJBLENBREE7QUFBQSxRQUVBLE9BQUFoQixHQUZBO0FBREZvRCxNQUFBQSxDQUFBQSxtQ0FBQUEsQ0FBQUEsdUJBclRBO0FBREZuRixJQUFBQSxHQUFBQSxXQUFBQTtBQURGQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2NjE2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZHhvcGFsL2lucHV0L2tleV9jb2Rlcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgRFhPcGFsXG4gIG1vZHVsZSBJbnB1dFxuICAgICMgTGlzdCBvZiBrZXkgY29kZXMgKGV2ZW50LmNvZGUpXG4gICAgIyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9qYS9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudFxuICAgIG1vZHVsZSBLZXlDb2Rlc1xuICAgICAgIyBUT0RPOiBhZGQgZXZlbnQuY29kZSBmb3IgdGhvc2UgY29tbWVudGVkIG91dCAocHVsbCByZXF1ZXN0IHdlbGNvbWUpXG4gICAgICBLX0VTQ0FQRSA9ICdFc2NhcGUnXG4gICAgICBLXzEgPSAnRGlnaXQxJ1xuICAgICAgS18yID0gJ0RpZ2l0MidcbiAgICAgIEtfMyA9ICdEaWdpdDMnXG4gICAgICBLXzQgPSAnRGlnaXQ0J1xuICAgICAgS181ID0gJ0RpZ2l0NSdcbiAgICAgIEtfNiA9ICdEaWdpdDYnXG4gICAgICBLXzcgPSAnRGlnaXQ3J1xuICAgICAgS184ID0gJ0RpZ2l0OCdcbiAgICAgIEtfOSA9ICdEaWdpdDknXG4gICAgICBLXzAgPSAnRGlnaXQwJ1xuICAgICAgS19NSU5VUyA9ICdNaW51cydcbiAgICAgIEtfRVFVQUxTID0gJ0VxdWFsJ1xuICAgICAgS19CQUNLID0gJ0JhY2tzcGFjZSdcbiAgICAgIEtfVEFCID0gJ1RhYidcbiAgICAgIEtfUSA9ICdLZXlRJ1xuICAgICAgS19XID0gJ0tleVcnXG4gICAgICBLX0UgPSAnS2V5RSdcbiAgICAgIEtfUiA9ICdLZXlSJ1xuICAgICAgS19UID0gJ0tleVQnXG4gICAgICBLX1kgPSAnS2V5WSdcbiAgICAgIEtfVSA9ICdLZXlVJ1xuICAgICAgS19JID0gJ0tleUknXG4gICAgICBLX08gPSAnS2V5TydcbiAgICAgIEtfUCA9ICdLZXlQJ1xuICAgICAgS19MQlJBQ0tFVCA9ICdCcmFja2V0TGVmdCdcbiAgICAgIEtfUkJSQUNLRVQgPSAnQnJhY2tldFJpZ2h0J1xuICAgICAgS19SRVRVUk4gPSAnRW50ZXInXG4gICAgICBLX0VOVEVSID0gJ0VudGVyJyAgIyBBbGlhczsgbm90IGluIERYUnVieVxuICAgICAgS19MQ09OVFJPTCA9ICdDb250cm9sTGVmdCdcbiAgICAgIEtfQSA9ICdLZXlBJ1xuICAgICAgS19TID0gJ0tleVMnXG4gICAgICBLX0QgPSAnS2V5RCdcbiAgICAgIEtfRiA9ICdLZXlGJ1xuICAgICAgS19HID0gJ0tleUcnXG4gICAgICBLX0ggPSAnS2V5SCdcbiAgICAgIEtfSiA9ICdLZXlKJ1xuICAgICAgS19LID0gJ0tleUsnXG4gICAgICBLX0wgPSAnS2V5TCdcbiAgICAgIEtfU0VNSUNPTE9OID0gJ1NlbWljb2xvbidcbiAgICAgIEtfQVBPU1RST1BIRSA9ICdRdW90ZScgICMgJ1xuICAgICAgS19HUkFWRSA9IFwiQmFja3F1b3RlXCIgICAjIGBcbiAgICAgIEtfTFNISUZUID0gJ1NoaWZ0TGVmdCdcbiAgICAgIEtfQkFDS1NMQVNIID0gJ0JhY2tTbGFzaCcgICMgTm90ZTogZGlmZmVyZW50IHRvIEtfWUVOXG4gICAgICBLX1ogPSAnS2V5WidcbiAgICAgIEtfWCA9ICdLZXlYJ1xuICAgICAgS19DID0gJ0tleUMnXG4gICAgICBLX1YgPSAnS2V5VidcbiAgICAgIEtfQiA9ICdLZXlCJ1xuICAgICAgS19OID0gJ0tleU4nXG4gICAgICBLX00gPSAnS2V5TSdcbiAgICAgIEtfQ09NTUEgPSAnQ29tbWEnXG4gICAgICBLX1BFUklPRCA9ICdQZXJpb2QnXG4gICAgICBLX1NMQVNIID0gJ1NsYXNoJ1xuICAgICAgS19SU0hJRlQgPSAnU2hpZnRSaWdodCdcbiAgICAgIEtfTVVMVElQTFkgPSBcIk51bXBhZE11bHRpcGx5XCJcbiAgICAgICNLX0xNRU5VIEFsdFxuICAgICAgS19TUEFDRSA9ICdTcGFjZSdcbiAgICAgICNLX0NBUElUQUxcbiAgICAgIEtfRjEgID0gXCJGMVwiXG4gICAgICBLX0YyICA9IFwiRjJcIlxuICAgICAgS19GMyAgPSBcIkYzXCJcbiAgICAgIEtfRjQgID0gXCJGNFwiXG4gICAgICBLX0Y1ICA9IFwiRjVcIlxuICAgICAgS19GNiAgPSBcIkY2XCJcbiAgICAgIEtfRjcgID0gXCJGN1wiXG4gICAgICBLX0Y4ICA9IFwiRjhcIlxuICAgICAgS19GOSAgPSBcIkY5XCJcbiAgICAgIEtfRjEwID0gXCJGMTBcIlxuICAgICAgS19OVU1MT0NLID0gXCJOdW1Mb2NrXCJcbiAgICAgIEtfU0NST0xMID0gXCJTY3JvbGxMb2NrXCJcbiAgICAgIEtfTlVNUEFENyA9IFwiTnVtcGFkN1wiXG4gICAgICBLX05VTVBBRDggPSBcIk51bXBhZDhcIlxuICAgICAgS19OVU1QQUQ5ID0gXCJOdW1wYWQ5XCJcbiAgICAgIEtfU1VCVFJBQ1QgPSBcIk51bXBhZFN1YnRyYWN0XCJcbiAgICAgIEtfTlVNUEFENCA9IFwiTnVtcGFkNFwiXG4gICAgICBLX05VTVBBRDUgPSBcIk51bXBhZDVcIlxuICAgICAgS19OVU1QQUQ2ID0gXCJOdW1wYWQ2XCJcbiAgICAgIEtfQUREID0gXCJOdW1wYWRBZGRcIlxuICAgICAgS19OVU1QQUQxID0gXCJOdW1wYWQxXCJcbiAgICAgIEtfTlVNUEFEMiA9IFwiTnVtcGFkMlwiXG4gICAgICBLX05VTVBBRDMgPSBcIk51bXBhZDNcIlxuICAgICAgS19OVU1QQUQwID0gXCJOdW1wYWQwXCJcbiAgICAgIEtfREVDSU1BTCA9IFwiTnVtcGFkRGVjaW1hbFwiXG4gICAgICAjS19PRU1fMTAyIFxuICAgICAgS19GMTEgPSBcIkYxMVwiXG4gICAgICBLX0YxMiA9IFwiRjEyXCJcbiAgICAgIEtfRjEzID0gXCJGMTNcIlxuICAgICAgS19GMTQgPSBcIkYxNFwiXG4gICAgICBLX0YxNSA9IFwiRjE1XCJcbiAgICAgIEtfS0FOQSA9IFwiS2FuYU1vZGVcIlxuICAgICAgI0tfQUJOVF9DMSBcbiAgICAgIEtfQ09OVkVSVCA9IFwiQ29udmVydFwiXG4gICAgICBLX05PQ09OVkVSVCA9IFwiTm9uQ29udmVydFwiXG4gICAgICBLX1lFTiA9ICdJbnRsWWVuJ1xuICAgICAgI0tfQUJOVF9DMiBcbiAgICAgICNLX05VTVBBREVRVUFMUyAgPSAqMyAqMVxuICAgICAgI0tfUFJFVlRSQUNLXG4gICAgICAjS19BVFxuICAgICAgS19DT0xPTiA9ICdDb2xvbidcbiAgICAgIEtfVU5ERVJMSU5FID0gJ0ludGxSbycgICAjIF9cbiAgICAgICNLX0tBTkpJIFxuICAgICAgI0tfU1RPUFxuICAgICAgI0tfQVhcbiAgICAgICNLX1VOTEFCRUxFRFxuICAgICAgI0tfTkVYVFRSQUNLXG4gICAgICBLX05VTVBBREVOVEVSID0gXCJOdW1wYWRFbnRlclwiXG4gICAgICBLX1JDT05UUk9MID0gJ0NvbnRyb2xSaWdodCdcbiAgICAgIEtfTVVURSA9IFwiVm9sdW1lTXV0ZVwiXG4gICAgICAjS19DQUxDVUxBVE9SXG4gICAgICAjS19QTEFZUEFVU0VcbiAgICAgICNLX01FRElBU1RPUFxuICAgICAgS19WT0xVTUVET1dOID0gXCJWb2x1bWVEb3duXCJcbiAgICAgIEtfVk9MVU1FVVAgPSBcIlZvbHVtZVVwXCJcbiAgICAgIEtfV0VCSE9NRSA9IFwiQnJvd3NlckhvbWVcIlxuICAgICAgI0tfTlVNUEFEQ09NTUEgLCAqMyAqMVxuICAgICAgS19ESVZJREUgPSBcIk51bXBhZERpdmlkZVwiXG4gICAgICAjS19TWVNSUVxuICAgICAgI0tfUk1FTlUgQWx0XG4gICAgICBLX1BBVVNFID0gXCJQYXVzZVwiXG4gICAgICBLX0hPTUUgPSBcIkhvbWVcIlxuICAgICAgS19VUCA9ICdBcnJvd1VwJ1xuICAgICAgI0tfUFJJT1JcbiAgICAgIEtfTEVGVCA9ICdBcnJvd0xlZnQnXG4gICAgICBLX1JJR0hUID0gJ0Fycm93UmlnaHQnXG4gICAgICBLX0VORCA9IFwiRW5kXCJcbiAgICAgIEtfRE9XTiA9ICdBcnJvd0Rvd24nXG4gICAgICAjS19ORVhUXG4gICAgICBLX0lOU0VSVCA9IFwiSW5zZXJ0XCJcbiAgICAgIEtfREVMRVRFID0gXCJEZWxldGVcIlxuICAgICAgI0tfTFdJTlxuICAgICAgI0tfUldJTlxuICAgICAgI0tfQVBQU1xuICAgICAgI0tfUE9XRVJcbiAgICAgICNLX1NMRUVQXG4gICAgICAjS19XQUtFXG4gICAgICBLX1dFQlNFQVJDSCA9IFwiQnJvd3NlclNlYXJjaFwiXG4gICAgICBLX1dFQkZBVk9SSVRFUyA9IFwiQnJvd3NlckZhdm9yaXRlc1wiXG4gICAgICBLX1dFQlJFRlJFU0ggPSBcIkJyb3dzZXJSZWZyZXNoXCJcbiAgICAgIEtfV0VCU1RPUCA9IFwiQnJvd3NlclN0b3BcIlxuICAgICAgS19XRUJGT1JXQVJEID0gXCJCcm93c2VyRm9yd2FyZFwiXG4gICAgICBLX1dFQkJBQ0sgPSBcIkJyb3dzZXJCYWNrXCJcbiAgICAgICNLX01ZQ09NUFVURVJcbiAgICAgICNLX01BSUxcbiAgICAgICNLX01FRElBU0VMRUNUXG4gICAgICBLX0JBQ0tTUEFDRSA9ICdCYWNrc3BhY2UnXG4gICAgICBLX05VTVBBRFNUQVIgPSBcIk51bXBhZE11bHRpcGx5XCJcbiAgICAgIEtfTEFMVCA9IFwiQWx0TGVmdFwiXG4gICAgICBLX0NBUFNMT0NLID0gJ0NhcHNMb2NrJ1xuICAgICAgS19OVU1QQURNSU5VUyA9IFwiTnVtcGFkU3VidHJhY3RcIlxuICAgICAgS19OVU1QQURQTFVTID0gXCJOdW1wYWRBZGRcIlxuICAgICAgS19OVU1QQURQRVJJT0QgPSBcIk51bXBhZERlY2ltYWxcIlxuICAgICAgS19OVU1QQURTTEFTSCA9IFwiTnVtcGFkRGl2aWRlXCJcbiAgICAgIEtfUkFMVCA9IFwiQWx0UmlnaHRcIlxuICAgICAgS19VUEFSUk9XID0gJ0Fycm93VXAnXG4gICAgICBLX1BHVVAgPSBcIlBhZ2VVcFwiXG4gICAgICBLX0xFRlRBUlJPVyA9ICdBcnJvd0xlZnQnXG4gICAgICBLX1JJR0hUQVJST1cgPSAnQXJyb3dSaWdodCdcbiAgICAgIEtfRE9XTkFSUk9XID0gJ0Fycm93RG93bidcbiAgICAgIEtfUEdETiA9IFwiUGFnZURvd25cIlxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSJdLCJtYXBwaW5ncyI6Ijs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRSxPQUFBQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BR0UsT0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUVFLFFBQUEsd0NBQVcsUUFBWCxDQUFBO0FBQUEsUUFDQSxtQ0FBTSxRQUFOLENBREE7QUFBQSxRQUVBLG1DQUFNLFFBQU4sQ0FGQTtBQUFBLFFBR0EsbUNBQU0sUUFBTixDQUhBO0FBQUEsUUFJQSxtQ0FBTSxRQUFOLENBSkE7QUFBQSxRQUtBLG1DQUFNLFFBQU4sQ0FMQTtBQUFBLFFBTUEsbUNBQU0sUUFBTixDQU5BO0FBQUEsUUFPQSxtQ0FBTSxRQUFOLENBUEE7QUFBQSxRQVFBLG1DQUFNLFFBQU4sQ0FSQTtBQUFBLFFBU0EsbUNBQU0sUUFBTixDQVRBO0FBQUEsUUFVQSxt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QSxRQWdJQSx3Q0FBVyxRQUFYLENBaElBO0FBQUEsUUFpSUEsd0NBQVcsUUFBWCxDQWpJQTtBQUFBLFFBd0lBLDJDQUFjLGVBQWQsQ0F4SUE7QUFBQSxRQXlJQSw4Q0FBaUIsa0JBQWpCLENBeklBO0FBQUEsUUEwSUEsNENBQWUsZ0JBQWYsQ0ExSUE7QUFBQSxRQTJJQSx5Q0FBWSxhQUFaLENBM0lBO0FBQUEsUUE0SUEsNENBQWUsZ0JBQWYsQ0E1SUE7QUFBQSxRQTZJQSx5Q0FBWSxhQUFaLENBN0lBO0FBQUEsUUFpSkEsMkNBQWMsV0FBZCxDQWpKQTtBQUFBLFFBa0pBLDRDQUFlLGdCQUFmLENBbEpBO0FBQUEsUUFtSkEsc0NBQVMsU0FBVCxDQW5KQTtBQUFBLFFBb0pBLDBDQUFhLFVBQWIsQ0FwSkE7QUFBQSxRQXFKQSw2Q0FBZ0IsZ0JBQWhCLENBckpBO0FBQUEsUUFzSkEsNENBQWUsV0FBZixDQXRKQTtBQUFBLFFBdUpBLDhDQUFpQixlQUFqQixDQXZKQTtBQUFBLFFBd0pBLDZDQUFnQixjQUFoQixDQXhKQTtBQUFBLFFBeUpBLHNDQUFTLFVBQVQsQ0F6SkE7QUFBQSxRQTBKQSx5Q0FBWSxTQUFaLENBMUpBO0FBQUEsUUEySkEsc0NBQVMsUUFBVCxDQTNKQTtBQUFBLFFBNEpBLDJDQUFjLFdBQWQsQ0E1SkE7QUFBQSxRQTZKQSw0Q0FBZSxZQUFmLENBN0pBO0FBQUEsUUE4SkEsMkNBQWMsV0FBZCxDQTlKQTtBQUFBLFFBK0pBLE9BQUEsc0NBQVMsVUFBVCxDQS9KQTtBQUZGQSxNQUFBQSxHQUFBQSxXQUFBQTtBQUhGQSxJQUFBQSxHQUFBQSxXQUFBQTtBQURGQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2NzcxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZHhvcGFsL3JlbW90ZV9yZXNvdXJjZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgRFhPcGFsXG4gICMgQSBiYXNlIGNsYXNzIGZvciByZXNvdXJjZXMgYWNxdWlyZWQgdGhyb3VnaCBKUyBQcm9taXNlcy5cbiAgIyBQcm92aWRlcyBgPGtsYXNzPi5yZWdpc3RlcmAgYW5kIGA8a2xhc3M+W25hbWVdYC5cbiAgIyBBIHN1YmNsYXNzIG11c3QgaW1wZWxtZW50IGA8a2xhc3M+Ll9sb2FkYC5cbiAgI1xuICAjIFRPRE86IGJldHRlciBuYW1lPyAoU291bmRFZmZlY3QgaXMgbm90IGFjdHVhbGx5ICdyZW1vdGUnKVxuICBjbGFzcyBSZW1vdGVSZXNvdXJjZVxuICAgICMgTGlzdCBvZiByZWdpc3RlcmVkIHJlc291cmNlcyAoQ29udGFpbnMgcGF0aF9vcl91cmwpXG4gICAgQEByZXNvdXJjZXMgPSBIYXNoLm5ld3t8aCxrfCBoW2tdID0ge319XG4gICAgIyBDb250YWlucyBwcm9taXNlc1xuICAgIEBAcHJvbWlzZXMgPSBIYXNoLm5ld3t8aCxrfCBoW2tdID0ge319XG4gICAgIyBDb250YWlucyBpbnN0YW5jZXMgb2YgSW1hZ2UsIFNvdW5kXG4gICAgQEBpbnN0YW5jZXMgPSBIYXNoLm5ld3t8aCxrfCBoW2tdID0ge319XG5cbiAgICAjIFN1YmNsYXNzZXMgb2YgUmVtb3RlUmVzb3VyY2VcbiAgICBAQGtsYXNzZXMgPSB7fVxuICAgIGRlZiBzZWxmLmFkZF9jbGFzcyhzdWJrbGFzcylcbiAgICAgIEBAa2xhc3Nlc1tzdWJrbGFzcy5fa2xhc3NfbmFtZV0gPSBzdWJrbGFzc1xuICAgIGVuZFxuXG4gICAgIyBSZXNlcnZlIGluc3RhbmNlIGdlbmVyYXRpb25cbiAgICBkZWYgc2VsZi5yZWdpc3RlcihuYW1lLCAqYXJncywgJmJsb2NrKVxuICAgICAgQEByZXNvdXJjZXNbX2tsYXNzX25hbWVdIHx8PSB7fVxuICAgICAgQEByZXNvdXJjZXNbX2tsYXNzX25hbWVdW25hbWVdID0gW2Jsb2NrLCBhcmdzXVxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm4gaW5zdGFuY2Ugb2YgbG9hZGVkIHJlc291cmNlIChjYWxsIG9uIHN1YmNsYXNzZXMpXG4gICAgZGVmIHNlbGYuW10obmFtZSlcbiAgICAgIGlmIChyZXQgPSBAQGluc3RhbmNlc1tfa2xhc3NfbmFtZV1bbmFtZV0pXG4gICAgICAgIHJldHVybiByZXRcbiAgICAgIGVsc2VcbiAgICAgICAgcmFpc2UgXCIje19rbGFzc19uYW1lfSAje25hbWUuaW5zcGVjdH0gaXMgbm90IHJlZ2lzdGVyZWRcIlxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIENhbGxlZCBmcm9tIFdpbmRvdy5sb2FkX3Jlc291cmNlc1xuICAgIGRlZiBzZWxmLl9sb2FkX3Jlc291cmNlcygmYmxvY2spXG4gICAgICBAQHJlc291cmNlcy5lYWNoIGRvIHxrbGFzc19uYW1lLCBpdGVtc3xcbiAgICAgICAga2xhc3MgPSBAQGtsYXNzZXNba2xhc3NfbmFtZV0gXG4gICAgICAgIGl0ZW1zLmVhY2ggZG8gfG5hbWUsIChibG9jazIsIGFyZ3MpfFxuICAgICAgICAgIGlmICFAQHByb21pc2VzW2tsYXNzX25hbWVdW25hbWVdXG4gICAgICAgICAgICBpbnN0YW5jZSwgcHJvbWlzZSA9IGtsYXNzLl9sb2FkKCphcmdzLCAmYmxvY2syKVxuICAgICAgICAgICAgQEBpbnN0YW5jZXNba2xhc3NfbmFtZV1bbmFtZV0gPSBpbnN0YW5jZVxuICAgICAgICAgICAgQEBwcm9taXNlc1trbGFzc19uYW1lXVtuYW1lXSA9IHByb21pc2VcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHByb21pc2VzID0gQEBwcm9taXNlcy52YWx1ZXMuZmxhdF9tYXAoJjp2YWx1ZXMpXG4gICAgICAleHtcbiAgICAgICAgUHJvbWlzZS5hbGwoI3twcm9taXNlc30pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgI3tibG9jay5jYWxsfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgICMgTG9hZCBhY3R1YWwgY29udGVudCAoZGVmaW5lZCBvbiBzdWJjbGFzc2VzKVxuICAgICMgUmV0dXJuIGBbaW5zdGFuY2UsIHByb21pc2VdYFxuICAgIGRlZiBzZWxmLl9sb2FkKCphcmdzKVxuICAgICAgcmFpc2UgXCJvdmVycmlkZSBtZVwiXG4gICAgZW5kXG5cbiAgICAjIFJldHVybiBhIHN0cmluZyBsaWtlIFwiSW1hZ2VcIiBvciBcIlNvdW5kXCJcbiAgICBkZWYgc2VsZi5fa2xhc3NfbmFtZVxuICAgICAgcmV0dXJuIHNlbGYubmFtZS5zcGxpdCgvOjovKS5sYXN0XG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJAQHJlc291cmNlcyIsIm5ldyIsIiR3cml0ZXIiLCJrIiwiW109IiwiaCIsIi0iLCIxIiwiQEBwcm9taXNlcyIsIkBAaW5zdGFuY2VzIiwiQEBrbGFzc2VzIiwiYWRkX2NsYXNzIiwic2VsZiIsInN1YmtsYXNzIiwiX2tsYXNzX25hbWUiLCJyZWdpc3RlciIsIiRyZXRfb3JfMSIsIltdIiwibmFtZSIsImJsb2NrIiwiYXJncyIsInJldCIsInJhaXNlIiwiaW5zcGVjdCIsIl9sb2FkX3Jlc291cmNlcyIsImVhY2giLCJrbGFzcyIsImtsYXNzX25hbWUiLCJpdGVtcyIsIiRtbGhzX3RtcDEiLCJibG9jazIiLCIhIiwiX2xvYWQiLCJpbnN0YW5jZSIsInByb21pc2UiLCJwcm9taXNlcyIsImZsYXRfbWFwIiwidmFsdWVzIiwiY2FsbCIsInNwbGl0IiwibGFzdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBTUUsT0FBQUM7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQTtBQUVFLE1BQUFDLGdEQUFjQyxNQUFBLG9CQUFBQSxPQUFBQSxFQUFBQSxFQUFBQSxFQVRsQiw4QkFTNEIsQ0FBRCxFQUFHLENBVDlCLEVBQUE7O0FBQUE7QUFBQTtBQVM0QixRQUFBO0FBQUEsUUFBQTtBQUFBLFFBQUEsQ0FUNUI7QUFBQTtBQVM4QixRQUFBO0FBQUEsUUFBQTtBQUFBLFFBQUEsQ0FUOUI7QUFBQSxRQUFBQyxVQUFBLENBU21DQyxDQVRuQyxFQVN3QyxZQUFBLEVBVHhDLENBQUE7QUFBQSxRQVNpQ0MsTUFBQUMsQ0FBQUQsT0FBQUEsRUFUakMsVUFBQUYsT0FBQSxDQVNpQ0UsQ0FUakM7QUFBQSxRQUFBLE9BQUFGLE9BQUEsQ0FBQUksVUFBQUosT0FBQSxDQUFBLFFBQUEsQ0FBQUksRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBQUEsZ0NBQUEsK0JBQUEsbUJBU2tCTCxDQUFkRCxDQUFBO0FBQUEsTUFFQVEsK0NBQWFQLE1BQUEsb0JBQUFBLE9BQUFBLEVBQUFBLEVBQUFBLEVBWGpCLDhCQVcyQixDQUFELEVBQUcsQ0FYN0IsRUFBQTs7QUFBQTtBQUFBO0FBVzJCLFFBQUE7QUFBQSxRQUFBO0FBQUEsUUFBQSxDQVgzQjtBQUFBO0FBVzZCLFFBQUE7QUFBQSxRQUFBO0FBQUEsUUFBQSxDQVg3QjtBQUFBLFFBQUFDLFVBQUEsQ0FXa0NDLENBWGxDLEVBV3VDLFlBQUEsRUFYdkMsQ0FBQTtBQUFBLFFBV2dDQyxNQUFBQyxDQUFBRCxPQUFBQSxFQVhoQyxVQUFBRixPQUFBLENBV2dDRSxDQVhoQztBQUFBLFFBQUEsT0FBQUYsT0FBQSxDQUFBSSxVQUFBSixPQUFBLENBQUEsUUFBQSxDQUFBSSxFQUFBQyxDQUFBRCxDQUFBLENBQUEsQ0FBQSxnQ0FBQSwrQkFBQSxtQkFXaUJMLENBQWJPLENBRkE7QUFBQSxNQUlBQyxnREFBY1IsTUFBQSxvQkFBQUEsT0FBQUEsRUFBQUEsRUFBQUEsRUFibEIsOEJBYTRCLENBQUQsRUFBRyxDQWI5QixFQUFBOztBQUFBO0FBQUE7QUFhNEIsUUFBQTtBQUFBLFFBQUE7QUFBQSxRQUFBLENBYjVCO0FBQUE7QUFhOEIsUUFBQTtBQUFBLFFBQUE7QUFBQSxRQUFBLENBYjlCO0FBQUEsUUFBQUMsVUFBQSxDQWFtQ0MsQ0FibkMsRUFhd0MsWUFBQSxFQWJ4QyxDQUFBO0FBQUEsUUFhaUNDLE1BQUFDLENBQUFELE9BQUFBLEVBYmpDLFVBQUFGLE9BQUEsQ0FhaUNFLENBYmpDO0FBQUEsUUFBQSxPQUFBRixPQUFBLENBQUFJLFVBQUFKLE9BQUEsQ0FBQSxRQUFBLENBQUFJLEVBQUFDLENBQUFELENBQUEsQ0FBQSxDQUFBLGdDQUFBLCtCQUFBLG1CQWFrQkwsQ0FBZFEsQ0FKQTtBQUFBLE1BT0FDLDhDQUFZLFlBQUEsRUFBWkEsQ0FQQTtBQUFBLE1BUUFDLFVBQUlDLElBQUpELGdCQUFBQSw4QkFBQUEscUJBQW1CLFFBQW5CQTtBQUFBQSxRQUFBQTs7QUFBQUE7QUFqQkosUUFBQVQsVUFBQSxDQWtCZ0JXLFFBQUFDLGFBQUFBLENBQUFBLENBbEJoQixFQWtCd0NELFFBbEJ4QyxDQUFBO0FBQUEsUUFrQk1ULE1BQUFNLG9EQUFBTixPQUFBQSxFQWxCTixVQUFBRixPQUFBLENBa0JNRSxDQWxCTjtBQUFBLFFBQUEsT0FBQUYsT0FBQSxDQUFBSSxVQUFBSixPQUFBLENBQUEsUUFBQSxDQUFBSSxFQUFBQyxDQUFBRCxDQUFBLENBQUE7QUFpQklLLE1BQUFBLENBQUFBLHlDQUFBQSxDQVJBO0FBQUEsTUFhQUksVUFBSUgsSUFBSkcsZUFBQUEsNkJBQUFBLG9CQUFrQixJQUFELEVBdEJyQixFQXNCSUE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQUFBO0FBQUFBO0FBdEJKO0FBc0JtQyxRQUFBLGlEQXRCbkM7QUFBQTtBQUFBLFFBQUEsNERBQUE7QUFBQTtBQXNCNEIsUUFBQSxrQkF0QjVCO0FBQUEsUUFBQSxJQUFBLFFBQUFDLENBQUFBLFlBdUJNaEIsc0RBQUFpQixPQUFBQSxLQUFZSCxhQUFBQSxDQUFBQSxDQUFaRyxDQXZCTkQsQ0FBQSxDQUFBO0FBQUEsVUFBQTtBQUFBLFFBQUE7QUFBQTtBQUFBLFVBQUFkLFVBQUEsS0F1QmtCWSxhQUFBQSxDQUFBQSxDQXZCbEIsRUF1Qm1DLFlBQUEsRUF2Qm5DLENBQUE7QUFBQSxVQXVCTVYsTUFBQUosc0RBQUFJLE9BQUFBLEVBdkJOLFVBQUFGLE9BQUEsQ0F1Qk1FLENBdkJOO0FBQUEsVUFBQUYsT0FBQSxDQUFBSSxVQUFBSixPQUFBLENBQUEsUUFBQSxDQUFBSSxFQUFBQyxDQUFBRCxDQUFBLENBQUE7QUFBQSxRQUFBLENBQUE7QUFBQTtBQUFBLFFBQUFKLFVBQUEsQ0F3QitCZ0IsSUF4Qi9CLEVBd0J1QyxDQUFDQyxLQUFELEVBQVFDLElBQVIsQ0F4QnZDLENBQUE7QUFBQSxRQXdCTWhCLE1BQUFKLHNEQUFBaUIsT0FBQUEsS0FBWUgsYUFBQUEsQ0FBQUEsQ0FBWkcsQ0FBQWIsT0FBQUEsRUF4Qk4sVUFBQUYsT0FBQSxDQXdCTUUsQ0F4Qk47QUFBQSxRQUFBLE9BQUFGLE9BQUEsQ0FBQUksVUFBQUosT0FBQSxDQUFBLFFBQUEsQ0FBQUksRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBQUE7QUFzQklTLE1BQUFBLENBQUFBLHlDQUFBQSxDQWJBO0FBQUEsTUFtQkFFLFVBQUlMLElBQUpLLFNBQUFBLHVCQUFBQSxTQUFZLElBQVpBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLElBQUEsUUFBSUksQ0FBQUEsTUFBTVosc0RBQUFRLE9BQUFBLEtBQVlILGFBQUFBLENBQUFBLENBQVpHLENBQUFBLE9BQUFBLENBQXlCQyxJQUF6QkQsQ0FBTkksQ0FBSixDQUFBO0FBQUEsVUFDRSxPQUFPQTtBQURULFFBQUE7QUFBQSxVQUdFLFdBQUFDLE9BQUFBLENBQU0sRUFBQSxHQUFBLEtBQUdSLGFBQUFBLENBQUFBLENBQUgsQ0FBQSxHQUFBLEdBQUEsR0FBQSxDQUFrQkksSUFBQUssU0FBQUEsQ0FBQUEsQ0FBbEIsQ0FBQSxHQUFBLG9CQUFORDtBQUhGLFFBQUE7QUFERkwsTUFBQUEsQ0FBQUEsa0NBQUFBLENBbkJBO0FBQUEsTUE0QkFPLFVBQUlaLElBQUpZLHNCQUFBQSxvQ0FBQUEsMkJBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUFBQTtBQUFBQTtBQXJDSjtBQXFDNkIsUUFBQSx3REFyQzdCO0FBQUEsUUFzQ01DLE1BQUF6QixzREFBQXlCLFFBQUFBLEVBQUFBLEVBQUFBLEVBdENOLGdCQXNDMkIsVUFBRCxFQUFhLEtBdEN2QyxFQUFBOztBQUFBO0FBQUE7QUFzQzJCLFVBQUE7QUFBQSxVQUFBO0FBQUEsVUFBQSxDQXRDM0I7QUFBQTtBQXNDdUMsVUFBQTtBQUFBLFVBQUE7QUFBQSxVQUFBLENBdEN2QztBQUFBLFVBdUNRQyxRQUFRaEIsb0RBQUFPLE9BQUFBLENBQVVVLFVBQVZWLENBdkNoQjtBQUFBLFVBd0NRLE9BQUFRLE1BQUFHLEtBQUFILFFBQUFBLEVBQUFBLEVBQUFBLEVBeENSLGdCQXdDdUIsSUFBRCxFQXhDdEIsVUFBQSxFQUFBOztBQUFBO0FBQUE7QUF3Q3VCLFlBQUE7QUFBQSxZQUFBO0FBQUEsWUFBQSxDQXhDdkI7QUFBQTtBQUFBLFlBQUE7QUFBQSxZQUFBO0FBQUEsWUFBQSxDQUFBO0FBQUEsWUFBQSxLQUFBSSxVQUFBLHNCQUFBLEVBd0M4QkMsQ0FBQUEsc0NBQUFBLENBeEM5QixFQXdDc0NWLENBQUFBLG9DQUFBQSxDQXhDdEMsSUFBQTtBQUFBLFlBeUNVLElBQUEsUUFBSVoscURBQUFTLE9BQUFBLENBQVdVLFVBQVhWLENBQUFBLE9BQUFBLENBQXVCQyxJQUF2QkQsQ0FBRGMsTUFBQUEsQ0FBQUEsQ0FBSCxDQUFBO0FBQUE7QUFDRSxjQUFBLEtBQW9CQyxNQUFBTixLQUFBTSxTQUFBQSxFQUFZLFVBQUNaLElBQUQsQ0FBWlksRUFBb0JGLGlCQUFwQkUsQ0FBcEIsc0JBQUEsRUFBQUMsQ0FBQUEsd0NBQUFBLENBQUEsRUFBVUMsQ0FBQUEsdUNBQUFBLENBQVYsSUFBQTtBQUFBO0FBMUNaLGNBQUFoQyxVQUFBLENBMkNvQ2dCLElBM0NwQyxFQTJDNENlLFFBM0M1QyxDQUFBO0FBQUEsY0EyQ1k3QixNQUFBSyxzREFBQVEsT0FBQUEsQ0FBWVUsVUFBWlYsQ0FBQWIsT0FBQUEsRUEzQ1osVUFBQUYsT0FBQSxDQTJDWUUsQ0EzQ1o7QUFBQSxjQUFBRixPQUFBLENBQUFJLFVBQUFKLE9BQUEsQ0FBQSxRQUFBLENBQUFJLEVBQUFDLENBQUFELENBQUEsQ0FBQSxDQTBDWTtBQUFBO0FBMUNaLGNBQUFKLFVBQUEsQ0E0Q21DZ0IsSUE1Q25DLEVBNEMyQ2dCLE9BNUMzQyxDQUFBO0FBQUEsY0E0Q1k5QixNQUFBSSxxREFBQVMsT0FBQUEsQ0FBV1UsVUFBWFYsQ0FBQWIsT0FBQUEsRUE1Q1osVUFBQUYsT0FBQSxDQTRDWUUsQ0E1Q1o7QUFBQSxjQUFBLE9BQUFGLE9BQUEsQ0FBQUksVUFBQUosT0FBQSxDQUFBLFFBQUEsQ0FBQUksRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBMENZO0FBREYsWUFBQTtBQUFBO0FBQUEsWUFBQSxDQXpDVixDQUFBLGtCQUFBLGlCQUFBLHFDQUFBLEtBd0NRbUIsQ0F4Q1IsQ0FBQSxrQkFBQSxpQkFBQSxLQXNDTUEsQ0F0Q047QUFBQSxRQWdETVUsV0FBV0MsTUFBQTVCLHFEQUFBNkIsUUFBQUEsQ0FBQUEsQ0FBQUQsWUFBQUEsRUFBQUEsRUFBQUEsRUFBNEIsbUJBQTVCQSxDQWhEakI7QUFBQTtBQWtEQSxvQkFBc0JELFFBQVM7QUFDL0IsVUFBWWhCLEtBQUFtQixNQUFBQSxDQUFBQTtBQUNaO0FBQ0EsTUFyREE7QUFxQ0lkLE1BQUFBLENBQUFBLCtDQUFBQSxDQTVCQTtBQUFBLE1BaURBUSxVQUFJcEIsSUFBSm9CLFlBQUFBLDJCQUFBQSxpQkExREosRUEwRElBO0FBQUFBLFFBQUFBOztBQUFBQTtBQTFESjtBQUFBLFFBQUEsNERBQUE7QUFBQTtBQTBEbUIsUUFBQSxrQkExRG5CO0FBQUEsUUEyRE0sV0FBQVYsT0FBQUEsQ0FBTSxhQUFOQSxDQTNETjtBQTBESVUsTUFBQUEsQ0FBQUEsdUNBQUFBLENBakRBO0FBQUEsTUFzREEsT0FBQWxCLENBQUFBLFVBQUlGLElBQUpFLGtCQUFBQSxpQ0FBQUEsdUJBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLE9BQU9GLElBQUFNLE1BQUFBLENBQUFBLENBQUFxQixPQUFBQSxDQUFnQixJQUFoQkEsQ0FBQUMsTUFBQUEsQ0FBQUE7QUFEVDFCLE1BQUFBLENBQUFBLDRDQUFBQSxDQUFBQSx1QkF0REE7QUFGRmYsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFORkQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjk0NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImR4b3BhbC9pbWFnZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdkeG9wYWwvcmVtb3RlX3Jlc291cmNlJ1xuXG5tb2R1bGUgRFhPcGFsXG4gICMgUmVwcmVzZW50cyBhbiBpbWFnZVxuICAjIEVhY2ggaW5zdGFuY2Ugb2YgSW1hZ2UgaGFzIGl0cyBvd24gb2ZmLXNjcmVlbiBjYW52YXMuXG4gIGNsYXNzIEltYWdlIDwgUmVtb3RlUmVzb3VyY2VcbiAgICBSZW1vdGVSZXNvdXJjZS5hZGRfY2xhc3MoSW1hZ2UpXG5cbiAgICAjIENvbnZlcnQgSFNMIHRvIFJHQiAoRFhPcGFsIG9yaWdpbmFsOyBub3QgaW4gRFhSdWJ5KVxuICAgICMgaDogMC0zNTlcbiAgICAjIHM6IDAtMTAwXG4gICAgIyBsOiAwLTEwMFxuICAgIGRlZiBzZWxmLmhzbDJyZ2IoaCwgcywgbClcbiAgICAgIGlmIGwgPCA1MFxuICAgICAgICBtYXggPSAyLjU1ICogKGwgKyBsKihzLzEwMC4wKSlcbiAgICAgICAgbWluID0gMi41NSAqIChsIC0gbCoocy8xMDAuMCkpXG4gICAgICBlbHNlXG4gICAgICAgIG1heCA9IDIuNTUgKiAobCArICgxMDAtbCkqKHMvMTAwLjApKVxuICAgICAgICBtaW4gPSAyLjU1ICogKGwgLSAoMTAwLWwpKihzLzEwMC4wKSlcbiAgICAgIGVuZFxuICAgICAgY2FzZSBoXG4gICAgICB3aGVuIDAuLi42MFxuICAgICAgICBbbWF4LCAoaC82MC4wKSoobWF4LW1pbikgKyBtaW4sIG1pbl1cbiAgICAgIHdoZW4gNjAuLi4xMjBcbiAgICAgICAgWygoMTIwLWgpLzYwLjApKihtYXgtbWluKSArIG1pbiwgbWF4LCBtaW5dXG4gICAgICB3aGVuIDEyMC4uLjE4MFxuICAgICAgICBbbWluLCBtYXgsICgoaC0xMjApLzYwLjApKihtYXgtbWluKSArIG1pbl1cbiAgICAgIHdoZW4gMTgwLi4uMjQwXG4gICAgICAgIFttaW4sICgoMjQwLWgpLzYwLjApKihtYXgtbWluKSArIG1pbiwgbWF4XVxuICAgICAgd2hlbiAyNDAuLi4zMDBcbiAgICAgICAgWygoaC0yNDApLzYwLjApKihtYXgtbWluKSArIG1pbiwgbWluLCBtYXhdXG4gICAgICBlbHNlXG4gICAgICAgIFttYXgsIG1pbiwgKCgzNjAtaCkvNjAuMCkqKG1heC1taW4pICsgbWluXVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIExvYWQgcmVtb3RlIGltYWdlIChjYWxsZWQgdmlhIFdpbmRvdy5sb2FkX3Jlc291cmNlcylcbiAgICBkZWYgc2VsZi5fbG9hZChwYXRoX29yX3VybClcbiAgICAgIHJhd19pbWcgPSBgbmV3IEltYWdlKClgXG4gICAgICBpbWdfcHJvbWlzZSA9ICV4e1xuICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByYXdfaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShyYXdfaW1nKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJhd19pbWcuc3JjID0gcGF0aF9vcl91cmw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpbWcgPSBuZXcoMCwgMClcbiAgICAgICV4e1xuICAgICAgICAje2ltZ19wcm9taXNlfS50aGVuKGZ1bmN0aW9uKHJhd19pbWcpe1xuICAgICAgICAgIGltZy4kX3Jlc2l6ZShyYXdfaW1nLndpZHRoLCByYXdfaW1nLmhlaWdodCk7XG4gICAgICAgICAgaW1nLiRfZHJhd19yYXdfaW1hZ2UoMCwgMCwgcmF3X2ltZyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGltZywgaW1nX3Byb21pc2VcbiAgICBlbmRcblxuICAgIGF0dHJfYWNjZXNzb3IgOnByb21pc2UsIDpsb2FkZWRcbiAgICBkZWYgbG9hZGVkPzsgbG9hZGVkOyBlbmRcblxuICAgIGRlZiBzZWxmLmxvYWQocGF0aF9vcl91cmwpXG4gICAgICByZXR1cm4gbmV3KDEsIDEpLmxvYWQocGF0aF9vcl91cmwpXG4gICAgZW5kXG5cbiAgICBkZWYgbG9hZChwYXRoX29yX3VybClcbiAgICAgIHJhd19pbWcgPSBgbmV3IEltYWdlKClgXG4gICAgICBAcHJvbWlzZSA9ICV4e1xuICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByYXdfaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi4kX3Jlc2l6ZShyYXdfaW1nLndpZHRoLCByYXdfaW1nLmhlaWdodCk7XG4gICAgICAgICAgICBzZWxmLiRfZHJhd19yYXdfaW1hZ2UoMCwgMCwgcmF3X2ltZyk7XG4gICAgICAgICAgICBzZWxmLmxvYWRlZCA9ICN7dHJ1ZX07XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByYXdfaW1nLnNyYyA9IHBhdGhfb3JfdXJsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgb25sb2FkKCZibG9jaylcbiAgICAgICV4e1xuICAgICAgICAje0Bwcm9taXNlfS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICAgICAgICAje2Jsb2NrLmNhbGwoKX1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICAjIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBJbWFnZVxuICAgIGRlZiBpbml0aWFsaXplKHdpZHRoLCBoZWlnaHQsIGNvbG9yPUNfREVGQVVMVCwgY2FudmFzOiBuaWwpXG4gICAgICBAd2lkdGgsIEBoZWlnaHQgPSB3aWR0aCwgaGVpZ2h0XG4gICAgICBAY2FudmFzID0gY2FudmFzIHx8IGBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpYFxuICAgICAgQGN0eCA9IGAje0BjYW52YXN9LmdldENvbnRleHQoJzJkJylgXG4gICAgICBfcmVzaXplKEB3aWR0aCwgQGhlaWdodClcbiAgICAgIGJveF9maWxsKDAsIDAsIEB3aWR0aCwgQGhlaWdodCwgY29sb3IpXG4gICAgZW5kXG4gICAgYXR0cl9yZWFkZXIgOmN0eCwgOmNhbnZhcywgOndpZHRoLCA6aGVpZ2h0XG5cbiAgICAjIFNldCBzaXplIG9mIHRoaXMgaW1hZ2VcbiAgICBkZWYgX3Jlc2l6ZSh3LCBoKVxuICAgICAgQHdpZHRoLCBAaGVpZ2h0ID0gdywgaFxuICAgICAgJXh7XG4gICAgICAgICN7QGNhbnZhc30ud2lkdGggPSB3O1xuICAgICAgICAje0BjYW52YXN9LmhlaWdodCA9IGg7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICAjIERyYXcgYW4gSW1hZ2Ugb24gdGhpcyBpbWFnZVxuICAgIGRlZiBkcmF3KHgsIHksIGltYWdlKVxuICAgICAgJXh7XG4gICAgICAgICN7QGN0eH0uZHJhd0ltYWdlKCN7aW1hZ2UuY2FudmFzfSwgeCwgeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZlxuICAgIGVuZFxuXG4gICAgIyBEcmF3IGFuIEltYWdlIG9uIHRoaXMgaW1hZ2Ugd2l0aCBzY2FsaW5nXG4gICAgIyAtIHNjYWxlX3gsIHNjYWxlX3k6IHNjYWxpbmcgZmFjdG9yIChlZy4gMS41KVxuICAgICMgLSBjZW50ZXJfeCwgY2VudGVyX3k6IHNjYWxpbmcgY2VudGVyIChpbiBvdGhlciB3b3JkcywgdGhlIHBvaW50XG4gICAgIyAgIHdoaWNoIGRvZXMgbm90IG1vdmUgYnkgdGhpcyBzY2FsaW5nLiBEZWZhdWx0OiBpbWFnZSBjZW50ZXIpXG4gICAgZGVmIGRyYXdfc2NhbGUoeCwgeSwgaW1hZ2UsIHNjYWxlX3gsIHNjYWxlX3ksIGNlbnRlcl94PW5pbCwgY2VudGVyX3k9bmlsKVxuICAgICAgZHJhd19leCh4LCB5LCBpbWFnZSwgc2NhbGVfeDogc2NhbGVfeCwgc2NhbGVfeTogc2NhbGVfeSwgY2VudGVyX3g6IGNlbnRlcl94LCBjZW50ZXJfeTogY2VudGVyX3kpXG4gICAgZW5kXG5cbiAgICAjIERyYXcgYW4gSW1hZ2Ugb24gdGhpcyBpbWFnZSB3aXRoIHJvdGF0aW9uXG4gICAgIyAtIGFuZ2xlOiBSb3RhdGlvbiBhbmdsZSAocmFkaWFuKVxuICAgICMgLSBjZW50ZXJfeCwgY2VudGVyX3k6IFJvdGF0aW9uIGNlbnRlciBpbiB0aGUgYGltYWdlYCAoZGVmYXVsdDogY2VudGVyIG9mIHRoZSBgaW1hZ2VgKVxuICAgIGRlZiBkcmF3X3JvdCh4LCB5LCBpbWFnZSwgYW5nbGUsIGNlbnRlcl94PW5pbCwgY2VudGVyX3k9bmlsKVxuICAgICAgZHJhd19leCh4LCB5LCBpbWFnZSwgYW5nbGU6IGFuZ2xlLCBjZW50ZXJfeDogY2VudGVyX3gsIGNlbnRlcl95OiBjZW50ZXJfeSlcbiAgICBlbmRcblxuICAgIEJMRU5EX1RZUEVTID0ge1xuICAgICAgYWxwaGE6IFwic291cmNlLW92ZXJcIiwgIyBBIG92ZXIgQiAoRGVmYXVsdClcbiAgICAgIGFkZDogICBcImxpZ2h0ZXJcIiAgICAgICMgQSArIEJcbiAgICB9XG5cbiAgICBkZWYgZHJhd19leCh4LCB5LCBpbWFnZSwgb3B0aW9ucz17fSlcbiAgICAgIHNjYWxlX3ggPSBvcHRpb25zWzpzY2FsZV94XSB8fCAxXG4gICAgICBzY2FsZV95ID0gb3B0aW9uc1s6c2NhbGVfeV0gfHwgMVxuICAgICAgY2VudGVyX3ggPSBvcHRpb25zWzpjZW50ZXJfeF0gfHwgaW1hZ2Uud2lkdGgvMlxuICAgICAgY2VudGVyX3kgPSBvcHRpb25zWzpjZW50ZXJfeV0gfHwgaW1hZ2UuaGVpZ2h0LzIgXG4gICAgICBhbHBoYSA9IG9wdGlvbnNbOmFscGhhXSB8fCAyNTVcbiAgICAgIGJsZW5kID0gb3B0aW9uc1s6YmxlbmRdIHx8IDphbHBoYVxuICAgICAgYW5nbGUgPSBvcHRpb25zWzphbmdsZV0gfHwgMFxuXG4gICAgICBjeCA9IHggKyBjZW50ZXJfeFxuICAgICAgY3kgPSB5ICsgY2VudGVyX3lcbiAgICAgICV4e1xuICAgICAgICAje0BjdHh9LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICAje0BjdHh9LnJvdGF0ZShhbmdsZSAqIE1hdGguUEkgLyAxODAuMCk7XG4gICAgICAgICN7QGN0eH0uc2NhbGUoc2NhbGVfeCwgc2NhbGVfeSk7XG4gICAgICAgICN7QGN0eH0uc2F2ZSgpO1xuICAgICAgICAje0BjdHh9Lmdsb2JhbEFscGhhID0gYWxwaGEgLyAyNTU7XG4gICAgICAgICN7QGN0eH0uZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gI3tCTEVORF9UWVBFU1tibGVuZF19O1xuICAgICAgICAje0BjdHh9LmRyYXdJbWFnZSgje2ltYWdlLmNhbnZhc30sIHgtY3gsIHktY3kpO1xuICAgICAgICAje0BjdHh9LnJlc3RvcmUoKTtcbiAgICAgICAgI3tAY3R4fS5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7IC8vIHJlc2V0XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZlxuICAgIGVuZFxuXG4gICAgIyBEcmF3IHNvbWUgdGV4dCBvbiB0aGlzIGltYWdlXG4gICAgZGVmIGRyYXdfZm9udCh4LCB5LCBzdHJpbmcsIGZvbnQsIGNvbG9yPVsyNTUsMjU1LDI1NV0pXG4gICAgICBjdHggPSBAY3R4XG4gICAgICAleHtcbiAgICAgICAgY3R4LmZvbnQgPSAje2ZvbnQuX3NwZWNfc3RyfTtcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gI3tfcmdiYShjb2xvcil9O1xuICAgICAgICBjdHguZmlsbFRleHQoc3RyaW5nLCB4LCB5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmXG4gICAgZW5kXG5cbiAgICAjIEdldCBhIHBpeGVsIGFzIEFSR0IgYXJyYXlcbiAgICBkZWYgW10oeCwgeSlcbiAgICAgIGN0eCA9IEBjdHhcbiAgICAgIHJldCA9IG5pbFxuICAgICAgJXh7XG4gICAgICAgIHZhciBwaXhlbCA9IGN0eC5nZXRJbWFnZURhdGEoeCwgeSwgMSwgMSk7XG4gICAgICAgIHZhciByZ2JhID0gcGl4ZWwuZGF0YTtcbiAgICAgICAgcmV0ID0gW3JnYmFbM10sIHJnYmFbMF0sIHJnYmFbMV0sIHJnYmFbMl1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldFxuICAgIGVuZFxuXG4gICAgIyBQdXQgYSBwaXhlbCBvbiB0aGlzIGltYWdlXG4gICAgZGVmIFtdPSh4LCB5LCBjb2xvcilcbiAgICAgIGJveF9maWxsKHgsIHksIHgrMSwgeSsxLCBjb2xvcilcbiAgICBlbmRcblxuICAgICMgUmV0dXJuIHRydWUgaWYgdGhlIHBpeGVsIGF0IGAoeCwgeSlgIGhhcyB0aGUgYGNvbG9yYFxuICAgIGRlZiBjb21wYXJlKHgsIHksIGNvbG9yKVxuICAgICAgY3R4ID0gQGN0eFxuICAgICAgcmdiYTEgPSBfcmdiYV9hcnkoY29sb3IpXG4gICAgICByZ2JhMiA9IG5pbFxuICAgICAgcmV0ID0gbmlsXG4gICAgICAleHtcbiAgICAgICAgdmFyIHBpeGVsID0gY3R4LmdldEltYWdlRGF0YSh4LCB5LCAxLCAxKTtcbiAgICAgICAgcmdiYTIgPSBwaXhlbC5kYXRhO1xuICAgICAgICAvLyBUT0RPOiB3aGF0IGlzIHRoZSByaWdodCB3YXkgdG8gY29tcGFyZSBhbiBBcnJheSBhbmQgYW4gVWludDhDbGFtcGVkQXJyYXk/XG4gICAgICAgIHJldCA9IHJnYmExWzBdID09IHJnYmEyWzBdICYmXG4gICAgICAgICAgICAgIHJnYmExWzFdID09IHJnYmEyWzFdICYmXG4gICAgICAgICAgICAgIHJnYmExWzJdID09IHJnYmEyWzJdICYmXG4gICAgICAgICAgICAgIHJnYmExWzNdID09IHJnYmEyWzNdXG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0XG4gICAgZW5kXG5cbiAgICAjIERyYXcgYSBsaW5lIG9uIHRoaXMgaW1hZ2VcbiAgICBkZWYgbGluZSh4MSwgeTEsIHgyLCB5MiwgY29sb3IpXG4gICAgICBjdHggPSBAY3R4XG4gICAgICAleHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAje19yZ2JhKGNvbG9yKX07XG4gICAgICAgIGN0eC5tb3ZlVG8oeDErMC41LCB5MSswLjUpOyBcbiAgICAgICAgY3R4LmxpbmVUbyh4MiswLjUsIHkyKzAuNSk7IFxuICAgICAgICBjdHguc3Ryb2tlKCk7IFxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGZcbiAgICBlbmRcblxuICAgICMgRHJhdyBhIHJlY3RhbmdsZSBvbiB0aGlzIGltYWdlXG4gICAgZGVmIGJveCh4MSwgeTEsIHgyLCB5MiwgY29sb3IpXG4gICAgICBjdHggPSBAY3R4XG4gICAgICAleHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAje19yZ2JhKGNvbG9yKX07XG4gICAgICAgIGN0eC5yZWN0KHgxKzAuNSwgeTErMC41LCB4Mi14MSwgeTIteTEpOyBcbiAgICAgICAgY3R4LnN0cm9rZSgpOyBcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmXG4gICAgZW5kXG5cbiAgICAjIERyYXcgYSBmaWxsZWQgYm94IG9uIHRoaXMgaW1hZ2VcbiAgICBkZWYgYm94X2ZpbGwoeDEsIHkxLCB4MiwgeTIsIGNvbG9yKVxuICAgICAgY3R4ID0gQGN0eFxuICAgICAgJXh7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICN7X3JnYmEoY29sb3IpfTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KHgxLCB5MSwgeDIteDEsIHkyLXkxKTsgXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZlxuICAgIGVuZFxuXG4gICAgIyBEcmF3IGEgY2lyY2xlIG9uIHRoaXMgaW1hZ2VcbiAgICBkZWYgY2lyY2xlKHgsIHksIHIsIGNvbG9yKVxuICAgICAgY3R4ID0gQGN0eFxuICAgICAgJXh7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gI3tfcmdiYShjb2xvcil9O1xuICAgICAgICBjdHguYXJjKHgrMC41LCB5KzAuNSwgciwgMCwgTWF0aC5QSSoyLCBmYWxzZSlcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGZcbiAgICBlbmRcblxuICAgICMgRHJhdyBhIGZpbGxlZCBjaXJjbGUgb24gdGhpcyBpbWFnZVxuICAgIGRlZiBjaXJjbGVfZmlsbCh4LCB5LCByLCBjb2xvcilcbiAgICAgIGN0eCA9IEBjdHhcbiAgICAgICV4e1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAje19yZ2JhKGNvbG9yKX07XG4gICAgICAgIGN0eC5hcmMoeCwgeSwgciwgMCwgTWF0aC5QSSoyLCBmYWxzZSlcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmXG4gICAgZW5kXG5cbiAgICAjIERyYXcgYSB0cmlhbmdsZSBvbiB0aGlzIGltYWdlXG4gICAgZGVmIHRyaWFuZ2xlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIGNvbG9yKVxuICAgICAgY3R4ID0gQGN0eFxuICAgICAgJXh7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gI3tfcmdiYShjb2xvcil9O1xuICAgICAgICBjdHgubW92ZVRvKHgxKzAuNSwgeTErMC41KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4MiswLjUsIHkyKzAuNSk7XG4gICAgICAgIGN0eC5saW5lVG8oeDMrMC41LCB5MyswLjUpO1xuICAgICAgICBjdHgubGluZVRvKHgxKzAuNSwgeTErMC41KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGZcbiAgICBlbmRcblxuICAgICMgRHJhdyBhIGZpbGxlZCB0cmlhbmdsZSBvbiB0aGlzIGltYWdlXG4gICAgZGVmIHRyaWFuZ2xlX2ZpbGwoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgY29sb3IpXG4gICAgICBjdHggPSBAY3R4XG4gICAgICAleHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gI3tfcmdiYShjb2xvcil9O1xuICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4MywgeTMpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGZcbiAgICBlbmRcblxuICAgICMgRmlsbCB0aGlzIGltYWdlIHdpdGggYGNvbG9yYFxuICAgIGRlZiBmaWxsKGNvbG9yKVxuICAgICAgYm94X2ZpbGwoMCwgMCwgQHdpZHRoLTEsIEBoZWlnaHQtMSwgY29sb3IpXG4gICAgZW5kXG5cbiAgICAjIENsZWFyIHRoaXMgaW1hZ2UgKGkuZS4gZmlsbCB3aXRoIGBbMCwwLDAsMF1gKVxuICAgIGRlZiBjbGVhclxuICAgICAgZmlsbChbMCwgMCwgMCwgMF0pXG4gICAgZW5kXG5cbiAgICAjIFJldHVybiBhbiBJbWFnZSB3aGljaCBpcyBhIGNvcHkgb2YgdGhlIHNwZWNpZmllZCBhcmVhXG4gICAgZGVmIHNsaWNlKHgsIHksIHdpZHRoLCBoZWlnaHQpXG4gICAgICBuZXdpbWcgPSBJbWFnZS5uZXcod2lkdGgsIGhlaWdodClcbiAgICAgIGRhdGEgPSBfaW1hZ2VfZGF0YSh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgbmV3aW1nLl9wdXRfaW1hZ2VfZGF0YShkYXRhKVxuICAgICAgcmV0dXJuIG5ld2ltZ1xuICAgIGVuZFxuXG4gICAgIyBTbGljZSB0aGlzIGltYWdlIGludG8geGNvdW50Knljb3VudCB0aWxlc1xuICAgIGRlZiBzbGljZV90aWxlcyh4Y291bnQsIHljb3VudClcbiAgICAgIHRpbGVfdyA9IEB3aWR0aCAvIHhjb3VudFxuICAgICAgdGlsZV9oID0gQGhlaWdodCAvIHljb3VudFxuICAgICAgcmV0dXJuICgwLi4ueWNvdW50KS5mbGF0X21hcHt8dnxcbiAgICAgICAgKDAuLi54Y291bnQpLm1hcHt8dXxcbiAgICAgICAgICBzbGljZSh0aWxlX3cgKiB1LCB0aWxlX2ggKiB2LCB0aWxlX3csIHRpbGVfaClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgIyBTZXQgYWxwaGEgb2YgdGhlIHBpeGVscyBvZiB0aGUgZ2l2ZW4gY29sb3IgdG8gMFxuICAgICMgLSBjb2xvciA6IFJHQiBjb2xvciAoSWYgQVJHViBjb2xvciBpcyBnaXZlbiwgQSBpcyBqdXN0IGlnbm9yZWQpXG4gICAgZGVmIHNldF9jb2xvcl9rZXkoY29sb3IpXG4gICAgICByLCBnLCBiLCBfID0gX3JnYmFfYXJ5KGNvbG9yKVxuICAgICAgZGF0YSA9IF9pbWFnZV9kYXRhKClcbiAgICAgICV4e1xuICAgICAgICB2YXIgYnVmID0gZGF0YS5kYXRhO1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDQpe1xuICAgICAgICAgIGlmIChidWZbaV0gPT0gciAmJiBidWZbaSsxXSA9PSBnICYmIGJ1ZltpKzJdID09IGIpIHtcbiAgICAgICAgICAgIGJ1ZltpKzNdID0gMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3B1dF9pbWFnZV9kYXRhKGRhdGEpXG4gICAgZW5kXG5cbiAgICAjIENvcHkgYW4gPGltZz4gb250byB0aGlzIGltYWdlXG4gICAgZGVmIF9kcmF3X3Jhd19pbWFnZSh4LCB5LCByYXdfaW1nKVxuICAgICAgJXh7XG4gICAgICAgICN7QGN0eH0uZHJhd0ltYWdlKCN7cmF3X2ltZ30sIHgsIHkpO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm4gLmdldEltYWdlRGF0YVxuICAgIGRlZiBfaW1hZ2VfZGF0YSh4PTAsIHk9MCwgdz1Ad2lkdGgsIGg9QGhlaWdodClcbiAgICAgIHJldHVybiBgI3tAY3R4fS5nZXRJbWFnZURhdGEoeCwgeSwgdywgaClgXG4gICAgZW5kXG5cbiAgICAjIENhbGwgLnB1dEltYWdlRGF0YVxuICAgIGRlZiBfcHV0X2ltYWdlX2RhdGEoaW1hZ2VfZGF0YSwgeD0wLCB5PTApXG4gICAgICBgI3tAY3R4fS5wdXRJbWFnZURhdGEoaW1hZ2VfZGF0YSwgeCwgeSlgXG4gICAgZW5kXG5cbiAgICAjIFJldHVybiBhIHN0cmluZyBsaWtlICdyZ2IoMjU1LCAyNTUsIDI1NSknXG4gICAgIyBgY29sb3JgIGlzIDMgb3IgNCBudW1iZXJzXG4gICAgZGVmIF9yZ2IoY29sb3IpXG4gICAgICBjYXNlIGNvbG9yLmxlbmd0aFxuICAgICAgd2hlbiA0XG4gICAgICAgICMgSnVzdCBpZ25vcmUgYWxwaGFcbiAgICAgICAgcmdiID0gY29sb3JbMSwgM11cbiAgICAgIHdoZW4gM1xuICAgICAgICByZ2IgPSBjb2xvclxuICAgICAgZWxzZVxuICAgICAgICByYWlzZSBcImludmFsaWQgY29sb3I6ICN7Y29sb3IuaW5zcGVjdH1cIlxuICAgICAgZW5kXG4gICAgICByZXR1cm4gXCJyZ2IoXCIgKyByZ2Iuam9pbignLCAnKSArIFwiKVwiO1xuICAgIGVuZFxuXG4gICAgIyBSZXR1cm4gYSBzdHJpbmcgbGlrZSAncmdiYSgyNTUsIDI1NSwgMjU1LCAxMjgpJ1xuICAgICMgYGNvbG9yYCBpcyAzIG9yIDQgbnVtYmVyc1xuICAgIGRlZiBfcmdiYShjb2xvcilcbiAgICAgIHJldHVybiBcInJnYmEoXCIgKyBfcmdiYV9hcnkoY29sb3IpLmpvaW4oJywgJykgKyBcIilcIlxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm4gYW4gYXJyYXkgbGlrZSBgWzI1NSwgMjU1LCAyNTUsIDEyOF1gXG4gICAgZGVmIF9yZ2JhX2FyeShjb2xvcilcbiAgICAgIGNhc2UgY29sb3IubGVuZ3RoXG4gICAgICB3aGVuIDRcbiAgICAgICAgIyBjb2xvciBpcyBBUkdCIGluIERYUnVieSwgc28gbW92ZSBBIHRvIHRoZSBsYXN0XG4gICAgICAgIGNvbG9yWzEsIDNdICsgW2NvbG9yWzBdLzI1NS4wXVxuICAgICAgd2hlbiAzXG4gICAgICAgICMgQ29tcGxlbWVudCAyNTUgYXMgYWxwaGEgXG4gICAgICAgIGNvbG9yICsgWzEuMF1cbiAgICAgIGVsc2VcbiAgICAgICAgcmFpc2UgXCJpbnZhbGlkIGNvbG9yOiAje2NvbG9yLmluc3BlY3R9XCJcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJtb2R1bGUiLCJjbGFzcyIsImFkZF9jbGFzcyIsImhzbDJyZ2IiLCJzZWxmIiwiPCIsImwiLCI1MCIsIm1heCIsIioiLCIrIiwiLyIsInMiLCJtaW4iLCItIiwiMTAwIiwiaCIsIjAiLCI2MCIsIjEyMCIsIjE4MCIsIjI0MCIsIjMwMCIsIjM2MCIsIl9sb2FkIiwicmF3X2ltZyIsImltZ19wcm9taXNlIiwiaW1nIiwibmV3IiwiYXR0cl9hY2Nlc3NvciIsImxvYWRlZD8iLCJsb2FkZWQiLCJsb2FkIiwiMSIsInBhdGhfb3JfdXJsIiwiQHByb21pc2UiLCJvbmxvYWQiLCJibG9jayIsImNhbGwiLCJpbml0aWFsaXplIiwid2lkdGgiLCJoZWlnaHQiLCJAd2lkdGgiLCJAaGVpZ2h0IiwiQGNhbnZhcyIsIiRyZXRfb3JfMSIsImNhbnZhcyIsIkBjdHgiLCJfcmVzaXplIiwiYm94X2ZpbGwiLCJjb2xvciIsImF0dHJfcmVhZGVyIiwidyIsImRyYXciLCJpbWFnZSIsImRyYXdfc2NhbGUiLCJkcmF3X2V4IiwieCIsInkiLCJzY2FsZV94Iiwic2NhbGVfeSIsImNlbnRlcl94IiwiY2VudGVyX3kiLCJkcmF3X3JvdCIsImFuZ2xlIiwiJHJldF9vcl8yIiwib3B0aW9ucyIsIltdIiwiJHJldF9vcl8zIiwiJHJldF9vcl80IiwiMiIsIiRyZXRfb3JfNSIsImFscGhhIiwiJHJldF9vcl82IiwiMjU1IiwiYmxlbmQiLCIkcmV0X29yXzciLCIkcmV0X29yXzgiLCJjeCIsImN5IiwiZHJhd19mb250IiwiY3R4IiwiZm9udCIsIl9zcGVjX3N0ciIsIl9yZ2JhIiwicmV0IiwiW109IiwiY29tcGFyZSIsInJnYmExIiwiX3JnYmFfYXJ5IiwicmdiYTIiLCJsaW5lIiwiYm94IiwiY2lyY2xlIiwiY2lyY2xlX2ZpbGwiLCJ0cmlhbmdsZSIsInRyaWFuZ2xlX2ZpbGwiLCJmaWxsIiwiY2xlYXIiLCJzbGljZSIsIm5ld2ltZyIsImRhdGEiLCJfaW1hZ2VfZGF0YSIsIl9wdXRfaW1hZ2VfZGF0YSIsInNsaWNlX3RpbGVzIiwidGlsZV93IiwieGNvdW50IiwidGlsZV9oIiwieWNvdW50IiwiZmxhdF9tYXAiLCJtYXAiLCJ1IiwidiIsInNldF9jb2xvcl9rZXkiLCJyIiwiZyIsImIiLCJfIiwiX2RyYXdfcmF3X2ltYWdlIiwiX3JnYiIsImxlbmd0aCIsIjQiLCJyZ2IiLCIzIiwicmFpc2UiLCJpbnNwZWN0Iiwiam9pbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSx3QkFBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUdFLE9BQUFDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxNQUFBLDhCQUFBQyxXQUFBQSxDQUF5QixxQkFBekJBLENBQUE7QUFBQSxNQU1BQyxVQUFJQyxJQUFKRCxjQUFBQSxtQkFBQUEsbUJBQWlCLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBdkJBO0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUEsSUFBQSxRQUFHRSxPQUFBQyxDQUFBRCxFQUFJRSxFQUFKRixDQUFILENBQUE7QUFBQTtBQUNFLFVBQUFHLE1BQU1DLFVBQUEsSUFBQUEsRUFBUUMsU0FBQUosQ0FBQUksRUFBSUQsVUFBQUgsQ0FBQUcsRUFBR0UsV0FBQUMsQ0FBQUQsRUFBRSxLQUFGQSxDQUFIRixDQUFKQyxDQUFSRCxDQUFOO0FBQUEsVUFDQUksTUFBTUosVUFBQSxJQUFBQSxFQUFRSyxVQUFBUixDQUFBUSxFQUFJTCxV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VStFLFdBQUFBLENBQVV2QyxLQUFWdUMsQ0FBQXFDLE1BQUFBLENBQXNCLElBQXRCQSxDQUFWcEgsQ0FBQUEsRUFBd0MsR0FBeENBO0FBRFQwRSxNQUFBQSxDQUFBQSw2QkFBQUEsQ0FuWEE7QUFBQSxNQXdYQSxPQUFBSyxDQUFBQSw2QkFBQUEsc0JBQUFBLHFCQUFjLEtBQWRBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLE9BQUEsYUFBQSxRQUFLdkMsS0FBQXNFLFFBQUFBLENBQUFBLENBQUw7QUFBQSxRQUNBLElBQUtDLENBQUFBLENBQUFBLGdCQUFMLEdBRUUsT0FBQS9HLFNBQUF3QyxLQUFBaUIsT0FBQUEsQ0FBTWxDLEdBQUcwRixDQUFUeEQsQ0FBQXpELEVBQWMsQ0FBQ0MsV0FBQXVDLEtBQUFpQixPQUFBQSxDQUFNbEQsQ0FBTmtELENBQUF4RCxFQUFTLEtBQVRBLENBQUQsQ0FBZEQsQ0FGRjtBQURBLFFBQUEsS0FJQSxJQUFLaUgsQ0FBQUEsQ0FBQUEsZ0JBQUwsR0FFRSxPQUFBakgsU0FBQXdDLEtBQUF4QyxFQUFRLENBQUMsR0FBRCxDQUFSQSxDQUZGO0FBSkEsUUFBQSxNQVFFLFdBQUFrSCxPQUFBQSxDQUFNLEVBQUEsR0FBQSxpQkFBQSxHQUFBLENBQWtCMUUsS0FBQTJFLFNBQUFBLENBQUFBLENBQWxCLENBQU5ELENBUkYsQ0FBQTtBQURGbkMsTUFBQUEsQ0FBQUEsaUNBQUFBLENBQUFBLHFCQXhYQTtBQURGeEYsSUFBQUEsR0FBQUEsV0FBQUEsRUFBYyw4QkFBZEE7QUFIRkQsRUFBQUEsR0FBQUEsV0FBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3NTE3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZHhvcGFsL3NvdW5kLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2R4b3BhbC9yZW1vdGVfcmVzb3VyY2UnXG5cbm1vZHVsZSBEWE9wYWxcbiAgY2xhc3MgU291bmQgPCBSZW1vdGVSZXNvdXJjZVxuICAgIFJlbW90ZVJlc291cmNlLmFkZF9jbGFzcyhTb3VuZClcblxuICAgICMgUmV0dXJuIEF1ZGlvQ29udGV4dFxuICAgIGRlZiBzZWxmLmF1ZGlvX2NvbnRleHRcbiAgICAgIEBAYXVkaW9fY29udGV4dCB8fD0gJXh7XG4gICAgICAgIG5ldyAod2luZG93LkF1ZGlvQ29udGV4dHx8d2luZG93LndlYmtpdEF1ZGlvQ29udGV4dClcbiAgICAgIH1cbiAgICBlbmRcblxuICAgICMgTG9hZCByZW1vdGUgc291bmQgKGNhbGxlZCB2aWEgV2luZG93LmxvYWRfcmVzb3VyY2VzKVxuICAgIGRlZiBzZWxmLl9sb2FkKHBhdGhfb3JfdXJsKVxuICAgICAgc25kID0gbmV3KHBhdGhfb3JfdXJsKVxuICAgICAgc25kX3Byb21pc2UgPSAleHtcbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsICN7cGF0aF9vcl91cmx9LCB0cnVlKTtcbiAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhdWRpb0RhdGEgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSAje1NvdW5kLmF1ZGlvX2NvbnRleHR9O1xuICAgICAgICAgICAgY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoYXVkaW9EYXRhLCBmdW5jdGlvbihkZWNvZGVkKSB7XG4gICAgICAgICAgICAgIHNuZFsnJGRlY29kZWQ9J10oZGVjb2RlZCk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNuZCwgc25kX3Byb21pc2VcbiAgICBlbmRcblxuICAgIGRlZiBpbml0aWFsaXplKHBhdGhfb3JfdXJsKVxuICAgICAgQHBhdGhfb3JfdXJsID0gcGF0aF9vcl91cmwgICMgVXNlZCBpbiBlcnJvciBtZXNzYWdlXG4gICAgZW5kXG4gICAgYXR0cl9hY2Nlc3NvciA6ZGVjb2RlZFxuXG4gICAgIyBQbGF5IHRoaXMgc291bmQgb25jZVxuICAgIGRlZiBwbGF5XG4gICAgICByYWlzZSBcIlNvdW5kICN7cGF0aF9vcl91cmx9IGlzIG5vdCBsb2FkZWQgeWV0XCIgdW5sZXNzIEBkZWNvZGVkXG4gICAgICBzb3VyY2UgPSBuaWxcbiAgICAgICV4e1xuICAgICAgICB2YXIgY29udGV4dCA9ICN7U291bmQuYXVkaW9fY29udGV4dH07XG4gICAgICAgIHNvdXJjZSA9IGNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICAgIHNvdXJjZS5idWZmZXIgPSAje0BkZWNvZGVkfTtcbiAgICAgICAgc291cmNlLmNvbm5lY3QoY29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgIHNvdXJjZS5zdGFydCgwKTsgXG4gICAgICB9XG4gICAgICBAc291cmNlID0gc291cmNlXG4gICAgZW5kXG5cbiAgICAjIFN0b3AgcGxheWluZyB0aGlzIHNvdW5kIChpZiBwbGF5aW5nKVxuICAgIGRlZiBzdG9wXG4gICAgICByZXR1cm4gdW5sZXNzIEBkZWNvZGVkIFxuICAgICAgcmV0dXJuIHVubGVzcyBAc291cmNlXG4gICAgICBAc291cmNlLkpTLnN0b3AoKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJtb2R1bGUiLCJjbGFzcyIsImFkZF9jbGFzcyIsImF1ZGlvX2NvbnRleHQiLCJzZWxmIiwiQEBhdWRpb19jb250ZXh0IiwiJHJldF9vcl8xIiwiX2xvYWQiLCJzbmQiLCJuZXciLCJwYXRoX29yX3VybCIsInNuZF9wcm9taXNlIiwiaW5pdGlhbGl6ZSIsIkBwYXRoX29yX3VybCIsImF0dHJfYWNjZXNzb3IiLCJwbGF5IiwiQGRlY29kZWQiLCJyYWlzZSIsInNvdXJjZSIsIkBzb3VyY2UiLCJzdG9wIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLHdCQUFSQSxDQUFBO0FBQUEsRUFFQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsT0FBQUM7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQTtBQUFBQTtBQUNFLE1BQUEsOEJBQUFDLFdBQUFBLENBQXlCLHFCQUF6QkEsQ0FBQTtBQUFBLE1BR0FDLFVBQUlDLElBQUpELG9CQUFBQSx5QkFBQUEseUJBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLE9BQUFFLG9EQVROLGFBQUEsSUFBQSxRQUFBLENBQUEseURBQUEsMEJBQUEsQ0FBQTtBQUFBO0FBQUEsVUFBQSxJQUFBLFFBQUFDLENBQUFBLFlBU01ELDBEQVROQyxDQUFBLENBQUE7QUFBQSxZQUFBLE9BQUE7QUFBQSxVQUFBO0FBQUEsWUFTMEIsT0FDMUIsNERBRDBCO0FBVDFCLFVBQUEsQ0FBQTtBQUFBLFFBQUE7QUFBQSxVQVMwQixPQUMxQiw0REFEMEI7QUFUMUIsUUFBQSxDQUFBLGtCQVNNRDtBQURGRixNQUFBQSxDQUFBQSxvQ0FBQUEsQ0FIQTtBQUFBLE1BVUFJLFVBQUlILElBQUpHLFlBQUFBLGlCQUFBQSxpQkFBZSxXQUFmQTtBQUFBQSxRQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxVQUFNQyxLQUFBQSxDQUFJQyxXQUFKRCxDQUFOO0FBQUEsUUFDQUU7QUFDTjtBQUNBO0FBQ0EsOEJBQWdDRCxXQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDBCQUE0QixxQkFBQVAsZUFBQUEsQ0FBQUEsQ0FBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQWhCTTtBQUFBLFFBaUJBLFFBQU9LLEtBQUtHLFlBakJaO0FBREZKLE1BQUFBLENBQUFBLDRCQUFBQSxDQVZBO0FBQUE7QUErQkFLLE1BQUFBLDhCQUFBQSxzQkFBQUEsc0JBQWUsV0FBZkE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQ0UsT0FBQUMsQ0FBQUEsbUJBQWVILFdBQWZHO0FBREZELE1BQUFBLENBQUFBLGlDQUFBQSxDQS9CQTtBQUFBLFVBa0NBRSxlQUFBQSxDQUFjLFNBQWRBLENBbENBO0FBQUE7QUFxQ0FDLE1BQUFBLHdCQUFBQSxnQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUEsSUFBQSxRQUFzREMsWUFBdEQsQ0FBQTtBQUFBLFFBQUE7QUFBQSxjQUFBQyxPQUFBQSxDQUFNLEVBQUEsR0FBQSxRQUFBLEdBQUEsS0FBU1AsYUFBQUEsQ0FBQUEsQ0FBVCxDQUFBLEdBQUEsb0JBQU5PO0FBQUEsUUFBQSxDQUFBO0FBQUEsUUFDQUMsU0FBUyxHQURUO0FBQUE7QUFHTixzQkFBd0IscUJBQUFmLGVBQUFBLENBQUFBLENBQW9CO0FBQzVDO0FBQ0Esd0JBQTBCYSxZQUFTO0FBQ25DO0FBQ0E7QUFDQSxNQVJNO0FBQUEsUUFTQSxPQUFBRyxDQUFBQSxjQUFVRCxNQUFWQyxDQVRBO0FBREZKLE1BQUFBLENBQUFBLDJCQUFBQSxDQXJDQTtBQUFBLE1BbURBLE9BQUFLLENBQUFBLHdCQUFBQSxnQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUEsSUFBQSxRQUFjSixZQUFkLENBQUE7QUFBQSxRQUFBO0FBQUEsVUFBQTtBQUFBLFFBQUEsQ0FBQTtBQUFBLFFBQ0EsSUFBQSxRQUFjRyxXQUFkLENBQUE7QUFBQSxRQUFBO0FBQUEsVUFBQTtBQUFBLFFBQUEsQ0FEQTtBQUFBLFFBRUEsT0FBQUEsV0FBQSxLQUFBLENBQUEsQ0FGQTtBQURGQyxNQUFBQSxDQUFBQSwyQkFBQUEsQ0FBQUEsZ0JBbkRBO0FBREZuQixJQUFBQSxHQUFBQSxXQUFBQSxFQUFjLDhCQUFkQTtBQURGRCxFQUFBQSxHQUFBQSxXQUFBQSxXQUZBOzsifX0seyJvZmZzZXQiOnsibGluZSI6Mjc2MTgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJkeG9wYWwvc291bmRfZWZmZWN0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBEWE9wYWxcbiAgIyBVc2VyLWdlbmVyYXRlZCBzb3VuZFxuICAjXG4gICMgRXhhbXBsZTpcbiAgIyAgIHYgPSA4MFxuICAjICAgU291bmRFZmZlY3QucmVnaXN0ZXIoOnNvdW5kMSwgNDAwMCwgV0FWRV9SRUNULCA1MDAwKSBkb1xuICAjICAgICB2ID0gdiAtIDAuMDNcbiAgIyAgICAgW3JhbmQoMzAwKSwgdl1cbiAgIyAgIGVuZFxuICAjXG4gICMgVGhpcyB3aWxsIGdlbmVyYXRlIGEgc291bmQgd2l0aCBXZWJBdWRpby5cbiAgY2xhc3MgU291bmRFZmZlY3QgPCBTb3VuZFxuICAgIFJlbW90ZVJlc291cmNlLmFkZF9jbGFzcyhTb3VuZEVmZmVjdClcblxuICAgIG1vZHVsZSBXYXZlVHlwZXNcbiAgICAgIFdBVkVfU0lOID0gOnNpbmVcbiAgICAgIFdBVkVfU0FXID0gOnNhd3Rvb3RoXG4gICAgICBXQVZFX1RSSSA9IDp0cmlhbmdsZVxuICAgICAgV0FWRV9SRUNUID0gOnNxdWFyZVxuICAgIGVuZFxuXG4gICAgIyB0aW1lIDogVG90YWwgbnVtYmVyIG9mIHRpY2tzXG4gICAgIyAgIFdoZW4gcmVzb2x1dGlvbj0xMDAwKGRlZmF1bHQpLCBgdGltZWAgaXMgZXF1aXZhbGVudCB0byB0aGUgXG4gICAgIyAgIHRvdGFsIGxlbmd0aCBvZiB0aGUgc291bmQgaW4gbWlsbGlzZWNvbmRzLlxuICAgICMgd2F2ZV90eXBlIDogVHlwZSBvZiB3YXZlIGZvcm1cbiAgICAjIHJlc29sdXRpb24gOiBOdW1iZXIgb2YgdGlja3MgcGVyIHNlY29uZFxuICAgICMgYmxvY2sgOiBTaG91bGQgcmV0dXJuIFtmcmVxKDB+NDQxMDApLCB2b2x1bWUoMH4yNTUpXVxuICAgIGRlZiBzZWxmLl9sb2FkKHRpbWUsIHdhdmVfdHlwZT1XQVZFX1JFQ1QsIHJlc29sdXRpb249MTAwMCwgJmJsb2NrKVxuICAgICAgc25kID0gbmV3KFwiKHNvdW5kZWZmZWN0KVwiKVxuICAgICAgc25kX3Byb21pc2UgPSAleHtcbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgICB2YXIgbl9jaGFubmVscyA9IDE7XG4gICAgICAgICAgdmFyIGNvbnRleHQgPSAje1NvdW5kLmF1ZGlvX2NvbnRleHR9O1xuICAgICAgICAgIHZhciBuX3RpY2tzID0gI3t0aW1lfTtcbiAgICAgICAgICB2YXIgdG90YWxTZWNvbmRzID0gI3t0aW1lIC8gcmVzb2x1dGlvbn07XG4gICAgICAgICAgdmFyIHZhbHVlc1BlclNlY29uZCA9IGNvbnRleHQuc2FtcGxlUmF0ZTtcbiAgICAgICAgICB2YXIgbl92YWx1ZXMgPSB0b3RhbFNlY29uZHMgKiB2YWx1ZXNQZXJTZWNvbmQ7XG4gICAgICAgICAgdmFyIG15QXJyYXlCdWZmZXIgPSBjb250ZXh0LmNyZWF0ZUJ1ZmZlcihuX2NoYW5uZWxzLCBuX3ZhbHVlcywgdmFsdWVzUGVyU2Vjb25kKTtcbiAgICAgICAgICB2YXIgdmFsdWVzID0gbXlBcnJheUJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX3RpY2tzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZXQgPSAje2Jsb2NrLmNhbGx9O1xuICAgICAgICAgICAgdmFyIGZyZXEgPSByZXRbMF0sIHZvbHVtZSA9IHJldFsxXTtcbiAgICAgICAgICAgIGlmIChmcmVxIDwgMCkgZnJlcSA9IDA7XG4gICAgICAgICAgICBpZiAoZnJlcSA+IDQ0MTAwKSBmcmVxID0gNDQxMDA7XG4gICAgICAgICAgICBpZiAodm9sdW1lIDwgMCkgdm9sdW1lID0gMDtcbiAgICAgICAgICAgIGlmICh2b2x1bWUgPiAyNTUpIHZvbHVtZSA9IDI1NTtcbiAgICAgICAgICAgIHZhciB2b2wgPSB2b2x1bWUgLyAyNTU7ICAgLy8gMC4wfjEuMFxuXG4gICAgICAgICAgICB2YXIgcGVyaW9kID0gdmFsdWVzUGVyU2Vjb25kICogMSAvIGZyZXE7XG4gICAgICAgICAgICBmb3IgKDsgbiA8ICgoaSsxKSAvIG5fdGlja3MgKiBuX3ZhbHVlcyk7IG4rKykge1xuICAgICAgICAgICAgICB2YXIgcGhhc2UgPSAobiAlIHBlcmlvZCkgLyBwZXJpb2Q7IC8vIDAuMH4xLjBcbiAgICAgICAgICAgICAgdmFyIHZhbHVlOyAvLyAtMS4wfjEuMFxuICAgICAgICAgICAgICBzd2l0Y2goI3t3YXZlX3R5cGV9KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJzaW5lXCI6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnNpbigyICogTWF0aC5QSSAqIHBoYXNlKSAqIDIgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwic2F3dG9vdGhcIjpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBoYXNlICogMiAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0cmlhbmdsZVwiOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGhhc2UgPCAwLjI1ID8gIDArcGhhc2UqNCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaGFzZSA8IDAuNSAgPyAgMS0ocGhhc2UtMC4yNSkqNCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaGFzZSA8IDAuNzUgPyAgMC0ocGhhc2UtMC41KSo0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xKyhwaGFzZS0wLjc1KSo0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwic3F1YXJlXCI6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAocGhhc2UgPCAwLjUgPyAxIDogLTEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICN7cmFpc2UgXCJ1bmtub3duIHdhdmVfdHlwZTogXCIgKyB3YXZlX3R5cGUuaW5zcGVjdH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWVzW25dID0gdmFsdWUgKiB2b2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNuZFsnJGRlY29kZWQ9J10obXlBcnJheUJ1ZmZlcik7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbmQsIHNuZF9wcm9taXNlXG4gICAgZW5kXG5cbiAgICBkZWYgYWRkKHdhdmVfdHlwZT1XQVZFX1JFQ1QsIHJlc29sdXRpb249MTAwMClcbiAgICAgIFRPRE9cbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsImFkZF9jbGFzcyIsIl9sb2FkIiwic2VsZiIsIjEwMDAiLCJzbmQiLCJuZXciLCJzbmRfcHJvbWlzZSIsImF1ZGlvX2NvbnRleHQiLCJ0aW1lIiwiLyIsInJlc29sdXRpb24iLCJibG9jayIsImNhbGwiLCJ3YXZlX3R5cGUiLCJyYWlzZSIsIisiLCJpbnNwZWN0IiwiYWRkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFXRSxPQUFBQztBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQSw4QkFBQUMsV0FBQUEsQ0FBeUIsMkJBQXpCQSxDQUFBO0FBQUEsTUFFQUY7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUEsd0NBQVcsTUFBWCxDQUFBO0FBQUEsUUFDQSx3Q0FBVyxVQUFYLENBREE7QUFBQSxRQUVBLHdDQUFXLFVBQVgsQ0FGQTtBQUFBLFFBR0EsT0FBQSx5Q0FBWSxRQUFaLENBSEE7QUFERkEsTUFBQUEsR0FBQUEsV0FBQUEsV0FGQTtBQUFBLE1BZUFHLFVBQUlDLElBQUpELFlBQUFBLHVCQUFBQSxpQkFBZSxJQUFELEVBQU8sU0FBUCxFQUE0QixVQUExQ0E7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQUFBO0FBQUFBO0FBNUJKO0FBNEIrRCxRQUFBLDJDQTVCL0Q7QUFBQTtBQTRCeUIsUUFBQTtBQUFBLFFBQUEsY0FBVSx5QkFBVjtBQUFBLFFBQUEsQ0E1QnpCO0FBQUE7QUE0QjhDLFFBQUE7QUFBQSxRQUFBLGVBQVdFLElBQVg7QUFBQSxRQUFBLENBNUI5QztBQUFBLFFBNkJNQyxVQUFNQyxLQUFBQSxDQUFJLGVBQUpBLENBN0JaO0FBQUEsUUE4Qk1DO0FBQ047QUFDQTtBQUNBLHdCQUEwQixxQkFBQUMsZUFBQUEsQ0FBQUEsQ0FBb0I7QUFDOUMsd0JBQTBCQyxJQUFLO0FBQy9CLDZCQUErQkMsV0FBQUQsSUFBQUMsRUFBT0MsVUFBUEQsQ0FBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXdCRSxLQUFBQyxNQUFBQSxDQUFBQSxDQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUF1QkMsU0FBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFrQkMsT0FBQUEsQ0FBTUMsU0FBQSxxQkFBQUEsRUFBd0JGLFNBQUFHLFNBQUFBLENBQUFBLENBQXhCRCxDQUFORCxDQUFnRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BL0VBO0FBQUEsUUFnRk0sUUFBT1YsS0FBS0UsWUFoRmxCO0FBNEJJTCxNQUFBQSxDQUFBQSxtQ0FBQUEsQ0FmQTtBQUFBLE1Bc0VBLE9BQUFnQixDQUFBQSx1QkFBQUEscUJBQUFBLGVBQVEsU0FBRCxFQUFzQixVQUE3QkE7QUFBQUEsUUFBQUE7O0FBQUFBO0FBbkZKO0FBbUZZLFFBQUE7QUFBQSxRQUFBLGNBQVUseUJBQVY7QUFBQSxRQUFBLENBbkZaO0FBQUE7QUFtRmlDLFFBQUE7QUFBQSxRQUFBLGVBQVdkLElBQVg7QUFBQSxRQUFBLENBbkZqQztBQUFBLFFBb0ZNLE9BQUEsb0JBcEZOO0FBbUZJYyxNQUFBQSxDQUFBQSxpQ0FBQUEsQ0FBQUEsZUF0RUE7QUFERmxCLElBQUFBLEdBQUFBLFdBQUFBLEVBQW9CLHFCQUFwQkE7QUFYRkQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNzczOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImR4b3BhbC9zcHJpdGUvY29sbGlzaW9uX2NoZWNrZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyB2aW06IHNldCBmdD1qYXZhc2NyaXB0OlxuIyBDb2xsaXNpb24gY2hlY2tpbmcgYWxnb3JpdGhtLCBpbXBsZW1lbnRlZCBpbiBKYXZhU2NyaXB0LlxuIyBBdmFpbGFibGUgYXMgYE9wYWwuRFhPcGFsLkNvbGxpc2lvbkNoZWNrZXJgIGluIHRoZSBydW50aW1lLlxuJXh7IChmdW5jdGlvbigpe1xuXG52YXIgaW50ZXJzZWN0ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KXtcbiAgcmV0dXJuICgoeDEgLSB4MikgKiAoeTMgLSB5MSkgKyAoeTEgLSB5MikgKiAoeDEgLSB4MykpICpcbiAgICAgICAgICgoeDEgLSB4MikgKiAoeTQgLSB5MSkgKyAoeTEgLSB5MikgKiAoeDEgLSB4NCkpO1xufTtcblxudmFyIGNoZWNrX2xpbmVfbGluZSA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCl7XG4gIHJldHVybiAhKCgoKHgxIC0geDIpICogKHkzIC0geTEpICsgKHkxIC0geTIpICogKHgxIC0geDMpKSAqXG4gICAgICAgICAgICAoKHgxIC0geDIpICogKHk0IC0geTEpICsgKHkxIC0geTIpICogKHgxIC0geDQpKSA+IDAuMCkgfHxcbiAgICAgICAgICAgKCgoeDMgLSB4NCkgKiAoeTEgLSB5MykgKyAoeTMgLSB5NCkgKiAoeDMgLSB4MSkpICpcbiAgICAgICAgICAgICgoeDMgLSB4NCkgKiAoeTIgLSB5MykgKyAoeTMgLSB5NCkgKiAoeDMgLSB4MikpID4gMC4wICkpO1xufTtcblxudmFyIGNoZWNrX2NpcmNsZV9saW5lID0gZnVuY3Rpb24oeCwgeSwgciwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgdmFyIHZ4ID0geDIteDEsIHZ5ID0geTIteTE7XG4gIHZhciBjeCA9IHgteDEsIGN5ID0geS15MTtcblxuICBpZiAodnggPT0gMCAmJiB2eSA9PSAwIClcbiAgICByZXR1cm4gQ0NrLmNoZWNrX3BvaW50X2NpcmNsZSh4LCB5LCByLCB4MSwgeTEpO1xuXG4gIHZhciBuMSA9IHZ4ICogY3ggKyB2eSAqIGN5O1xuICBpZiAobjEgPCAwKVxuICAgIHJldHVybiBjeCpjeCArIGN5KmN5IDwgciAqIHI7XG5cbiAgdmFyIG4yID0gdnggKiB2eCArIHZ5ICogdnk7XG4gIGlmIChuMSA+IG4yKSB7XG4gICAgdmFyIGxlbiA9ICh4MiAtIHgpKih4MiAtIHgpICsgKHkyIC0geSkqKHkyIC0geSk7XG4gICAgcmV0dXJuIGxlbiA8IHIgKiByO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHZhciBuMyA9IGN4ICogY3ggKyBjeSAqIGN5O1xuICAgIHJldHVybiBuMy0objEvbjIpKm4xIDwgciAqIHI7XG4gIH1cbn07XG5cbnZhciBDQ2sgPSB7XG4gIGNoZWNrX3BvaW50X2NpcmNsZTogZnVuY3Rpb24ocHgsIHB5LCBjeCwgY3ksIGNyKSB7XG4gICAgcmV0dXJuIChjcipjcikgPj0gKChjeC1weCkgKiAoY3gtcHgpICsgKGN5LXB5KSAqIChjeS1weSkpO1xuICB9LFxuXG4gIGNoZWNrX3BvaW50X3N0cmFpZ2h0X3JlY3Q6IGZ1bmN0aW9uKHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuICgoeCkgPj0gKHgxKSAmJlxuICAgICAgICAgICAgKHkpID49ICh5MSkgJiZcbiAgICAgICAgICAgICh4KSA8ICh4MikgJiZcbiAgICAgICAgICAgICh5KSA8ICh5MikpO1xuICB9LFxuXG4gIGNoZWNrX3BvaW50X3RyaWFuZ2xlOiBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKXtcbiAgICBpZiAoKHgxIC0geDMpICogKHkxIC0geTIpID09ICh4MSAtIHgyKSAqICh5MSAtIHkzKSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBjeCA9ICh4MSArIHgyICsgeDMpIC8gMyxcbiAgICAgICAgY3kgPSAoeTEgKyB5MiArIHkzKSAvIDM7XG5cbiAgICBpZiAoaW50ZXJzZWN0KCB4MSwgeTEsIHgyLCB5MiwgeCwgeSwgY3gsIGN5ICkgPCAwLjAgfHxcbiAgICAgICAgaW50ZXJzZWN0KCB4MiwgeTIsIHgzLCB5MywgeCwgeSwgY3gsIGN5ICkgPCAwLjAgfHxcbiAgICAgICAgaW50ZXJzZWN0KCB4MywgeTMsIHgxLCB5MSwgeCwgeSwgY3gsIGN5ICkgPCAwLjAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIGNoZWNrX2NpcmNsZV9jaXJjbGU6IGZ1bmN0aW9uKG94LCBveSwgb3IsIGR4LCBkeSwgZHIpIHtcbiAgICByZXR1cm4gKChvcitkcikgKiAob3IrZHIpID49IChveC1keCkgKiAob3gtZHgpICsgKG95LWR5KSAqIChveS1keSkpO1xuICB9LFxuXG4gIGNoZWNrX2VsbGlwc2VfZWxsaXBzZTogZnVuY3Rpb24oRTEsIEUyKSB7XG4gICAgIHZhciBEZWZBbmcgPSBFMS5mQW5nbGUtRTIuZkFuZ2xlO1xuICAgICB2YXIgQ29zID0gTWF0aC5jb3MoIERlZkFuZyApO1xuICAgICB2YXIgU2luID0gTWF0aC5zaW4oIERlZkFuZyApO1xuICAgICB2YXIgbnggPSBFMi5mUmFkX1ggKiBDb3M7XG4gICAgIHZhciBueSA9IC1FMi5mUmFkX1ggKiBTaW47XG4gICAgIHZhciBweCA9IEUyLmZSYWRfWSAqIFNpbjtcbiAgICAgdmFyIHB5ID0gRTIuZlJhZF9ZICogQ29zO1xuICAgICB2YXIgb3ggPSBNYXRoLmNvcyggRTEuZkFuZ2xlICkqKEUyLmZDeC1FMS5mQ3gpICsgTWF0aC5zaW4oRTEuZkFuZ2xlKSooRTIuZkN5LUUxLmZDeSk7XG4gICAgIHZhciBveSA9IC1NYXRoLnNpbiggRTEuZkFuZ2xlICkqKEUyLmZDeC1FMS5mQ3gpICsgTWF0aC5jb3MoRTEuZkFuZ2xlKSooRTIuZkN5LUUxLmZDeSk7XG5cbiAgICAgdmFyIHJ4X3BvdzIgPSAxLyhFMS5mUmFkX1gqRTEuZlJhZF9YKTtcbiAgICAgdmFyIHJ5X3BvdzIgPSAxLyhFMS5mUmFkX1kqRTEuZlJhZF9ZKTtcbiAgICAgdmFyIEEgPSByeF9wb3cyKm54Km54ICsgcnlfcG93MipueSpueTtcbiAgICAgdmFyIEIgPSByeF9wb3cyKnB4KnB4ICsgcnlfcG93MipweSpweTtcbiAgICAgdmFyIEQgPSAyKnJ4X3BvdzIqbngqcHggKyAyKnJ5X3BvdzIqbnkqcHk7XG4gICAgIHZhciBFID0gMipyeF9wb3cyKm54Km94ICsgMipyeV9wb3cyKm55Km95O1xuICAgICB2YXIgRiA9IDIqcnhfcG93MipweCpveCArIDIqcnlfcG93MipweSpveTtcbiAgICAgdmFyIEcgPSAob3gvRTEuZlJhZF9YKSoob3gvRTEuZlJhZF9YKSArIChveS9FMS5mUmFkX1kpKihveS9FMS5mUmFkX1kpIC0gMTtcblxuICAgICB2YXIgdG1wMSA9IDEvKEQqRC00KkEqQik7XG4gICAgIHZhciBoID0gKEYqRC0yKkUqQikqdG1wMTtcbiAgICAgdmFyIGsgPSAoRSpELTIqQSpGKSp0bXAxO1xuICAgICB2YXIgVGggPSAoQi1BKT09MCA/IDAgOiBNYXRoLmF0YW4oIEQvKEItQSkgKSAqIDAuNTtcblxuICAgICB2YXIgQ29zVGggPSBNYXRoLmNvcyhUaCk7XG4gICAgIHZhciBTaW5UaCA9IE1hdGguc2luKFRoKTtcbiAgICAgdmFyIEFfdHQgPSBBKkNvc1RoKkNvc1RoICsgQipTaW5UaCpTaW5UaCAtIEQqQ29zVGgqU2luVGg7XG4gICAgIHZhciBCX3R0ID0gQSpTaW5UaCpTaW5UaCArIEIqQ29zVGgqQ29zVGggKyBEKkNvc1RoKlNpblRoO1xuICAgICB2YXIgS0sgPSBBKmgqaCArIEIqayprICsgRCpoKmsgLSBFKmggLSBGKmsgKyBHID4gMCA/IDAgOiBBKmgqaCArIEIqayprICsgRCpoKmsgLSBFKmggLSBGKmsgKyBHO1xuICAgICB2YXIgUnhfdHQgPSAxK01hdGguc3FydCgtS0svQV90dCk7XG4gICAgIHZhciBSeV90dCA9IDErTWF0aC5zcXJ0KC1LSy9CX3R0KTtcbiAgICAgdmFyIHhfdHQgPSBDb3NUaCpoLVNpblRoKms7XG4gICAgIHZhciB5X3R0ID0gU2luVGgqaCtDb3NUaCprO1xuICAgICB2YXIgSnVkZ2VWYWx1ZSA9IHhfdHQqeF90dC8oUnhfdHQqUnhfdHQpICsgeV90dCp5X3R0LyhSeV90dCpSeV90dCk7XG5cbiAgICAgcmV0dXJuIChKdWRnZVZhbHVlIDw9IDEpO1xuICB9LFxuXG4gIGNoZWNrX2NpcmNsZV90aWx0ZWRfcmVjdDogZnVuY3Rpb24oY3gsIGN5LCBjciwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KXtcbiAgICByZXR1cm4gQ0NrLmNoZWNrX3BvaW50X3RyaWFuZ2xlKGN4LCBjeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MykgfHwgXG4gICAgICAgICAgIENDay5jaGVja19wb2ludF90cmlhbmdsZShjeCwgY3ksIHgxLCB5MSwgeDMsIHkzLCB4NCwgeTQpIHx8IFxuICAgICAgICAgICBjaGVja19jaXJjbGVfbGluZShjeCwgY3ksIGNyLCB4MSwgeTEsIHgyLCB5MikgfHxcbiAgICAgICAgICAgY2hlY2tfY2lyY2xlX2xpbmUoY3gsIGN5LCBjciwgeDIsIHkyLCB4MywgeTMpIHx8XG4gICAgICAgICAgIGNoZWNrX2NpcmNsZV9saW5lKGN4LCBjeSwgY3IsIHgzLCB5MywgeDQsIHk0KSB8fFxuICAgICAgICAgICBjaGVja19jaXJjbGVfbGluZShjeCwgY3ksIGNyLCB4NCwgeTQsIHgxLCB5MSk7XG4gIH0sXG5cbiAgY2hlY2tfY2lyY2xlX3RyaWFuZ2xlOiBmdW5jdGlvbihjeCwgY3ksIGNyLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgcmV0dXJuIENDay5jaGVja19wb2ludF90cmlhbmdsZShjeCwgY3ksIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHx8IFxuICAgICAgICAgICBjaGVja19jaXJjbGVfbGluZShjeCwgY3ksIGNyLCB4MSwgeTEsIHgyLCB5MikgfHxcbiAgICAgICAgICAgY2hlY2tfY2lyY2xlX2xpbmUoY3gsIGN5LCBjciwgeDIsIHkyLCB4MywgeTMpIHx8XG4gICAgICAgICAgIGNoZWNrX2NpcmNsZV9saW5lKGN4LCBjeSwgY3IsIHgzLCB5MywgeDEsIHkxKTtcbiAgfSxcblxuICBjaGVja19yZWN0X3JlY3Q6IGZ1bmN0aW9uKGF4MSwgYXkxLCBheDIsIGF5MiwgYngxLCBieTEsIGJ4MiwgYnkyKSB7XG4gICAgcmV0dXJuIGF4MSA8IGJ4MiAmJlxuICAgICAgICAgICBheTEgPCBieTIgJiZcbiAgICAgICAgICAgYngxIDwgYXgyICYmXG4gICAgICAgICAgIGJ5MSA8IGF5MjtcbiAgfSxcblxuICAvLyBSZWN0KG1heSBiZSB0aWx0ZWQpIHZzIFRyaWFuZ2xlXG4gIGNoZWNrX3RpbHRlZF9yZWN0X3RyaWFuZ2xlOiBmdW5jdGlvbihveDEsIG95MSwgb3gyLCBveTIsIG94Mywgb3kzLCBveDQsIG95NCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4MSwgZHkxLCBkeDIsIGR5MiwgZHgzLCBkeTMpIHtcbiAgICByZXR1cm4gY2hlY2tfbGluZV9saW5lKG94MSwgb3kxLCBveDIsIG95MiwgZHgxLCBkeTEsIGR4MiwgZHkyKSB8fFxuICAgICAgICAgICBjaGVja19saW5lX2xpbmUob3gxLCBveTEsIG94Miwgb3kyLCBkeDIsIGR5MiwgZHgzLCBkeTMpIHx8XG4gICAgICAgICAgIGNoZWNrX2xpbmVfbGluZShveDEsIG95MSwgb3gyLCBveTIsIGR4MywgZHkzLCBkeDEsIGR5MSkgfHxcbiAgICAgICAgICAgY2hlY2tfbGluZV9saW5lKG94Miwgb3kyLCBveDMsIG95MywgZHgxLCBkeTEsIGR4MiwgZHkyKSB8fFxuICAgICAgICAgICBjaGVja19saW5lX2xpbmUob3gyLCBveTIsIG94Mywgb3kzLCBkeDIsIGR5MiwgZHgzLCBkeTMpIHx8XG4gICAgICAgICAgIGNoZWNrX2xpbmVfbGluZShveDIsIG95Miwgb3gzLCBveTMsIGR4MywgZHkzLCBkeDEsIGR5MSkgfHxcbiAgICAgICAgICAgY2hlY2tfbGluZV9saW5lKG94Mywgb3kzLCBveDQsIG95NCwgZHgxLCBkeTEsIGR4MiwgZHkyKSB8fFxuICAgICAgICAgICBjaGVja19saW5lX2xpbmUob3gzLCBveTMsIG94NCwgb3k0LCBkeDIsIGR5MiwgZHgzLCBkeTMpIHx8XG4gICAgICAgICAgIGNoZWNrX2xpbmVfbGluZShveDMsIG95Mywgb3g0LCBveTQsIGR4MywgZHkzLCBkeDEsIGR5MSkgfHxcbiAgICAgICAgICAgY2hlY2tfbGluZV9saW5lKG94NCwgb3k0LCBveDEsIG95MSwgZHgxLCBkeTEsIGR4MiwgZHkyKSB8fFxuICAgICAgICAgICBjaGVja19saW5lX2xpbmUob3g0LCBveTQsIG94MSwgb3kxLCBkeDIsIGR5MiwgZHgzLCBkeTMpIHx8XG4gICAgICAgICAgIGNoZWNrX2xpbmVfbGluZShveDQsIG95NCwgb3gxLCBveTEsIGR4MywgZHkzLCBkeDEsIGR5MSkgfHxcbiAgICAgICAgICAgQ0NrLmNoZWNrX3BvaW50X3RyaWFuZ2xlKGR4MSwgZHkxLCBveDEsIG95MSwgb3gyLCBveTIsIG94Mywgb3kzKSB8fCBcbiAgICAgICAgICAgQ0NrLmNoZWNrX3BvaW50X3RyaWFuZ2xlKGR4MSwgZHkxLCBveDEsIG95MSwgb3gzLCBveTMsIG94NCwgb3k0KSB8fCBcbiAgICAgICAgICAgQ0NrLmNoZWNrX3BvaW50X3RyaWFuZ2xlKG94MSwgb3kxLCBkeDEsIGR5MSwgZHgyLCBkeTIsIGR4MywgZHkzKTtcbiAgfSxcblxuICAvLyBUcmlhbmdsZSB2cyBUcmlhbmdsZVxuICBjaGVja190cmlhbmdsZV90cmlhbmdsZTogZnVuY3Rpb24ob3gxLCBveTEsIG94Miwgb3kyLCBveDMsIG95MyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4MSwgZHkxLCBkeDIsIGR5MiwgZHgzLCBkeTMpIHtcbiAgICByZXR1cm4gY2hlY2tfbGluZV9saW5lKG94MSwgb3kxLCBveDIsIG95MiwgZHgyLCBkeTIsIGR4MywgZHkzKSB8fFxuICAgICAgICAgICBjaGVja19saW5lX2xpbmUob3gxLCBveTEsIG94Miwgb3kyLCBkeDMsIGR5MywgZHgxLCBkeTEpIHx8XG4gICAgICAgICAgIGNoZWNrX2xpbmVfbGluZShveDIsIG95Miwgb3gzLCBveTMsIGR4MSwgZHkxLCBkeDIsIGR5MikgfHxcbiAgICAgICAgICAgY2hlY2tfbGluZV9saW5lKG94Miwgb3kyLCBveDMsIG95MywgZHgzLCBkeTMsIGR4MSwgZHkxKSB8fFxuICAgICAgICAgICBjaGVja19saW5lX2xpbmUob3gzLCBveTMsIG94MSwgb3kxLCBkeDEsIGR5MSwgZHgyLCBkeTIpIHx8XG4gICAgICAgICAgIGNoZWNrX2xpbmVfbGluZShveDMsIG95Mywgb3gxLCBveTEsIGR4MiwgZHkyLCBkeDMsIGR5MykgfHxcbiAgICAgICAgICAgQ0NrLmNoZWNrX3BvaW50X3RyaWFuZ2xlKG94MSwgb3kxLCBkeDEsIGR5MSwgZHgyLCBkeTIsIGR4MywgZHkzKSB8fFxuICAgICAgICAgICBDQ2suY2hlY2tfcG9pbnRfdHJpYW5nbGUoZHgxLCBkeTEsIG94MSwgb3kxLCBveDIsIG95Miwgb3gzLCBveTMpO1xuICB9XG59O1xuXG5PcGFsLkRYT3BhbC5Db2xsaXNpb25DaGVja2VyID0gQ0NrO1xuT3BhbC5EWE9wYWwuQ0NrID0gQ0NrOyAvLyBBbGlhc1xuXG59KSgpOyB9XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztFQUdHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3OTEyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZHhvcGFsL3Nwcml0ZS9jb2xsaXNpb25fYXJlYS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdkeG9wYWwvc3ByaXRlL2NvbGxpc2lvbl9jaGVja2VyJ1xuXG5tb2R1bGUgRFhPcGFsXG4gIGNsYXNzIFNwcml0ZVxuICAgICMgTWV0aG9kcyBvZiBTcHJpdGUgcmVsYXRlZCB0byBjb2xsaXNpb24gY2hlY2tpbmdcbiAgICBtb2R1bGUgQ29sbGlzaW9uQXJlYVxuICAgICAgY2xhc3MgQmFzZVxuICAgICAgICAjIFNwcml0ZSBjb3JyZXNwb25kcyB0byB0aGlzIGhpdGFyZWFcbiAgICAgICAgYXR0cl9yZWFkZXIgOnNwcml0ZVxuXG4gICAgICAgICMgUmV0dXJuIGEgc3RyaW5nIGxpa2UgXCJQb2ludFwiLCBcIlJlY3RcIiwgZXRjLlxuICAgICAgICAjIFVzZWQgZm9yIHR5cGUgY2hlY2tpbmcgaW4gYGNvbGxpZGVzP2AgKGJlY2F1c2UgT3BhbCdzIENsYXNzI2lzX2E/IGlzIG5vdCB2ZXJ5IGZhc3QpXG4gICAgICAgIGRlZiB0eXBlXG4gICAgICAgICAgcmFpc2UgXCJvdmVycmlkZSBtZVwiXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGRlZiBhYnNvbHV0ZShwb3NzKVxuICAgICAgICAgIG94ID0gQHNwcml0ZS54XG4gICAgICAgICAgb3kgPSBAc3ByaXRlLnlcbiAgICAgICAgICByZXR1cm4gcG9zcy5tYXB7fCh4LCB5KXwgW3grb3gsIHkrb3ldfSBpZiAhQHNwcml0ZS5jb2xsaXNpb25fc3luY1xuICAgICAgICAgIGFuZ2xlID0gQHNwcml0ZS5hbmdsZVxuICAgICAgICAgIGN4ID0gQHNwcml0ZS5jZW50ZXJfeFxuICAgICAgICAgIGN5ID0gQHNwcml0ZS5jZW50ZXJfeVxuICAgICAgICAgIHN4ID0gQHNwcml0ZS5zY2FsZV94XG4gICAgICAgICAgc3kgPSBAc3ByaXRlLnNjYWxlX3lcblxuICAgICAgICAgIHJldCA9IFtdXG4gICAgICAgICAgJXh7XG4gICAgICAgICAgICB2YXIgcmFkID0gTWF0aC5QSSAvIDE4MC4wICogYW5nbGU7XG4gICAgICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4ocmFkKTtcbiAgICAgICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyYWQpO1xuICAgICAgICAgICAgcG9zcy5mb3JFYWNoKGZ1bmN0aW9uKHBvcyl7XG4gICAgICAgICAgICAgIHZhciB4ID0gcG9zWzBdLCB5ID0gcG9zWzFdO1xuICAgICAgICAgICAgICB4MiA9ICh4IC0gY3gpICogc3ggKiBjb3MgLSAoeSAtIGN5KSAqIHN5ICogc2luICsgY3ggKyBveDtcbiAgICAgICAgICAgICAgeTIgPSAoeCAtIGN4KSAqIHN4ICogc2luICsgKHkgLSBjeSkgKiBzeSAqIGNvcyArIGN5ICsgb3k7XG4gICAgICAgICAgICAgIHJldC5wdXNoKFt4MiwgeTJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0XG4gICAgICAgIGVuZFxuXG4gICAgICAgIGRlZiBhYnNvbHV0ZTEocG9zKVxuICAgICAgICAgIGFic29sdXRlKFtwb3NdKS5maXJzdFxuICAgICAgICBlbmRcbiAgICAgICAgXG4gICAgICAgIGRlZiB0cmFuc2JhY2socG9zcywgc3ByaXRlKVxuICAgICAgICAgIHJldHVybiBwb3NzIGlmICFzcHJpdGUuY29sbGlzaW9uX3N5bmNcbiAgICAgICAgICBhbmdsZSA9IHNwcml0ZS5hbmdsZVxuICAgICAgICAgIGN4ID0gc3ByaXRlLnggKyBzcHJpdGUuY2VudGVyX3hcbiAgICAgICAgICBjeSA9IHNwcml0ZS55ICsgc3ByaXRlLmNlbnRlcl95XG4gICAgICAgICAgc3ggPSBzcHJpdGUuc2NhbGVfeFxuICAgICAgICAgIHN5ID0gc3ByaXRlLnNjYWxlX3lcblxuICAgICAgICAgIHJldCA9IFtdXG4gICAgICAgICAgJXh7XG4gICAgICAgICAgICB2YXIgcmFkID0gTWF0aC5QSSAvIDE4MC4wICogLWFuZ2xlO1xuICAgICAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHJhZCk7XG4gICAgICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MocmFkKTtcbiAgICAgICAgICAgIHBvc3MuZm9yRWFjaChmdW5jdGlvbihwb3Mpe1xuICAgICAgICAgICAgICB2YXIgeCA9IHBvc1swXSwgeSA9IHBvc1sxXTtcbiAgICAgICAgICAgICAgeDIgPSAoKHggLSBjeCkgKiBjb3MgLSAoeSAtIGN5KSAqIHNpbikgLyBzeCArIGN4O1xuICAgICAgICAgICAgICB5MiA9ICgoeCAtIGN4KSAqIHNpbiArICh5IC0gY3kpICogY29zKSAvIHN5ICsgY3k7XG4gICAgICAgICAgICAgIHJldC5wdXNoKFt4MiwgeTJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0XG4gICAgICAgIGVuZFxuXG4gICAgICAgIGRlZiB0cmFuc2JhY2sxKHBvcywgc3ByaXRlKVxuICAgICAgICAgIHRyYW5zYmFjayhbcG9zXSwgc3ByaXRlKS5maXJzdFxuICAgICAgICBlbmRcblxuICAgICAgICBkZWYgYWFiYihwb3NzKVxuICAgICAgICAgIHgxID0geTEgPSAgRmxvYXQ6OklORklOSVRZXG4gICAgICAgICAgeDIgPSB5MiA9IC1GbG9hdDo6SU5GSU5JVFlcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHBvc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHBvc3NbaV1bMF0gPCB4MSkgeDEgPSBwb3NzW2ldWzBdO1xuICAgICAgICAgICAgICBpZiAocG9zc1tpXVsxXSA8IHkxKSB5MSA9IHBvc3NbaV1bMV07XG4gICAgICAgICAgICAgIGlmIChwb3NzW2ldWzBdID4geDIpIHgyID0gcG9zc1tpXVswXTtcbiAgICAgICAgICAgICAgaWYgKHBvc3NbaV1bMV0gPiB5MikgeTIgPSBwb3NzW2ldWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW1t4MSwgeTFdLCBbeDIsIHkyXV1cbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgY2xhc3MgUG9pbnQgPCBCYXNlXG4gICAgICAgIGRlZiBpbml0aWFsaXplKHNwcml0ZSwgeCwgeSlcbiAgICAgICAgICBAc3ByaXRlLCBAeCwgQHkgPSBzcHJpdGUsIHgsIHlcbiAgICAgICAgICBzdXBlcigpXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGRlZiB0eXBlOyA6UG9pbnQ7IGVuZFxuXG4gICAgICAgIGRlZiBjb2xsaWRlcz8ob3RoZXIpXG4gICAgICAgICAgY2FzZSBvdGhlci50eXBlXG4gICAgICAgICAgd2hlbiA6UG9pbnRcbiAgICAgICAgICAgIHNlbGYuYWJzb2x1dGVfcG9zID09IG90aGVyLmFic29sdXRlX3Bvc1xuICAgICAgICAgIHdoZW4gOkNpcmNsZVxuICAgICAgICAgICAgeCwgeSA9ICp0cmFuc2JhY2sxKHNlbGYuYWJzb2x1dGVfcG9zLCBvdGhlci5zcHJpdGUpXG4gICAgICAgICAgICBjeCwgY3kgPSAqb3RoZXIuYWJzb2x1dGVfbm9yb3RfcG9zXG4gICAgICAgICAgICBgT3BhbC5EWE9wYWwuQ0NrLmNoZWNrX3BvaW50X2NpcmNsZSh4LCB5LCBjeCwgY3ksICN7b3RoZXIucn0pYFxuICAgICAgICAgIHdoZW4gOlJlY3RcbiAgICAgICAgICAgIHgsIHkgPSAqdHJhbnNiYWNrMShzZWxmLmFic29sdXRlX3Bvcywgb3RoZXIuc3ByaXRlKVxuICAgICAgICAgICAgKCh4MSwgeTEpLCAoeDIsIHkyKSkgPSAqb3RoZXIuYWJzb2x1dGVfbm9yb3RfcG9zc1xuICAgICAgICAgICAgYE9wYWwuRFhPcGFsLkNDay5jaGVja19wb2ludF9zdHJhaWdodF9yZWN0KHgsIHksIHgxLCB5MSwgeDIsIHkyKWBcbiAgICAgICAgICB3aGVuIDpUcmlhbmdsZVxuICAgICAgICAgICAgeCwgeSA9ICphYnNvbHV0ZV9wb3NcbiAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSwgKHgzLCB5MykgPSAqb3RoZXIuYWJzb2x1dGVfcG9zc1xuICAgICAgICAgICAgYE9wYWwuRFhPcGFsLkNDay5jaGVja19wb2ludF90cmlhbmdsZSh4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKWBcbiAgICAgICAgICBlbHNlIHJhaXNlXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuXG4gICAgICAgICMgUmV0dXJuIFt4LCB5XVxuICAgICAgICBkZWYgYWJzb2x1dGVfcG9zXG4gICAgICAgICAgYWJzb2x1dGUxKFtAeCwgQHldKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICBjbGFzcyBDaXJjbGUgPCBCYXNlXG4gICAgICAgIGRlZiBpbml0aWFsaXplKHNwcml0ZSwgeCwgeSwgcilcbiAgICAgICAgICBAc3ByaXRlLCBAeCwgQHksIEByID0gc3ByaXRlLCB4LCB5LCByXG4gICAgICAgICAgc3VwZXIoKVxuICAgICAgICBlbmRcbiAgICAgICAgYXR0cl9yZWFkZXIgOnJcblxuICAgICAgICBkZWYgdHlwZTsgOkNpcmNsZTsgZW5kXG5cbiAgICAgICAgIyBSZXR1cm4gdHJ1ZSBpZiB0aGlzIGlzIG5vdCBhbiBlbGxpcHNpc1xuICAgICAgICBkZWYgY2lyY2xlP1xuICAgICAgICAgIEBzcHJpdGUuc2NhbGVfeCA9PSBAc3ByaXRlLnNjYWxlX3lcbiAgICAgICAgZW5kXG5cbiAgICAgICAgZGVmIGNvbGxpZGVzPyhvdGhlcilcbiAgICAgICAgICBjYXNlIG90aGVyLnR5cGVcbiAgICAgICAgICB3aGVuIDpQb2ludFxuICAgICAgICAgICAgb3RoZXIuY29sbGlkZXM/KHNlbGYpXG4gICAgICAgICAgd2hlbiA6Q2lyY2xlXG4gICAgICAgICAgICBjb2xsaWRlc19jaXJjbGU/KG90aGVyKVxuICAgICAgICAgIHdoZW4gOlJlY3RcbiAgICAgICAgICAgIGN4LCBjeSA9ICpzZWxmLmFic29sdXRlX25vcm90X3Bvc1xuICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpLCAoeDMsIHkzKSwgKHg0LCB5NCkgPSAqdHJhbnNiYWNrKG90aGVyLmFic29sdXRlX3Bvc3MsIEBzcHJpdGUpXG4gICAgICAgICAgICBgT3BhbC5EWE9wYWwuQ0NrLmNoZWNrX2NpcmNsZV90aWx0ZWRfcmVjdChjeCwgY3ksICN7QHJ9LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQpYFxuICAgICAgICAgIHdoZW4gOlRyaWFuZ2xlXG4gICAgICAgICAgICBjeCwgY3kgPSAqc2VsZi5hYnNvbHV0ZV9ub3JvdF9wb3NcbiAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSwgKHgzLCB5MykgPSAqdHJhbnNiYWNrKG90aGVyLmFic29sdXRlX3Bvc3MsIEBzcHJpdGUpXG4gICAgICAgICAgICBgT3BhbC5EWE9wYWwuQ0NrLmNoZWNrX2NpcmNsZV90cmlhbmdsZShjeCwgY3ksICN7QHJ9LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKWBcbiAgICAgICAgICBlbHNlIHJhaXNlXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuXG4gICAgICAgICMgUmV0dXJuIFt4LCB5XVxuICAgICAgICBkZWYgYWJzb2x1dGVfcG9zXG4gICAgICAgICAgYWJzb2x1dGUxKFtAeCwgQHldKVxuICAgICAgICBlbmRcblxuICAgICAgICBkZWYgYWJzb2x1dGVfbm9yb3RfcG9zXG4gICAgICAgICAgW0B4ICsgQHNwcml0ZS54LCBAeSArIEBzcHJpdGUueV1cbiAgICAgICAgZW5kXG5cbiAgICAgICAgcHJpdmF0ZVxuXG4gICAgICAgIGRlZiBjb2xsaWRlc19jaXJjbGU/KG90aGVyKVxuICAgICAgICAgIHgxLCB5MSA9ICpzZWxmLmFic29sdXRlX3Bvc1xuICAgICAgICAgIHIxID0gQHJcbiAgICAgICAgICB4MiwgeTIgPSAqb3RoZXIuYWJzb2x1dGVfcG9zXG4gICAgICAgICAgcjIgPSBvdGhlci5yXG4gICAgICAgICAgaWYgc2VsZi5jaXJjbGU/ICYmIG90aGVyLmNpcmNsZT9cbiAgICAgICAgICAgIGBPcGFsLkRYT3BhbC5DQ2suY2hlY2tfY2lyY2xlX2NpcmNsZSh4MSwgeTEsICN7QHJ9LCB4MiwgeTIsICN7b3RoZXIucn0pYFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIEBzcHJpdGUuY29sbGlzaW9uX3N5bmNcbiAgICAgICAgICAgICAgc2NhbGVfeDEgPSBAc3ByaXRlLnNjYWxlX3hcbiAgICAgICAgICAgICAgc2NhbGVfeTEgPSBAc3ByaXRlLnNjYWxlX3lcbiAgICAgICAgICAgICAgYW5nbGUxID0gQHNwcml0ZS5hbmdsZSAqIE1hdGg6OlBJIC8gMTgwXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHNjYWxlX3gxID0gMVxuICAgICAgICAgICAgICBzY2FsZV95MSA9IDFcbiAgICAgICAgICAgICAgYW5nbGUxID0gMFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBpZiBvdGhlci5zcHJpdGUuY29sbGlzaW9uX3N5bmNcbiAgICAgICAgICAgICAgc2NhbGVfeDIgPSBvdGhlci5zcHJpdGUuc2NhbGVfeFxuICAgICAgICAgICAgICBzY2FsZV95MiA9IG90aGVyLnNwcml0ZS5zY2FsZV95XG4gICAgICAgICAgICAgIGFuZ2xlMiA9IG90aGVyLnNwcml0ZS5hbmdsZSAqIE1hdGg6OlBJIC8gMTgwXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHNjYWxlX3gyID0gMVxuICAgICAgICAgICAgICBzY2FsZV95MiA9IDFcbiAgICAgICAgICAgICAgYW5nbGUyID0gMFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICByZXQgPSBuaWxcbiAgICAgICAgICAgICV4e1xuICAgICAgICAgICAgICB2YXIgZTEgPSB7XG4gICAgICAgICAgICAgICAgZlJhZF9YOiBzY2FsZV94MSAqIHIxLFxuICAgICAgICAgICAgICAgIGZSYWRfWTogc2NhbGVfeTEgKiByMSxcbiAgICAgICAgICAgICAgICBmQW5nbGU6IGFuZ2xlMSxcbiAgICAgICAgICAgICAgICBmQ3g6IHgxLFxuICAgICAgICAgICAgICAgIGZDeTogeTEsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGUyID0ge1xuICAgICAgICAgICAgICAgIGZSYWRfWDogc2NhbGVfeDIgKiByMixcbiAgICAgICAgICAgICAgICBmUmFkX1k6IHNjYWxlX3kyICogcjIsXG4gICAgICAgICAgICAgICAgZkFuZ2xlOiBhbmdsZTIsXG4gICAgICAgICAgICAgICAgZkN4OiB4MixcbiAgICAgICAgICAgICAgICBmQ3k6IHkyLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldCA9IE9wYWwuRFhPcGFsLkNDay5jaGVja19lbGxpcHNlX2VsbGlwc2UoZTEsIGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICBjbGFzcyBSZWN0IDwgQmFzZVxuICAgICAgICBkZWYgaW5pdGlhbGl6ZShzcHJpdGUsIHgxLCB5MSwgeDIsIHkyKVxuICAgICAgICAgIEBzcHJpdGUsIEB4MSwgQHkxLCBAeDIsIEB5MiA9IHNwcml0ZSwgeDEsIHkxLCB4MiwgeTJcbiAgICAgICAgICBAcG9zcyA9IFtbeDEsIHkxXSwgW3gyLCB5MV0sIFt4MiwgeTJdLCBbeDEsIHkyXV1cbiAgICAgICAgICBzdXBlcigpXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGRlZiB0eXBlOyA6UmVjdDsgZW5kXG5cbiAgICAgICAgZGVmIGluc3BlY3RcbiAgICAgICAgICBcIiM8Q29sbGlzaW9uQXJlYTo6UmVjdCgje0B4MX0sICN7QHkxfSwgI3tAeDJ9LCAje0B5Mn0pPlwiXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGRlZiBjb2xsaWRlcz8ob3RoZXIpXG4gICAgICAgICAgY2FzZSBvdGhlci50eXBlXG4gICAgICAgICAgd2hlbiA6UG9pbnQsIDpDaXJjbGVcbiAgICAgICAgICAgIG90aGVyLmNvbGxpZGVzPyhzZWxmKVxuICAgICAgICAgIHdoZW4gOlJlY3RcbiAgICAgICAgICAgICgob3gxLCBveTEpLCAob3gyLCBveTIpKSA9IHNlbGYuYWJzb2x1dGVfbm9yb3RfcG9zc1xuICAgICAgICAgICAgKChkeDEsIGR5MSksIChkeDIsIGR5MikpID0gYWFiYih0cmFuc2JhY2sob3RoZXIuYWJzb2x1dGVfcG9zcywgQHNwcml0ZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2UgdW5sZXNzIGBPcGFsLkRYT3BhbC5DQ2suY2hlY2tfcmVjdF9yZWN0KG94MSwgb3kxLCBveDIsIG95MiwgZHgxLCBkeTEsIGR4MiwgZHkyKWBcblxuICAgICAgICAgICAgKChveDEsIG95MSksIChveDIsIG95MikpID0gb3RoZXIuYWJzb2x1dGVfbm9yb3RfcG9zc1xuICAgICAgICAgICAgKChkeDEsIGR5MSksIChkeDIsIGR5MikpID0gYWFiYih0cmFuc2JhY2soc2VsZi5hYnNvbHV0ZV9wb3NzLCBvdGhlci5zcHJpdGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlIHVubGVzcyBgT3BhbC5EWE9wYWwuQ0NrLmNoZWNrX3JlY3RfcmVjdChveDEsIG95MSwgb3gyLCBveTIsIGR4MSwgZHkxLCBkeDIsIGR5MilgXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgd2hlbiA6VHJpYW5nbGVcbiAgICAgICAgICAgIChveDEsIG95MSksIChveDIsIG95MiksIChveDMsIG95MyksIChveDQsIG95NCkgPSAqc2VsZi5hYnNvbHV0ZV9wb3NzXG4gICAgICAgICAgICAoZHgxLCBkeTEpLCAoZHgyLCBkeTIpLCAoZHgzLCBkeTMpID0gKm90aGVyLmFic29sdXRlX3Bvc3NcbiAgICAgICAgICAgIGBPcGFsLkRYT3BhbC5DQ2suY2hlY2tfdGlsdGVkX3JlY3RfdHJpYW5nbGUob3gxLCBveTEsIG94Miwgb3kyLCBveDMsIG95Mywgb3g0LCBveTQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4MSwgZHkxLCBkeDIsIGR5MiwgZHgzLCBkeTMpYFxuXG4gICAgICAgICAgZWxzZSByYWlzZVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcblxuICAgICAgICBkZWYgYWJzb2x1dGVfcG9zc1xuICAgICAgICAgIGFic29sdXRlKEBwb3NzKVxuICAgICAgICBlbmRcblxuICAgICAgICBkZWYgYWJzb2x1dGVfbm9yb3RfcG9zc1xuICAgICAgICAgIFtbQHgxICsgQHNwcml0ZS54LCBAeTEgKyBAc3ByaXRlLnldLFxuICAgICAgICAgICBbQHgyICsgQHNwcml0ZS54LCBAeTIgKyBAc3ByaXRlLnldXVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICBjbGFzcyBUcmlhbmdsZSA8IEJhc2VcbiAgICAgICAgZGVmIGluaXRpYWxpemUoc3ByaXRlLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKVxuICAgICAgICAgIEBzcHJpdGUgPSBzcHJpdGVcbiAgICAgICAgICBAcG9zcyA9IFtbeDEsIHkxXSwgW3gyLCB5Ml0sIFt4MywgeTNdXVxuICAgICAgICAgIHN1cGVyKClcbiAgICAgICAgZW5kXG5cbiAgICAgICAgZGVmIHR5cGU7IDpUcmlhbmdsZTsgZW5kXG5cbiAgICAgICAgZGVmIGNvbGxpZGVzPyhvdGhlcilcbiAgICAgICAgICBjYXNlIG90aGVyLnR5cGVcbiAgICAgICAgICB3aGVuIDpQb2ludCwgOkNpcmNsZSwgOlJlY3RcbiAgICAgICAgICAgIG90aGVyLmNvbGxpZGVzPyhzZWxmKVxuICAgICAgICAgIHdoZW4gOlRyaWFuZ2xlXG4gICAgICAgICAgICAob3gxLCBveTEpLCAob3gyLCBveTIpLCAob3gzLCBveTMpID0gKnNlbGYuYWJzb2x1dGVfcG9zc1xuICAgICAgICAgICAgKGR4MSwgZHkxKSwgKGR4MiwgZHkyKSwgKGR4MywgZHkzKSA9ICpvdGhlci5hYnNvbHV0ZV9wb3NzXG4gICAgICAgICAgICBgT3BhbC5EWE9wYWwuQ0NrLmNoZWNrX3RyaWFuZ2xlX3RyaWFuZ2xlKG94MSwgb3kxLCBveDIsIG95Miwgb3gzLCBveTMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4MSwgZHkxLCBkeDIsIGR5MiwgZHgzLCBkeTMpYFxuICAgICAgICAgIGVsc2UgcmFpc2VcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG5cbiAgICAgICAgZGVmIGFic29sdXRlX3Bvc3NcbiAgICAgICAgICBhYnNvbHV0ZShAcG9zcylcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwibW9kdWxlIiwiY2xhc3MiLCJhdHRyX3JlYWRlciIsInR5cGUiLCJyYWlzZSIsImFic29sdXRlIiwib3giLCJAc3ByaXRlIiwieCIsIm95IiwieSIsImNvbGxpc2lvbl9zeW5jIiwiISIsIm1hcCIsInBvc3MiLCIkbWxoc190bXAxIiwiKyIsImFuZ2xlIiwiY3giLCJjZW50ZXJfeCIsImN5IiwiY2VudGVyX3kiLCJzeCIsInNjYWxlX3giLCJzeSIsInNjYWxlX3kiLCJyZXQiLCJhYnNvbHV0ZTEiLCJwb3MiLCJmaXJzdCIsInRyYW5zYmFjayIsInNwcml0ZSIsInRyYW5zYmFjazEiLCJhYWJiIiwieDEiLCJ5MSIsIngyIiwieTIiLCItQCIsImluaXRpYWxpemUiLCJAeCIsIkB5IiwiY29sbGlkZXM/Iiwib3RoZXIiLCJzZWxmIiwiYWJzb2x1dGVfcG9zIiwiPT0iLCJhYnNvbHV0ZV9ub3JvdF9wb3MiLCJyIiwiYWJzb2x1dGVfbm9yb3RfcG9zcyIsImFic29sdXRlX3Bvc3MiLCJ4MyIsInkzIiwiQHIiLCJjaXJjbGU/IiwiY29sbGlkZXNfY2lyY2xlPyIsIng0IiwieTQiLCJwcml2YXRlIiwicjEiLCJyMiIsIiRyZXRfb3JfMSIsInNjYWxlX3gxIiwic2NhbGVfeTEiLCJhbmdsZTEiLCIvIiwiKiIsIjE4MCIsIjEiLCIwIiwic2NhbGVfeDIiLCJzY2FsZV95MiIsImFuZ2xlMiIsIkB4MSIsIkB5MSIsIkB4MiIsIkB5MiIsIkBwb3NzIiwiaW5zcGVjdCIsIm94MSIsIm95MSIsIm94MiIsIm95MiIsImR4MSIsImR5MSIsImR4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QUE7O0FBQUFBLFlBQ0UsV0FBQTdDLFVBQUFBLENBQVN3RSxTQUFUeEU7QUFERjZDLFVBQUFBLENBQUFBLHdDQUFBQSxDQUFBQSx5QkFyQkE7QUFERmpELFFBQUFBLEdBQUFBLFdBQUFBLEVBQWlCLG9CQUFqQkEsV0E3UEE7QUFERkQsTUFBQUEsR0FBQUEsV0FBQUE7QUFGRkMsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFERkQsRUFBQUEsR0FBQUEsV0FBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI4MzMxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZHhvcGFsL3Nwcml0ZS9jb2xsaXNpb25fY2hlY2sucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnZHhvcGFsL3Nwcml0ZS9jb2xsaXNpb25fYXJlYSdcblxubW9kdWxlIERYT3BhbFxuICBjbGFzcyBTcHJpdGVcbiAgICAjIE1ldGhvZHMgb2YgU3ByaXRlIHJlbGF0ZWQgdG8gY29sbGlzaW9uIGNoZWNraW5nXG4gICAgbW9kdWxlIENvbGxpc2lvbkNoZWNrXG4gICAgICBtb2R1bGUgQ2xhc3NNZXRob2RzXG4gICAgICAgICMgUnVuIGNvbGxpc2lvbiBjaGVja2luZyBmb3Igc2V0IG9mIHNwcml0ZXNcbiAgICAgICAgIyAtIG9mZmVuY2VzOiBTcHJpdGUgb3IgW1Nwcml0ZV1cbiAgICAgICAgIyAtIGRlZmVuY2VzOiBTcHJpdGUgb3IgW1Nwcml0ZV1cbiAgICAgICAgIyAtIHNob3Q6IG1ldGhvZCBuYW1lXG4gICAgICAgICMgLSBoaXQ6IG1ldGhvZCBuYW1lXG4gICAgICAgICNcbiAgICAgICAgIyBUaGlzIG1ldGhvZCBoYXMgdHdvIG1vZGVzLlxuICAgICAgICAjIC0gSWYgYG9mZmVuY2VzYCBhbmQgYGRlZmVuY2VzYCBhcmUgdGhlIHNhbWUsIGNvbGxpc2lvbiBjaGVjayB3aWxsXG4gICAgICAgICMgICBiZSBwZXJmb3JtZWQgb24gZWFjaCBwYWlyIGZyb20gdGhlIGFycmF5LiBNZXRob2QgYGhpdGAgaXMgY2FsbGVkXG4gICAgICAgICMgICBvbiB0aGUgZWFjaCBzcHJpdGUsIHdpdGggdGhlIG90aGVyIHNwcml0ZSBhcyBhbiBhcmd1bWVudC5cbiAgICAgICAgIyAtIE90aGVyd2lzZSwgY29sbGlzaW9uIGNoZWNrIHdpbGwgYmUgcGVyZm9ybWVkIG9uIGVhY2ggcGFpclxuICAgICAgICAjICAgb2Ygb2ZmZW5jZSBzcHJpdGUgYW5kIGRlZmVuY2Ugc3ByaXRlLiBJbiB0aGlzIGNhc2UsXG4gICAgICAgICMgICBtZXRob2QgYHNob3RgIGlzIGNhbGxlZCBvbiB0aGUgb2ZmZW5jZSBzcHJpdGUgYW5kXG4gICAgICAgICMgICBtZXRob2QgYGhpdGAgaXMgY2FsbGVkIG9uIHRoZSBkZWZlbmNlIHNwcml0ZSwgd2l0aCB0aGVcbiAgICAgICAgIyAgIG90aGVyIHNwcml0ZSBhcyBhbiBhcmd1bWVudC5cbiAgICAgICAgI1xuICAgICAgICAjIFRPRE86IHJldHVybiB0cnVlIGlmIGFueSBjb2xsaXRpb24gaXMgZGV0ZWN0ZWRcbiAgICAgICAgIyBUT0RPOiBza2lwIGNvbGxpc2lvbiBjaGVja2luZyBpZiBzaG90L2hpdCByZXR1cm5lZCBgOmRpc2NhcmRgXG4gICAgICAgIGRlZiBjaGVjayhvZmZlbmNlcywgZGVmZW5jZXMsIHNob3Q9OnNob3QsIGhpdD06aGl0KVxuICAgICAgICAgIG9mZmVuY2VzID0gQXJyYXkob2ZmZW5jZXMpXG4gICAgICAgICAgZGVmZW5jZXMgPSBBcnJheShkZWZlbmNlcylcbiAgICAgICAgICBpID0gaiA9IDAgICMgdHJpY2sgdG8gdXNlIGksIGogaW4gdGhlIGAje31gXG4gICAgICAgICAgaWYgb2ZmZW5jZXMuZXF1YWw/KGRlZmVuY2VzKVxuICAgICAgICAgICAgIyBhbnktdnMtYW55IG1vZGVcbiAgICAgICAgICAgIHNwcml0ZXMgPSBvZmZlbmNlcy5zZWxlY3R7fHh8IHguaXNfYT8oU3ByaXRlKX1cbiAgICAgICAgICAgIG4gPSBzcHJpdGVzLmxlbmd0aFxuICAgICAgICAgICAgJXh7XG4gICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPWkrMTsgajxuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmICgje3Nwcml0ZXNbaV0gPT09IHNwcml0ZXNbal19KSB7XG4gICAgICAgICAgICAgICAgICAgICN7c3ByaXRlc1tpXS5fX3NlbmRfXyhoaXQpfTtcbiAgICAgICAgICAgICAgICAgICAgI3tzcHJpdGVzW2pdLl9fc2VuZF9fKGhpdCl9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICMgb2ZmZW5jZS12cy1kZWZlbmNlIG1vZGVcbiAgICAgICAgICAgICV4e1xuICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8b2ZmZW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8ZGVmZW5jZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmICgje29mZmVuY2VzW2ldID09PSBkZWZlbmNlc1tqXX0pIHtcbiAgICAgICAgICAgICAgICAgICAgI3tvZmZlbmNlc1tpXS5fX3NlbmRfXyhzaG90LCBkZWZlbmNlc1tqXSl9O1xuICAgICAgICAgICAgICAgICAgICAje2RlZmVuY2VzW2pdLl9fc2VuZF9fKGhpdCwgb2ZmZW5jZXNbaV0pfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgIyBEZWZhdWx0IGNhbGxiYWNrIG1ldGhvZHMgb2YgYFNwcml0ZS5jaGVja2BcbiAgICAgIGRlZiBzaG90KG90aGVyKTsgZW5kXG4gICAgICBkZWYgaGl0KG90aGVyKTsgZW5kXG5cbiAgICAgICMgQ2FsbGVkIGZyb20gU3ByaXRlcyNpbml0aWFsaXplXG4gICAgICBkZWYgX2luaXRfY29sbGlzaW9uX2luZm8oaW1hZ2UpXG4gICAgICAgIEBjb2xsaXNpb24gfHw9IG5pbFxuICAgICAgICBAY29sbGlzaW9uX2VuYWJsZSA9IHRydWUgaWYgQGNvbGxpc2lvbl9lbmFibGUubmlsP1xuICAgICAgICBAY29sbGlzaW9uX3N5bmMgPSB0cnVlIGlmIEBjb2xsaXNpb25fc3luYy5uaWw/XG4gICAgICAgIEBfY29sbGlzaW9uX2FyZWEgfHw9XG4gICAgICAgICAgaWYgaW1hZ2VcbiAgICAgICAgICAgIENvbGxpc2lvbkFyZWE6OlJlY3QubmV3KHNlbGYsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbmlsXG4gICAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgICMgV2hldGhlciBjb2xsaXNpb24gaXMgZGV0ZWN0ZWQgZm9yIHRoaXMgb2JqZWN0IChkZWZhdWx0OiB0cnVlKVxuICAgICAgYXR0cl9hY2Nlc3NvciA6Y29sbGlzaW9uX2VuYWJsZVxuICAgICAgIyBXaGV0aGVyIGNvbGxpc2lvbiBhcmVhcyBzeW5jaHJvbml6ZSB3aXRoIC5zY2FsZSBhbmQgLmFuZ2xlIChkZWZhdWx0OiB0cnVlKVxuICAgICAgIyBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgbWF5IGltcHJvdmUgY29sbGlzaW9uIGRldGVjdGlvbiBwZXJmb3JtYW5jZVxuICAgICAgYXR0cl9hY2Nlc3NvciA6Y29sbGlzaW9uX3N5bmNcbiAgICAgICMgUmV0dXJuIGFuIGFycmF5IHJlcHJlc2VudHMgaXRzIGNvbGxpc2lvbiBhcmVhXG4gICAgICBhdHRyX3JlYWRlciA6Y29sbGlzaW9uXG4gICAgICAjIChpbnRlcm5hbCkgUmV0dXJuIGEgQ29sbGlzaW9uQXJlYSBvYmplY3RcbiAgICAgIGF0dHJfcmVhZGVyIDpfY29sbGlzaW9uX2FyZWFcblxuICAgICAgIyBTZXQgY29sbGlzaW9uIGFyZWEgb2YgdGhpcyBzcHJpdGVcbiAgICAgIGRlZiBjb2xsaXNpb249KGFyZWFfc3BlYylcbiAgICAgICAgQF9jb2xsaXNpb25fYXJlYSA9XG4gICAgICAgICAgY2FzZSBhcmVhX3NwZWMubGVuZ3RoXG4gICAgICAgICAgd2hlbiAyIHRoZW4gQ29sbGlzaW9uQXJlYTo6UG9pbnQubmV3KHNlbGYsICphcmVhX3NwZWMpXG4gICAgICAgICAgd2hlbiAzIHRoZW4gQ29sbGlzaW9uQXJlYTo6Q2lyY2xlLm5ldyhzZWxmLCAqYXJlYV9zcGVjKVxuICAgICAgICAgIHdoZW4gNCB0aGVuIENvbGxpc2lvbkFyZWE6OlJlY3QubmV3KHNlbGYsICphcmVhX3NwZWMpXG4gICAgICAgICAgd2hlbiA2IHRoZW4gQ29sbGlzaW9uQXJlYTo6VHJpYW5nbGUubmV3KHNlbGYsICphcmVhX3NwZWMpXG4gICAgICAgICAgZWxzZSBcbiAgICAgICAgICAgIHJhaXNlIFwiSW5saXZhZCBhcmVhIGRhdGE6ICN7eC5pbnNwZWN0fVwiXG4gICAgICAgICAgZW5kXG4gICAgICAgIEBjb2xsaXNpb24gPSBhcmVhX3NwZWNcbiAgICAgIGVuZFxuXG4gICAgICAjIFJldHVybiB0cnVlIHdoZW4gdGhpcyBzcHJpdGUgY29sbGlkZXMgd2l0aCBvdGhlciBzcHJpdGUocylcbiAgICAgIGRlZiA9PT0oc3ByaXRlX29yX3Nwcml0ZXMpXG4gICAgICAgIHJldHVybiBjaGVjayhzcHJpdGVfb3Jfc3ByaXRlcykuYW55P1xuICAgICAgZW5kXG5cbiAgICAgICMgUmV0dXJuIGxpc3Qgb2Ygc3ByaXRlcyBjb2xsaWRlcyB3aXRoIHRoaXMgc3ByaXRlXG4gICAgICBkZWYgY2hlY2soc3ByaXRlX29yX3Nwcml0ZXMpXG4gICAgICAgIHNwcml0ZXMgPSBBcnJheShzcHJpdGVfb3Jfc3ByaXRlcylcbiAgICAgICAgcmV0dXJuIHNwcml0ZXMuc2VsZWN0e3xzcHJpdGV8IF9jb2xsaWRlcz8oc3ByaXRlKX1cbiAgICAgIGVuZFxuXG4gICAgICAjIFJldHVybiB0cnVlIHdoZW4gdGhpcyBzcHJpdGUgY29sbGlkZXMgd2l0aCBgc3ByaXRlYFxuICAgICAgZGVmIF9jb2xsaWRlcz8oc3ByaXRlKVxuICAgICAgICBpZiBAX2NvbGxpc2lvbl9hcmVhLm5pbD8gfHwgc3ByaXRlLl9jb2xsaXNpb25fYXJlYS5uaWw/XG4gICAgICAgICAgcmFpc2UgXCJTcHJpdGUgaW1hZ2Ugbm90IHNldFwiXG4gICAgICAgIGVuZFxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgIXNlbGYuX2NvbGxpZGFibGU/IHx8ICFzcHJpdGUuX2NvbGxpZGFibGU/XG4gICAgICAgIHJldHVybiBAX2NvbGxpc2lvbl9hcmVhLmNvbGxpZGVzPyhzcHJpdGUuX2NvbGxpc2lvbl9hcmVhKVxuICAgICAgZW5kXG5cbiAgICAgICMgUmV0dXJuIHRydWUgd2hlbiB0aGlzIHNwcml0ZSBtYXkgY29sbGlkZVxuICAgICAgZGVmIF9jb2xsaWRhYmxlP1xuICAgICAgICByZXR1cm4gIUB2YW5pc2hlZCAmJiBAY29sbGlzaW9uX2VuYWJsZVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsIm1vZHVsZSIsImNsYXNzIiwiY2hlY2siLCJvZmZlbmNlcyIsIkFycmF5IiwiZGVmZW5jZXMiLCJpIiwiaiIsIjAiLCJlcXVhbD8iLCJzcHJpdGVzIiwic2VsZWN0IiwieCIsImlzX2E/IiwibiIsImxlbmd0aCIsIltdIiwiPT09IiwiX19zZW5kX18iLCJoaXQiLCJzaG90IiwiX2luaXRfY29sbGlzaW9uX2luZm8iLCJAY29sbGlzaW9uIiwiJHJldF9vcl8xIiwiQGNvbGxpc2lvbl9lbmFibGUiLCJuaWw/IiwiQGNvbGxpc2lvbl9zeW5jIiwiQF9jb2xsaXNpb25fYXJlYSIsIiRyZXRfb3JfMiIsImltYWdlIiwibmV3Iiwic2VsZiIsIndpZHRoIiwiaGVpZ2h0IiwiYXR0cl9hY2Nlc3NvciIsImF0dHJfcmVhZGVyIiwiY29sbGlzaW9uPSIsImFyZWFfc3BlYyIsIjIiLCIzIiwiNCIsIjYiLCJyYWlzZSIsImluc3BlY3QiLCJzcHJpdGVfb3Jfc3ByaXRlcyIsImFueT8iLCJfY29sbGlkZXM/Iiwic3ByaXRlIiwiJHJldF9vcl8zIiwiX2NvbGxpc2lvbl9hcmVhIiwiJHJldF9vcl80IiwiX2NvbGxpZGFibGU/IiwiISIsImNvbGxpZGVzPyIsIiRyZXRfb3JfNSIsIkB2YW5pc2hlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSw4QkFBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUFDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFRSxPQUFBRDtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQSxVQW1CRSxPQUFBRSxDQUFBQSx5QkFBQUEsd0JBQUFBLGlCQUFVLFFBQUQsRUFBVyxRQUFYLEVBQXFCLElBQXJCLEVBQWlDLEdBQTFDQTtBQUFBQSxZQUFBQTs7QUFBQUE7QUExQlI7QUEwQnNDLFlBQUE7QUFBQSxZQUFBLFNBQUssTUFBTDtBQUFBLFlBQUEsQ0ExQnRDO0FBQUE7QUEwQmtELFlBQUE7QUFBQSxZQUFBLFFBQUksS0FBSjtBQUFBLFlBQUEsQ0ExQmxEO0FBQUEsWUEyQlVDLGVBQVdDLE9BQUFBLENBQU1ELFFBQU5DLENBM0JyQjtBQUFBLFlBNEJVQyxlQUFXRCxPQUFBQSxDQUFNQyxRQUFORCxDQTVCckI7QUFBQSxZQTZCVUUsSUFBSUMsQ0FBQUEsSUFBSUMsQ0FBSkQsQ0E3QmQ7QUFBQSxZQThCVSxJQUFBLFFBQUdKLFFBQUFNLFdBQUFBLENBQWdCSixRQUFoQkksQ0FBSCxDQUFBO0FBQUE7QUFFRSxjQUFBQyxVQUFVQyxNQUFBUixRQUFBUSxVQUFBQSxFQUFBQSxFQUFBQSxFQWhD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LENBQUE7QUFBQSxZQXBIeEIsT0FBQTtBQW9Id0IsVUFBQTtBQUFBLFlBQXNCLE9BQUNILE1BQUFJLGlCQUFBQSxDQUFBQSxDQUFEQyxNQUFBQSxDQUFBQTtBQUF0QixVQUFBLENBQUEsa0JBQWhCLENBQUE7QUFBQSxZQUFBLE9BQU8sS0FBUCxDQUhBO0FBQUEsVUFJQSxPQUFPekIsb0JBQUEwQixjQUFBQSxDQUEyQk4sTUFBQUUsaUJBQUFBLENBQUFBLENBQTNCSSxDQUpQO0FBREZQLFFBQUFBLENBQUFBLCtDQUFBQSxDQXpHQTtBQUFBLFFBa0hBLE9BQUFLLENBQUFBLGdDQUFBQSxzQ0FBQUEsU0FBQUE7QUFBQUEsVUFBQUE7QUFBQUE7QUFBQUE7O0FBQUFBLFVBQ0UsT0FBTyxhQUFBLElBQUEsUUExSGZHLENBQUFBLFlBMEhnQkMsYUFBREgsTUFBQUEsQ0FBQUEsQ0ExSGZFLENBMEhlLENBQUE7QUFBQSxZQUFjLE9BQUE5QjtBQUFkLFVBQUE7QUFBQSxZQTFIZixPQUFBO0FBMEhlLFVBQUEsQ0FBQTtBQURUMkIsUUFBQUEsQ0FBQUEsaURBQUFBLENBQUFBLHdCQWxIQTtBQURGbkQsTUFBQUEsR0FBQUEsV0FBQUE7QUFGRkMsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFERkQsRUFBQUEsR0FBQUEsV0FBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI4NTIxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZHhvcGFsL3Nwcml0ZS9waHlzaWNzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBEWE9wYWxcbiAgY2xhc3MgU3ByaXRlXG4gICAgIyBFeHBlcmltZW50YWwgTWF0dGVyLmpzIChwaHlzaWNzIGVuZ2luZSkgc3VwcG9ydFxuICAgICNcbiAgICAjIFlvdSBuZWVkIHRvIGxvYWQgbWF0dGVyLmpzIGluIGFkdmFuY2UgdG8gdXNpbmcgdGhlc2UgZmVhdHVyZXMuXG4gICAgbW9kdWxlIFBoeXNpY3NcbiAgICAgICMgQ3JlYXRlIE1hdHRlciBCb2R5IGFuZCByZWdpc3RlciBpdCB0byB0aGUgV29ybGRcbiAgICAgICMgLSB0eXBlOiA6cmVjdGFuZ2xlLCBldGMuXG4gICAgICBkZWYgcGh5c2ljYWxfYm9keT0oYXJ5KVxuICAgICAgICByYWlzZSBcIkNhbGwgU3ByaXRlI2luaXRpYWxpemUgYmVmb3JlIGNhbGxpbmcgcGh5c2ljYWxfYm9keT1cIiBpZiBzZWxmLngubmlsP1xuICAgICAgICB0eXBlID0gYXJ5WzBdXG4gICAgICAgIGNhc2UgdHlwZVxuICAgICAgICB3aGVuIDpyZWN0YW5nbGVcbiAgICAgICAgICBfLCB3aWR0aCwgaGVpZ2h0LCBvcHRzID0gKmFyeVxuICAgICAgICAgIHggPSBzZWxmLnggKyB3aWR0aC8yXG4gICAgICAgICAgeSA9IHNlbGYueSArIGhlaWdodC8yXG4gICAgICAgICAgaW5mbyA9IFt3aWR0aCwgaGVpZ2h0XVxuICAgICAgICAgIGBvcHRzLmFuZ2xlID0gb3B0cy5hbmdsZSB8fCAje3NlbGYuYW5nbGUgKiBNYXRoOjpQSSAvIDE4MH1gXG4gICAgICAgICAgQF9tYXR0ZXJfYm9keSA9IGBNYXR0ZXIuQm9kaWVzW3R5cGVdKHgsIHksIHdpZHRoLCBoZWlnaHQsIG9wdHMpYFxuICAgICAgICBlbHNlXG4gICAgICAgICAgcmFpc2UgXCJ0eXBlICN7dHlwZS5pbnNwZWN0fSBpcyB1bmtub3duIG9yIG5vdCBzdXBwb3J0ZWQgeWV0XCJcbiAgICAgICAgZW5kXG4gICAgICAgIFNwcml0ZS5fYWRkX21hdHRlcl9ib2R5KEBfbWF0dGVyX2JvZHksIHR5cGUsIHNlbGYsIGluZm8pXG4gICAgICBlbmRcbiAgICAgIGF0dHJfcmVhZGVyIDpfbWF0dGVyX2JvZHlcblxuICAgICAgZGVmIF9tb3ZlX21hdHRlcl9ib2R5XG4gICAgICAgICMgVE9ETzogc3VwcG9ydCBub24tZGVmYXVsdCBjZW50ZXJfeCwgY2VudGVyX3lcbiAgICAgICAgYE1hdHRlci5Cb2R5LnNldFBvc2l0aW9uKCN7QF9tYXR0ZXJfYm9keX0sXG4gICAgICAgICAgIE1hdHRlci5WZWN0b3IuY3JlYXRlKCN7QHgrQGNlbnRlcl94fSwgI3tAeStAY2VudGVyX3l9KSlgXG4gICAgICBlbmRcblxuICAgICAgZGVmIF9tb3ZlX3RvX21hdHRlcl9ib2R5KG14LCBteSlcbiAgICAgICAgQHggPSBteCAtIEBjZW50ZXJfeFxuICAgICAgICBAeSA9IG15IC0gQGNlbnRlcl95XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICMgKGludGVybmFsKSBNYXR0ZXIuRW5naW5lIGluc3RhbmNlXG4gICAgZGVmIHNlbGYuX21hdHRlcl9lbmdpbmVcbiAgICAgIEBtYXR0ZXJfZW5naW5lIHx8PSBgTWF0dGVyLkVuZ2luZS5jcmVhdGUoKWBcbiAgICBlbmRcblxuICAgICMgKGludGVybmFsKSBNYXR0ZXIuUnVubmVyIGluc3RhbmNlXG4gICAgZGVmIHNlbGYuX21hdHRlcl9ydW5uZXJcbiAgICAgIEBtYXR0ZXJfcnVubmVyIHx8PSBgTWF0dGVyLlJ1bm5lci5jcmVhdGUoKWBcbiAgICBlbmRcblxuICAgICMgKGludGVybmFsKSBcbiAgICBkZWYgc2VsZi5fbWF0dGVyX3Nwcml0ZXNcbiAgICAgIEBtYXR0ZXJfYm9kaWVzIHx8PSB7fVxuICAgIGVuZFxuXG4gICAgZGVmIHNlbGYuX2FkZF9tYXR0ZXJfYm9keShib2R5LCB0eXBlLCBzcHJpdGUsIGluZm8pXG4gICAgICBfbWF0dGVyX3Nwcml0ZXNbYGJvZHkuaWRgXSA9IFt0eXBlLCBzcHJpdGUsIGluZm9dXG4gICAgICBgTWF0dGVyLldvcmxkLmFkZEJvZHkoI3tTcHJpdGUuX21hdHRlcl9lbmdpbmV9LndvcmxkLCBib2R5KWBcbiAgICBlbmRcblxuICAgIGRlZiByZW1vdmVfbWF0dGVyX2JvZHlcbiAgICAgIFNwcml0ZS5fcmVtb3ZlX21hdHRlcl9ib2R5KEBfbWF0dGVyX2JvZHkpXG4gICAgZW5kXG5cbiAgICBkZWYgc2VsZi5fcmVtb3ZlX21hdHRlcl9ib2R5KGJvZHkpXG4gICAgICBfbWF0dGVyX3Nwcml0ZXMuZGVsZXRlKGBib2R5LmlkYClcbiAgICAgIGBNYXR0ZXIuV29ybGQucmVtb3ZlKCN7U3ByaXRlLl9tYXR0ZXJfZW5naW5lfS53b3JsZCwgYm9keSwgbnVsbClgXG4gICAgZW5kXG5cbiAgICAjIFJldHVybiB0cnVlIGlmIGBwaHlzaWNhbF9ib2R5PWAgaXMgZXZlciBjYWxsZWRcbiAgICBkZWYgc2VsZi5tYXR0ZXJfZW5hYmxlZD9cbiAgICAgICMgTm90ZTogd2UgY2Fubm90IHVzZSBgISFgIGhlcmUgYmVjYXVzZSBAbWF0dGVyX2VuZ2luZSBtYXkgYmUgYSBKUyBvYmplY3QsXG4gICAgICAjIHdoaWNoIGRvZXMgbm90IGhhdmUgUnVieSdzIGAhQGAgbWV0aG9kXG4gICAgICBAbWF0dGVyX2VuZ2luZSA/IHRydWUgOiBmYWxzZVxuICAgIGVuZFxuXG4gICAgIyBDYWxsIE1hdHRlci5SdW5uZXIudGlja1xuICAgICMgLSB0aW1lOiB0aW1lIGdpdmVuIGJ5IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgIGRlZiBzZWxmLm1hdHRlcl90aWNrKHRpbWUpXG4gICAgICAleHtcbiAgICAgICAgTWF0dGVyLlJ1bm5lci50aWNrKCN7U3ByaXRlLl9tYXR0ZXJfcnVubmVyfSwgI3tTcHJpdGUuX21hdHRlcl9lbmdpbmV9LCB0aW1lKTtcbiAgICAgICAgTWF0dGVyLkNvbXBvc2l0ZS5hbGxCb2RpZXMoI3tTcHJpdGUuX21hdHRlcl9lbmdpbmV9LndvcmxkKS5mb3JFYWNoKChib2R5KSA9PiB7XG4gICAgICAgICAgdmFyIFt0eXBlLCBzcHJpdGUsIGluZm9dID0gI3tTcHJpdGUuX21hdHRlcl9zcHJpdGVzW2Bib2R5LmlkYF19O1xuICAgICAgICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInJlY3RhbmdsZVwiOlxuICAgICAgICAgICAgdmFyIFt3aWR0aCwgaGVpZ2h0XSA9IGluZm87XG4gICAgICAgICAgICBzcHJpdGVbJyRfbW92ZV90b19tYXR0ZXJfYm9keSddKGJvZHkucG9zaXRpb24ueCwgYm9keS5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgIHNwcml0ZVsnJGFuZ2xlPSddKGJvZHkuYW5nbGUgLyBNYXRoLlBJICogMTgwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBgI3tyYWlzZSBcInVua25vd24gdHlwZTogI3t0eXBlfVwifWBcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwicGh5c2ljYWxfYm9keT0iLCJzZWxmIiwieCIsIm5pbD8iLCJyYWlzZSIsInR5cGUiLCJhcnkiLCJbXSIsIjAiLCJfIiwid2lkdGgiLCJoZWlnaHQiLCJvcHRzIiwiKyIsIi8iLCIyIiwieSIsImluZm8iLCIqIiwiYW5nbGUiLCIxODAiLCJAX21hdHRlcl9ib2R5IiwiaW5zcGVjdCIsIl9hZGRfbWF0dGVyX2JvZHkiLCJhdHRyX3JlYWRlciIsIl9tb3ZlX21hdHRlcl9ib2R5IiwiQHgiLCJAY2VudGVyX3giLCJAeSIsIkBjZW50ZXJfeSIsIl9tb3ZlX3RvX21hdHRlcl9ib2R5IiwiLSIsIm14IiwibXkiLCJfbWF0dGVyX2VuZ2luZSIsIkBtYXR0ZXJfZW5naW5lIiwiJHJldF9vcl8xIiwiX21hdHRlcl9ydW5uZXIiLCJAbWF0dGVyX3J1bm5lciIsIiRyZXRfb3JfMiIsIl9tYXR0ZXJfc3ByaXRlcyIsIkBtYXR0ZXJfYm9kaWVzIiwiJHJldF9vcl8zIiwiJHdyaXRlciIsInNwcml0ZSIsIltdPSIsIjEiLCJyZW1vdmVfbWF0dGVyX2JvZHkiLCJfcmVtb3ZlX21hdHRlcl9ib2R5IiwiZGVsZXRlIiwibWF0dGVyX2VuYWJsZWQ/IiwibWF0dGVyX3RpY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUFDO0FBQUFBLElBQUFBOztBQUFB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QWlCQyxNQUFBQSxDQUFBQSxDQUFqQixDQUFORCxDQUE4QjtBQUM3QztBQUNBO0FBQ0E7QUFmSStDLE1BQUFBLENBQUFBLG9DQUFBQSxDQUFBQSx1QkF2RUE7QUFKRnBELElBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBREZELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg2ODUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJkeG9wYWwvc3ByaXRlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2R4b3BhbC9zcHJpdGUvY29sbGlzaW9uX2NoZWNrJ1xucmVxdWlyZSAnZHhvcGFsL3Nwcml0ZS9waHlzaWNzJ1xuXG5tb2R1bGUgRFhPcGFsXG4gIGNsYXNzIFNwcml0ZVxuICAgIGV4dGVuZCBEWE9wYWw6OlNwcml0ZTo6Q29sbGlzaW9uQ2hlY2s6OkNsYXNzTWV0aG9kc1xuICAgIGluY2x1ZGUgRFhPcGFsOjpTcHJpdGU6OkNvbGxpc2lvbkNoZWNrXG4gICAgaW5jbHVkZSBEWE9wYWw6OlNwcml0ZTo6UGh5c2ljc1xuXG4gICAgIyBDYWxsICN1cGRhdGUgb24gZWFjaCBzcHJpdGUgKHVubGVzcyBpdCBpcyB2YW5pc2hlZCBvciBkbyBub3QgaGF2ZSAjdXBkYXRlKVxuICAgIGRlZiBzZWxmLnVwZGF0ZShzcHJpdGVzKVxuICAgICAgc3ByaXRlcy5lYWNoIGRvIHxzcHJpdGV8XG4gICAgICAgIG5leHQgaWYgIXNwcml0ZS5yZXNwb25kX3RvPyg6dXBkYXRlKVxuICAgICAgICBuZXh0IGlmIHNwcml0ZS5yZXNwb25kX3RvPyg6dmFuaXNoZWQ/KSAmJiBzcHJpdGUudmFuaXNoZWQ/XG4gICAgICAgIHNwcml0ZS51cGRhdGVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgIyBSZW1vdmUgdmFuaXNoZWQgc3ByaXRlcyAoYW5kIG5pbHMpIGZyb20gdGhlIGFycmF5LCBkZXN0cnVjdGl2ZWx5XG4gICAgZGVmIHNlbGYuY2xlYW4oc3ByaXRlcylcbiAgICAgIHNwcml0ZXMucmVqZWN0IXt8c3ByaXRlfFxuICAgICAgICBzcHJpdGUubmlsPyB8fCBzcHJpdGUudmFuaXNoZWQ/XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICAjIERyYXcgZWFjaCBvZiB0aGUgZ2l2ZW4gc3ByaXRlcyAodW5sZXNzIGl0IGlzIHZhbmlzaGVkKVxuICAgIGRlZiBzZWxmLmRyYXcoc3ByaXRlcylcbiAgICAgIHNwcml0ZXMuZmxhdHRlbi5zb3J0X2J5KCY6eikuZWFjaCBkbyB8c3ByaXRlfFxuICAgICAgICBuZXh0IGlmIHNwcml0ZS5yZXNwb25kX3RvPyg6dmFuaXNoZWQ/KSAmJiBzcHJpdGUudmFuaXNoZWQ/XG4gICAgICAgIHNwcml0ZS5kcmF3XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBpbml0aWFsaXplKHg9MCwgeT0wLCBpbWFnZT1uaWwpXG4gICAgICBAeCwgQHksIEBpbWFnZSA9IHgsIHksIGltYWdlXG4gICAgICBAeiA9IDBcbiAgICAgIEBhbmdsZSA9IDBcbiAgICAgIEBzY2FsZV94ID0gQHNjYWxlX3kgPSAxLjBcbiAgICAgIGlmIGltYWdlXG4gICAgICAgIEBjZW50ZXJfeCA9IGltYWdlLndpZHRoIC8gMlxuICAgICAgICBAY2VudGVyX3kgPSBpbWFnZS5oZWlnaHQgLyAyXG4gICAgICBlbmRcblxuICAgICAgQHZpc2libGUgPSB0cnVlXG4gICAgICBAdmFuaXNoZWQgPSBmYWxzZVxuICAgICAgX2luaXRfY29sbGlzaW9uX2luZm8oQGltYWdlKVxuICAgIGVuZFxuICAgIGF0dHJfYWNjZXNzb3IgOnosIDp2aXNpYmxlXG5cbiAgICAjIFNldCBhbmdsZSAoMH4zNjAsIGRlZmF1bHQ6IDApXG4gICAgYXR0cl9hY2Nlc3NvciA6YW5nbGVcbiAgICAjIFNldCBob3Jpem9udGFsL3ZlcnRpY2FsIHNjYWxlIChkZWZhdWx0OiAxLjApXG4gICAgYXR0cl9hY2Nlc3NvciA6c2NhbGVfeCwgOnNjYWxlX3lcbiAgICAjIFNldCByb3RhdGlvbiBjZW50ZXIgKGRlZmF1bHQ6IGNlbnRlciBvZiBgaW1hZ2VgKVxuICAgIGF0dHJfYWNjZXNzb3IgOmNlbnRlcl94LCA6Y2VudGVyX3lcbiAgICAjIFNldCBhbHBoYSAoMH4yNTUsIGRlZmF1bHQ6IG5pbClcbiAgICBhdHRyX2FjY2Vzc29yIDphbHBoYVxuICAgICMgU2V0IGJsZW5kIHR5cGUgKEFueSBvZiA6YWxwaGEoZGVmYXVsdCksIDphZGQpXG4gICAgIyAoOm5vbmUsIDphZGQyIGFuZCA6c3ViIGFyZSBub3QgaW1wbGVtZW50ZWQgeWV0OyBQdWxsIHJlcXVlc3QgaXMgd2VsY29tZSlcbiAgICBhdHRyX2FjY2Vzc29yIDpibGVuZFxuXG4gICAgYXR0cl9yZWFkZXIgOngsIDp5XG5cbiAgICBkZWYgeD0obmV3eClcbiAgICAgIEB4ID0gbmV3eFxuICAgICAgX21vdmVfbWF0dGVyX2JvZHkgaWYgQF9tYXR0ZXJfYm9keVxuICAgIGVuZFxuXG4gICAgZGVmIHk9KG5ld3kpXG4gICAgICBAeSA9IG5ld3lcbiAgICAgIF9tb3ZlX21hdHRlcl9ib2R5IGlmIEBfbWF0dGVyX2JvZHlcbiAgICBlbmRcblxuICAgIGRlZiBpbWFnZTsgQGltYWdlOyBlbmRcbiAgICBkZWYgaW1hZ2U9KGltZylcbiAgICAgIEBpbWFnZSA9IGltZ1xuICAgICAgaWYgQGNvbGxpc2lvbi5uaWw/XG4gICAgICAgIHNlbGYuY29sbGlzaW9uID0gWzAsIDAsIGltZy53aWR0aC0xLCBpbWcuaGVpZ2h0LTFdXG4gICAgICBlbmRcbiAgICAgIGlmIEBjZW50ZXJfeC5uaWw/XG4gICAgICAgIEBjZW50ZXJfeCA9IGltZy53aWR0aCAvIDJcbiAgICAgICAgQGNlbnRlcl95ID0gaW1nLmhlaWdodCAvIDJcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIHZhbmlzaDsgQHZhbmlzaGVkID0gdHJ1ZTsgZW5kXG4gICAgZGVmIHZhbmlzaGVkPzsgQHZhbmlzaGVkOyBlbmRcblxuICAgICMgRHJhdyB0aGlzIHNwcml0ZSB0byBXaW5kb3dcbiAgICBkZWYgZHJhd1xuICAgICAgcmFpc2UgXCJpbWFnZSBub3Qgc2V0IHRvIFNwcml0ZVwiIGlmIEBpbWFnZS5uaWw/XG4gICAgICByZXR1cm4gaWYgIUB2aXNpYmxlXG5cbiAgICAgIFdpbmRvdy5kcmF3X2V4KEB4LCBAeSwgQGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgc2NhbGVfeDogQHNjYWxlX3gsIHNjYWxlX3k6IEBzY2FsZV95LFxuICAgICAgICAgICAgICAgICAgICAgYWxwaGE6IEBhbHBoYSwgYmxlbmQ6IEBibGVuZCxcbiAgICAgICAgICAgICAgICAgICAgIGFuZ2xlOiBAYW5nbGUsIGNlbnRlcl94OiBAY2VudGVyX3gsIGNlbnRlcl95OiBAY2VudGVyX3kpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsIm1vZHVsZSIsImNsYXNzIiwiZXh0ZW5kIiwiaW5jbHVkZSIsInVwZGF0ZSIsInNlbGYiLCJlYWNoIiwic3ByaXRlcyIsInNwcml0ZSIsInJlc3BvbmRfdG8/IiwiISIsIiRyZXRfb3JfMSIsInZhbmlzaGVkPyIsImNsZWFuIiwicmVqZWN0ISIsIiRyZXRfb3JfMiIsIm5pbD8iLCJkcmF3Iiwic29ydF9ieSIsImZsYXR0ZW4iLCIkcmV0X29yXzMiLCJpbml0aWFsaXplIiwiMCIsIngiLCJ5IiwiaW1hZ2UiLCJAeCIsIkB5IiwiQGltYWdlIiwiQHoiLCJAYW5nbGUiLCJAc2NhbGVfeCIsIkBzY2FsZV95IiwiQGNlbnRlcl94IiwiLyIsIndpZHRoIiwiMiIsIkBjZW50ZXJfeSIsImhlaWdodCIsIkB2aXNpYmxlIiwiQHZhbmlzaGVkIiwiX2luaXRfY29sbGlzaW9uX2luZm8iLCJhdHRyX2FjY2Vzc29yIiwiYXR0cl9yZWFkZXIiLCJ4PSIsIm5ld3giLCJAX21hdHRlcl9ib2R5IiwiX21vdmVfbWF0dGVyX2JvZHkiLCJ5PSIsIm5ld3kiLCJpbWFnZT0iLCJpbWciLCJAY29sbGlzaW9uIiwiJHdyaXRlciIsIi0i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QUFBQSxnQkFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQ0UsUUFBQSxJQUFBLFFBQW1DVyxVQUFBWixTQUFBQSxDQUFBQSxDQUFuQyxDQUFBO0FBQUEsY0FBQTBDLE9BQUFBLENBQU0seUJBQU5BLENBQUEsQ0FBQTtBQUFBLFFBQ0EsSUFBQSxRQUFXbkIsWUFBRDdCLE1BQUFBLENBQUFBLENBQVYsQ0FBQTtBQUFBLFVBQUEsVUFBQSxDQURBO0FBQUEsUUFHQSxPQUFBLHNCQUFBaUQsU0FBQUEsQ0FBZWpDLFFBQUlDLFFBQUlDLFlBQ1IsbUZBQUEsV0FBU0csWUFBVCxFQUFBLFdBQTRCQyxZQUE1QixFQUFBLFNBQ080QixVQURQLEVBQUEsU0FDc0JDLFVBRHRCLEVBQUEsU0FFTy9CLFVBRlAsRUFBQSxZQUV5QkcsYUFGekIsRUFBQSxZQUU4Q0ksYUFGOUMsRUFEZnNCLENBSEE7QUFERjFDLE1BQUFBLENBQUFBLDZCQUFBQSxDQUFBQSxnQkFwRkE7QUFERmhCLElBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBREZELEVBQUFBLEdBQUFBLFdBQUFBLFdBSEE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODg3OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImR4b3BhbC93aW5kb3cucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnZHhvcGFsL2NvbnN0YW50cy9jb2xvcnMnXG5cbm1vZHVsZSBEWE9wYWxcbiAgbW9kdWxlIFdpbmRvd1xuICAgIEBAZnBzID0gNjBcbiAgICBAQGZwc190cyA9IG5pbFxuICAgIEBAZnBzX2N0ID0gMFxuICAgIEBAcmVhbF9mcHMgPSAwXG4gICAgQEByZWFsX2Zwc19jdCA9IDFcbiAgICBAQHJlYWxfZnBzX3QgPSBUaW1lLm5vd1xuICAgIEBAd2lkdGggPSA2NDBcbiAgICBAQGhlaWdodCA9IDQ4MFxuICAgIEBAYmxvY2sgPSBuaWxcbiAgICBAQHBhdXNlZCA9IGZhbHNlXG5cbiAgICAjIExvYWQgcmVzb3VyY2VzIHNwZWNpZmllZCB3aXRoIEltYWdlLnJlZ2lzdGVyIG9yIFNvdW5kLnJlZ2lzdGVyXG4gICAgIyBDYWxsIGJsb2NrIHdoZW4gbG9hZGVkXG4gICAgZGVmIHNlbGYubG9hZF9yZXNvdXJjZXMoJmJsb2NrKVxuICAgICAgUmVtb3RlUmVzb3VyY2UuX2xvYWRfcmVzb3VyY2VzIGRvXG4gICAgICAgIERYT3BhbC5kdW1wX2Vycm9yKCZibG9jaylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgIyBTdGFydCBtYWluIGxvb3BcbiAgICAjXG4gICAgIyBXaGVuIGNhbGxlZCB0d2ljZSwgcHJldmlvdXMgbG9vcCBpcyBzdG9wcGVkICh0aGlzIGlzIHVzZWZ1bFxuICAgICMgd2hlbiBpbXBsZW1lbnRpbmcgaW50ZXJhY3RpdmUgZ2FtZSBlZGl0b3IsIGV0Yy4pXG4gICAgZGVmIHNlbGYubG9vcCgmYmxvY2spXG4gICAgICBhbHJlYWR5X3J1bm5pbmcgPSAhIUBAYmxvY2tcbiAgICAgIEBAYmxvY2sgPSBibG9ja1xuICAgICAgcmV0dXJuIGlmIGFscmVhZHlfcnVubmluZ1xuICAgICAgYHdpbmRvd2AuSlMucmVxdWVzdEFuaW1hdGlvbkZyYW1le3x0aW1lfCBfbG9vcCh0aW1lKSB9XG4gICAgZW5kXG5cbiAgICAjIChEWE9wYWwgb3JpZ2luYWwpIFBhdXNlICYgcmVzdW1lXG4gICAgZGVmIHNlbGYucGF1c2VcbiAgICAgIEBAcGF1c2VkID0gdHJ1ZVxuICAgICAgQEBkcmF3X3F1ZXVlLmNsZWFyXG4gICAgICBkcmF3X3BhdXNlX3NjcmVlblxuICAgIGVuZFxuICAgIGRlZiBzZWxmLnBhdXNlZD87IEBAcGF1c2VkOyBlbmRcbiAgICBkZWYgc2VsZi5yZXN1bWVcbiAgICAgIHJhaXNlIFwiV2luZG93LnJlc3VtZSBpcyBjYWxsZWQgYmVmb3JlIFdpbmRvdy5sb29wXCIgaWYgQEBibG9jay5uaWw/XG4gICAgICBAQHBhdXNlZCA9IGZhbHNlOyBXaW5kb3cubG9vcCgmQEBibG9jaylcbiAgICBlbmRcbiAgICBkZWYgc2VsZi5kcmF3X3BhdXNlX3NjcmVlblxuICAgICAgV2luZG93LmRyYXdfYm94X2ZpbGwoMCwgMCwgV2luZG93LndpZHRoLCBXaW5kb3cuaGVpZ2h0LCBDX0JMQUNLKVxuICAgICAgV2luZG93LmRyYXdfZm9udCgwLCAwLCBcIi4uLlBBVVNFLi4uXCIsIEZvbnQuZGVmYXVsdCwgY29sb3I6IENfV0hJVEUpXG4gICAgZW5kXG5cbiAgICAjIChpbnRlcm5hbCkgY2FsbCBAQGJsb2NrIHBlcmlvZGljYWxseVxuICAgIGRlZiBzZWxmLl9sb29wKHRpbWVzdGFtcClcbiAgICAgIEBAaW1nIHx8PSBfaW5pdFxuXG4gICAgICAjIENhbGN1bGF0ZSBmcHNcbiAgICAgIGZyYW1lX21zZWMgPSAxMDAwLjAgLyBAQGZwc1xuICAgICAgQEBmcHNfdHMgfHw9IHRpbWVzdGFtcFxuICAgICAgcGFzc2VkX21zZWMgPSB0aW1lc3RhbXAgLSBAQGZwc190c1xuICAgICAgQEBmcHNfdHMgPSB0aW1lc3RhbXBcbiAgICAgIEBAZnBzX2N0ICs9IHBhc3NlZF9tc2VjXG4gICAgICBpZiBAQGZwc19jdCA+PSBmcmFtZV9tc2VjXG4gICAgICAgIEBAZnBzX2N0IC09IGZyYW1lX21zZWNcbiAgICAgIGVsc2VcbiAgICAgICAgYHdpbmRvd2AuSlMucmVxdWVzdEFuaW1hdGlvbkZyYW1le3x0aW1lfCBfbG9vcCh0aW1lKSB9XG4gICAgICAgIHJldHVyblxuICAgICAgZW5kXG5cbiAgICAgICMgQ2FsY3VsYXRlIHJlYWxfZnBzXG4gICAgICB0ID0gVGltZS5ub3dcbiAgICAgIGlmIHQgLSBAQHJlYWxfZnBzX3QgPj0gMS4wXG4gICAgICAgIEBAcmVhbF9mcHMgPSBAQHJlYWxfZnBzX2N0XG4gICAgICAgIEBAcmVhbF9mcHNfY3QgPSAxXG4gICAgICAgIEBAcmVhbF9mcHNfdCA9IHRcbiAgICAgIGVsc2VcbiAgICAgICAgQEByZWFsX2Zwc19jdCArPSAxXG4gICAgICBlbmRcblxuICAgICAgIyBVcGRhdGUgcGh5c2ljc1xuICAgICAgU3ByaXRlLm1hdHRlcl90aWNrKHRpbWVzdGFtcCkgaWYgU3ByaXRlLm1hdHRlcl9lbmFibGVkP1xuXG4gICAgICAjIERldGVjdCBpbnB1dHNcbiAgICAgIElucHV0Ll9vbl90aWNrXG5cbiAgICAgICMgQ2FsbCB1c2VyIGNvZGVcbiAgICAgIEBAZHJhd19xdWV1ZSA9IFtdXG4gICAgICBpZiBAQHBhdXNlZFxuICAgICAgICBXaW5kb3cuZHJhd19wYXVzZV9zY3JlZW5cbiAgICAgIGVsc2VcbiAgICAgICAgRFhPcGFsLmR1bXBfZXJyb3IoJkBAYmxvY2spXG4gICAgICBlbmRcblxuICAgICAgIyBEcmF3XG4gICAgICBAQGltZy5ib3hfZmlsbCgwLCAwLCBAQHdpZHRoLCBAQGhlaWdodCwgQEBiZ2NvbG9yKVxuICAgICAgc29ydGVkID0gQEBkcmF3X3F1ZXVlLnNvcnR7fGEsIGJ8IGFbMF0gPT0gYlswXSA/IGFbMV0gPD0+IGJbMV0gOiBhWzBdIDw9PiBiWzBdIH1cbiAgICAgIHNvcnRlZC5lYWNoIGRvIHxpdGVtfFxuICAgICAgICBjYXNlIGl0ZW1bMl1cbiAgICAgICAgd2hlbiA6aW1hZ2UgdGhlbiBAQGltZy5kcmF3KCppdGVtLmRyb3AoMykpXG4gICAgICAgIHdoZW4gOmltYWdlX3JvdCB0aGVuIEBAaW1nLmRyYXdfcm90KCppdGVtLmRyb3AoMykpXG4gICAgICAgIHdoZW4gOmltYWdlX3NjYWxlIHRoZW4gQEBpbWcuZHJhd19zY2FsZSgqaXRlbS5kcm9wKDMpKVxuICAgICAgICB3aGVuIDpkcmF3X2V4IHRoZW4gQEBpbWcuZHJhd19leCgqaXRlbS5kcm9wKDMpKVxuICAgICAgICB3aGVuIDpmb250IHRoZW4gQEBpbWcuZHJhd19mb250KCppdGVtLmRyb3AoMykpIFxuICAgICAgICB3aGVuIDpwaXhlbCB0aGVuIEBAaW1nLltdPSgqaXRlbS5kcm9wKDMpKVxuICAgICAgICB3aGVuIDpsaW5lIHRoZW4gQEBpbWcubGluZSgqaXRlbS5kcm9wKDMpKVxuICAgICAgICB3aGVuIDpib3ggdGhlbiBAQGltZy5ib3goKml0ZW0uZHJvcCgzKSlcbiAgICAgICAgd2hlbiA6Ym94X2ZpbGwgdGhlbiBAQGltZy5ib3hfZmlsbCgqaXRlbS5kcm9wKDMpKVxuICAgICAgICB3aGVuIDpjaXJjbGUgdGhlbiBAQGltZy5jaXJjbGUoKml0ZW0uZHJvcCgzKSlcbiAgICAgICAgd2hlbiA6Y2lyY2xlX2ZpbGwgdGhlbiBAQGltZy5jaXJjbGVfZmlsbCgqaXRlbS5kcm9wKDMpKVxuICAgICAgICB3aGVuIDp0cmlhbmdsZSB0aGVuIEBAaW1nLnRyaWFuZ2xlKCppdGVtLmRyb3AoMykpXG4gICAgICAgIHdoZW4gOnRyaWFuZ2xlX2ZpbGwgdGhlbiBAQGltZy50cmlhbmdsZV9maWxsKCppdGVtLmRyb3AoMykpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIGB3aW5kb3dgLkpTLnJlcXVlc3RBbmltYXRpb25GcmFtZXt8dGltZXwgX2xvb3AodGltZSkgfVxuICAgIGVuZFxuXG4gICAgZGVmIHNlbGYuX2luaXRcbiAgICAgIGNhbnZhcyA9IGBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImR4b3BhbC1jYW52YXNcIilgXG4gICAgICAjIElmIHVzZXIgZGlkIG5vdCBjaGFuZ2UgV2luZG93LndpZHRoL1dpbmRvdy5oZWlnaHQsIHNldCB0aGUgY2FudmFzIHNpemUgaGVyZVxuICAgICAgc2VsZi53aWR0aCA9IEBAd2lkdGhcbiAgICAgIHNlbGYuaGVpZ2h0ID0gQEBoZWlnaHRcbiAgICAgIGltZyA9IEltYWdlLm5ldyhzZWxmLndpZHRoLCBzZWxmLmhlaWdodCwgY2FudmFzOiBjYW52YXMpXG4gICAgICBJbnB1dC5faW5pdChjYW52YXMpXG4gICAgICByZXR1cm4gaW1nXG4gICAgZW5kXG5cbiAgICAjIFJldHVybiBpbnRlcm5hbCBEWE9wYWw6OkltYWdlIG9iamVjdCAoZm9yIGV4cGVyaW1lbnRhbC9oYWNraW5nIHVzZSlcbiAgICBkZWYgc2VsZi5faW1nOyBAQGltZzsgZW5kXG5cbiAgICBkZWYgc2VsZi5mcHM7IEBAZnBzOyBlbmRcbiAgICBkZWYgc2VsZi5mcHM9KHcpOyBAQGZwcyA9IHc7IGVuZFxuICAgIGRlZiBzZWxmLnJlYWxfZnBzOyBAQHJlYWxfZnBzOyBlbmRcbiAgICBkZWYgc2VsZi53aWR0aDsgQEB3aWR0aDsgZW5kXG4gICAgIyBTZXQgd2luZG93IHdpZHRoIGFuZCByZXNpemUgdGhlIGNhbnZhc1xuICAgICMgU2V0IGBuaWxgIHRvIG1heGltaXplIGNhbnZhc1xuICAgIGRlZiBzZWxmLndpZHRoPSh3KVxuICAgICAgY2FudmFzID0gYGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHhvcGFsLWNhbnZhc1wiKWBcbiAgICAgIEBAd2lkdGggPSB3IHx8IGB3aW5kb3cuaW5uZXJXaWR0aGBcbiAgICAgIGBjYW52YXMud2lkdGggPSAje0BAd2lkdGh9YFxuICAgICAgYGNhbnZhcy5zdHlsZS53aWR0aCA9ICN7QEB3aWR0aH1gXG4gICAgZW5kXG4gICAgZGVmIHNlbGYuaGVpZ2h0OyBAQGhlaWdodDsgZW5kXG4gICAgIyBTZXQgd2luZG93IGhlaWdodCBhbmQgcmVzaXplIHRoZSBjYW52YXNcbiAgICAjIFNldCBgbmlsYCB0byBtYXhpbWl6ZSBjYW52YXNcbiAgICBkZWYgc2VsZi5oZWlnaHQ9KGgpXG4gICAgICBjYW52YXMgPSBgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkeG9wYWwtY2FudmFzXCIpYFxuICAgICAgQEBoZWlnaHQgPSBoIHx8IGB3aW5kb3cuaW5uZXJIZWlnaHRgXG4gICAgICBgY2FudmFzLmhlaWdodCA9ICN7QEBoZWlnaHR9YFxuICAgICAgYGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAje0BAaGVpZ2h0fWBcbiAgICBlbmRcbiAgICBAQGJnY29sb3IgPSBDb25zdGFudHM6OkNvbG9yczo6Q19CTEFDS1xuICAgIGRlZiBzZWxmLmJnY29sb3I7IEBAYmdjb2xvcjsgZW5kXG4gICAgZGVmIHNlbGYuYmdjb2xvcj0oY29sKTsgQEBiZ2NvbG9yID0gY29sOyBlbmRcblxuICAgIGRlZiBzZWxmLmRyYXcoeCwgeSwgaW1hZ2UsIHo9MClcbiAgICAgIGVucXVldWVfZHJhdyh6LCA6aW1hZ2UsIHgsIHksIGltYWdlKVxuICAgIGVuZFxuXG4gICAgZGVmIHNlbGYuZHJhd19zY2FsZSh4LCB5LCBpbWFnZSwgc2NhbGVfeCwgc2NhbGVfeSwgY2VudGVyX3g9bmlsLCBjZW50ZXJfeT1uaWwsIHo9MClcbiAgICAgIGVucXVldWVfZHJhdyh6LCA6aW1hZ2Vfc2NhbGUsIHgsIHksIGltYWdlLCBzY2FsZV94LCBzY2FsZV95LCBjZW50ZXJfeCwgY2VudGVyX3kpXG4gICAgZW5kXG5cbiAgICBkZWYgc2VsZi5kcmF3X3JvdCh4LCB5LCBpbWFnZSwgYW5nbGUsIGNlbnRlcl94PW5pbCwgY2VudGVyX3k9bmlsLCB6PTApXG4gICAgICBlbnF1ZXVlX2RyYXcoeiwgOmltYWdlX3JvdCwgeCwgeSwgaW1hZ2UsIGFuZ2xlLCBjZW50ZXJfeCwgY2VudGVyX3kpXG4gICAgZW5kXG5cbiAgICBkZWYgc2VsZi5kcmF3X2V4KHgsIHksIGltYWdlLCBvcHRpb25zPXt9KVxuICAgICAgZW5xdWV1ZV9kcmF3KG9wdGlvbnNbOnpdIHx8IDAsIDpkcmF3X2V4LCB4LCB5LCBpbWFnZSwgb3B0aW9ucylcbiAgICBlbmRcblxuICAgIGRlZiBzZWxmLmRyYXdfZm9udCh4LCB5LCBzdHJpbmcsIGZvbnQsIG9wdGlvbj17fSlcbiAgICAgIHogPSBvcHRpb25bOnpdIHx8IDBcbiAgICAgIGNvbG9yID0gb3B0aW9uWzpjb2xvcl0gfHwgWzI1NSwgMjU1LCAyNTVdXG4gICAgICBlbnF1ZXVlX2RyYXcoeiwgOmZvbnQsIHgsIHksIHN0cmluZywgZm9udCwgY29sb3IpXG4gICAgZW5kXG5cbiAgICBkZWYgc2VsZi5kcmF3X3BpeGVsKHgsIHksIGNvbG9yLCB6PTApXG4gICAgICBlbnF1ZXVlX2RyYXcoeiwgOnBpeGVsLCB4LCB5LCBjb2xvcilcbiAgICBlbmRcblxuICAgIGRlZiBzZWxmLmRyYXdfbGluZSh4MSwgeTEsIHgyLCB5MiwgY29sb3IsIHo9MClcbiAgICAgIGVucXVldWVfZHJhdyh6LCA6bGluZSwgeDEsIHkxLCB4MiwgeTIsIGNvbG9yKVxuICAgIGVuZFxuXG4gICAgZGVmIHNlbGYuZHJhd19ib3goeDEsIHkxLCB4MiwgeTIsIGNvbG9yLCB6PTApXG4gICAgICBlbnF1ZXVlX2RyYXcoeiwgOmJveCwgeDEsIHkxLCB4MiwgeTIsIGNvbG9yKVxuICAgIGVuZFxuXG4gICAgZGVmIHNlbGYuZHJhd19ib3hfZmlsbCh4MSwgeTEsIHgyLCB5MiwgY29sb3IsIHo9MClcbiAgICAgIGVucXVldWVfZHJhdyh6LCA6Ym94X2ZpbGwsIHgxLCB5MSwgeDIsIHkyLCBjb2xvcilcbiAgICBlbmRcblxuICAgIGRlZiBzZWxmLmRyYXdfY2lyY2xlKHgsIHksIHIsIGNvbG9yLCB6PTApXG4gICAgICBlbnF1ZXVlX2RyYXcoeiwgOmNpcmNsZSwgeCwgeSwgciwgY29sb3IpXG4gICAgZW5kXG5cbiAgICBkZWYgc2VsZi5kcmF3X2NpcmNsZV9maWxsKHgsIHksIHIsIGNvbG9yLCB6PTApXG4gICAgICBlbnF1ZXVlX2RyYXcoeiwgOmNpcmNsZV9maWxsLCB4LCB5LCByLCBjb2xvcilcbiAgICBlbmRcblxuICAgIGRlZiBzZWxmLmRyYXdfdHJpYW5nbGUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgY29sb3IsIHo9MClcbiAgICAgIGVucXVldWVfZHJhdyh6LCA6dHJpYW5nbGUsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIGNvbG9yKVxuICAgIGVuZFxuXG4gICAgZGVmIHNlbGYuZHJhd190cmlhbmdsZV9maWxsKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIGNvbG9yLCB6PTApXG4gICAgICBlbnF1ZXVlX2RyYXcoeiwgOnRyaWFuZ2xlX2ZpbGwsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIGNvbG9yKVxuICAgIGVuZFxuXG4gICAgIyAoaW50ZXJuYWwpXG4gICAgZGVmIHNlbGYuZW5xdWV1ZV9kcmF3KHosICphcmdzKVxuICAgICAgQEBkcmF3X3F1ZXVlLnB1c2goW3osIEBAZHJhd19xdWV1ZS5sZW5ndGgsICphcmdzXSlcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwibW9kdWxlIiwiQEBmcHMiLCI2MCIsIkBAZnBzX3RzIiwiQEBmcHNfY3QiLCIwIiwiQEByZWFsX2ZwcyIsIkBAcmVhbF9mcHNfY3QiLCIxIiwiQEByZWFsX2Zwc190Iiwibm93IiwiQEB3aWR0aCIsIjY0MCIsIkBAaGVpZ2h0IiwiNDgwIiwiQEBibG9jayIsIkBAcGF1c2VkIiwibG9hZF9yZXNvdXJjZXMiLCJzZWxmIiwiX2xvYWRfcmVzb3VyY2VzIiwiZHVtcF9lcnJvciIsImJsb2NrIiwibG9vcCIsImFscmVhZHlfcnVubmluZyIsIiEiLCJfbG9vcCIsInRpbWUiLCJwYXVzZSIsIkBAZHJhd19xdWV1ZSIsImNsZWFyIiwiZHJhd19wYXVzZV9zY3JlZW4iLCJwYXVzZWQ/IiwicmVzdW1lIiwibmlsPyIsInJhaXNlIiwiZHJhd19ib3hfZmlsbCIsIndpZHRoIiwiaGVpZ2h0IiwiZHJhd19mb250IiwiZGVmYXVsdCIsIkBAaW1nIiwiJHJldF9vcl8xIiwiX2luaXQiLCJmcmFtZV9tc2VjIiwiLyIsIiRyZXRfb3JfMiIsInRpbWVzdGFtcCIsInBhc3NlZF9tc2VjIiwiLSIsIisiLCI+PSIsInQiLCJtYXR0ZXJfZW5hYmxlZD8iLCJtYXR0ZXJfdGljayIsIl9vbl90aWNrIiwiYm94X2ZpbGwiLCJAQGJnY29sb3IiLCJzb3J0ZWQiLCJzb3J0IiwiYSIsIltdIiwiPT0iLCJiIiwiPD0+IiwiZWFjaCIsIml0ZW0iLCIyIiwiZHJhdyIsImRyb3AiLCIzIiwiZHJhd19yb3QiLCJkcmF3X3NjYWxlIiwiZHJhd19leCIsIiR3cml0ZXIiLCJbXT0iLCJsaW5lIiwiYm94IiwiY2lyY2xlIiwiY2lyY2xlX2ZpbGwiLCJ0cmlhbmdsZSIsInRyaWFuZ2xlX2ZpbGwiLCJjYW52YXMiLCJ3aWR0aD0iLCJoZWlnaHQ9IiwiaW1nIiwibmV3IiwiX2ltZyIsImZwcyIsImZwcz0iLCJ3IiwicmVhbF9mcHMiLCIkcmV0X29yXzMiLCIkcmV0X29yXzQiLCJoIiwiYmdjb2xvciIsImJnY29sb3I9IiwiY29sIiwiZW5xdWV1ZV9kcmF3IiwieiIsIngiLCJ5IiwiaW1hZ2UiLCJzY2FsZV94Iiwic2NhbGVfeSIsImNlbnRlcl94IiwiY2VudGVyX3kiLCJhbmdsZSIsIiRyZXRfb3JfNSIsIm9wdGlvbnMiLCIkcmV0X29yXzYiLCJvcHRpb24iLCJjb2xvciIsIiRyZXRfb3JfNyIsIjI1NSIsInN0cmluZyIsImZvbnQiLCJkcmF3X3BpeGVsIiwiZHJhd19saW5lIiwieDEiLCJ5MSIsIngyIiwieTIiLCJkcmF3X2JveCIsImRyYXdfY2lyY2xlIiwiciIsImRyYXdfY2lyY2xlX2ZpbGwiLCJkcmF3X3RyaWFuZ2xlIiwieDMiLCJ5MyIsImRyYXdfdHJpYW5nbGVfZmlsbCIsInB1c2giLCJsZW5ndGgiLCJhcmdzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLHlCQUFSQSxDQUFBO0FBQUEsRUFFQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsT0FBQUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFDLDBDQUFRQyxFQUFSRCxDQUFBO0FBQUEsTUFDQUUsNkNBQVcsR0FBWEEsQ0FEQTtBQUFBLE1BRUFDLDZDQUFXQyxDQUFYRCxDQUZBO0FBQUEsTUFHQUUsK0NBQWFELENBQWJDLENBSEE7QUFBQSxNQUlBQyxrREFBZ0JDLENBQWhCRCxDQUpBO0FBQUEsTUFLQUUsaURBQWUsb0JBQUFDLEtBQUFBLENBQUFBLENBQWZELENBTEE7QUFBQSxNQU1BRSw0Q0FBVUMsR0FBVkQsQ0FOQTtBQUFBLE1BT0FFLDZDQUFXQyxHQUFYRCxDQVBBO0FBQUEsTUFRQUUsNENBQVUsR0FBVkEsQ0FSQTtBQUFBLE1BU0FDLDZDQUFXLEtBQVhBLENBVEE7QUFBQSxNQWFBQyxVQUFJQyxJQUFKRCxxQkFBQUEsMkJB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REE7QUFBQUEsUUFBQUE7O0FBQUFBO0FBNU1KO0FBNE0rRCxRQUFBO0FBQUEsUUFBQSxNQUFFNUgsQ0FBRjtBQUFBLFFBQUEsQ0E1TS9EO0FBQUEsUUE2TU0sV0FBQTRGLGNBQUFBLENBQWFDLEdBQUcsaUJBQWdCb0IsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSU0sSUFBSUMsSUFBSWpCLEtBQXhEZCxDQTdNTjtBQTRNSWdDLE1BQUFBLENBQUFBLDRDQUFBQSxDQXZNQTtBQUFBLE1BNE1BLE9BQUFoQyxDQUFBQSxVQUFJL0UsSUFBSitFLG1CQUFBQSwwQkFBQUEsd0JBQXNCLENBQUQsRUFqTnpCLEVBaU5JQTtBQUFBQSxRQUFBQTs7QUFBQUE7QUFqTko7QUFBQSxRQUFBLDREQUFBO0FBQUE7QUFpTjZCLFFBQUEsa0JBak43QjtBQUFBLFFBa05NLE9BQUFyRSx1REFBQXNHLE1BQUFBLENBQWtCLENBQUNoQyxDQUFELEVBQUl0RSx1REFBQXVHLFFBQUFBLENBQUFBLENBQUosQ0FBQSxRQUF5QixVQUFDQyxJQUFELENBQXpCLENBQWxCRixDQWxOTjtBQWlOSWpDLE1BQUFBLENBQUFBLHNDQUFBQSxDQUFBQSx3QkE1TUE7QUFERmpHLElBQUFBLEdBQUFBLFdBQUFBO0FBREZBLEVBQUFBLEdBQUFBLFdBQUFBLFdBRkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTM0OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImR4b3BhbC92ZXJzaW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBEWE9wYWxcbiAgVkVSU0lPTiA9IFwiMS41LjJcIlxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUEsdUNBQVUsT0FBVjtBQURGQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5MzYxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9zaW5nbGV0b24ucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIFNpbmdsZXRvblxuICBkZWYgY2xvbmVcbiAgICByYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgY2xvbmUgaW5zdGFuY2Ugb2Ygc2luZ2xldG9uICN7c2VsZi5jbGFzc31cIlxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgcmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGR1cCBpbnN0YW5jZSBvZiBzaW5nbGV0b24gI3tzZWxmLmNsYXNzfVwiXG4gIGVuZFxuXG4gIG1vZHVsZSBTaW5nbGV0b25DbGFzc01ldGhvZHNcbiAgICBkZWYgY2xvbmVcbiAgICAgIFNpbmdsZXRvbi5fX2luaXRfXyhzdXBlcilcbiAgICBlbmRcblxuICAgIGRlZiBpbmhlcml0ZWQoc3ViX2tsYXNzKVxuICAgICAgc3VwZXJcbiAgICAgIFNpbmdsZXRvbi5fX2luaXRfXyhzdWJfa2xhc3MpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGNsYXNzIDw8IFNpbmdsZXRvblxuICAgIGRlZiBfX2luaXRfXyhrbGFzcylcbiAgICAgIGtsYXNzLmluc3RhbmNlX2V2YWwgZG9cbiAgICAgICAgQHNpbmdsZXRvbl9faW5zdGFuY2VfXyA9IG5pbFxuICAgICAgZW5kXG4gICAgICBkZWYga2xhc3MuaW5zdGFuY2VcbiAgICAgICAgcmV0dXJuIEBzaW5nbGV0b25fX2luc3RhbmNlX18gaWYgQHNpbmdsZXRvbl9faW5zdGFuY2VfX1xuICAgICAgICBAc2luZ2xldG9uX19pbnN0YW5jZV9fID0gbmV3XG4gICAgICBlbmRcbiAgICAgIGtsYXNzXG4gICAgZW5kXG5cbiAgICBkZWYgaW5jbHVkZWQoa2xhc3MpXG4gICAgICBzdXBlclxuICAgICAga2xhc3MuZXh0ZW5kIFNpbmdsZXRvbkNsYXNzTWV0aG9kc1xuICAgICAgU2luZ2xldG9uLl9faW5pdF9fKGtsYXNzKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsb25lIiwicmFpc2UiLCJzZWxmIiwiY2xhc3MiLCJkdXAiLCJfX2luaXRfXyIsImluaGVyaXRlZCIsInN1Yl9rbGFzcyIsImluc3RhbmNlX2V2YWwiLCJrbGFzcyIsIkBzaW5nbGV0b25fX2luc3RhbmNlX18iLCJpbnN0YW5jZSIsIm5ldyIsImluY2x1ZGVkIiwiZXh0ZW5kIl0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRTtBQUFBQyxJQUFBQSx5QkFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBQyxPQUFBQSxDQUFNLDJCQUFXLEVBQUEsR0FBQSxvQ0FBQSxHQUFBLENBQXFDQyxJQUFBQyxPQUFBQSxDQUFBQSxDQUFyQyxDQUFqQkY7QUFERkQsSUFBQUEsQ0FBQUEsZ0NBQUFBLENBQUE7QUFBQTtBQUlBSSxJQUFBQSx1QkFBQUEsbUJBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLFdBQUFILE9BQUFBLENBQU0sMkJBQVcsRUFBQSxHQUFBLGtDQUFBLEdBQUEsQ0FBbUNDLElBQUFDLE9BQUFBLENBQUFBLENBQW5DLENBQWpCRjtBQURGRyxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FKQTtBQUFBLElBUUFMO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRTtBQUFBQyxNQUFBQSx5QkFBQUEsaUNBQUFBLGlCQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFBQUE7QUFBQUEsUUFBQUE7QUFBQUEsUUFBQUE7QUFBQUEsUUFBQUE7QUFBQUEsUUFBQUE7QUFBQUEsUUFDRSxPQUFBLHlCQUFBSyxVQUFBQSxDQUFtQixXQUFBLEVBQUEsc0ZBQUEsU0FBQSxRQUFBLE9BQUEsQ0FBbkJBO0FBREZMLE1BQUFBLENBQUFBLDRDQUFBQSxDQUFBO0FBQUEsTUFJQSxPQUFBTSxDQUFBQSw2QkFBQUEscUNBQUFBLHFCQUFjLFNBQWRBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQTtBQUNFLFFBQUEsV0FBQSxFQUFBLDhGQUFBLGFBQUEsUUFBQSxPQUFBLENBQUE7QUFBQSxRQUNBLE9BQUEseUJBQUFELFVBQUFBLENBQW1CRSxTQUFuQkYsQ0FEQTtBQURGQyxNQUFBQSxDQUFBQSxnREFBQUEsQ0FBQUEscUJBSkE7QUFERlAsSUFBQUEsR0FBQUEsV0FBQUEsV0FSQTtBQUFBLElBbUJBLE9BQUE7QUFBQSxNQUFBOztBQUFBO0FBQ0U7QUFBQU0sTUFBQUEsNEJBQUFBLGNBQUFBLG9CQUFhLEtBQWJBO0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUFHLE1BQUFDLEtBQUFELGlCQUFBQSxFQUFBQSxFQUFBQSxFQXZCTixnQkFBQSxFQUFBOztBQUFBLFFBd0JRLE9BQUFFLENBQUFBLDZCQUF5QixHQUF6QkEsQ0F4QlIsa0JBQUEsaUJBQUEsS0F1Qk1GLENBQUE7QUFBQSxRQUdBRyxVQUFJRixLQUFKRSxlQUFBQSxjQUFBQSxvQkFBQUE7QUFBQUEsVUFBQUE7QUFBQUE7O0FBQUFBO0FBQ0UsVUFBQSxJQUFBLFFBQWlDRCwwQkFBakMsQ0FBQTtBQUFBLFlBQUEsT0FBT0EsMEJBQVAsQ0FBQTtBQUFBLFVBQ0EsT0FBQUEsQ0FBQUEsaUNBQXlCRSxLQUFBQSxDQUFBQSxDQUF6QkYsQ0FEQTtBQURGQyxRQUFBQSxDQUFBQSx5QkFBQUEsQ0FIQTtBQUFBLFFBT0EsT0FBQUYsS0FQQTtBQURGSixNQUFBQSxDQUFBQSx5QkFBQUEsQ0FBQTtBQUFBLE1BV0EsT0FBQVEsQ0FBQUEsNEJBQUFBLGNBQUFBLG9CQUFhLEtBQWJBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQTtBQUNFLFFBQUEsV0FBQSxFQUFBLHNFQUFBLFlBQUEsUUFBQSxPQUFBLENBQUE7QUFBQSxRQUNBSixLQUFBSyxRQUFBQSxDQUFhLHFDQUFiQSxDQURBO0FBQUEsUUFFQSxPQUFBLHlCQUFBVCxVQUFBQSxDQUFtQkksS0FBbkJKLENBRkE7QUFERlEsTUFBQUEsQ0FBQUEseUJBQUFBLENBQUFBLG9CQVhBO0FBREYsSUFBQSw0QkFBUyx5QkFBVCxZQW5CQTtBQURGZCxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5NDU0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9kZWxlZ2F0ZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBEZWxlZ2F0b3IgPCBCYXNpY09iamVjdFxuICBkZWYgaW5pdGlhbGl6ZShvYmopXG4gICAgX19zZXRvYmpfXyhvYmopXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfbWlzc2luZyhtLCAqYXJncywgJmJsb2NrKVxuICAgIHRhcmdldCA9IF9fZ2V0b2JqX19cblxuICAgIGlmIHRhcmdldC5yZXNwb25kX3RvPyhtKVxuICAgICAgdGFyZ2V0Ll9fc2VuZF9fKG0sICphcmdzLCAmYmxvY2spXG4gICAgZWxzZVxuICAgICAgc3VwZXIobSwgKmFyZ3MsICZibG9jaylcbiAgICBlbmRcbiAgZW5kXG5cbiAgI1xuICAjIENoZWNrcyBmb3IgYSBtZXRob2QgcHJvdmlkZWQgYnkgdGhpcyB0aGUgZGVsZWdhdGUgb2JqZWN0IGJ5IGZvcndhcmRpbmcgdGhlXG4gICMgY2FsbCB0aHJvdWdoIFxcX1xcX2dldG9ialxcX1xcXy5cbiAgI1xuICBkZWYgcmVzcG9uZF90b19taXNzaW5nPyhtLCBpbmNsdWRlX3ByaXZhdGUpXG4gICAgX19nZXRvYmpfXy5yZXNwb25kX3RvPyhtLCBpbmNsdWRlX3ByaXZhdGUpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFNpbXBsZURlbGVnYXRvciA8IERlbGVnYXRvclxuICBkZWYgX19nZXRvYmpfX1xuICAgIEBkZWxlZ2F0ZV9zZF9vYmpcbiAgZW5kXG5cbiAgZGVmIF9fc2V0b2JqX18ob2JqKVxuICAgIEBkZWxlZ2F0ZV9zZF9vYmogPSBvYmpcbiAgZW5kXG5lbmRcblxuZGVmIERlbGVnYXRlQ2xhc3Moc3VwZXJrbGFzcylcbiAgU2ltcGxlRGVsZWdhdG9yXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsImluaXRpYWxpemUiLCJfX3NldG9ial9fIiwib2JqIiwibWV0aG9kX21pc3NpbmciLCJ0YXJnZXQiLCJfX2dldG9ial9fIiwicmVzcG9uZF90bz8iLCJtIiwiX19zZW5kX18iLCJhcmdzIiwiYmxvY2siLCJyZXNwb25kX3RvX21pc3Npbmc/IiwiaW5jbHVkZV9wcml2YXRlIiwiQGRlbGVnYXRlX3NkX29iaiIsIkRlbGVnYXRlQ2xhc3MiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLEVBQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRTtBQUFBQyxJQUFBQSw4QkFBQUEsMEJBQUFBLHNCQUFlLEdBQWZBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLFdBQUFDLFlBQUFBLENBQVdDLEdBQVhEO0FBREZELElBQUFBLENBQUFBLHFDQUFBQSxDQUFBO0FBQUE7QUFJQUcsSUFBQUEsa0NBQUFBLDhCQUFBQSwwQkFBbUIsQ0FBRCxFQU5wQixFQU1FQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFORjtBQU0rQixNQUFBLGtEQU4vQjtBQUFBO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBTXdCLE1BQUEsa0JBTnhCO0FBQUEsTUFPSUMsYUFBU0MsWUFBQUEsQ0FBQUEsQ0FQYjtBQUFBLE1BU0ksSUFBQSxRQUFHRCxNQUFBRSxnQkFBQUEsQ0FBbUJDLENBQW5CRCxDQUFILENBQUE7QUFBQSxRQUNFLE9BQUFFLE1BQUFKLE1BQUFJLFlBQUFBLEdBQWdCRCxVQUFHLFVBQUNFLElBQUQsRUFBbkJELEVBQTJCRSxnQkFBM0JGO0FBREYsTUFBQTtBQUFBLFFBR0UsT0FBQSxXQUFBLEVBQUEsNEZBQUEsa0JBQUEsR0FBTUQsVUFBRyxVQUFDRSxJQUFELEVBQVQsRUFBaUJDLGdCQUFqQjtBQUhGLE1BQUEsQ0FUSjtBQU1FUCxJQUFBQSxDQUFBQSwwQ0FBQUEsQ0FKQTtBQUFBLElBa0JBLE9BQUFRLENBQUFBLHVDQUFBQSx1Q0FBQUEsU0FBd0IsQ0FBRCxFQUFJLGVBQTNCQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBTixZQUFBQSxDQUFBQSxDQUFBQyxnQkFBQUEsQ0FBdUJDLEdBQUdLLGVBQTFCTjtBQURGSyxJQUFBQSxDQUFBQSxrREFBQUEsQ0FBQUEsK0JBbEJBO0FBREZaLEVBQUFBLEdBQUFBLFdBQUFBLEVBQWtCLDJCQUFsQkEsV0FBQTtBQUFBLEVBd0JBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0U7QUFBQU0sSUFBQUEsOEJBQUFBLGdDQUFBQSxzQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQVE7QUFERlIsSUFBQUEsQ0FBQUEsMkNBQUFBLENBQUE7QUFBQSxJQUlBLE9BQUFKLENBQUFBLDhCQUFBQSxnQ0FBQUEsc0JBQWUsR0FBZkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQVksQ0FBQUEsdUJBQW1CWCxHQUFuQlc7QUFERlosSUFBQUEsQ0FBQUEsMkNBQUFBLENBQUFBLHNCQUpBO0FBREZGLEVBQUFBLEdBQUFBLFdBQUFBLEVBQXdCLHlCQUF4QkEsV0F4QkE7QUFBQSxFQWtDQSxPQUFBZSxDQUFBQSxpQ0FBQUEsbUJBQUFBLHlCQUFrQixVQUFsQkE7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsT0FBQTtBQURGQSxFQUFBQSxDQUFBQSw4QkFBQUEsQ0FBQUEseUJBbENBOzsifX0seyJvZmZzZXQiOnsibGluZSI6Mjk1MjMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL2ZvcndhcmRhYmxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBGb3J3YXJkYWJsZVxuICBkZWYgaW5zdGFuY2VfZGVsZWdhdGUoaGFzaClcbiAgICBoYXNoLmVhY2ggZG8gfG1ldGhvZHMsIGFjY2Vzc29yfFxuICAgICAgbWV0aG9kcyA9IFttZXRob2RzXSB1bmxlc3MgbWV0aG9kcy5yZXNwb25kX3RvPyA6ZWFjaFxuXG4gICAgICBtZXRob2RzLmVhY2ggZG8gfG1ldGhvZHxcbiAgICAgICAgZGVmX2luc3RhbmNlX2RlbGVnYXRvcihhY2Nlc3NvciwgbWV0aG9kKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBkZWZfaW5zdGFuY2VfZGVsZWdhdG9ycyhhY2Nlc3NvciwgKm1ldGhvZHMpXG4gICAgbWV0aG9kcy5lYWNoIGRvIHxtZXRob2R8XG4gICAgICBuZXh0IGlmICV3W19fc2VuZF9fIF9faWRfX10uaW5jbHVkZT8obWV0aG9kKVxuXG4gICAgICBkZWZfaW5zdGFuY2VfZGVsZWdhdG9yKGFjY2Vzc29yLCBtZXRob2QpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBkZWZfaW5zdGFuY2VfZGVsZWdhdG9yKGFjY2Vzc29yLCBtZXRob2QsIGFsaSA9IG1ldGhvZClcbiAgICBpZiBhY2Nlc3Nvci50b19zLnN0YXJ0X3dpdGg/ICdAJ1xuICAgICAgZGVmaW5lX21ldGhvZCBhbGkgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAgIGluc3RhbmNlX3ZhcmlhYmxlX2dldChhY2Nlc3NvcikuX19zZW5kX18obWV0aG9kLCAqYXJncywgJmJsb2NrKVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZGVmaW5lX21ldGhvZCBhbGkgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAgIF9fc2VuZF9fKGFjY2Vzc29yKS5fX3NlbmRfXyhtZXRob2QsICphcmdzLCAmYmxvY2spXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgZGVsZWdhdGUgaW5zdGFuY2VfZGVsZWdhdGVcbiAgYWxpYXMgZGVmX2RlbGVnYXRvcnMgZGVmX2luc3RhbmNlX2RlbGVnYXRvcnNcbiAgYWxpYXMgZGVmX2RlbGVnYXRvciBkZWZfaW5zdGFuY2VfZGVsZWdhdG9yXG5lbmRcblxubW9kdWxlIFNpbmdsZUZvcndhcmRhYmxlXG4gIGRlZiBzaW5nbGVfZGVsZWdhdGUoaGFzaClcbiAgICBoYXNoLmVhY2ggZG8gfG1ldGhvZHMsIGFjY2Vzc29yfFxuICAgICAgbWV0aG9kcyA9IFttZXRob2RzXSB1bmxlc3MgbWV0aG9kcy5yZXNwb25kX3RvPyA6ZWFjaFxuXG4gICAgICBtZXRob2RzLmVhY2ggZG8gfG1ldGhvZHxcbiAgICAgICAgZGVmX3NpbmdsZV9kZWxlZ2F0b3IoYWNjZXNzb3IsIG1ldGhvZClcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZGVmX3NpbmdsZV9kZWxlZ2F0b3JzKGFjY2Vzc29yLCAqbWV0aG9kcylcbiAgICBtZXRob2RzLmVhY2ggZG8gfG1ldGhvZHxcbiAgICAgIG5leHQgaWYgJXdbX19zZW5kX18gX19pZF9fXS5pbmNsdWRlPyBtZXRob2RcblxuICAgICAgZGVmX3NpbmdsZV9kZWxlZ2F0b3IoYWNjZXNzb3IsIG1ldGhvZClcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGRlZl9zaW5nbGVfZGVsZWdhdG9yKGFjY2Vzc29yLCBtZXRob2QsIGFsaSA9IG1ldGhvZClcbiAgICBpZiBhY2Nlc3Nvci50b19zLnN0YXJ0X3dpdGg/ICdAJ1xuICAgICAgZGVmaW5lX3NpbmdsZXRvbl9tZXRob2QgYWxpIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgICBpbnN0YW5jZV92YXJpYWJsZV9nZXQoYWNjZXNzb3IpLl9fc2VuZF9fKG1ldGhvZCwgKmFyZ3MsICZibG9jaylcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGRlZmluZV9zaW5nbGV0b25fbWV0aG9kIGFsaSBkbyB8KmFyZ3MsICZibG9ja3xcbiAgICAgICAgX19zZW5kX18oYWNjZXNzb3IpLl9fc2VuZF9fKG1ldGhvZCwgKmFyZ3MsICZibG9jaylcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBkZWxlZ2F0ZSBzaW5nbGVfZGVsZWdhdGVcbiAgYWxpYXMgZGVmX2RlbGVnYXRvcnMgZGVmX3NpbmdsZV9kZWxlZ2F0b3JzXG4gIGFsaWFzIGRlZl9kZWxlZ2F0b3IgZGVmX3NpbmdsZV9kZWxlZ2F0b3JcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImluc3RhbmNlX2RlbGVnYXRlIiwiZWFjaCIsImhhc2giLCJtZXRob2RzIiwicmVzcG9uZF90bz8iLCJkZWZfaW5zdGFuY2VfZGVsZWdhdG9yIiwiYWNjZXNzb3IiLCJtZXRob2QiLCJkZWZfaW5zdGFuY2VfZGVsZWdhdG9ycyIsImluY2x1ZGU/IiwidG9fcyIsInN0YXJ0X3dpdGg/IiwiZGVmaW5lX21ldGhvZCIsImFsaSIsIl9fc2VuZF9fIiwiaW5zdGFuY2VfdmFyaWFibGVfZ2V0IiwiYXJncyIsImJsb2NrIiwic2luZ2xlX2RlbGVnYXRlIiwiZGVmX3NpbmdsZV9kZWxlZ2F0b3IiLCJkZWZfc2luZ2xlX2RlbGVnYXRvcnMiLCJkZWZpbmVfc2luZ2xldG9uX21ldGhvZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFO0FBQUFDLElBQUFBLHFDQUFBQSxtQ0FBQUEsNkJBQXNCLElBQXRCQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBQyxNQUFBQyxJQUFBRCxRQUFBQSxFQUFBQSxFQUFBQSxFQUhKLGdCQUdrQixPQUFELEVBQVUsUUFIM0IsRUFBQTs7QUFBQTtBQUFBO0FBR2tCLFFBQUE7QUFBQSxRQUFBO0FBQUEsUUFBQSxDQUhsQjtBQUFBO0FBRzJCLFFBQUE7QUFBQSxRQUFBO0FBQUEsUUFBQSxDQUgzQjtBQUFBLFFBSU0sSUFBQSxRQUEyQkUsT0FBQUMsZ0JBQUFBLENBQW9CLE1BQXBCQSxDQUEzQixDQUFBO0FBQUEsUUFBQTtBQUFBLFVBQUFELFVBQVUsQ0FBQ0EsT0FBRDtBQUFWLFFBQUEsQ0FKTjtBQUFBLFFBTU0sT0FBQUYsTUFBQUUsT0FBQUYsUUFBQUEsRUFBQUEsRUFBQUEsRUFOTixnQkFN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Q0FBQUEseURBQUFBLENBbEJBO0FBQUEsSUE4QkEsaUJBQU0sVUFBTixFQUFlLGlCQUFmLENBOUJBO0FBQUEsSUErQkEsaUJBQU0sZ0JBQU4sRUFBcUIsdUJBQXJCLENBL0JBO0FBQUEsSUFnQ0EsT0FBQSxpQkFBTSxlQUFOLEVBQW9CLHNCQUFwQixDQWhDQTtBQURGcEIsRUFBQUEsR0FBQUEsV0FBQUEsV0FwQ0E7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTcxNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vdGhyZWFkLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgVGhpcyBzaGltIGltcGxlbWVudGF0aW9uIG9mIFRocmVhZCBpcyBtZWFudCB0byBvbmx5IGFwcGVhc2UgY29kZSB0aGF0IHRyaWVzXG4jIHRvIGJlIHNhZmUgaW4gdGhlIHByZXNlbmNlIG9mIHRocmVhZHMsIGJ1dCBkb2VzIG5vdCBhY3R1YWxseSB1dGlsaXplIHRoZW0sXG4jIGUuZy4sIHVzZXMgdGhyZWFkLSBvciBmaWJlci1sb2NhbCB2YXJpYWJsZXMuXG5cbmNsYXNzIFRocmVhZEVycm9yIDwgU3RhbmRhcmRFcnJvclxuZW5kXG5cbmNsYXNzIFRocmVhZFxuICBkZWYgc2VsZi5jdXJyZW50XG4gICAgdW5sZXNzIEBjdXJyZW50XG4gICAgICBAY3VycmVudCA9IGFsbG9jYXRlXG4gICAgICBAY3VycmVudC5jb3JlX2luaXRpYWxpemUhXG4gICAgZW5kXG5cbiAgICBAY3VycmVudFxuICBlbmRcblxuICBkZWYgc2VsZi5saXN0XG4gICAgW2N1cnJlbnRdXG4gIGVuZFxuXG4gICMgRG8gbm90IGFsbG93IGNyZWF0aW9uIG9mIG5ldyBpbnN0YW5jZXMuXG4gIGRlZiBpbml0aWFsaXplKCphcmdzKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdUaHJlYWQgY3JlYXRpb24gbm90IGF2YWlsYWJsZSdcbiAgZW5kXG5cbiAgIyBmaWJlci1sb2NhbCBhdHRyaWJ1dGUgYWNjZXNzLlxuICBkZWYgW10oa2V5KVxuICAgIEBmaWJlcl9sb2NhbHNbY29lcmNlX2tleV9uYW1lKGtleSldXG4gIGVuZFxuXG4gIGRlZiBbXT0oa2V5LCB2YWx1ZSlcbiAgICBAZmliZXJfbG9jYWxzW2NvZXJjZV9rZXlfbmFtZShrZXkpXSA9IHZhbHVlXG4gIGVuZFxuXG4gIGRlZiBrZXk/KGtleSlcbiAgICBAZmliZXJfbG9jYWxzLmtleT8oY29lcmNlX2tleV9uYW1lKGtleSkpXG4gIGVuZFxuXG4gIGRlZiBrZXlzXG4gICAgQGZpYmVyX2xvY2Fscy5rZXlzXG4gIGVuZFxuXG4gICMgdGhyZWFkLWxvY2FsIGF0dHJpYnV0ZSBhY2Nlc3MuXG4gIGRlZiB0aHJlYWRfdmFyaWFibGVfZ2V0KGtleSlcbiAgICBAdGhyZWFkX2xvY2Fsc1tjb2VyY2Vfa2V5X25hbWUoa2V5KV1cbiAgZW5kXG5cbiAgZGVmIHRocmVhZF92YXJpYWJsZV9zZXQoa2V5LCB2YWx1ZSlcbiAgICBAdGhyZWFkX2xvY2Fsc1tjb2VyY2Vfa2V5X25hbWUoa2V5KV0gPSB2YWx1ZVxuICBlbmRcblxuICBkZWYgdGhyZWFkX3ZhcmlhYmxlPyhrZXkpXG4gICAgQHRocmVhZF9sb2NhbHMua2V5Pyhjb2VyY2Vfa2V5X25hbWUoa2V5KSlcbiAgZW5kXG5cbiAgZGVmIHRocmVhZF92YXJpYWJsZXNcbiAgICBAdGhyZWFkX2xvY2Fscy5rZXlzXG4gIGVuZFxuXG4gIHByaXZhdGVcblxuICBkZWYgY29yZV9pbml0aWFsaXplIVxuICAgIEB0aHJlYWRfbG9jYWxzID0ge31cbiAgICBAZmliZXJfbG9jYWxzICA9IHt9XG4gIGVuZFxuXG4gIGRlZiBjb2VyY2Vfa2V5X25hbWUoa2V5KVxuICAgIE9wYWwuY29lcmNlX3RvIShrZXksIFN0cmluZywgOnRvX3MpXG4gIGVuZFxuXG4gIGNsYXNzIFF1ZXVlXG4gICAgZGVmIGluaXRpYWxpemVcbiAgICAgIGNsZWFyXG4gICAgZW5kXG5cbiAgICBkZWYgY2xlYXJcbiAgICAgIEBzdG9yYWdlID0gW11cbiAgICBlbmRcblxuICAgIGRlZiBlbXB0eT9cbiAgICAgIEBzdG9yYWdlLmVtcHR5P1xuICAgIGVuZFxuXG4gICAgZGVmIHNpemVcbiAgICAgIEBzdG9yYWdlLnNpemVcbiAgICBlbmRcblxuICAgIGFsaWFzIGxlbmd0aCBzaXplXG5cbiAgICBkZWYgcG9wKG5vbl9ibG9jayA9IGZhbHNlKVxuICAgICAgaWYgZW1wdHk/XG4gICAgICAgIHJhaXNlIFRocmVhZEVycm9yLCAnUXVldWUgZW1wdHknIGlmIG5vbl9ibG9ja1xuICAgICAgICByYWlzZSBUaHJlYWRFcnJvciwgJ0RlYWRsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIEBzdG9yYWdlLnNoaWZ0XG4gICAgZW5kXG5cbiAgICBhbGlhcyBzaGlmdCBwb3BcbiAgICBhbGlhcyBkZXEgICBwb3BcblxuICAgIGRlZiBwdXNoKHZhbHVlKVxuICAgICAgQHN0b3JhZ2UucHVzaCh2YWx1ZSlcbiAgICBlbmRcblxuICAgIGFsaWFzIDw8ICBwdXNoXG4gICAgYWxpYXMgZW5xIHB1c2hcblxuICAgIGRlZiBlYWNoKCZibG9jaylcbiAgICAgIEBzdG9yYWdlLmVhY2goJmJsb2NrKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5RdWV1ZSA9IFRocmVhZDo6UXVldWVcblxuY2xhc3MgTXV0ZXhcbiAgZGVmIGluaXRpYWxpemVcbiAgICAjIFdlIHN0aWxsIGtlZXAgdGhlIEBsb2NrZWQgc3RhdGUgc28gYW55IGxvZ2ljIGJhc2VkIG9uIHRyeV9sb2NrIHdoaWxlXG4gICAgIyBoZWxkIHlpZWxkcyByZWFzb25hYmxlIHJlc3VsdHMuXG4gICAgQGxvY2tlZCA9IGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBsb2NrXG4gICAgcmFpc2UgVGhyZWFkRXJyb3IsICdEZWFkbG9jaycgaWYgQGxvY2tlZFxuICAgIEBsb2NrZWQgPSB0cnVlXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbG9ja2VkP1xuICAgIEBsb2NrZWRcbiAgZW5kXG5cbiAgZGVmIG93bmVkP1xuICAgICMgQmVpbmcgdGhlIG9ubHkgXCJ0aHJlYWRcIiwgd2UgaW1wbGljaXRseSBvd24gYW55IGxvY2tlZCBtdXRleC5cbiAgICBAbG9ja2VkXG4gIGVuZFxuXG4gIGRlZiB0cnlfbG9ja1xuICAgIGlmIGxvY2tlZD9cbiAgICAgIGZhbHNlXG4gICAgZWxzZVxuICAgICAgbG9ja1xuICAgICAgdHJ1ZVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdW5sb2NrXG4gICAgcmFpc2UgVGhyZWFkRXJyb3IsICdNdXRleCBub3QgbG9ja2VkJyB1bmxlc3MgQGxvY2tlZFxuICAgIEBsb2NrZWQgPSBmYWxzZVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHN5bmNocm9uaXplXG4gICAgbG9ja1xuICAgIGJlZ2luXG4gICAgICB5aWVsZFxuICAgIGVuc3VyZVxuICAgICAgdW5sb2NrXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJjdXJyZW50Iiwic2VsZiIsIkBjdXJyZW50IiwiYWxsb2NhdGUiLCJjb3JlX2luaXRpYWxpemUhIiwibGlzdCIsImluaXRpYWxpemUiLCJyYWlzZSIsIltdIiwiQGZpYmVyX2xvY2FscyIsImNvZXJjZV9rZXlfbmFtZSIsImtleSIsIltdPSIsIiR3cml0ZXIiLCJ2YWx1ZSIsIi0iLCIxIiwia2V5PyIsImtleXMiLCJ0aHJlYWRfdmFyaWFibGVfZ2V0IiwiQHRocmVhZF9sb2NhbHMiLCJ0aHJlYWRfdmFyaWFibGVfc2V0IiwidGhyZWFkX3ZhcmlhYmxlPyIsInRocmVhZF92YXJpYWJsZXMiLCJwcml2YXRlIiwiY29lcmNlX3RvISIsImNsZWFyIiwiQHN0b3JhZ2UiLCJlbXB0eT8iLCJzaXplIiwicG9wIiwibm9uX2Jsb2NrIiwic2hpZnQiLCJwdXNoIiwiZWFjaCIsImJsb2NrIiwiQGxvY2tlZCIsImxvY2siLCJsb2NrZWQ/Iiwib3duZWQ/IiwidHJ5X2xvY2siLCJ1bmxvY2siLCJzeW5jaHJvbml6ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBSUEsRUFB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InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vc3RyaW5naW8ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgU3RyaW5nSU8gPCBJT1xuICBpbmNsdWRlIElPOjpSZWFkYWJsZVxuICBpbmNsdWRlIElPOjpXcml0YWJsZVxuXG4gIGRlZiBzZWxmLm9wZW4oc3RyaW5nID0gXCJcIiwgbW9kZSA9IG5pbCwgJmJsb2NrKVxuICAgIGlvICA9IG5ldyhzdHJpbmcsIG1vZGUpXG4gICAgcmVzID0gYmxvY2suY2FsbChpbylcbiAgICBpby5jbG9zZVxuXG4gICAgcmVzXG4gIGVuZFxuXG4gIGF0dHJfYWNjZXNzb3IgOnN0cmluZ1xuXG4gIGRlZiBpbml0aWFsaXplKHN0cmluZyA9IFwiXCIsIG1vZGUgPSAncncnKVxuICAgIEBzdHJpbmcgICA9IHN0cmluZ1xuICAgIEBwb3NpdGlvbiA9IHN0cmluZy5sZW5ndGhcblxuICAgIGlmIG1vZGUuaW5jbHVkZT8oJ3InKSBhbmQgbm90IG1vZGUuaW5jbHVkZT8oJ3cnKVxuICAgICAgQGNsb3NlZCA9IDp3cml0ZVxuICAgIGVsc2lmIG1vZGUuaW5jbHVkZT8oJ3cnKSBhbmQgbm90IG1vZGUuaW5jbHVkZT8oJ3InKVxuICAgICAgQGNsb3NlZCA9IDpyZWFkXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBlb2Y/XG4gICAgY2hlY2tfcmVhZGFibGVcblxuICAgIEBwb3NpdGlvbiA9PSBAc3RyaW5nLmxlbmd0aFxuICBlbmRcblxuICBhbGlhcyBlb2YgZW9mP1xuXG4gIGRlZiBzZWVrKHBvcywgd2hlbmNlID0gSU86OlNFRUtfU0VUKVxuICAgIGNhc2Ugd2hlbmNlXG4gICAgd2hlbiBJTzo6U0VFS19TRVRcbiAgICAgIHJhaXNlIEVycm5vOjpFSU5WQUwgdW5sZXNzIHBvcyA+PSAwXG5cbiAgICAgIEBwb3NpdGlvbiA9IHBvc1xuXG4gICAgd2hlbiBJTzo6U0VFS19DVVJcbiAgICAgIGlmIEBwb3NpdGlvbiArIHBvcyA+IEBzdHJpbmcubGVuZ3RoXG4gICAgICAgIEBwb3NpdGlvbiA9IEBzdHJpbmcubGVuZ3RoXG4gICAgICBlbHNlXG4gICAgICAgIEBwb3NpdGlvbiArPSBwb3NcbiAgICAgIGVuZFxuXG4gICAgd2hlbiBJTzo6U0VFS19FTkRcbiAgICAgIGlmIHBvcyA+IEBzdHJpbmcubGVuZ3RoXG4gICAgICAgIEBwb3NpdGlvbiA9IDBcbiAgICAgIGVsc2VcbiAgICAgICAgQHBvc2l0aW9uIC09IHBvc1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAwXG4gIGVuZFxuXG4gIGRlZiB0ZWxsXG4gICAgQHBvc2l0aW9uXG4gIGVuZFxuXG4gIGFsaWFzIHBvcyB0ZWxsXG5cbiAgYWxpYXMgcG9zPSBzZWVrXG5cbiAgZGVmIHJld2luZFxuICAgIHNlZWsgMFxuICBlbmRcblxuICBkZWYgZWFjaF9ieXRlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfYnl0ZSB1bmxlc3MgYmxvY2tcblxuICAgIGNoZWNrX3JlYWRhYmxlXG5cbiAgICBpID0gQHBvc2l0aW9uXG4gICAgdW50aWwgZW9mP1xuICAgICAgYmxvY2suY2FsbChAc3RyaW5nW2ldLm9yZClcbiAgICAgIGkgKz0gMVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9jaGFyKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfY2hhciB1bmxlc3MgYmxvY2tcblxuICAgIGNoZWNrX3JlYWRhYmxlXG5cbiAgICBpID0gQHBvc2l0aW9uXG4gICAgdW50aWwgZW9mP1xuICAgICAgYmxvY2suY2FsbChAc3RyaW5nW2ldKVxuICAgICAgaSArPSAxXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoKHNlcGFyYXRvciA9ICQvKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9saW5lIHVubGVzcyBibG9ja19naXZlbj9cbiAgICBjaGVja19yZWFkYWJsZVxuICAgIGNob21wX2xpbmVzID0gZmFsc2VcbiAgICBpZiA6Okhhc2ggPT09IHNlcGFyYXRvclxuICAgICAgc2VwYXJhdG9yID0gKGNob21wX2xpbmVzID0gc2VwYXJhdG9yWzpjaG9tcF0pID8gL1xccj9cXG4vIDogJC9cbiAgICBlbHNpZiBzZXBhcmF0b3JcbiAgICAgIHNlcGFyYXRvciA9IHNlcGFyYXRvci50b19zdHJcbiAgICBlbHNlXG4gICAgICBzZXBhcmF0b3IgPSBgdW5kZWZpbmVkYFxuICAgIGVuZFxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IHNlbGYuc3RyaW5nLCBzdHJpbmdMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgICAgaWYgKHNlbGYucG9zaXRpb24gPCBzdHJpbmdMZW5ndGgpIHN0ciA9IHN0ci5zdWJzdHIoc2VsZi5wb3NpdGlvbik7XG4gICAgICBpZiAoc2VwYXJhdG9yKSB7XG4gICAgICAgIHZhciBjaG9tcGVkID0gI3tgc3RyYC5jaG9tcH0sIHRyYWlsaW5nID0gc3RyLmxlbmd0aCAhPT0gY2hvbXBlZC5sZW5ndGgsIHNwbGl0dGVkID0gY2hvbXBlZC5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3BsaXR0ZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGluZSA9IGNob21wX2xpbmVzID8gc3BsaXR0ZWRbaV0gOiAoaSA8IGxlbiAtIDEgfHwgdHJhaWxpbmcgPyBzcGxpdHRlZFtpXSArIHNlcGFyYXRvciA6IHNwbGl0dGVkW2ldKTtcbiAgICAgICAgICAje3lpZWxkIGBsaW5lYH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgI3t5aWVsZCBgc3RyYH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbSwgcmUgPSAvKC4rKD86XFxuXFxufCQpKVxcbiovZztcbiAgICAgICAgd2hpbGUgKChtID0gcmUuZXhlYyhzdHIpKSkgI3t5aWVsZCBgbVsxXWB9O1xuICAgICAgfVxuICAgICAgc2VsZi5wb3NpdGlvbiA9IHN0cmluZ0xlbmd0aDtcbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBlYWNoX2xpbmUgZWFjaFxuXG4gIGRlZiB3cml0ZShzdHJpbmcpXG4gICAgY2hlY2tfd3JpdGFibGVcblxuICAgIHN0cmluZyA9IFN0cmluZyhzdHJpbmcpXG5cbiAgICBpZiBAc3RyaW5nLmxlbmd0aCA9PSBAcG9zaXRpb25cbiAgICAgIEBzdHJpbmcgICArPSBzdHJpbmdcbiAgICAgIEBwb3NpdGlvbiArPSBzdHJpbmcubGVuZ3RoXG4gICAgZWxzZVxuICAgICAgYmVmb3JlID0gQHN0cmluZ1swIC4uIEBwb3NpdGlvbiAtIDFdXG4gICAgICBhZnRlciAgPSBAc3RyaW5nW0Bwb3NpdGlvbiArIHN0cmluZy5sZW5ndGggLi4gLTFdXG5cbiAgICAgIEBzdHJpbmcgICA9IGJlZm9yZSArIHN0cmluZyArIGFmdGVyXG4gICAgICBAcG9zaXRpb24gKz0gc3RyaW5nLmxlbmd0aFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmVhZChsZW5ndGggPSBuaWwsIG91dGJ1ZiA9IG5pbClcbiAgICBjaGVja19yZWFkYWJsZVxuXG4gICAgcmV0dXJuIGlmIGVvZj9cblxuICAgIHN0cmluZyA9IGlmIGxlbmd0aFxuICAgICAgc3RyID0gQHN0cmluZ1tAcG9zaXRpb24sIGxlbmd0aF1cbiAgICAgIEBwb3NpdGlvbiArPSBsZW5ndGhcbiAgICAgIHN0clxuICAgIGVsc2VcbiAgICAgIHN0ciA9IEBzdHJpbmdbQHBvc2l0aW9uIC4uIC0xXVxuICAgICAgQHBvc2l0aW9uID0gQHN0cmluZy5sZW5ndGhcbiAgICAgIHN0clxuICAgIGVuZFxuXG4gICAgaWYgb3V0YnVmXG4gICAgICBvdXRidWYud3JpdGUoc3RyaW5nKVxuICAgIGVsc2VcbiAgICAgIHN0cmluZ1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2xvc2VcbiAgICBAY2xvc2VkID0gOmJvdGhcbiAgZW5kXG5cbiAgZGVmIGNsb3NlX3JlYWRcbiAgICBpZiBAY2xvc2VkID09IDp3cml0ZVxuICAgICAgQGNsb3NlZCA9IDpib3RoXG4gICAgZWxzZVxuICAgICAgQGNsb3NlZCA9IDpyZWFkXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBjbG9zZV93cml0ZVxuICAgIGlmIEBjbG9zZWQgPT0gOnJlYWRcbiAgICAgIEBjbG9zZWQgPSA6Ym90aFxuICAgIGVsc2VcbiAgICAgIEBjbG9zZWQgPSA6d3JpdGVcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGNsb3NlZD9cbiAgICBAY2xvc2VkID09IDpib3RoXG4gIGVuZFxuXG4gIGRlZiBjbG9zZWRfcmVhZD9cbiAgICBAY2xvc2VkID09IDpyZWFkIHx8IEBjbG9zZWQgPT0gOmJvdGhcbiAgZW5kXG5cbiAgZGVmIGNsb3NlZF93cml0ZT9cbiAgICBAY2xvc2VkID09IDp3cml0ZSB8fCBAY2xvc2VkID09IDpib3RoXG4gIGVuZFxuXG4gIGRlZiBjaGVja193cml0YWJsZVxuICAgIGlmIGNsb3NlZF93cml0ZT9cbiAgICAgIHJhaXNlIElPRXJyb3IsIFwibm90IG9wZW5lZCBmb3Igd3JpdGluZ1wiXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBjaGVja19yZWFkYWJsZVxuICAgIGlmIGNsb3NlZF9yZWFkP1xuICAgICAgcmFpc2UgSU9FcnJvciwgXCJub3Qgb3BlbmVkIGZvciByZWFkaW5nXCJcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsImluY2x1ZGUiLCJvcGVuIiwic2VsZiIsImlvIiwibmV3Iiwic3RyaW5nIiwibW9kZSIsInJlcyIsImJsb2NrIiwiY2FsbCIsImNsb3NlIiwiYXR0cl9hY2Nlc3NvciIsImluaXRpYWxpemUiLCJAc3RyaW5nIiwiQHBvc2l0aW9uIiwibGVuZ3RoIiwiJHJldF9vcl8xIiwiaW5jbHVkZT8iLCIhIiwiQGNsb3NlZCIsIiRyZXRfb3JfMiIsImVvZj8iLCJjaGVja19yZWFkYWJsZSIsIj09Iiwic2VlayIsIndoZW5jZSIsIj49IiwicG9zIiwiMCIsInJhaXNlIiwiPiIsIisiLCItIiwidGVsbCIsInJld2luZCIsImVhY2hfYnl0ZSIsImVudW1fZm9yIiwiaSIsIltdIiwib3JkIiwiMSIsImVhY2hfY2hhciIsImVhY2giLCIkLyIsImJsb2NrX2dpdmVuPyIsImNob21wX2xpbmVzIiwiPT09Iiwic2VwYXJhdG9yIiwidG9fc3RyIiwiY2hvbXAiLCJ3cml0ZSIsImNoZWNrX3dyaXRhYmxlIiwiU3RyaW5nIiwiYmVmb3JlIiwiYWZ0ZXIiLCItMSIsInJlYWQiLCJzdHIiLCJvdXRidWYiLCJjbG9zZV9yZWFkIiwiY2xvc2Vfd3JpdGUiLCJjbG9zZWQ/IiwiY2xvc2VkX3JlYWQ/IiwiJHJldF9vcl8zIiwiY2xvc2VkX3dyaXRlPyIsIiRyZXRfb3JfNCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsUUFBQUMsU0FBQUEsQ0FBUSxJQUFBLGtCQUFBLGFBQVJBLENBQUE7QUFBQSxRQUNBQSxTQUFBQSxDQUFRLElBQUEsa0JBQUEsYUFBUkEsQ0FEQTtBQUFBLElBR0FDLFVBQUlDLElBQUpELFdBQUFBLG1CQUFBQSxnQkFBYyxNQUFELEVBQWMsSUFBM0JBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQUxGO0FBS3lDLE1BQUEsdUNBTHpDO0FBQUE7QUFLZ0IsTUFBQTtBQUFBLE1BQUEsV0FBUyxFQUFUO0FBQUEsTUFBQSxDQUxoQjtBQUFBO0FBSzZCLE1BQUE7QUFBQSxNQUFBLFNBQU8sR0FBUDtBQUFBLE1BQUEsQ0FMN0I7QUFBQSxNQU1JRSxTQUFNQyxLQUFBQSxDQUFJQyxRQUFRQyxJQUFaRixDQU5WO0FBQUEsTUFPSUcsTUFBTUMsS0FBQUMsTUFBQUEsQ0FBV04sRUFBWE0sQ0FQVjtBQUFBLE1BUUlOLEVBQUFPLE9BQUFBLENBQUFBLENBUko7QUFBQSxNQVVJLE9BQUFILEdBVko7QUFLRU4sSUFBQUEsQ0FBQUEsK0JBQUFBLENBSEE7QUFB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LE1BQUE7QUFERlAsSUFBQUEsQ0FBQUEseUNBQUFBLENBQUFBLDBCQS9NQTtBQURGdkIsRUFBQUEsR0FBQUEsV0FBQUEsRUFBaUIsa0JBQWpCQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMwMzI2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9wcmV0dHlwcmludC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuI1xuIyBUaGlzIGNsYXNzIGltcGxlbWVudHMgYSBwcmV0dHkgcHJpbnRpbmcgYWxnb3JpdGhtLiBJdCBmaW5kcyBsaW5lIGJyZWFrcyBhbmRcbiMgbmljZSBpbmRlbnRhdGlvbnMgZm9yIGdyb3VwZWQgc3RydWN0dXJlLlxuI1xuIyBCeSBkZWZhdWx0LCB0aGUgY2xhc3MgYXNzdW1lcyB0aGF0IHByaW1pdGl2ZSBlbGVtZW50cyBhcmUgc3RyaW5ncyBhbmQgZWFjaFxuIyBieXRlIGluIHRoZSBzdHJpbmdzIGhhdmUgc2luZ2xlIGNvbHVtbiBpbiB3aWR0aC4gQnV0IGl0IGNhbiBiZSB1c2VkIGZvclxuIyBvdGhlciBzaXR1YXRpb25zIGJ5IGdpdmluZyBzdWl0YWJsZSBhcmd1bWVudHMgZm9yIHNvbWUgbWV0aG9kczpcbiMgKiBuZXdsaW5lIG9iamVjdCBhbmQgc3BhY2UgZ2VuZXJhdGlvbiBibG9jayBmb3IgUHJldHR5UHJpbnQubmV3XG4jICogb3B0aW9uYWwgd2lkdGggYXJndW1lbnQgZm9yIFByZXR0eVByaW50I3RleHRcbiMgKiBQcmV0dHlQcmludCNicmVha2FibGVcbiNcbiMgVGhlcmUgYXJlIHNldmVyYWwgY2FuZGlkYXRlIHVzZXM6XG4jICogdGV4dCBmb3JtYXR0aW5nIHVzaW5nIHByb3BvcnRpb25hbCBmb250c1xuIyAqIG11bHRpYnl0ZSBjaGFyYWN0ZXJzIHdoaWNoIGhhcyBjb2x1bW5zIGRpZmZlcmVudCB0byBudW1iZXIgb2YgYnl0ZXNcbiMgKiBub24tc3RyaW5nIGZvcm1hdHRpbmdcbiNcbiMgPT0gQnVnc1xuIyAqIEJveCBiYXNlZCBmb3JtYXR0aW5nP1xuIyAqIE90aGVyIChiZXR0ZXIpIG1vZGVsL2FsZ29yaXRobT9cbiNcbiMgUmVwb3J0IGFueSBidWdzIGF0IGh0dHA6Ly9idWdzLnJ1YnktbGFuZy5vcmdcbiNcbiMgPT0gUmVmZXJlbmNlc1xuIyBDaHJpc3RpYW4gTGluZGlnLCBTdHJpY3RseSBQcmV0dHksIE1hcmNoIDIwMDAsXG4jIGh0dHA6Ly93d3cuc3QuY3MudW5pLXNiLmRlL35saW5kaWcvcGFwZXJzLyNwcmV0dHlcbiNcbiMgUGhpbGlwIFdhZGxlciwgQSBwcmV0dGllciBwcmludGVyLCBNYXJjaCAxOTk4LFxuIyBodHRwOi8vaG9tZXBhZ2VzLmluZi5lZC5hYy51ay93YWRsZXIvdG9waWNzL2xhbmd1YWdlLWRlc2lnbi5odG1sI3ByZXR0aWVyXG4jXG4jID09IEF1dGhvclxuIyBUYW5ha2EgQWtpcmEgPGFrckBmc2lqLm9yZz5cbiNcbmNsYXNzIFByZXR0eVByaW50XG5cbiAgIyBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIHdoaWNoIGlzIHNhbWUgYXMgZm9sbG93czpcbiAgI1xuICAjICAgYmVnaW5cbiAgIyAgICAgcSA9IFByZXR0eVByaW50Lm5ldyhvdXRwdXQsIG1heHdpZHRoLCBuZXdsaW5lLCAmZ2Vuc3BhY2UpXG4gICMgICAgIC4uLlxuICAjICAgICBxLmZsdXNoXG4gICMgICAgIG91dHB1dFxuICAjICAgZW5kXG4gICNcbiAgZGVmIFByZXR0eVByaW50LmZvcm1hdChvdXRwdXQ9JycuZHVwLCBtYXh3aWR0aD03OSwgbmV3bGluZT1cIlxcblwiLCBnZW5zcGFjZT1sYW1iZGEge3xufCAnICcgKiBufSlcbiAgICBxID0gUHJldHR5UHJpbnQubmV3KG91dHB1dCwgbWF4d2lkdGgsIG5ld2xpbmUsICZnZW5zcGFjZSlcbiAgICB5aWVsZCBxXG4gICAgcS5mbHVzaFxuICAgIG91dHB1dFxuICBlbmRcblxuICAjIFRoaXMgaXMgc2ltaWxhciB0byBQcmV0dHlQcmludDo6Zm9ybWF0IGJ1dCB0aGUgcmVzdWx0IGhhcyBubyBicmVha3MuXG4gICNcbiAgIyArbWF4d2lkdGgrLCArbmV3bGluZSsgYW5kICtnZW5zcGFjZSsgYXJlIGlnbm9yZWQuXG4gICNcbiAgIyBUaGUgaW52b2NhdGlvbiBvZiArYnJlYWthYmxlKyBpbiB0aGUgYmxvY2sgZG9lc24ndCBicmVhayBhIGxpbmUgYW5kIGlzXG4gICMgdHJlYXRlZCBhcyBqdXN0IGFuIGludm9jYXRpb24gb2YgK3RleHQrLlxuICAjXG4gIGRlZiBQcmV0dHlQcmludC5zaW5nbGVsaW5lX2Zvcm1hdChvdXRwdXQ9JycuZHVwLCBtYXh3aWR0aD1uaWwsIG5ld2xpbmU9bmlsLCBnZW5zcGFjZT1uaWwpXG4gICAgcSA9IFNpbmdsZUxpbmUubmV3KG91dHB1dClcbiAgICB5aWVsZCBxXG4gICAgb3V0cHV0XG4gIGVuZFxuXG4gICMgQ3JlYXRlcyBhIGJ1ZmZlciBmb3IgcHJldHR5IHByaW50aW5nLlxuICAjXG4gICMgK291dHB1dCsgaXMgYW4gb3V0cHV0IHRhcmdldC4gSWYgaXQgaXMgbm90IHNwZWNpZmllZCwgJycgaXMgYXNzdW1lZC4gSXRcbiAgIyBzaG91bGQgaGF2ZSBhIDw8IG1ldGhvZCB3aGljaCBhY2NlcHRzIHRoZSBmaXJzdCBhcmd1bWVudCArb2JqKyBvZlxuICAjIFByZXR0eVByaW50I3RleHQsIHRoZSBmaXJzdCBhcmd1bWVudCArc2VwKyBvZiBQcmV0dHlQcmludCNicmVha2FibGUsIHRoZVxuICAjIGZpcnN0IGFyZ3VtZW50ICtuZXdsaW5lKyBvZiBQcmV0dHlQcmludC5uZXcsIGFuZCB0aGUgcmVzdWx0IG9mIGEgZ2l2ZW5cbiAgIyBibG9jayBmb3IgUHJldHR5UHJpbnQubmV3LlxuICAjXG4gICMgK21heHdpZHRoKyBzcGVjaWZpZXMgbWF4aW11bSBsaW5lIGxlbmd0aC4gSWYgaXQgaXMgbm90IHNwZWNpZmllZCwgNzkgaXNcbiAgIyBhc3N1bWVkLiBIb3dldmVyIGFjdHVhbCBvdXRwdXRzIG1heSBvdmVyZmxvdyArbWF4d2lkdGgrIGlmIGxvbmdcbiAgIyBub24tYnJlYWthYmxlIHRleHRzIGFyZSBwcm92aWRlZC5cbiAgI1xuICAjICtuZXdsaW5lKyBpcyB1c2VkIGZvciBsaW5lIGJyZWFrcy4gXCJcXG5cIiBpcyB1c2VkIGlmIGl0IGlzIG5vdCBzcGVjaWZpZWQuXG4gICNcbiAgIyBUaGUgYmxvY2sgaXMgdXNlZCB0byBnZW5lcmF0ZSBzcGFjZXMuIHt8d2lkdGh8ICcgJyAqIHdpZHRofSBpcyB1c2VkIGlmIGl0XG4gICMgaXMgbm90IGdpdmVuLlxuICAjXG4gIGRlZiBpbml0aWFsaXplKG91dHB1dD0nJy5kdXAsIG1heHdpZHRoPTc5LCBuZXdsaW5lPVwiXFxuXCIsICZnZW5zcGFjZSlcbiAgICBAb3V0cHV0ID0gb3V0cHV0XG4gICAgQG1heHdpZHRoID0gbWF4d2lkdGhcbiAgICBAbmV3bGluZSA9IG5ld2xpbmVcbiAgICBAZ2Vuc3BhY2UgPSBnZW5zcGFjZSB8fCBsYW1iZGEge3xufCAnICcgKiBufVxuXG4gICAgQG91dHB1dF93aWR0aCA9IDBcbiAgICBAYnVmZmVyX3dpZHRoID0gMFxuICAgIEBidWZmZXIgPSBbXVxuXG4gICAgcm9vdF9ncm91cCA9IEdyb3VwLm5ldygwKVxuICAgIEBncm91cF9zdGFjayA9IFtyb290X2dyb3VwXVxuICAgIEBncm91cF9xdWV1ZSA9IEdyb3VwUXVldWUubmV3KHJvb3RfZ3JvdXApXG4gICAgQGluZGVudCA9IDBcbiAgZW5kXG5cbiAgIyBUaGUgb3V0cHV0IG9iamVjdC5cbiAgI1xuICAjIFRoaXMgZGVmYXVsdHMgdG8gJycsIGFuZCBzaG91bGQgYWNjZXB0IHRoZSA8PCBtZXRob2RcbiAgYXR0cl9yZWFkZXIgOm91dHB1dFxuXG4gICMgVGhlIG1heGltdW0gd2lkdGggb2YgYSBsaW5lLCBiZWZvcmUgaXQgaXMgc2VwYXJhdGVkIGluIHRvIGEgbmV3bGluZVxuICAjXG4gICMgVGhpcyBkZWZhdWx0cyB0byA3OSwgYW5kIHNob3VsZCBiZSBhIEZpeG51bVxuICBhdHRyX3JlYWRlciA6bWF4d2lkdGhcblxuICAjIFRoZSB2YWx1ZSB0aGF0IGlzIGFwcGVuZGVkIHRvICtvdXRwdXQrIHRvIGFkZCBhIG5ldyBsaW5lLlxuICAjXG4gICMgVGhpcyBkZWZhdWx0cyB0byBcIlxcblwiLCBhbmQgc2hvdWxkIGJlIFN0cmluZ1xuICBhdHRyX3JlYWRlciA6bmV3bGluZVxuXG4gICMgQSBsYW1iZGEgb3IgUHJvYywgdGhhdCB0YWtlcyBvbmUgYXJndW1lbnQsIG9mIGEgRml4bnVtLCBhbmQgcmV0dXJuc1xuICAjIHRoZSBjb3JyZXNwb25kaW5nIG51bWJlciBvZiBzcGFjZXMuXG4gICNcbiAgIyBCeSBkZWZhdWx0IHRoaXMgaXM6XG4gICMgICBsYW1iZGEge3xufCAnICcgKiBufVxuICBhdHRyX3JlYWRlciA6Z2Vuc3BhY2VcblxuICAjIFRoZSBudW1iZXIgb2Ygc3BhY2VzIHRvIGJlIGluZGVudGVkXG4gIGF0dHJfcmVhZGVyIDppbmRlbnRcblxuICAjIFRoZSBQcmV0dHlQcmludDo6R3JvdXBRdWV1ZSBvZiBncm91cHMgaW4gc3RhY2sgdG8gYmUgcHJldHR5IHByaW50ZWRcbiAgYXR0cl9yZWFkZXIgOmdyb3VwX3F1ZXVlXG5cbiAgIyBSZXR1cm5zIHRoZSBncm91cCBtb3N0IHJlY2VudGx5IGFkZGVkIHRvIHRoZSBzdGFjay5cbiAgI1xuICAjIENvbnRyaXZlZCBleGFtcGxlOlxuICAjICAgb3V0ID0gXCJcIlxuICAjICAgPT4gXCJcIlxuICAjICAgcSA9IFByZXR0eVByaW50Lm5ldyhvdXQpXG4gICMgICA9PiAjPFByZXR0eVByaW50OjB4ODJmODVjMCBAb3V0cHV0PVwiXCIsIEBtYXh3aWR0aD03OSwgQG5ld2xpbmU9XCJcXG5cIiwgQGdlbnNwYWNlPSM8UHJvYzoweDgyZjgzNjhAL2hvbWUvdmJhdHRzLy5ydm0vcnViaWVzL3J1YnktaGVhZC9saWIvcnVieS8yLjAuMC9wcmV0dHlwcmludC5yYjo4MiAobGFtYmRhKT4sIEBvdXRwdXRfd2lkdGg9MCwgQGJ1ZmZlcl93aWR0aD0wLCBAYnVmZmVyPVtdLCBAZ3JvdXBfc3RhY2s9WyM8UHJldHR5UHJpbnQ6Okdyb3VwOjB4ODJmODEzOCBAZGVwdGg9MCwgQGJyZWFrYWJsZXM9W10sIEBicmVhaz1mYWxzZT5dLCBAZ3JvdXBfcXVldWU9IzxQcmV0dHlQcmludDo6R3JvdXBRdWV1ZToweDgyZmI3YzAgQHF1ZXVlPVtbIzxQcmV0dHlQcmludDo6R3JvdXA6MHg4MmY4MTM4IEBkZXB0aD0wLCBAYnJlYWthYmxlcz1bXSwgQGJyZWFrPWZhbHNlPl1dPiwgQGluZGVudD0wPlxuICAjICAgcS5ncm91cCB7XG4gICMgICAgIHEudGV4dCBxLmN1cnJlbnRfZ3JvdXAuaW5zcGVjdFxuICAjICAgICBxLnRleHQgcS5uZXdsaW5lXG4gICMgICAgIHEuZ3JvdXAocS5jdXJyZW50X2dyb3VwLmRlcHRoICsgMSkge1xuICAjICAgICAgIHEudGV4dCBxLmN1cnJlbnRfZ3JvdXAuaW5zcGVjdFxuICAjICAgICAgIHEudGV4dCBxLm5ld2xpbmVcbiAgIyAgICAgICBxLmdyb3VwKHEuY3VycmVudF9ncm91cC5kZXB0aCArIDEpIHtcbiAgIyAgICAgICAgIHEudGV4dCBxLmN1cnJlbnRfZ3JvdXAuaW5zcGVjdFxuICAjICAgICAgICAgcS50ZXh0IHEubmV3bGluZVxuICAjICAgICAgICAgcS5ncm91cChxLmN1cnJlbnRfZ3JvdXAuZGVwdGggKyAxKSB7XG4gICMgICAgICAgICAgIHEudGV4dCBxLmN1cnJlbnRfZ3JvdXAuaW5zcGVjdFxuICAjICAgICAgICAgICBxLnRleHQgcS5uZXdsaW5lXG4gICMgICAgICAgICB9XG4gICMgICAgICAgfVxuICAjICAgICB9XG4gICMgICB9XG4gICMgICA9PiAyODRcbiAgIyAgICBwdXRzIG91dFxuICAjICAgIzxQcmV0dHlQcmludDo6R3JvdXA6MHg4MzU0NzU4IEBkZXB0aD0xLCBAYnJlYWthYmxlcz1bXSwgQGJyZWFrPWZhbHNlPlxuICAjICAgIzxQcmV0dHlQcmludDo6R3JvdXA6MHg4MzU0NTUwIEBkZXB0aD0yLCBAYnJlYWthYmxlcz1bXSwgQGJyZWFrPWZhbHNlPlxuICAjICAgIzxQcmV0dHlQcmludDo6R3JvdXA6MHg4MzU0MWNjIEBkZXB0aD0zLCBAYnJlYWthYmxlcz1bXSwgQGJyZWFrPWZhbHNlPlxuICAjICAgIzxQcmV0dHlQcmludDo6R3JvdXA6MHg4MzQ3ZTU0IEBkZXB0aD00LCBAYnJlYWthYmxlcz1bXSwgQGJyZWFrPWZhbHNlPlxuICBkZWYgY3VycmVudF9ncm91cFxuICAgIEBncm91cF9zdGFjay5sYXN0XG4gIGVuZFxuXG4gICMgQnJlYWtzIHRoZSBidWZmZXIgaW50byBsaW5lcyB0aGF0IGFyZSBzaG9ydGVyIHRoYW4gI21heHdpZHRoXG4gIGRlZiBicmVha19vdXRtb3N0X2dyb3Vwc1xuICAgIHdoaWxlIEBtYXh3aWR0aCA8IEBvdXRwdXRfd2lkdGggKyBAYnVmZmVyX3dpZHRoXG4gICAgICByZXR1cm4gdW5sZXNzIGdyb3VwID0gQGdyb3VwX3F1ZXVlLmRlcVxuICAgICAgdW50aWwgZ3JvdXAuYnJlYWthYmxlcy5lbXB0eT9cbiAgICAgICAgZGF0YSA9IEBidWZmZXIuc2hpZnRcbiAgICAgICAgQG91dHB1dF93aWR0aCA9IGRhdGEub3V0cHV0KEBvdXRwdXQsIEBvdXRwdXRfd2lkdGgpXG4gICAgICAgIEBidWZmZXJfd2lkdGggLT0gZGF0YS53aWR0aFxuICAgICAgZW5kXG4gICAgICB3aGlsZSAhQGJ1ZmZlci5lbXB0eT8gJiYgVGV4dCA9PT0gQGJ1ZmZlci5maXJzdFxuICAgICAgICB0ZXh0ID0gQGJ1ZmZlci5zaGlmdFxuICAgICAgICBAb3V0cHV0X3dpZHRoID0gdGV4dC5vdXRwdXQoQG91dHB1dCwgQG91dHB1dF93aWR0aClcbiAgICAgICAgQGJ1ZmZlcl93aWR0aCAtPSB0ZXh0LndpZHRoXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBUaGlzIGFkZHMgK29iaisgYXMgYSB0ZXh0IG9mICt3aWR0aCsgY29sdW1ucyBpbiB3aWR0aC5cbiAgI1xuICAjIElmICt3aWR0aCsgaXMgbm90IHNwZWNpZmllZCwgb2JqLmxlbmd0aCBpcyB1c2VkLlxuICAjXG4gIGRlZiB0ZXh0KG9iaiwgd2lkdGg9b2JqLmxlbmd0aClcbiAgICBpZiBAYnVmZmVyLmVtcHR5P1xuICAgICAgQG91dHB1dCA8PCBvYmpcbiAgICAgIEBvdXRwdXRfd2lkdGggKz0gd2lkdGhcbiAgICBlbHNlXG4gICAgICB0ZXh0ID0gQGJ1ZmZlci5sYXN0XG4gICAgICB1bmxlc3MgVGV4dCA9PT0gdGV4dFxuICAgICAgICB0ZXh0ID0gVGV4dC5uZXdcbiAgICAgICAgQGJ1ZmZlciA8PCB0ZXh0XG4gICAgICBlbmRcbiAgICAgIHRleHQuYWRkKG9iaiwgd2lkdGgpXG4gICAgICBAYnVmZmVyX3dpZHRoICs9IHdpZHRoXG4gICAgICBicmVha19vdXRtb3N0X2dyb3Vwc1xuICAgIGVuZFxuICBlbmRcblxuICAjIFRoaXMgaXMgc2ltaWxhciB0byAjYnJlYWthYmxlIGV4Y2VwdFxuICAjIHRoZSBkZWNpc2lvbiB0byBicmVhayBvciBub3QgaXMgZGV0ZXJtaW5lZCBpbmRpdmlkdWFsbHkuXG4gICNcbiAgIyBUd28gI2ZpbGxfYnJlYWthYmxlIHVuZGVyIGEgZ3JvdXAgbWF5IGNhdXNlIDQgcmVzdWx0czpcbiAgIyAoYnJlYWssYnJlYWspLCAoYnJlYWssbm9uLWJyZWFrKSwgKG5vbi1icmVhayxicmVhayksIChub24tYnJlYWssbm9uLWJyZWFrKS5cbiAgIyBUaGlzIGlzIGRpZmZlcmVudCB0byAjYnJlYWthYmxlIGJlY2F1c2UgdHdvICNicmVha2FibGUgdW5kZXIgYSBncm91cFxuICAjIG1heSBjYXVzZSAyIHJlc3VsdHM6XG4gICMgKGJyZWFrLGJyZWFrKSwgKG5vbi1icmVhayxub24tYnJlYWspLlxuICAjXG4gICMgVGhlIHRleHQgK3NlcCsgaXMgaW5zZXJ0ZWQgaWYgYSBsaW5lIGlzIG5vdCBicm9rZW4gYXQgdGhpcyBwb2ludC5cbiAgI1xuICAjIElmICtzZXArIGlzIG5vdCBzcGVjaWZpZWQsIFwiIFwiIGlzIHVzZWQuXG4gICNcbiAgIyBJZiArd2lkdGgrIGlzIG5vdCBzcGVjaWZpZWQsICtzZXAubGVuZ3RoKyBpcyB1c2VkLiBZb3Ugd2lsbCBoYXZlIHRvXG4gICMgc3BlY2lmeSB0aGlzIHdoZW4gK3NlcCsgaXMgYSBtdWx0aWJ5dGUgY2hhcmFjdGVyLCBmb3IgZXhhbXBsZS5cbiAgI1xuICBkZWYgZmlsbF9icmVha2FibGUoc2VwPScgJywgd2lkdGg9c2VwLmxlbmd0aClcbiAgICBncm91cCB7IGJyZWFrYWJsZSBzZXAsIHdpZHRoIH1cbiAgZW5kXG5cbiAgIyBUaGlzIHNheXMgXCJ5b3UgY2FuIGJyZWFrIGEgbGluZSBoZXJlIGlmIG5lY2Vzc2FyeVwiLCBhbmQgYSArd2lkdGgrXFwtY29sdW1uXG4gICMgdGV4dCArc2VwKyBpcyBpbnNlcnRlZCBpZiBhIGxpbmUgaXMgbm90IGJyb2tlbiBhdCB0aGUgcG9pbnQuXG4gICNcbiAgIyBJZiArc2VwKyBpcyBub3Qgc3BlY2lmaWVkLCBcIiBcIiBpcyB1c2VkLlxuICAjXG4gICMgSWYgK3dpZHRoKyBpcyBub3Qgc3BlY2lmaWVkLCArc2VwLmxlbmd0aCsgaXMgdXNlZC4gWW91IHdpbGwgaGF2ZSB0b1xuICAjIHNwZWNpZnkgdGhpcyB3aGVuICtzZXArIGlzIGEgbXVsdGlieXRlIGNoYXJhY3RlciwgZm9yIGV4YW1wbGUuXG4gICNcbiAgZGVmIGJyZWFrYWJsZShzZXA9JyAnLCB3aWR0aD1zZXAubGVuZ3RoKVxuICAgIGdyb3VwID0gQGdyb3VwX3N0YWNrLmxhc3RcbiAgICBpZiBncm91cC5icmVhaz9cbiAgICAgIGZsdXNoXG4gICAgICBAb3V0cHV0IDw8IEBuZXdsaW5lXG4gICAgICBAb3V0cHV0IDw8IEBnZW5zcGFjZS5jYWxsKEBpbmRlbnQpXG4gICAgICBAb3V0cHV0X3dpZHRoID0gQGluZGVudFxuICAgICAgQGJ1ZmZlcl93aWR0aCA9IDBcbiAgICBlbHNlXG4gICAgICBAYnVmZmVyIDw8IEJyZWFrYWJsZS5uZXcoc2VwLCB3aWR0aCwgc2VsZilcbiAgICAgIEBidWZmZXJfd2lkdGggKz0gd2lkdGhcbiAgICAgIGJyZWFrX291dG1vc3RfZ3JvdXBzXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgR3JvdXBzIGxpbmUgYnJlYWsgaGludHMgYWRkZWQgaW4gdGhlIGJsb2NrLiBUaGUgbGluZSBicmVhayBoaW50cyBhcmUgYWxsXG4gICMgdG8gYmUgdXNlZCBvciBub3QuXG4gICNcbiAgIyBJZiAraW5kZW50KyBpcyBzcGVjaWZpZWQsIHRoZSBtZXRob2QgY2FsbCBpcyByZWdhcmRlZCBhcyBuZXN0ZWQgYnlcbiAgIyBuZXN0KGluZGVudCkgeyAuLi4gfS5cbiAgI1xuICAjIElmICtvcGVuX29iaisgaXMgc3BlY2lmaWVkLCA8dHQ+dGV4dCBvcGVuX29iaiwgb3Blbl93aWR0aDwvdHQ+IGlzIGNhbGxlZFxuICAjIGJlZm9yZSBncm91cGluZy4gSWYgK2Nsb3NlX29iaisgaXMgc3BlY2lmaWVkLCA8dHQ+dGV4dCBjbG9zZV9vYmosXG4gICMgY2xvc2Vfd2lkdGg8L3R0PiBpcyBjYWxsZWQgYWZ0ZXIgZ3JvdXBpbmcuXG4gICNcbiAgZGVmIGdyb3VwKGluZGVudD0wLCBvcGVuX29iaj0nJywgY2xvc2Vfb2JqPScnLCBvcGVuX3dpZHRoPW9wZW5fb2JqLmxlbmd0aCwgY2xvc2Vfd2lkdGg9Y2xvc2Vfb2JqLmxlbmd0aClcbiAgICB0ZXh0IG9wZW5fb2JqLCBvcGVuX3dpZHRoXG4gICAgZ3JvdXBfc3ViIHtcbiAgICAgIG5lc3QoaW5kZW50KSB7XG4gICAgICAgIHlpZWxkXG4gICAgICB9XG4gICAgfVxuICAgIHRleHQgY2xvc2Vfb2JqLCBjbG9zZV93aWR0aFxuICBlbmRcblxuICAjIFRha2VzIGEgYmxvY2sgYW5kIHF1ZXVlcyBhIG5ldyBncm91cCB0aGF0IGlzIGluZGVudGVkIDEgbGV2ZWwgZnVydGhlci5cbiAgZGVmIGdyb3VwX3N1YlxuICAgIGdyb3VwID0gR3JvdXAubmV3KEBncm91cF9zdGFjay5sYXN0LmRlcHRoICsgMSlcbiAgICBAZ3JvdXBfc3RhY2sucHVzaCBncm91cFxuICAgIEBncm91cF9xdWV1ZS5lbnEgZ3JvdXBcbiAgICBiZWdpblxuICAgICAgeWllbGRcbiAgICBlbnN1cmVcbiAgICAgIEBncm91cF9zdGFjay5wb3BcbiAgICAgIGlmIGdyb3VwLmJyZWFrYWJsZXMuZW1wdHk/XG4gICAgICAgIEBncm91cF9xdWV1ZS5kZWxldGUgZ3JvdXBcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICAjIEluY3JlYXNlcyBsZWZ0IG1hcmdpbiBhZnRlciBuZXdsaW5lIHdpdGggK2luZGVudCsgZm9yIGxpbmUgYnJlYWtzIGFkZGVkIGluXG4gICMgdGhlIGJsb2NrLlxuICAjXG4gIGRlZiBuZXN0KGluZGVudClcbiAgICBAaW5kZW50ICs9IGluZGVudFxuICAgIGJlZ2luXG4gICAgICB5aWVsZFxuICAgIGVuc3VyZVxuICAgICAgQGluZGVudCAtPSBpbmRlbnRcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBvdXRwdXRzIGJ1ZmZlcmVkIGRhdGEuXG4gICNcbiAgZGVmIGZsdXNoXG4gICAgQGJ1ZmZlci5lYWNoIHt8ZGF0YXxcbiAgICAgIEBvdXRwdXRfd2lkdGggPSBkYXRhLm91dHB1dChAb3V0cHV0LCBAb3V0cHV0X3dpZHRoKVxuICAgIH1cbiAgICBAYnVmZmVyLmNsZWFyXG4gICAgQGJ1ZmZlcl93aWR0aCA9IDBcbiAgZW5kXG5cbiAgIyBUaGUgVGV4dCBjbGFzcyBpcyB0aGUgbWVhbnMgYnkgd2hpY2ggdG8gY29sbGVjdCBzdHJpbmdzIGZyb20gb2JqZWN0cy5cbiAgI1xuICAjIFRoaXMgY2xhc3MgaXMgaW50ZW5kZWQgZm9yIGludGVybmFsIHVzZSBvZiB0aGUgUHJldHR5UHJpbnQgYnVmZmVycy5cbiAgY2xhc3MgVGV4dCAjIDpub2RvYzpcblxuICAgICMgQ3JlYXRlcyBhIG5ldyB0ZXh0IG9iamVjdC5cbiAgICAjXG4gICAgIyBUaGlzIGNvbnN0cnVjdG9yIHRha2VzIG5vIGFyZ3VtZW50cy5cbiAgICAjXG4gICAgIyBUaGUgd29ya2Zsb3cgaXMgdG8gYXBwZW5kIGEgUHJldHR5UHJpbnQ6OlRleHQgb2JqZWN0IHRvIHRoZSBidWZmZXIsIGFuZFxuICAgICMgYmVpbmcgYWJsZSB0byBjYWxsIHRoZSBidWZmZXIubGFzdCgpIHRvIHJlZmVyZW5jZSBpdC5cbiAgICAjXG4gICAgIyBBcyB0aGVyZSBhcmUgb2JqZWN0cywgdXNlIFByZXR0eVByaW50OjpUZXh0I2FkZCB0byBpbmNsdWRlIHRoZSBvYmplY3RzXG4gICAgIyBhbmQgdGhlIHdpZHRoIHRvIHV0aWxpemVkIGJ5IHRoZSBTdHJpbmcgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICBkZWYgaW5pdGlhbGl6ZVxuICAgICAgQG9ianMgPSBbXVxuICAgICAgQHdpZHRoID0gMFxuICAgIGVuZFxuXG4gICAgIyBUaGUgdG90YWwgd2lkdGggb2YgdGhlIG9iamVjdHMgaW5jbHVkZWQgaW4gdGhpcyBUZXh0IG9iamVjdC5cbiAgICBhdHRyX3JlYWRlciA6d2lkdGhcblxuICAgICMgUmVuZGVyIHRoZSBTdHJpbmcgdGV4dCBvZiB0aGUgb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byB0aGlzIFRleHQgb2JqZWN0LlxuICAgICNcbiAgICAjIE91dHB1dCB0aGUgdGV4dCB0byArb3V0KywgYW5kIGluY3JlbWVudCB0aGUgd2lkdGggdG8gK291dHB1dF93aWR0aCtcbiAgICBkZWYgb3V0cHV0KG91dCwgb3V0cHV0X3dpZHRoKVxuICAgICAgQG9ianMuZWFjaCB7fG9ianwgb3V0IDw8IG9ian1cbiAgICAgIG91dHB1dF93aWR0aCArIEB3aWR0aFxuICAgIGVuZFxuXG4gICAgIyBJbmNsdWRlICtvYmorIGluIHRoZSBvYmplY3RzIHRvIGJlIHByZXR0eSBwcmludGVkLCBhbmQgaW5jcmVtZW50XG4gICAgIyB0aGlzIFRleHQgb2JqZWN0J3MgdG90YWwgd2lkdGggYnkgK3dpZHRoK1xuICAgIGRlZiBhZGQob2JqLCB3aWR0aClcbiAgICAgIEBvYmpzIDw8IG9ialxuICAgICAgQHdpZHRoICs9IHdpZHRoXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgVGhlIEJyZWFrYWJsZSBjbGFzcyBpcyB1c2VkIGZvciBicmVha2luZyB1cCBvYmplY3QgaW5mb3JtYXRpb25cbiAgI1xuICAjIFRoaXMgY2xhc3MgaXMgaW50ZW5kZWQgZm9yIGludGVybmFsIHVzZSBvZiB0aGUgUHJldHR5UHJpbnQgYnVmZmVycy5cbiAgY2xhc3MgQnJlYWthYmxlICMgOm5vZG9jOlxuXG4gICAgIyBDcmVhdGUgYSBuZXcgQnJlYWthYmxlIG9iamVjdC5cbiAgICAjXG4gICAgIyBBcmd1bWVudHM6XG4gICAgIyAqICtzZXArIFN0cmluZyBvZiB0aGUgc2VwYXJhdG9yXG4gICAgIyAqICt3aWR0aCsgRml4bnVtIHdpZHRoIG9mIHRoZSArc2VwK1xuICAgICMgKiArcSsgcGFyZW50IFByZXR0eVByaW50IG9iamVjdCwgdG8gYmFzZSBmcm9tXG4gICAgZGVmIGluaXRpYWxpemUoc2VwLCB3aWR0aCwgcSlcbiAgICAgIEBvYmogPSBzZXBcbiAgICAgIEB3aWR0aCA9IHdpZHRoXG4gICAgICBAcHAgPSBxXG4gICAgICBAaW5kZW50ID0gcS5pbmRlbnRcbiAgICAgIEBncm91cCA9IHEuY3VycmVudF9ncm91cFxuICAgICAgQGdyb3VwLmJyZWFrYWJsZXMucHVzaCBzZWxmXG4gICAgZW5kXG5cbiAgICAjIEhvbGRzIHRoZSBzZXBhcmF0b3IgU3RyaW5nXG4gICAgI1xuICAgICMgVGhlICtzZXArIGFyZ3VtZW50IGZyb20gOjpuZXdcbiAgICBhdHRyX3JlYWRlciA6b2JqXG5cbiAgICAjIFRoZSB3aWR0aCBvZiArb2JqKyAvICtzZXArXG4gICAgYXR0cl9yZWFkZXIgOndpZHRoXG5cbiAgICAjIFRoZSBudW1iZXIgb2Ygc3BhY2VzIHRvIGluZGVudC5cbiAgICAjXG4gICAgIyBUaGlzIGlzIGluZmVycmVkIGZyb20gK3ErIHdpdGhpbiBQcmV0dHlQcmludCwgcGFzc2VkIGluIDo6bmV3XG4gICAgYXR0cl9yZWFkZXIgOmluZGVudFxuXG4gICAgIyBSZW5kZXIgdGhlIFN0cmluZyB0ZXh0IG9mIHRoZSBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoaXNcbiAgICAjIEJyZWFrYWJsZSBvYmplY3QuXG4gICAgI1xuICAgICMgT3V0cHV0IHRoZSB0ZXh0IHRvICtvdXQrLCBhbmQgaW5jcmVtZW50IHRoZSB3aWR0aCB0byArb3V0cHV0X3dpZHRoK1xuICAgIGRlZiBvdXRwdXQob3V0LCBvdXRwdXRfd2lkdGgpXG4gICAgICBAZ3JvdXAuYnJlYWthYmxlcy5zaGlmdFxuICAgICAgaWYgQGdyb3VwLmJyZWFrP1xuICAgICAgICBvdXQgPDwgQHBwLm5ld2xpbmVcbiAgICAgICAgb3V0IDw8IEBwcC5nZW5zcGFjZS5jYWxsKEBpbmRlbnQpXG4gICAgICAgIEBpbmRlbnRcbiAgICAgIGVsc2VcbiAgICAgICAgQHBwLmdyb3VwX3F1ZXVlLmRlbGV0ZSBAZ3JvdXAgaWYgQGdyb3VwLmJyZWFrYWJsZXMuZW1wdHk/XG4gICAgICAgIG91dCA8PCBAb2JqXG4gICAgICAgIG91dHB1dF93aWR0aCArIEB3aWR0aFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgVGhlIEdyb3VwIGNsYXNzIGlzIHVzZWQgZm9yIG1ha2luZyBpbmRlbnRhdGlvbiBlYXNpZXIuXG4gICNcbiAgIyBXaGlsZSB0aGlzIGNsYXNzIGRvZXMgbmVpdGhlciB0aGUgYnJlYWtpbmcgaW50byBuZXdsaW5lcyBub3IgaW5kZW50YXRpb24sXG4gICMgaXQgaXMgdXNlZCBpbiBhIHN0YWNrIChhcyB3ZWxsIGFzIGEgcXVldWUpIHdpdGhpbiBQcmV0dHlQcmludCwgdG8gZ3JvdXBcbiAgIyBvYmplY3RzLlxuICAjXG4gICMgRm9yIGluZm9ybWF0aW9uIG9uIHVzaW5nIGdyb3Vwcywgc2VlIFByZXR0eVByaW50I2dyb3VwXG4gICNcbiAgIyBUaGlzIGNsYXNzIGlzIGludGVuZGVkIGZvciBpbnRlcm5hbCB1c2Ugb2YgdGhlIFByZXR0eVByaW50IGJ1ZmZlcnMuXG4gIGNsYXNzIEdyb3VwICMgOm5vZG9jOlxuICAgICMgQ3JlYXRlIGEgR3JvdXAgb2JqZWN0XG4gICAgI1xuICAgICMgQXJndW1lbnRzOlxuICAgICMgKiArZGVwdGgrIC0gdGhpcyBncm91cCdzIHJlbGF0aW9uIHRvIHByZXZpb3VzIGdyb3Vwc1xuICAgIGRlZiBpbml0aWFsaXplKGRlcHRoKVxuICAgICAgQGRlcHRoID0gZGVwdGhcbiAgICAgIEBicmVha2FibGVzID0gW11cbiAgICAgIEBicmVhayA9IGZhbHNlXG4gICAgZW5kXG5cbiAgICAjIFRoaXMgZ3JvdXAncyByZWxhdGlvbiB0byBwcmV2aW91cyBncm91cHNcbiAgICBhdHRyX3JlYWRlciA6ZGVwdGhcblxuICAgICMgQXJyYXkgdG8gaG9sZCB0aGUgQnJlYWthYmxlIG9iamVjdHMgZm9yIHRoaXMgR3JvdXBcbiAgICBhdHRyX3JlYWRlciA6YnJlYWthYmxlc1xuXG4gICAgIyBNYWtlcyBhIGJyZWFrIGZvciB0aGlzIEdyb3VwLCBhbmQgcmV0dXJucyB0cnVlXG4gICAgZGVmIGJyZWFrXG4gICAgICBAYnJlYWsgPSB0cnVlXG4gICAgZW5kXG5cbiAgICAjIEJvb2xlYW4gb2Ygd2hldGhlciB0aGlzIEdyb3VwIGhhcyBtYWRlIGEgYnJlYWtcbiAgICBkZWYgYnJlYWs/XG4gICAgICBAYnJlYWtcbiAgICBlbmRcblxuICAgICMgQm9vbGVhbiBvZiB3aGV0aGVyIHRoaXMgR3JvdXAgaGFzIGJlZW4gcXVlcmllZCBmb3IgYmVpbmcgZmlyc3RcbiAgICAjXG4gICAgIyBUaGlzIGlzIHVzZWQgYXMgYSBwcmVkaWNhdGUsIGFuZCBvdWdodCB0byBiZSBjYWxsZWQgZmlyc3QuXG4gICAgZGVmIGZpcnN0P1xuICAgICAgaWYgZGVmaW5lZD8gQGZpcnN0XG4gICAgICAgIGZhbHNlXG4gICAgICBlbHNlXG4gICAgICAgIEBmaXJzdCA9IGZhbHNlXG4gICAgICAgIHRydWVcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICAjIFRoZSBHcm91cFF1ZXVlIGNsYXNzIGlzIHVzZWQgZm9yIG1hbmFnaW5nIHRoZSBxdWV1ZSBvZiBHcm91cCB0byBiZSBwcmV0dHlcbiAgIyBwcmludGVkLlxuICAjXG4gICMgVGhpcyBxdWV1ZSBncm91cHMgdGhlIEdyb3VwIG9iamVjdHMsIGJhc2VkIG9uIHRoZWlyIGRlcHRoLlxuICAjXG4gICMgVGhpcyBjbGFzcyBpcyBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlIG9mIHRoZSBQcmV0dHlQcmludCBidWZmZXJzLlxuICBjbGFzcyBHcm91cFF1ZXVlICMgOm5vZG9jOlxuICAgICMgQ3JlYXRlIGEgR3JvdXBRdWV1ZSBvYmplY3RcbiAgICAjXG4gICAgIyBBcmd1bWVudHM6XG4gICAgIyAqICtncm91cHMrIC0gb25lIG9yIG1vcmUgUHJldHR5UHJpbnQ6Okdyb3VwIG9iamVjdHNcbiAgICBkZWYgaW5pdGlhbGl6ZSgqZ3JvdXBzKVxuICAgICAgQHF1ZXVlID0gW11cbiAgICAgIGdyb3Vwcy5lYWNoIHt8Z3wgZW5xIGd9XG4gICAgZW5kXG5cbiAgICAjIEVucXVldWUgK2dyb3VwK1xuICAgICNcbiAgICAjIFRoaXMgZG9lcyBub3Qgc3RyaWN0bHkgYXBwZW5kIHRoZSBncm91cCB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZSxcbiAgICAjIGJ1dCBpbnN0ZWFkIGFkZHMgaXQgaW4gbGluZSwgYmFzZSBvbiB0aGUgK2dyb3VwLmRlcHRoK1xuICAgIGRlZiBlbnEoZ3JvdXApXG4gICAgICBkZXB0aCA9IGdyb3VwLmRlcHRoXG4gICAgICBAcXVldWUgPDwgW10gdW50aWwgZGVwdGggPCBAcXVldWUubGVuZ3RoXG4gICAgICBAcXVldWVbZGVwdGhdIDw8IGdyb3VwXG4gICAgZW5kXG5cbiAgICAjIFJldHVybnMgdGhlIG91dGVyIGdyb3VwIG9mIHRoZSBxdWV1ZVxuICAgIGRlZiBkZXFcbiAgICAgIEBxdWV1ZS5lYWNoIHt8Z3N8XG4gICAgICAgIChncy5sZW5ndGgtMSkuZG93bnRvKDApIHt8aXxcbiAgICAgICAgICB1bmxlc3MgZ3NbaV0uYnJlYWthYmxlcy5lbXB0eT9cbiAgICAgICAgICAgIGdyb3VwID0gZ3Muc2xpY2UhKGksIDEpLmZpcnN0XG4gICAgICAgICAgICBncm91cC5icmVha1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwXG4gICAgICAgICAgZW5kXG4gICAgICAgIH1cbiAgICAgICAgZ3MuZWFjaCB7fGdyb3VwfCBncm91cC5icmVha31cbiAgICAgICAgZ3MuY2xlYXJcbiAgICAgIH1cbiAgICAgIHJldHVybiBuaWxcbiAgICBlbmRcblxuICAgICMgUmVtb3RlICtncm91cCsgZnJvbSB0aGlzIHF1ZXVlXG4gICAgZGVmIGRlbGV0ZShncm91cClcbiAgICAgIEBxdWV1ZVtncm91cC5kZXB0aF0uZGVsZXRlKGdyb3VwKVxuICAgIGVuZFxuICBlbmRcblxuICAjIFByZXR0eVByaW50OjpTaW5nbGVMaW5lIGlzIHVzZWQgYnkgUHJldHR5UHJpbnQuc2luZ2xlbGluZV9mb3JtYXRcbiAgI1xuICAjIEl0IGlzIHBhc3NlZCB0byBiZSBzaW1pbGFyIHRvIGEgUHJldHR5UHJpbnQgb2JqZWN0IGl0c2VsZiwgYnkgcmVzcG9uZGluZyB0bzpcbiAgIyAqICN0ZXh0XG4gICMgKiAjYnJlYWthYmxlXG4gICMgKiAjbmVzdFxuICAjICogI2dyb3VwXG4gICMgKiAjZmx1c2hcbiAgIyAqICNmaXJzdD9cbiAgI1xuICAjIGJ1dCBpbnN0ZWFkLCB0aGUgb3V0cHV0IGhhcyBubyBsaW5lIGJyZWFrc1xuICAjXG4gIGNsYXNzIFNpbmdsZUxpbmVcbiAgICAjIENyZWF0ZSBhIFByZXR0eVByaW50OjpTaW5nbGVMaW5lIG9iamVjdFxuICAgICNcbiAgICAjIEFyZ3VtZW50czpcbiAgICAjICogK291dHB1dCsgLSBTdHJpbmcgKG9yIHNpbWlsYXIpIHRvIHN0b3JlIHJlbmRlcmVkIHRleHQuIE5lZWRzIHRvIHJlc3BvbmQgdG8gJzw8J1xuICAgICMgKiArbWF4d2lkdGgrIC0gQXJndW1lbnQgcG9zaXRpb24gZXhwZWN0ZWQgdG8gYmUgaGVyZSBmb3IgY29tcGF0aWJpbGl0eS5cbiAgICAjICAgICAgICAgICAgICAgIFRoaXMgYXJndW1lbnQgaXMgYSBub29wLlxuICAgICMgKiArbmV3bGluZSsgLSBBcmd1bWVudCBwb3NpdGlvbiBleHBlY3RlZCB0byBiZSBoZXJlIGZvciBjb21wYXRpYmlsaXR5LlxuICAgICMgICAgICAgICAgICAgICBUaGlzIGFyZ3VtZW50IGlzIGEgbm9vcC5cbiAgICBkZWYgaW5pdGlhbGl6ZShvdXRwdXQsIG1heHdpZHRoPW5pbCwgbmV3bGluZT1uaWwpXG4gICAgICBAb3V0cHV0ID0gb3V0cHV0XG4gICAgICBAZmlyc3QgPSBbdHJ1ZV1cbiAgICBlbmRcblxuICAgICMgQWRkICtvYmorIHRvIHRoZSB0ZXh0IHRvIGJlIG91dHB1dC5cbiAgICAjXG4gICAgIyArd2lkdGgrIGFyZ3VtZW50IGlzIGhlcmUgZm9yIGNvbXBhdGliaWxpdHkuIEl0IGlzIGEgbm9vcCBhcmd1bWVudC5cbiAgICBkZWYgdGV4dChvYmosIHdpZHRoPW5pbClcbiAgICAgIEBvdXRwdXQgPDwgb2JqXG4gICAgZW5kXG5cbiAgICAjIEFwcGVuZHMgK3NlcCsgdG8gdGhlIHRleHQgdG8gYmUgb3V0cHV0LiBCeSBkZWZhdWx0ICtzZXArIGlzICcgJ1xuICAgICNcbiAgICAjICt3aWR0aCsgYXJndW1lbnQgaXMgaGVyZSBmb3IgY29tcGF0aWJpbGl0eS4gSXQgaXMgYSBub29wIGFyZ3VtZW50LlxuICAgIGRlZiBicmVha2FibGUoc2VwPScgJywgd2lkdGg9bmlsKVxuICAgICAgQG91dHB1dCA8PCBzZXBcbiAgICBlbmRcblxuICAgICMgVGFrZXMgK2luZGVudCsgYXJnLCBidXQgZG9lcyBub3RoaW5nIHdpdGggaXQuXG4gICAgI1xuICAgICMgWWllbGRzIHRvIGEgYmxvY2suXG4gICAgZGVmIG5lc3QoaW5kZW50KSAjIDpub2RvYzpcbiAgICAgIHlpZWxkXG4gICAgZW5kXG5cbiAgICAjIE9wZW5zIGEgYmxvY2sgZm9yIGdyb3VwaW5nIG9iamVjdHMgdG8gYmUgcHJldHR5IHByaW50ZWQuXG4gICAgI1xuICAgICMgQXJndW1lbnRzOlxuICAgICMgKiAraW5kZW50KyAtIG5vb3AgYXJndW1lbnQuIFByZXNlbnQgZm9yIGNvbXBhdGliaWxpdHkuXG4gICAgIyAqICtvcGVuX29iaisgLSB0ZXh0IGFwcGVuZGVkIGJlZm9yZSB0aGUgJmJsb2suIERlZmF1bHQgaXMgJydcbiAgICAjICogK2Nsb3NlX29iaisgLSB0ZXh0IGFwcGVuZGVkIGFmdGVyIHRoZSAmYmxvay4gRGVmYXVsdCBpcyAnJ1xuICAgICMgKiArb3Blbl93aWR0aCsgLSBub29wIGFyZ3VtZW50LiBQcmVzZW50IGZvciBjb21wYXRpYmlsaXR5LlxuICAgICMgKiArY2xvc2Vfd2lkdGgrIC0gbm9vcCBhcmd1bWVudC4gUHJlc2VudCBmb3IgY29tcGF0aWJpbGl0eS5cbiAgICBkZWYgZ3JvdXAoaW5kZW50PW5pbCwgb3Blbl9vYmo9JycsIGNsb3NlX29iaj0nJywgb3Blbl93aWR0aD1uaWwsIGNsb3NlX3dpZHRoPW5pbClcbiAgICAgIEBmaXJzdC5wdXNoIHRydWVcbiAgICAgIEBvdXRwdXQgPDwgb3Blbl9vYmpcbiAgICAgIHlpZWxkXG4gICAgICBAb3V0cHV0IDw8IGNsb3NlX29ialxuICAgICAgQGZpcnN0LnBvcFxuICAgIGVuZFxuXG4gICAgIyBNZXRob2QgcHJlc2VudCBmb3IgY29tcGF0aWJpbGl0eSwgYnV0IGlzIGEgbm9vcFxuICAgIGRlZiBmbHVzaCAjIDpub2RvYzpcbiAgICBlbmRcblxuICAgICMgVGhpcyBpcyB1c2VkIGFzIGEgcHJlZGljYXRlLCBhbmQgb3VnaHQgdG8gYmUgY2FsbGVkIGZpcnN0LlxuICAgIGRlZiBmaXJzdD9cbiAgICAgIHJlc3VsdCA9IEBmaXJzdFstMV1cbiAgICAgIEBmaXJzdFstMV0gPSBmYWxzZVxuICAgICAgcmVzdWx0XG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJmb3JtYXQiLCJkdXAiLCI3OSIsImxhbWJkYSIsIioiLCJuIiwicSIsIm5ldyIsIm91dHB1dCIsIm1heHdpZHRoIiwibmV3bGluZSIsImdlbnNwYWNlIiwiZmx1c2giLCJzaW5nbGVsaW5lX2Zvcm1hdCIsImluaXRpYWxpemUiLCJAb3V0cHV0IiwiQG1heHdpZHRoIiwiQG5ld2xpbmUiLCJAZ2Vuc3BhY2UiLCIkcmV0X29yXzEiLCJAb3V0cHV0X3dpZHRoIiwiMCIsIkBidWZmZXJfd2lkdGgiLCJAYnVmZmVyIiwicm9vdF9ncm91cCIsIkBncm91cF9zdGFjayIsIkBncm91cF9xdWV1ZSIsIkBpbmRlbnQiLCJhdHRyX3JlYWRlciIsImN1cnJlbnRfZ3JvdXAiLCJsYXN0IiwiYnJlYWtfb3V0bW9zdF9ncm91cHMiLCI8IiwiKyIsImdyb3VwIiwiZGVxIiwiYnJlYWthYmxlcyIsImVtcHR5PyIsImRhdGEiLCJzaGlmdCIsIi0iLCJ3aWR0aCIsIiRyZXRfb3JfMiIsIiEiLCI9PT0iLCJmaXJzdCIsInRleHQiLCJvYmoiLCJsZW5ndGgiLCI8PCIsImFkZCIsImZpbGxfYnJlYWthYmxlIiwic2VwIiwiYnJlYWthYmxlIiwiYnJlYWs/IiwiY2FsbCIsInNlbGYiLCJvcGVuX29iaiIsImNsb3NlX29iaiIsIm9wZW5fd2lkdGgiLCJncm91cF9zdWIiLCJuZXN0IiwiaW5kZW50IiwiY2xvc2Vfd2lkdGgiLCJkZXB0aCIsIjEiLCJwdXNoIiwiZW5xIiwicG9wIiwiZGVsZXRlIiwiZWFjaCIsImNsZWFyIiwiQG9ianMiLCJAd2lkdGgiLCJvdXQiLCJvdXRwdXRfd2lkdGgiLCJAb2JqIiwiQHBwIiwiQGdyb3VwIiwiZ3JvdXBfcXVldWUiLCJAZGVwdGgiLCJAYnJlYWthYmxlcyIsIkBicmVhayIsImJyZWFrIiwiZmlyc3Q/IiwiQGZpcnN0IiwiQHF1ZXVlIiwiZ3JvdXBzIiwiZyIsIltdIiwiZG93bnRvIiwiZ3MiLCJpIiwic2xpY2UhIiwicmVzdWx0IiwiLTEiLCIkd3JpdGVyIiwiW109Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7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SUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FqY0E7QUFYRkEsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMDk2MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vcHAucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcblxuIyBPcGFsOiBsb2FkIHN0ZGxpYi90aHJlYWQucmJcbnJlcXVpcmUgJ3RocmVhZCdcbnJlcXVpcmUgJ3N0cmluZ2lvJ1xucmVxdWlyZSAncHJldHR5cHJpbnQnXG5cbiMjXG4jIEEgcHJldHR5LXByaW50ZXIgZm9yIFJ1Ynkgb2JqZWN0cy5cbiNcbiMjXG4jID09IFdoYXQgUFAgRG9lc1xuI1xuIyBTdGFuZGFyZCBvdXRwdXQgYnkgI3AgcmV0dXJucyB0aGlzOlxuIyAgICM8UFA6MHg4MWZlZGYwIEBnZW5zcGFjZT0jPFByb2M6MHg4MWZlZGEwPiwgQGdyb3VwX3F1ZXVlPSM8UHJldHR5UHJpbnQ6Okdyb3VwUXVldWU6MHg4MWZlZDNjIEBxdWV1ZT1bWyM8UHJldHR5UHJpbnQ6Okdyb3VwOjB4ODFmZWQ3OCBAYnJlYWthYmxlcz1bXSwgQGRlcHRoPTAsIEBicmVhaz1mYWxzZT5dLCBbXV0+LCBAYnVmZmVyPVtdLCBAbmV3bGluZT1cIlxcblwiLCBAZ3JvdXBfc3RhY2s9WyM8UHJldHR5UHJpbnQ6Okdyb3VwOjB4ODFmZWQ3OCBAYnJlYWthYmxlcz1bXSwgQGRlcHRoPTAsIEBicmVhaz1mYWxzZT5dLCBAYnVmZmVyX3dpZHRoPTAsIEBpbmRlbnQ9MCwgQG1heHdpZHRoPTc5LCBAb3V0cHV0X3dpZHRoPTIsIEBvdXRwdXQ9IzxJTzoweDgxMTRlZTQ+PlxuI1xuIyBQcmV0dHktcHJpbnRlZCBvdXRwdXQgcmV0dXJucyB0aGlzOlxuIyAgICM8UFA6MHg4MWZlZGYwXG4jICAgIEBidWZmZXI9W10sXG4jICAgIEBidWZmZXJfd2lkdGg9MCxcbiMgICAgQGdlbnNwYWNlPSM8UHJvYzoweDgxZmVkYTA+LFxuIyAgICBAZ3JvdXBfcXVldWU9XG4jICAgICAjPFByZXR0eVByaW50OjpHcm91cFF1ZXVlOjB4ODFmZWQzY1xuIyAgICAgIEBxdWV1ZT1cbiMgICAgICAgW1sjPFByZXR0eVByaW50OjpHcm91cDoweDgxZmVkNzggQGJyZWFrPWZhbHNlLCBAYnJlYWthYmxlcz1bXSwgQGRlcHRoPTA+XSxcbiMgICAgICAgIFtdXT4sXG4jICAgIEBncm91cF9zdGFjaz1cbiMgICAgIFsjPFByZXR0eVByaW50OjpHcm91cDoweDgxZmVkNzggQGJyZWFrPWZhbHNlLCBAYnJlYWthYmxlcz1bXSwgQGRlcHRoPTA+XSxcbiMgICAgQGluZGVudD0wLFxuIyAgICBAbWF4d2lkdGg9NzksXG4jICAgIEBuZXdsaW5lPVwiXFxuXCIsXG4jICAgIEBvdXRwdXQ9IzxJTzoweDgxMTRlZTQ+LFxuIyAgICBAb3V0cHV0X3dpZHRoPTI+XG4jXG4jI1xuIyA9PSBVc2FnZVxuI1xuIyAgIHBwKG9iaikgICAgICAgICAgICAgIz0+IG9ialxuIyAgIHBwIG9iaiAgICAgICAgICAgICAgIz0+IG9ialxuIyAgIHBwKG9iajEsIG9iajIsIC4uLikgIz0+IFtvYmoxLCBvYmoyLCAuLi5dXG4jICAgcHAoKSAgICAgICAgICAgICAgICAjPT4gbmlsXG4jXG4jIE91dHB1dCA8dHQ+b2JqKHMpPC90dD4gdG8gPHR0PiQ+PC90dD4gaW4gcHJldHR5IHByaW50ZWQgZm9ybWF0LlxuI1xuIyBJdCByZXR1cm5zIDx0dD5vYmoocyk8L3R0Pi5cbiNcbiMjXG4jID09IE91dHB1dCBDdXN0b21pemF0aW9uXG4jXG4jIFRvIGRlZmluZSBhIGN1c3RvbWl6ZWQgcHJldHR5IHByaW50aW5nIGZ1bmN0aW9uIGZvciB5b3VyIGNsYXNzZXMsXG4jIHJlZGVmaW5lIG1ldGhvZCA8Y29kZT4jcHJldHR5X3ByaW50KHBwKTwvY29kZT4gaW4gdGhlIGNsYXNzLlxuI1xuIyA8Y29kZT4jcHJldHR5X3ByaW50PC9jb2RlPiB0YWtlcyB0aGUgK3BwKyBhcmd1bWVudCwgd2hpY2ggaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIFBQIGNsYXNzLlxuIyBUaGUgbWV0aG9kIHVzZXMgI3RleHQsICNicmVha2FibGUsICNuZXN0LCAjZ3JvdXAgYW5kICNwcCB0byBwcmludCB0aGVcbiMgb2JqZWN0LlxuI1xuIyNcbiMgPT0gUHJldHR5LVByaW50IEpTT05cbiNcbiMgVG8gcHJldHR5LXByaW50IEpTT04gcmVmZXIgdG8gSlNPTiNwcmV0dHlfZ2VuZXJhdGUuXG4jXG4jI1xuIyA9PSBBdXRob3JcbiMgVGFuYWthIEFraXJhIDxha3JAZnNpai5vcmc+XG5cbmNsYXNzIFBQIDwgUHJldHR5UHJpbnRcbiAgIyBPdXRwdXRzICtvYmorIHRvICtvdXQrIGluIHByZXR0eSBwcmludGVkIGZvcm1hdCBvZlxuICAjICt3aWR0aCsgY29sdW1ucyBpbiB3aWR0aC5cbiAgI1xuICAjIElmICtvdXQrIGlzIG9taXR0ZWQsIDxjb2RlPiQ+PC9jb2RlPiBpcyBhc3N1bWVkLlxuICAjIElmICt3aWR0aCsgaXMgb21pdHRlZCwgNzkgaXMgYXNzdW1lZC5cbiAgI1xuICAjIFBQLnBwIHJldHVybnMgK291dCsuXG4gIGRlZiBQUC5wcChvYmosIG91dD0kc3Rkb3V0LCB3aWR0aD03OSkgICMgT3BhbDogcmVwbGFjZSAkPiB3aXRoICRzdGRvdXRcbiAgICBxID0gUFAubmV3KG91dCwgd2lkdGgpXG4gICAgcS5ndWFyZF9pbnNwZWN0X2tleSB7cS5wcCBvYmp9XG4gICAgcS5mbHVzaFxuICAgICMkcHAgPSBxXG4gICAgb3V0IDw8IFwiXFxuXCJcbiAgZW5kXG5cbiAgIyBPdXRwdXRzICtvYmorIHRvICtvdXQrIGxpa2UgUFAucHAgYnV0IHdpdGggbm8gaW5kZW50IGFuZFxuICAjIG5ld2xpbmUuXG4gICNcbiAgIyBQUC5zaW5nbGVsaW5lX3BwIHJldHVybnMgK291dCsuXG4gIGRlZiBQUC5zaW5nbGVsaW5lX3BwKG9iaiwgb3V0PSRzdGRvdXQpICAjIE9wYWw6IHJlcGxhY2UgJD4gd2l0aCAkc3Rkb3V0XG4gICAgcSA9IFNpbmdsZUxpbmUubmV3KG91dClcbiAgICBxLmd1YXJkX2luc3BlY3Rfa2V5IHtxLnBwIG9ian1cbiAgICBxLmZsdXNoXG4gICAgb3V0XG4gIGVuZFxuXG4gICMgOnN0b3Bkb2M6XG4gIGRlZiBQUC5tY2FsbChvYmosIG1vZCwgbWV0aCwgKmFyZ3MsICZibG9jaylcbiAgICBtb2QuaW5zdGFuY2VfbWV0aG9kKG1ldGgpLmJpbmRfY2FsbChvYmosICphcmdzLCAmYmxvY2spXG4gIGVuZFxuICAjIDpzdGFydGRvYzpcblxuICBAc2hhcmluZ19kZXRlY3Rpb24gPSBmYWxzZVxuICBjbGFzcyA8PCBzZWxmXG4gICAgIyBSZXR1cm5zIHRoZSBzaGFyaW5nIGRldGVjdGlvbiBmbGFnIGFzIGEgYm9vbGVhbiB2YWx1ZS5cbiAgICAjIEl0IGlzIGZhbHNlIGJ5IGRlZmF1bHQuXG4gICAgYXR0cl9hY2Nlc3NvciA6c2hhcmluZ19kZXRlY3Rpb25cbiAgZW5kXG5cbiAgbW9kdWxlIFBQTWV0aG9kc1xuXG4gICAgIyBZaWVsZHMgdG8gYSBibG9ja1xuICAgICMgYW5kIHByZXNlcnZlcyB0aGUgcHJldmlvdXMgc2V0IG9mIG9iamVjdHMgYmVpbmcgcHJpbnRlZC5cbiAgICBkZWYgZ3VhcmRfaW5zcGVjdF9rZXlcbiAgICAgIGlmIFRocmVhZC5jdXJyZW50WzpfX3JlY3Vyc2l2ZV9rZXlfX10gPT0gbmlsXG4gICAgICAgIFRocmVhZC5jdXJyZW50WzpfX3JlY3Vyc2l2ZV9rZXlfX10gPSB7fS5jb21wYXJlX2J5X2lkZW50aXR5XG4gICAgICBlbmRcblxuICAgICAgaWYgVGhyZWFkLmN1cnJlbnRbOl9fcmVjdXJzaXZlX2tleV9fXVs6aW5zcGVjdF0gPT0gbmlsXG4gICAgICAgIFRocmVhZC5jdXJyZW50WzpfX3JlY3Vyc2l2ZV9rZXlfX11bOmluc3BlY3RdID0ge30uY29tcGFyZV9ieV9pZGVudGl0eVxuICAgICAgZW5kXG5cbiAgICAgIHNhdmUgPSBUaHJlYWQuY3VycmVudFs6X19yZWN1cnNpdmVfa2V5X19dWzppbnNwZWN0XVxuXG4gICAgICBiZWdpblxuICAgICAgICBUaHJlYWQuY3VycmVudFs6X19yZWN1cnNpdmVfa2V5X19dWzppbnNwZWN0XSA9IHt9LmNvbXBhcmVfYnlfaWRlbnRpdHlcbiAgICAgICAgeWllbGRcbiAgICAgIGVuc3VyZVxuICAgICAgICBUaHJlYWQuY3VycmVudFs6X19yZWN1cnNpdmVfa2V5X19dWzppbnNwZWN0XSA9IHNhdmVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgIyBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3RfaWQgK2lkKyBpcyBpbiB0aGUgY3VycmVudCBidWZmZXIgb2Ygb2JqZWN0c1xuICAgICMgdG8gYmUgcHJldHR5IHByaW50ZWQuIFVzZWQgdG8gYnJlYWsgY3ljbGVzIGluIGNoYWlucyBvZiBvYmplY3RzIHRvIGJlXG4gICAgIyBwcmV0dHkgcHJpbnRlZC5cbiAgICBkZWYgY2hlY2tfaW5zcGVjdF9rZXkoaWQpXG4gICAgICBUaHJlYWQuY3VycmVudFs6X19yZWN1cnNpdmVfa2V5X19dICYmXG4gICAgICBUaHJlYWQuY3VycmVudFs6X19yZWN1cnNpdmVfa2V5X19dWzppbnNwZWN0XSAmJlxuICAgICAgVGhyZWFkLmN1cnJlbnRbOl9fcmVjdXJzaXZlX2tleV9fXVs6aW5zcGVjdF0uaW5jbHVkZT8oaWQpXG4gICAgZW5kXG5cbiAgICAjIEFkZHMgdGhlIG9iamVjdF9pZCAraWQrIHRvIHRoZSBzZXQgb2Ygb2JqZWN0cyBiZWluZyBwcmV0dHkgcHJpbnRlZCwgc29cbiAgICAjIGFzIHRvIG5vdCByZXBlYXQgb2JqZWN0cy5cbiAgICBkZWYgcHVzaF9pbnNwZWN0X2tleShpZClcbiAgICAgIFRocmVhZC5jdXJyZW50WzpfX3JlY3Vyc2l2ZV9rZXlfX11bOmluc3BlY3RdW2lkXSA9IHRydWVcbiAgICBlbmRcblxuICAgICMgUmVtb3ZlcyBhbiBvYmplY3QgZnJvbSB0aGUgc2V0IG9mIG9iamVjdHMgYmVpbmcgcHJldHR5IHByaW50ZWQuXG4gICAgZGVmIHBvcF9pbnNwZWN0X2tleShpZClcbiAgICAgIFRocmVhZC5jdXJyZW50WzpfX3JlY3Vyc2l2ZV9rZXlfX11bOmluc3BlY3RdLmRlbGV0ZSBpZFxuICAgIGVuZFxuXG4gICAgIyBBZGRzICtvYmorIHRvIHRoZSBwcmV0dHkgcHJpbnRpbmcgYnVmZmVyXG4gICAgIyB1c2luZyBPYmplY3QjcHJldHR5X3ByaW50IG9yIE9iamVjdCNwcmV0dHlfcHJpbnRfY3ljbGUuXG4gICAgI1xuICAgICMgT2JqZWN0I3ByZXR0eV9wcmludF9jeWNsZSBpcyB1c2VkIHdoZW4gK29iaisgaXMgYWxyZWFkeVxuICAgICMgcHJpbnRlZCwgYS5rLmEgdGhlIG9iamVjdCByZWZlcmVuY2UgY2hhaW4gaGFzIGEgY3ljbGUuXG4gICAgZGVmIHBwKG9iailcbiAgICAgICMgSWYgb2JqIGlzIGEgRGVsZWdhdG9yIHRoZW4gdXNlIHRoZSBvYmplY3QgYmVpbmcgZGVsZWdhdGVkIHRvIGZvciBjeWNsZVxuICAgICAgIyBkZXRlY3Rpb25cbiAgICAgIG9iaiA9IG9iai5fX2dldG9ial9fIGlmIGRlZmluZWQ/KDo6RGVsZWdhdG9yKSBhbmQgb2JqLmlzX2E/KDo6RGVsZWdhdG9yKVxuXG4gICAgICBpZiBjaGVja19pbnNwZWN0X2tleShvYmopXG4gICAgICAgIGdyb3VwIHtvYmoucHJldHR5X3ByaW50X2N5Y2xlIHNlbGZ9XG4gICAgICAgIHJldHVyblxuICAgICAgZW5kXG5cbiAgICAgIGJlZ2luXG4gICAgICAgIHB1c2hfaW5zcGVjdF9rZXkob2JqKVxuICAgICAgICBncm91cCB7b2JqLnByZXR0eV9wcmludCBzZWxmfVxuICAgICAgZW5zdXJlXG4gICAgICAgIHBvcF9pbnNwZWN0X2tleShvYmopIHVubGVzcyBQUC5zaGFyaW5nX2RldGVjdGlvblxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIEEgY29udmVuaWVuY2UgbWV0aG9kIHdoaWNoIGlzIHNhbWUgYXMgZm9sbG93czpcbiAgICAjXG4gICAgIyAgIGdyb3VwKDEsICcjPCcgKyBvYmouY2xhc3MubmFtZSwgJz4nKSB7IC4uLiB9XG4gICAgZGVmIG9iamVjdF9ncm91cChvYmosICZibG9jaykgIyA6eWllbGQ6XG4gICAgICBncm91cCgxLCAnIzwnICsgb2JqLmNsYXNzLm5hbWUsICc+JywgJmJsb2NrKVxuICAgIGVuZFxuXG4gICAgIyBBIGNvbnZlbmllbmNlIG1ldGhvZCwgbGlrZSBvYmplY3RfZ3JvdXAsIGJ1dCBhbHNvIHJlZm9ybWF0cyB0aGUgT2JqZWN0J3NcbiAgICAjIG9iamVjdF9pZC5cbiAgICBkZWYgb2JqZWN0X2FkZHJlc3NfZ3JvdXAob2JqLCAmYmxvY2spXG4gICAgICBzdHIgPSBLZXJuZWwuaW5zdGFuY2VfbWV0aG9kKDp0b19zKS5iaW5kX2NhbGwob2JqKVxuICAgICAgc3RyLmNob21wISgnPicpXG4gICAgICBncm91cCgxLCBzdHIsICc+JywgJmJsb2NrKVxuICAgIGVuZFxuXG4gICAgIyBBIGNvbnZlbmllbmNlIG1ldGhvZCB3aGljaCBpcyBzYW1lIGFzIGZvbGxvd3M6XG4gICAgI1xuICAgICMgICB0ZXh0ICcsJ1xuICAgICMgICBicmVha2FibGVcbiAgICBkZWYgY29tbWFfYnJlYWthYmxlXG4gICAgICB0ZXh0ICcsJ1xuICAgICAgYnJlYWthYmxlXG4gICAgZW5kXG5cbiAgICAjIEFkZHMgYSBzZXBhcmF0ZWQgbGlzdC5cbiAgICAjIFRoZSBsaXN0IGlzIHNlcGFyYXRlZCBieSBjb21tYSB3aXRoIGJyZWFrYWJsZSBzcGFjZSwgYnkgZGVmYXVsdC5cbiAgICAjXG4gICAgIyAjc2VwbGlzdCBpdGVyYXRlcyB0aGUgK2xpc3QrIHVzaW5nICtpdGVyX21ldGhvZCsuXG4gICAgIyBJdCB5aWVsZHMgZWFjaCBvYmplY3QgdG8gdGhlIGJsb2NrIGdpdmVuIGZvciAjc2VwbGlzdC5cbiAgICAjIFRoZSBwcm9jZWR1cmUgK3NlcGFyYXRvcl9wcm9jKyBpcyBjYWxsZWQgYmV0d2VlbiBlYWNoIHlpZWxkcy5cbiAgICAjXG4gICAgIyBJZiB0aGUgaXRlcmF0aW9uIGlzIHplcm8gdGltZXMsICtzZXBhcmF0b3JfcHJvYysgaXMgbm90IGNhbGxlZCBhdCBhbGwuXG4gICAgI1xuICAgICMgSWYgK3NlcGFyYXRvcl9wcm9jKyBpcyBuaWwgb3Igbm90IGdpdmVuLFxuICAgICMgK2xhbWJkYSB7IGNvbW1hX2JyZWFrYWJsZSB9KyBpcyB1c2VkLlxuICAgICMgSWYgK2l0ZXJfbWV0aG9kKyBpcyBub3QgZ2l2ZW4sIDplYWNoIGlzIHVzZWQuXG4gICAgI1xuICAgICMgRm9yIGV4YW1wbGUsIGZvbGxvd2luZyAzIGNvZGUgZnJhZ21lbnRzIGhhcyBzaW1pbGFyIGVmZmVjdC5cbiAgICAjXG4gICAgIyAgIHEuc2VwbGlzdChbMSwyLDNdKSB7fHZ8IHh4eCB2IH1cbiAgICAjXG4gICAgIyAgIHEuc2VwbGlzdChbMSwyLDNdLCBsYW1iZGEgeyBxLmNvbW1hX2JyZWFrYWJsZSB9LCA6ZWFjaCkge3x2fCB4eHggdiB9XG4gICAgI1xuICAgICMgICB4eHggMVxuICAgICMgICBxLmNvbW1hX2JyZWFrYWJsZVxuICAgICMgICB4eHggMlxuICAgICMgICBxLmNvbW1hX2JyZWFrYWJsZVxuICAgICMgICB4eHggM1xuICAgIGRlZiBzZXBsaXN0KGxpc3QsIHNlcD1uaWwsIGl0ZXJfbWV0aG9kPTplYWNoKSAjIDp5aWVsZDogZWxlbWVudFxuICAgICAgc2VwIHx8PSBsYW1iZGEgeyBjb21tYV9icmVha2FibGUgfVxuICAgICAgZmlyc3QgPSB0cnVlXG4gICAgICBsaXN0Ll9fc2VuZF9fKGl0ZXJfbWV0aG9kKSB7fCp2fFxuICAgICAgICBpZiBmaXJzdFxuICAgICAgICAgIGZpcnN0ID0gZmFsc2VcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNlcC5jYWxsXG4gICAgICAgIGVuZFxuICAgICAgICB5aWVsZCgqdilcbiAgICAgIH1cbiAgICBlbmRcblxuICAgICMgQSBwcmVzZW50IHN0YW5kYXJkIGZhaWxzYWZlIGZvciBwcmV0dHkgcHJpbnRpbmcgYW55IGdpdmVuIE9iamVjdFxuICAgIGRlZiBwcF9vYmplY3Qob2JqKVxuICAgICAgb2JqZWN0X2FkZHJlc3NfZ3JvdXAob2JqKSB7XG4gICAgICAgIHNlcGxpc3Qob2JqLnByZXR0eV9wcmludF9pbnN0YW5jZV92YXJpYWJsZXMsIGxhbWJkYSB7IHRleHQgJywnIH0pIHt8dnxcbiAgICAgICAgICBicmVha2FibGVcbiAgICAgICAgICB2ID0gdi50b19zIGlmIFN5bWJvbCA9PT0gdlxuICAgICAgICAgIHRleHQgdlxuICAgICAgICAgIHRleHQgJz0nXG4gICAgICAgICAgZ3JvdXAoMSkge1xuICAgICAgICAgICAgYnJlYWthYmxlICcnXG4gICAgICAgICAgICBwcChvYmouaW5zdGFuY2VfZXZhbCh2KSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgICMgQSBwcmV0dHkgcHJpbnQgZm9yIGEgSGFzaFxuICAgIGRlZiBwcF9oYXNoKG9iailcbiAgICAgIGdyb3VwKDEsICd7JywgJ30nKSB7XG4gICAgICAgIHNlcGxpc3Qob2JqLCBuaWwsIDplYWNoX3BhaXIpIHt8aywgdnxcbiAgICAgICAgICBncm91cCB7XG4gICAgICAgICAgICBwcCBrXG4gICAgICAgICAgICB0ZXh0ICc9PidcbiAgICAgICAgICAgIGdyb3VwKDEpIHtcbiAgICAgICAgICAgICAgYnJlYWthYmxlICcnXG4gICAgICAgICAgICAgIHBwIHZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgaW5jbHVkZSBQUE1ldGhvZHNcblxuICBjbGFzcyBTaW5nbGVMaW5lIDwgUHJldHR5UHJpbnQ6OlNpbmdsZUxpbmUgIyA6bm9kb2M6XG4gICAgaW5jbHVkZSBQUE1ldGhvZHNcbiAgZW5kXG5cbiAgbW9kdWxlIE9iamVjdE1peGluICMgOm5vZG9jOlxuICAgICMgMS4gc3BlY2lmaWMgcHJldHR5X3ByaW50XG4gICAgIyAyLiBzcGVjaWZpYyBpbnNwZWN0XG4gICAgIyAzLiBnZW5lcmljIHByZXR0eV9wcmludFxuXG4gICAgIyBBIGRlZmF1bHQgcHJldHR5IHByaW50aW5nIG1ldGhvZCBmb3IgZ2VuZXJhbCBvYmplY3RzLlxuICAgICMgSXQgY2FsbHMgI3ByZXR0eV9wcmludF9pbnN0YW5jZV92YXJpYWJsZXMgdG8gbGlzdCBpbnN0YW5jZSB2YXJpYWJsZXMuXG4gICAgI1xuICAgICMgSWYgK3NlbGYrIGhhcyBhIGN1c3RvbWl6ZWQgKHJlZGVmaW5lZCkgI2luc3BlY3QgbWV0aG9kLFxuICAgICMgdGhlIHJlc3VsdCBvZiBzZWxmLmluc3BlY3QgaXMgdXNlZCBidXQgaXQgb2J2aW91c2x5IGhhcyBub1xuICAgICMgbGluZSBicmVhayBoaW50cy5cbiAgICAjXG4gICAgIyBUaGlzIG1vZHVsZSBwcm92aWRlcyBwcmVkZWZpbmVkICNwcmV0dHlfcHJpbnQgbWV0aG9kcyBmb3Igc29tZSBvZlxuICAgICMgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBidWlsdC1pbiBjbGFzc2VzIGZvciBjb252ZW5pZW5jZS5cbiAgICBkZWYgcHJldHR5X3ByaW50KHEpXG4gICAgICB1bWV0aG9kX21ldGhvZCA9IE9iamVjdC5pbnN0YW5jZV9tZXRob2QoOm1ldGhvZClcbiAgICAgIGJlZ2luXG4gICAgICAgIGluc3BlY3RfbWV0aG9kID0gdW1ldGhvZF9tZXRob2QuYmluZF9jYWxsKHNlbGYsIDppbnNwZWN0KVxuICAgICAgcmVzY3VlIE5hbWVFcnJvclxuICAgICAgZW5kXG4gICAgICBpZiBpbnNwZWN0X21ldGhvZCAmJiBpbnNwZWN0X21ldGhvZC5vd25lciAhPSBLZXJuZWxcbiAgICAgICAgcS50ZXh0IHNlbGYuaW5zcGVjdFxuICAgICAgZWxzaWYgIWluc3BlY3RfbWV0aG9kICYmIHNlbGYucmVzcG9uZF90bz8oOmluc3BlY3QpXG4gICAgICAgIHEudGV4dCBzZWxmLmluc3BlY3RcbiAgICAgIGVsc2VcbiAgICAgICAgcS5wcF9vYmplY3Qoc2VsZilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgIyBBIGRlZmF1bHQgcHJldHR5IHByaW50aW5nIG1ldGhvZCBmb3IgZ2VuZXJhbCBvYmplY3RzIHRoYXQgYXJlXG4gICAgIyBkZXRlY3RlZCBhcyBwYXJ0IG9mIGEgY3ljbGUuXG4gICAgZGVmIHByZXR0eV9wcmludF9jeWNsZShxKVxuICAgICAgcS5vYmplY3RfYWRkcmVzc19ncm91cChzZWxmKSB7XG4gICAgICAgIHEuYnJlYWthYmxlXG4gICAgICAgIHEudGV4dCAnLi4uJ1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm5zIGEgc29ydGVkIGFycmF5IG9mIGluc3RhbmNlIHZhcmlhYmxlIG5hbWVzLlxuICAgICNcbiAgICAjIFRoaXMgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2YgbmFtZXMgb2YgaW5zdGFuY2UgdmFyaWFibGVzIGFzIHN5bWJvbHMgb3Igc3RyaW5ncyBhczpcbiAgICAjICtbOkBhLCA6QGJdKy5cbiAgICBkZWYgcHJldHR5X3ByaW50X2luc3RhbmNlX3ZhcmlhYmxlc1xuICAgICAgaW5zdGFuY2VfdmFyaWFibGVzLnNvcnRcbiAgICBlbmRcblxuICAgICMgSXMgI2luc3BlY3QgaW1wbGVtZW50YXRpb24gdXNpbmcgI3ByZXR0eV9wcmludC5cbiAgICAjIElmIHlvdSBpbXBsZW1lbnQgI3ByZXR0eV9wcmludCwgaXQgY2FuIGJlIHVzZWQgYXMgZm9sbG93cy5cbiAgICAjXG4gICAgIyAgIGFsaWFzIGluc3BlY3QgcHJldHR5X3ByaW50X2luc3BlY3RcbiAgICAjXG4gICAgIyBIb3dldmVyLCBkb2luZyB0aGlzIHJlcXVpcmVzIHRoYXQgZXZlcnkgY2xhc3MgdGhhdCAjaW5zcGVjdCBpcyBjYWxsZWQgb25cbiAgICAjIGltcGxlbWVudCAjcHJldHR5X3ByaW50LCBvciBhIFJ1bnRpbWVFcnJvciB3aWxsIGJlIHJhaXNlZC5cbiAgICBkZWYgcHJldHR5X3ByaW50X2luc3BlY3RcbiAgICAgIGlmIE9iamVjdC5pbnN0YW5jZV9tZXRob2QoOm1ldGhvZCkuYmluZF9jYWxsKHNlbGYsIDpwcmV0dHlfcHJpbnQpLm93bmVyID09IFBQOjpPYmplY3RNaXhpblxuICAgICAgICByYWlzZSBcInByZXR0eV9wcmludCBpcyBub3Qgb3ZlcnJpZGRlbiBmb3IgI3tzZWxmLmNsYXNzfVwiXG4gICAgICBlbmRcbiAgICAgIFBQLnNpbmdsZWxpbmVfcHAoc2VsZiwgJycuZHVwKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBBcnJheSAjIDpub2RvYzpcbiAgZGVmIHByZXR0eV9wcmludChxKSAjIDpub2RvYzpcbiAgICBxLmdyb3VwKDEsICdbJywgJ10nKSB7XG4gICAgICBxLnNlcGxpc3Qoc2VsZikge3x2fFxuICAgICAgICBxLnBwIHZcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwcmV0dHlfcHJpbnRfY3ljbGUocSkgIyA6bm9kb2M6XG4gICAgcS50ZXh0KGVtcHR5PyA/ICdbXScgOiAnWy4uLl0nKVxuICBlbmRcbmVuZFxuXG5jbGFzcyBIYXNoICMgOm5vZG9jOlxuICBkZWYgcHJldHR5X3ByaW50KHEpICMgOm5vZG9jOlxuICAgIHEucHBfaGFzaCBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwcmV0dHlfcHJpbnRfY3ljbGUocSkgIyA6bm9kb2M6XG4gICAgcS50ZXh0KGVtcHR5PyA/ICd7fScgOiAney4uLn0nKVxuICBlbmRcbmVuZFxuXG5jbGFzcyA8PCBFTlYgIyA6bm9kb2M6XG4gIGRlZiBwcmV0dHlfcHJpbnQocSkgIyA6bm9kb2M6XG4gICAgaCA9IHt9XG4gICAgRU5WLmtleXMuc29ydC5lYWNoIHt8a3xcbiAgICAgIGhba10gPSBFTlZba11cbiAgICB9XG4gICAgcS5wcF9oYXNoIGhcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RydWN0ICMgOm5vZG9jOlxuICBkZWYgcHJldHR5X3ByaW50KHEpICMgOm5vZG9jOlxuICAgIHEuZ3JvdXAoMSwgc3ByaW50ZihcIiM8c3RydWN0ICVzXCIsIFBQLm1jYWxsKHNlbGYsIEtlcm5lbCwgOmNsYXNzKS5uYW1lKSwgJz4nKSB7XG4gICAgICBxLnNlcGxpc3QoUFAubWNhbGwoc2VsZiwgU3RydWN0LCA6bWVtYmVycyksIGxhbWJkYSB7IHEudGV4dCBcIixcIiB9KSB7fG1lbWJlcnxcbiAgICAgICAgcS5icmVha2FibGVcbiAgICAgICAgcS50ZXh0IG1lbWJlci50b19zXG4gICAgICAgIHEudGV4dCAnPSdcbiAgICAgICAgcS5ncm91cCgxKSB7XG4gICAgICAgICAgcS5icmVha2FibGUgJydcbiAgICAgICAgICBxLnBwIHNlbGZbbWVtYmVyXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHJldHR5X3ByaW50X2N5Y2xlKHEpICMgOm5vZG9jOlxuICAgIHEudGV4dCBzcHJpbnRmKFwiIzxzdHJ1Y3QgJXM6Li4uPlwiLCBQUC5tY2FsbChzZWxmLCBLZXJuZWwsIDpjbGFzcykubmFtZSlcbiAgZW5kXG5lbmRcblxuY2xhc3MgUmFuZ2UgIyA6bm9kb2M6XG4gIGRlZiBwcmV0dHlfcHJpbnQocSkgIyA6bm9kb2M6XG4gICAgcS5wcCBzZWxmLmJlZ2luXG4gICAgcS5icmVha2FibGUgJydcbiAgICBxLnRleHQoc2VsZi5leGNsdWRlX2VuZD8gPyAnLi4uJyA6ICcuLicpXG4gICAgcS5icmVha2FibGUgJydcbiAgICBxLnBwIHNlbGYuZW5kIGlmIHNlbGYuZW5kXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFN0cmluZyAjIDpub2RvYzpcbiAgZGVmIHByZXR0eV9wcmludChxKSAjIDpub2RvYzpcbiAgICBsaW5lcyA9IHNlbGYubGluZXNcbiAgICBpZiBsaW5lcy5zaXplID4gMVxuICAgICAgcS5ncm91cCgwLCAnJywgJycpIGRvXG4gICAgICAgIHEuc2VwbGlzdChsaW5lcywgbGFtYmRhIHsgcS50ZXh0ICcgKyc7IHEuYnJlYWthYmxlIH0pIGRvIHx2fFxuICAgICAgICAgIHEucHAgdlxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHEudGV4dCBpbnNwZWN0XG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbiMgT3BhbDogZG9lcyBub3QgaGF2ZSBGaWxlOjpTdGF0XG4jY2xhc3MgRmlsZSA8IElPICMgOm5vZG9jOlxuIyAgY2xhc3MgU3RhdCAjIDpub2RvYzpcbiMgICAgZGVmIHByZXR0eV9wcmludChxKSAjIDpub2RvYzpcbiMgICAgICByZXF1aXJlICdldGMuc28nXG4jICAgICAgcS5vYmplY3RfZ3JvdXAoc2VsZikge1xuIyAgICAgICAgcS5icmVha2FibGVcbiMgICAgICAgIHEudGV4dCBzcHJpbnRmKFwiZGV2PTB4JXhcIiwgc2VsZi5kZXYpOyBxLmNvbW1hX2JyZWFrYWJsZVxuIyAgICAgICAgcS50ZXh0IFwiaW5vPVwiOyBxLnBwIHNlbGYuaW5vOyBxLmNvbW1hX2JyZWFrYWJsZVxuIyAgICAgICAgcS5ncm91cCB7XG4jICAgICAgICAgIG0gPSBzZWxmLm1vZGVcbiMgICAgICAgICAgcS50ZXh0IHNwcmludGYoXCJtb2RlPTAlb1wiLCBtKVxuIyAgICAgICAgICBxLmJyZWFrYWJsZVxuIyAgICAgICAgICBxLnRleHQgc3ByaW50ZihcIiglcyAlYyVjJWMlYyVjJWMlYyVjJWMpXCIsXG4jICAgICAgICAgICAgc2VsZi5mdHlwZSxcbiMgICAgICAgICAgICAobSAmIDA0MDAgPT0gMCA/ID8tIDogP3IpLFxuIyAgICAgICAgICAgIChtICYgMDIwMCA9PSAwID8gPy0gOiA/dyksXG4jICAgICAgICAgICAgKG0gJiAwMTAwID09IDAgPyAobSAmIDA0MDAwID09IDAgPyA/LSA6ID9TKSA6XG4jICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobSAmIDA0MDAwID09IDAgPyA/eCA6ID9zKSksXG4jICAgICAgICAgICAgKG0gJiAwMDQwID09IDAgPyA/LSA6ID9yKSxcbiMgICAgICAgICAgICAobSAmIDAwMjAgPT0gMCA/ID8tIDogP3cpLFxuIyAgICAgICAgICAgIChtICYgMDAxMCA9PSAwID8gKG0gJiAwMjAwMCA9PSAwID8gPy0gOiA/UykgOlxuIyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG0gJiAwMjAwMCA9PSAwID8gP3ggOiA/cykpLFxuIyAgICAgICAgICAgIChtICYgMDAwNCA9PSAwID8gPy0gOiA/ciksXG4jICAgICAgICAgICAgKG0gJiAwMDAyID09IDAgPyA/LSA6ID93KSxcbiMgICAgICAgICAgICAobSAmIDAwMDEgPT0gMCA/IChtICYgMDEwMDAgPT0gMCA/ID8tIDogP1QpIDpcbiMgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtICYgMDEwMDAgPT0gMCA/ID94IDogP3QpKSlcbiMgICAgICAgIH1cbiMgICAgICAgIHEuY29tbWFfYnJlYWthYmxlXG4jICAgICAgICBxLnRleHQgXCJubGluaz1cIjsgcS5wcCBzZWxmLm5saW5rOyBxLmNvbW1hX2JyZWFrYWJsZVxuIyAgICAgICAgcS5ncm91cCB7XG4jICAgICAgICAgIHEudGV4dCBcInVpZD1cIjsgcS5wcCBzZWxmLnVpZFxuIyAgICAgICAgICBiZWdpblxuIyAgICAgICAgICAgIHB3ID0gRXRjLmdldHB3dWlkKHNlbGYudWlkKVxuIyAgICAgICAgICByZXNjdWUgQXJndW1lbnRFcnJvclxuIyAgICAgICAgICBlbmRcbiMgICAgICAgICAgaWYgcHdcbiMgICAgICAgICAgICBxLmJyZWFrYWJsZTsgcS50ZXh0IFwiKCN7cHcubmFtZX0pXCJcbiMgICAgICAgICAgZW5kXG4jICAgICAgICB9XG4jICAgICAgICBxLmNvbW1hX2JyZWFrYWJsZVxuIyAgICAgICAgcS5ncm91cCB7XG4jICAgICAgICAgIHEudGV4dCBcImdpZD1cIjsgcS5wcCBzZWxmLmdpZFxuIyAgICAgICAgICBiZWdpblxuIyAgICAgICAgICAgIGdyID0gRXRjLmdldGdyZ2lkKHNlbGYuZ2lkKVxuIyAgICAgICAgICByZXNjdWUgQXJndW1lbnRFcnJvclxuIyAgICAgICAgICBlbmRcbiMgICAgICAgICAgaWYgZ3JcbiMgICAgICAgICAgICBxLmJyZWFrYWJsZTsgcS50ZXh0IFwiKCN7Z3IubmFtZX0pXCJcbiMgICAgICAgICAgZW5kXG4jICAgICAgICB9XG4jICAgICAgICBxLmNvbW1hX2JyZWFrYWJsZVxuIyAgICAgICAgcS5ncm91cCB7XG4jICAgICAgICAgIHEudGV4dCBzcHJpbnRmKFwicmRldj0weCV4XCIsIHNlbGYucmRldilcbiMgICAgICAgICAgaWYgc2VsZi5yZGV2X21ham9yICYmIHNlbGYucmRldl9taW5vclxuIyAgICAgICAgICAgIHEuYnJlYWthYmxlXG4jICAgICAgICAgICAgcS50ZXh0IHNwcmludGYoJyglZCwgJWQpJywgc2VsZi5yZGV2X21ham9yLCBzZWxmLnJkZXZfbWlub3IpXG4jICAgICAgICAgIGVuZFxuIyAgICAgICAgfVxuIyAgICAgICAgcS5jb21tYV9icmVha2FibGVcbiMgICAgICAgIHEudGV4dCBcInNpemU9XCI7IHEucHAgc2VsZi5zaXplOyBxLmNvbW1hX2JyZWFrYWJsZVxuIyAgICAgICAgcS50ZXh0IFwiYmxrc2l6ZT1cIjsgcS5wcCBzZWxmLmJsa3NpemU7IHEuY29tbWFfYnJlYWthYmxlXG4jICAgICAgICBxLnRleHQgXCJibG9ja3M9XCI7IHEucHAgc2VsZi5ibG9ja3M7IHEuY29tbWFfYnJlYWthYmxlXG4jICAgICAgICBxLmdyb3VwIHtcbiMgICAgICAgICAgdCA9IHNlbGYuYXRpbWVcbiMgICAgICAgICAgcS50ZXh0IFwiYXRpbWU9XCI7IHEucHAgdFxuIyAgICAgICAgICBxLmJyZWFrYWJsZTsgcS50ZXh0IFwiKCN7dC50dl9zZWN9KVwiXG4jICAgICAgICB9XG4jICAgICAgICBxLmNvbW1hX2JyZWFrYWJsZVxuIyAgICAgICAgcS5ncm91cCB7XG4jICAgICAgICAgIHQgPSBzZWxmLm10aW1lXG4jICAgICAgICAgIHEudGV4dCBcIm10aW1lPVwiOyBxLnBwIHRcbiMgICAgICAgICAgcS5icmVha2FibGU7IHEudGV4dCBcIigje3QudHZfc2VjfSlcIlxuIyAgICAgICAgfVxuIyAgICAgICAgcS5jb21tYV9icmVha2FibGVcbiMgICAgICAgIHEuZ3JvdXAge1xuIyAgICAgICAgICB0ID0gc2VsZi5jdGltZVxuIyAgICAgICAgICBxLnRleHQgXCJjdGltZT1cIjsgcS5wcCB0XG4jICAgICAgICAgIHEuYnJlYWthYmxlOyBxLnRleHQgXCIoI3t0LnR2X3NlY30pXCJcbiMgICAgICAgIH1cbiMgICAgICB9XG4jICAgIGVuZFxuIyAgZW5kXG4jZW5kXG5cbmNsYXNzIE1hdGNoRGF0YSAjIDpub2RvYzpcbiAgZGVmIHByZXR0eV9wcmludChxKSAjIDpub2RvYzpcbiAgICBuYyA9IFtdXG4gICAgc2VsZi5yZWdleHAubmFtZWRfY2FwdHVyZXMuZWFjaCB7fG5hbWUsIGluZGV4ZXN8XG4gICAgICBpbmRleGVzLmVhY2gge3xpfCBuY1tpXSA9IG5hbWUgfVxuICAgIH1cbiAgICBxLm9iamVjdF9ncm91cChzZWxmKSB7XG4gICAgICBxLmJyZWFrYWJsZVxuICAgICAgcS5zZXBsaXN0KDAuLi5zZWxmLnNpemUsIGxhbWJkYSB7IHEuYnJlYWthYmxlIH0pIHt8aXxcbiAgICAgICAgaWYgaSA9PSAwXG4gICAgICAgICAgcS5wcCBzZWxmW2ldXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpZiBuY1tpXVxuICAgICAgICAgICAgcS50ZXh0IG5jW2ldXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcS5wcCBpXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgcS50ZXh0ICc6J1xuICAgICAgICAgIHEucHAgc2VsZltpXVxuICAgICAgICBlbmRcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG5cbiMgT3BhbDogZG9lcyBub3QgaGF2ZSBSdWJ5Vk1cbiNjbGFzcyBSdWJ5Vk06OkFic3RyYWN0U3ludGF4VHJlZTo6Tm9kZVxuIyAgZGVmIHByZXR0eV9wcmludF9jaGlsZHJlbihxLCBuYW1lcyA9IFtdKVxuIyAgICBjaGlsZHJlbi56aXAobmFtZXMpIGRvIHxjLCBufFxuIyAgICAgIGlmIG5cbiMgICAgICAgIHEuYnJlYWthYmxlXG4jICAgICAgICBxLnRleHQgXCIje259OlwiXG4jICAgICAgZW5kXG4jICAgICAgcS5ncm91cCgyKSBkb1xuIyAgICAgICAgcS5icmVha2FibGVcbiMgICAgICAgIHEucHAgY1xuIyAgICAgIGVuZFxuIyAgICBlbmRcbiMgIGVuZFxuI1xuIyAgZGVmIHByZXR0eV9wcmludChxKVxuIyAgICBxLmdyb3VwKDEsIFwiKCN7dHlwZX1AI3tmaXJzdF9saW5lbm99OiN7Zmlyc3RfY29sdW1ufS0je2xhc3RfbGluZW5vfToje2xhc3RfY29sdW1ufVwiLCBcIilcIikge1xuIyAgICAgIGNhc2UgdHlwZVxuIyAgICAgIHdoZW4gOlNDT1BFXG4jICAgICAgICBwcmV0dHlfcHJpbnRfY2hpbGRyZW4ocSwgJXdcInRibCBhcmdzIGJvZHlcIilcbiMgICAgICB3aGVuIDpBUkdTXG4jICAgICAgICBwcmV0dHlfcHJpbnRfY2hpbGRyZW4ocSwgJXdbcHJlX251bSBwcmVfaW5pdCBvcHQgZmlyc3RfcG9zdCBwb3N0X251bSBwb3N0X2luaXQgcmVzdCBrdyBrd3Jlc3QgYmxvY2tdKVxuIyAgICAgIHdoZW4gOkRFRk5cbiMgICAgICAgIHByZXR0eV9wcmludF9jaGlsZHJlbihxLCAld1ttaWQgYm9keV0pXG4jICAgICAgd2hlbiA6QVJZUFROXG4jICAgICAgICBwcmV0dHlfcHJpbnRfY2hpbGRyZW4ocSwgJXdbY29uc3QgcHJlIHJlc3QgcG9zdF0pXG4jICAgICAgd2hlbiA6SFNIUFROXG4jICAgICAgICBwcmV0dHlfcHJpbnRfY2hpbGRyZW4ocSwgJXdbY29uc3Qga3cga3dyZXN0XSlcbiMgICAgICBlbHNlXG4jICAgICAgICBwcmV0dHlfcHJpbnRfY2hpbGRyZW4ocSlcbiMgICAgICBlbmRcbiMgICAgfVxuIyAgZW5kXG4jZW5kXG5cbmNsYXNzIE9iamVjdCA8IEJhc2ljT2JqZWN0ICMgOm5vZG9jOlxuICBpbmNsdWRlIFBQOjpPYmplY3RNaXhpblxuZW5kXG5cbltOdW1lcmljLCBTeW1ib2wsIEZhbHNlQ2xhc3MsIFRydWVDbGFzcywgTmlsQ2xhc3MsIE1vZHVsZV0uZWFjaCB7fGN8XG4gIGMuY2xhc3NfZXZhbCB7XG4gICAgZGVmIHByZXR0eV9wcmludF9jeWNsZShxKVxuICAgICAgcS50ZXh0IGluc3BlY3RcbiAgICBlbmRcbiAgfVxufVxuXG5bTnVtZXJpYywgRmFsc2VDbGFzcywgVHJ1ZUNsYXNzLCBNb2R1bGVdLmVhY2gge3xjfFxuICBjLmNsYXNzX2V2YWwge1xuICAgIGRlZiBwcmV0dHlfcHJpbnQocSlcbiAgICAgIHEudGV4dCBpbnNwZWN0XG4gICAgZW5kXG4gIH1cbn1cblxubW9kdWxlIEtlcm5lbFxuICAjIFJldHVybnMgYSBwcmV0dHkgcHJpbnRlZCBvYmplY3QgYXMgYSBzdHJpbmcuXG4gICNcbiAgIyBJbiBvcmRlciB0byB1c2UgdGhpcyBtZXRob2QgeW91IG11c3QgZmlyc3QgcmVxdWlyZSB0aGUgUFAgbW9kdWxlOlxuICAjXG4gICMgICByZXF1aXJlICdwcCdcbiAgI1xuICAjIFNlZSB0aGUgUFAgbW9kdWxlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICBkZWYgcHJldHR5X2luc3BlY3RcbiAgICBQUC5wcChzZWxmLCBTdHJpbmdJTy5uZXcpLnN0cmluZ1xuICBlbmRcblxuICAjIHByaW50cyBhcmd1bWVudHMgaW4gcHJldHR5IGZvcm0uXG4gICNcbiAgIyBwcCByZXR1cm5zIGFyZ3VtZW50KHMpLlxuICBkZWYgcHAoKm9ianMpXG4gICAgb2Jqcy5lYWNoIHt8b2JqfFxuICAgICAgUFAucHAob2JqKVxuICAgIH1cbiAgICBvYmpzLnNpemUgPD0gMSA/IG9ianMuZmlyc3QgOiBvYmpzXG4gIGVuZFxuICBtb2R1bGVfZnVuY3Rpb24gOnBwXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJwcCIsIiRzdGRvdXQiLCI3OSIsInEiLCJuZXciLCJvdXQiLCJ3aWR0aCIsImd1YXJkX2luc3BlY3Rfa2V5Iiwib2JqIiwiZmx1c2giLCI8PCIsInNpbmdsZWxpbmVfcHAiLCJtY2FsbCIsImJpbmRfY2FsbCIsIm1vZCIsImluc3RhbmNlX21ldGhvZCIsIm1ldGgiLCJhcmdzIiwiYmxvY2siLCJAc2hhcmluZ19kZXRlY3Rpb24iLCJhdHRyX2FjY2Vzc29yIiwic2VsZiIsIm1vZHVsZSIsImN1cnJlbnQiLCJbXSIsIj09IiwiJHdyaXRlciIsImNvbXBhcmVfYnlfaWRlbnRpdHkiLCJbXT0iLCItIiwiMSIsInNhdmUiLCJjaGVja19pbnNwZWN0X2tleSIsIiRyZXRfb3JfMSIsIiRyZXRfb3JfMiIsImluY2x1ZGU/IiwiaWQiLCJwdXNoX2luc3BlY3Rfa2V5IiwicG9wX2luc3BlY3Rfa2V5IiwiZGVsZXRlIiwiJHJldF9vcl8zIiwiaXNfYT8iLCJfX2dldG9ial9fIiwiZ3JvdXAiLCJwcmV0dHlfcHJpbnRfY3ljbGUiLCJwcmV0dHlfcHJpbnQiLCJzaGFyaW5nX2RldGVjdGlvbiIsIm9iamVjdF9ncm91cCIsIisiLCJuYW1lIiwib2JqZWN0X2FkZHJlc3NfZ3JvdXAiLCJzdHIiLCJjaG9tcCEiLCJjb21tYV9icmVha2FibGUiLCJ0ZXh0IiwiYnJlYWthYmxlIiwic2VwbGlzdCIsInNlcCIsIiRyZXRfb3JfNCIsImxhbWJkYSIsImZpcnN0IiwiX19zZW5kX18iLCJsaXN0IiwiaXRlcl9tZXRob2QiLCJjYWxsIiwidiIsInBwX29iamVjdCIsInByZXR0eV9wcmludF9pbnN0YW5jZV92YXJpYWJsZXMiLCI9PT0iLCJ0b19zIiwiaW5zdGFuY2VfZXZhbCIsInBwX2hhc2giLCJrIiwiaW5jbHVkZSIsInVtZXRob2RfbWV0aG9kIiwiaW5zcGVjdF9tZXRob2QiLCIkcmV0X29yXzUiLCJvd25lciIsIiE9IiwiaW5zcGVjdCIsIiRyZXRfb3JfNiIsIiEiLCJyZXNwb25kX3RvPyIsImluc3RhbmNlX3ZhcmlhYmxlcyIsInNvcnQiLCJwcmV0dHlfcHJpbnRfaW5zcGVjdCIsInJhaXNlIiwiZHVwIiwiZW1wdHk/IiwiaCIsImVhY2giLCJrZXlzIiwic3ByaW50ZiIsIm1lbWJlciIsImJlZ2luIiwiZXhjbHVkZV9lbmQ/IiwiZW5kIiwibGluZXMiLCI+Iiwic2l6ZSIsIjAiLCJuYyIsInJlZ2V4cCIsIm5hbWVkX2NhcHR1cmVzIiwiaW5kZXhlcyIsImkiLCJjbGFzc19ldmFsIiwiYyIsInByZXR0eV9pbnNwZWN0Iiwic3RyaW5nIiwib2JqcyIsIjw9IiwibW9kdWxlX2Z1bmN0aW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQSxNQUFBQSxTQUFBQSxDQUFRLFFBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLFVBQVJBLENBREE7QUFBQSxNQUVBQSxTQUFBQSxDQUFRLGFBQVJBLENBRkE7QUFBQSxFQThEQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQVFFLElBQUFDLFVBQUksa0JBQUpBLFNBQUFBLFdBQUFBLGNBQVUsR0FBRCxFQUFNLEdBQU4sRUFBbUIsS0FBNUJBO0FBQUFBLE1BQUFBO0FBQUFBOztBQUFBQTtBQTFFRjtBQTBFaUIsTUFBQTtBQUFBLE1BQUEsUUFBSUMsYUFBSjtBQUFBLE1BQUEsQ0ExRWpCO0FBQUE7QUEwRThCLE1BQUE7QUFBQSxNQUFBLFVBQU1DLEVBQU47QUFBQSxNQUFBLENBMUU5QjtBQUFBLE1BMkVJQyxJQUFJLGtCQUFBQyxLQUFBQSxDQUFPQyxLQUFLQyxLQUFaRixDQTNFUjtBQUFBLE1BNEVJRyxNQUFBSixDQUFBSSxxQkFBQUEsRUFBQUEsRUFBQUEsRUE1RUosZ0JBQUEsRUFBQTs7QUFBQSxNQTRFeUIsT0FBQUosQ0FBQUgsSUFBQUEsQ0FBS1EsR0FBTFIsQ0E1RXpCLGtCQUFBLGlCQUFBLEtBNEVJTyxDQTVFSjtBQUFBLE1BNkVJSixDQUFBTSxPQUFBQSxDQUFBQSxDQTdFSjtBQUFBLE1BK0VJLE9BQUFKLEdBQUFLLE9BQUFBLENBQU8sSUFBUEEsQ0EvRUo7QUEwRUVWLElBQUFBLENBQUFBLHVCQUFBQSxDQUFBO0FBQUEsSUFZQVcsVUFBSSxrQkFBSkEsb0JBQUFBLHNCQUFBQSx5QkFBcUIsR0FBRCxFQUFNLEdB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LDRCQUFBQSwwQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxrQkFBQTVHLElBQUFBLENBQU1xQixNQUFNLHdCQUFBakIsS0FBQUEsQ0FBQUEsQ0FBWkosQ0FBQTZHLFFBQUFBLENBQUFBO0FBREZELElBQUFBLENBQUFBLHVDQUFBQSxDQUFBO0FBQUE7QUFPQTVHLElBQUFBLHNCQUFBQSxnQkFBQUEsY0FqbEJGLEVBaWxCRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBamxCRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQWlsQlMsTUFBQSxrQkFqbEJUO0FBQUEsTUFrbEJJMEYsTUFBQW9CLElBQUFwQixRQUFBQSxFQUFBQSxFQUFBQSxFQWxsQkosaUJBa2xCZ0IsR0FsbEJoQixFQUFBOztBQUFBO0FBQUE7QUFrbEJnQixRQUFBO0FBQUEsUUFBQTtBQUFBLFFBQUEsQ0FsbEJoQjtBQUFBLFFBbWxCTSxPQUFBLGtCQUFBMUYsSUFBQUEsQ0FBTVEsR0FBTlIsQ0FubEJOLENBQUEsbUJBQUEsa0JBQUEsTUFrbEJJMEYsQ0FsbEJKO0FBQUEsTUFxbEJJLElBQUEsUUFBQXFCLE9BQUFELElBQUFYLE1BQUFBLENBQUFBLENBQUFZLEVBQWFqRixDQUFiaUYsQ0FBQSxDQUFBO0FBQUEsUUFBaUIsT0FBQUQsSUFBQWxELE9BQUFBLENBQUFBO0FBQWpCLE1BQUE7QUFBQSxRQUE4QixPQUFBa0Q7QUFBOUIsTUFBQSxDQXJsQko7QUFpbEJFOUcsSUFBQUEsQ0FBQUEsNEJBQUFBLENBUEE7QUFBQSxJQWFBLFdBQUFnSCxpQkFBQUEsQ0FBZ0IsSUFBaEJBLENBYkE7QUFSRjFGLEVBQUFBLEdBQUFBLFdBQUFBLFdBOWpCQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMxNjI5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9wcm9taXNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMge1Byb21pc2V9IGlzIHVzZWQgdG8gaGVscCBzdHJ1Y3R1cmUgYXN5bmNocm9ub3VzIGNvZGUuXG4jXG4jIEl0IGlzIGF2YWlsYWJsZSBpbiB0aGUgT3BhbCBzdGFuZGFyZCBsaWJyYXJ5LCBhbmQgY2FuIGJlIHJlcXVpcmVkIGluIGFueSBPcGFsXG4jIGFwcGxpY2F0aW9uOlxuI1xuIyAgICAgcmVxdWlyZSAncHJvbWlzZSdcbiNcbiMgIyMgQmFzaWMgVXNhZ2VcbiNcbiMgUHJvbWlzZXMgYXJlIGNyZWF0ZWQgYW5kIHJldHVybmVkIGFzIG9iamVjdHMgd2l0aCB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZXlcbiMgd2lsbCBldmVudHVhbGx5IGJlIHJlc29sdmVkIG9yIHJlamVjdGVkLCBidXQgbmV2ZXIgYm90aC4gQSB7UHJvbWlzZX0gaGFzXG4jIGEgeyN0aGVufSBhbmQgeyNmYWlsfSBtZXRob2QgKG9yIG9uZSBvZiB0aGVpciBhbGlhc2VzKSB0aGF0IGNhbiBiZSB1c2VkIHRvXG4jIHJlZ2lzdGVyIGEgYmxvY2sgdGhhdCBnZXRzIGNhbGxlZCBvbmNlIHJlc29sdmVkIG9yIHJlamVjdGVkLlxuI1xuIyAgICAgcHJvbWlzZSA9IFByb21pc2UubmV3XG4jXG4jICAgICBwcm9taXNlLnRoZW4ge1xuIyAgICAgICBwdXRzIFwicmVzb2x2ZWQhXCJcbiMgICAgIH0uZmFpbCB7XG4jICAgICAgIHB1dHMgXCJyZWplY3RlZCFcIlxuIyAgICAgfVxuI1xuIyAgICAgIyBzb21lIHRpbWUgbGF0ZXJcbiMgICAgIHByb21pc2UucmVzb2x2ZVxuI1xuIyAgICAgIyA9PiBcInJlc29sdmVkIVwiXG4jXG4jIEl0IGlzIGltcG9ydGFudCB0byByZW1lbWJlciB0aGF0IGEgcHJvbWlzZSBjYW4gb25seSBiZSByZXNvbHZlZCBvciByZWplY3RlZFxuIyBvbmNlLCBzbyB0aGUgYmxvY2sgd2lsbCBvbmx5IGV2ZXIgYmUgY2FsbGVkIG9uY2UgKG9yIG5vdCBhdCBhbGwpLlxuI1xuIyAjIyBSZXNvbHZpbmcgUHJvbWlzZXNcbiNcbiMgVG8gcmVzb2x2ZSBhIHByb21pc2UsIG1lYW5zIHRvIGluZm9ybSB0aGUge1Byb21pc2V9IHRoYXQgaXQgaGFzIHN1Y2NlZWRlZFxuIyBvciBldmFsdWF0ZWQgdG8gYSB1c2VmdWwgdmFsdWUuIHsjcmVzb2x2ZX0gY2FuIGJlIHBhc3NlZCBhIHZhbHVlIHdoaWNoIGlzXG4jIHRoZW4gcGFzc2VkIGludG8gdGhlIGJsb2NrIGhhbmRsZXI6XG4jXG4jICAgICBkZWYgZ2V0X2pzb25cbiMgICAgICAgcHJvbWlzZSA9IFByb21pc2UubmV3XG4jXG4jICAgICAgIEhUVFAuZ2V0KFwic29tZV91cmxcIikgZG8gfHJlcXxcbiMgICAgICAgICBwcm9taXNlLnJlc29sdmUgcmVxLmpzb25cbiMgICAgICAgZW5kXG4jXG4jICAgICAgIHByb21pc2VcbiMgICAgIGVuZFxuI1xuIyAgICAgZ2V0X2pzb24udGhlbiBkbyB8anNvbnxcbiMgICAgICAgcHV0cyBcImdvdCBzb21lIEpTT04gZnJvbSBzZXJ2ZXJcIlxuIyAgICAgZW5kXG4jXG4jICMjIFJlamVjdGluZyBQcm9taXNlc1xuI1xuIyBQcm9taXNlcyBhcmUgYWxzbyBkZXNpZ25lZCB0byBoYW5kbGUgZXJyb3IgY2FzZXMsIG9yIHNpdHVhdGlvbnMgd2hlcmUgYW5cbiMgb3V0Y29tZSBpcyBub3QgYXMgZXhwZWN0ZWQuIFRha2luZyB0aGUgcHJldmlvdXMgZXhhbXBsZSwgd2UgY2FuIGFsc28gcGFzc1xuIyBhIHZhbHVlIHRvIGEgeyNyZWplY3R9IGNhbGwsIHdoaWNoIHBhc3NlcyB0aGF0IG9iamVjdCB0byB0aGUgcmVnaXN0ZXJlZFxuIyB7I2ZhaWx9IGhhbmRsZXI6XG4jXG4jICAgICBkZWYgZ2V0X2pzb25cbiMgICAgICAgcHJvbWlzZSA9IFByb21pc2UubmV3XG4jXG4jICAgICAgIEhUVFAuZ2V0KFwic29tZV91cmxcIikgZG8gfHJlcXxcbiMgICAgICAgICBpZiByZXEub2s/XG4jICAgICAgICAgICBwcm9taXNlLnJlc29sdmUgcmVxLmpzb25cbiMgICAgICAgICBlbHNlXG4jICAgICAgICAgICBwcm9taXNlLnJlamVjdCByZXFcbiMgICAgICAgICBlbmRcbiNcbiMgICAgICAgcHJvbWlzZVxuIyAgICAgZW5kXG4jXG4jICAgICBnZXRfanNvbi50aGVuIHtcbiMgICAgICAgIyAuLi5cbiMgICAgIH0uZmFpbCB7IHxyZXF8XG4jICAgICAgIHB1dHMgXCJpdCB3ZW50IHdyb25nOiAje3JlcS5tZXNzYWdlfVwiXG4jICAgICB9XG4jXG4jICMjIENoYWluaW5nIFByb21pc2VzXG4jXG4jIFByb21pc2VzIGJlY29tZSBldmVuIG1vcmUgdXNlZnVsIHdoZW4gY2hhaW5lZCB0b2dldGhlci4gRWFjaCB7I3RoZW59IG9yXG4jIHsjZmFpbH0gY2FsbCByZXR1cm5zIGEgbmV3IHtQcm9taXNlfSB3aGljaCBjYW4gYmUgdXNlZCB0byBjaGFpbiBtb3JlIGFuZCBtb3JlXG4jIGhhbmRsZXJzIHRvZ2V0aGVyLlxuI1xuIyAgICAgcHJvbWlzZS50aGVuIHsgd2FpdF9mb3Jfc29tZXRoaW5nIH0udGhlbiB7IGRvX3NvbWV0aGluZ19lbHNlIH1cbiNcbiMgUmVqZWN0aW9ucyBhcmUgcHJvcGFnYXRlZCB0aHJvdWdoIHRoZSBlbnRpcmUgY2hhaW4sIHNvIGEgXCJjYXRjaCBhbGxcIiBoYW5kbGVyXG4jIGNhbiBiZSBhdHRhY2hlZCBhdCB0aGUgZW5kIG9mIHRoZSB0YWlsOlxuI1xuIyAgICAgcHJvbWlzZS50aGVuIHsgLi4uIH0udGhlbiB7IC4uLiB9LmZhaWwgeyAuLi4gfVxuI1xuIyAjIyBDb21wb3NpbmcgUHJvbWlzZXNcbiNcbiMge1Byb21pc2Uud2hlbn0gY2FuIGJlIHVzZWQgdG8gd2FpdCBmb3IgbW9yZSB0aGFuIG9uZSBwcm9taXNlIHRvIHJlc29sdmUgKG9yXG4jIHJlamVjdCkuIFVzaW5nIHRoZSBwcmV2aW91cyBleGFtcGxlLCB3ZSBjb3VsZCByZXF1ZXN0IHR3byBkaWZmZXJlbnQganNvblxuIyByZXF1ZXN0cyBhbmQgd2FpdCBmb3IgYm90aCB0byBmaW5pc2g6XG4jXG4jICAgICBQcm9taXNlLndoZW4oZ2V0X2pzb24sIGdldF9qc29uMikudGhlbiB8Zmlyc3QsIHNlY29uZHxcbiMgICAgICAgcHV0cyBcImdvdCB0d28ganNvbiBwYXlsb2FkczogI3tmaXJzdH0sICN7c2Vjb25kfVwiXG4jICAgICBlbmRcbiNcbmNsYXNzIFByb21pc2VcbiAgZGVmIHNlbGYudmFsdWUodmFsdWUpXG4gICAgbmV3LnJlc29sdmUodmFsdWUpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmVycm9yKHZhbHVlKVxuICAgIG5ldy5yZWplY3QodmFsdWUpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLndoZW4oKnByb21pc2VzKVxuICAgIFdoZW4ubmV3KHByb21pc2VzKVxuICBlbmRcblxuICBhdHRyX3JlYWRlciA6ZXJyb3IsIDpwcmV2LCA6bmV4dFxuXG4gIGRlZiBpbml0aWFsaXplKGFjdGlvbiA9IHt9KVxuICAgIEBhY3Rpb24gPSBhY3Rpb25cblxuICAgIEByZWFsaXplZCAgPSBmYWxzZVxuICAgIEBleGNlcHRpb24gPSBmYWxzZVxuICAgIEB2YWx1ZSAgICAgPSBuaWxcbiAgICBAZXJyb3IgICAgID0gbmlsXG4gICAgQGRlbGF5ZWQgICA9IGZhbHNlXG5cbiAgICBAcHJldiA9IG5pbFxuICAgIEBuZXh0ID0gW11cbiAgZW5kXG5cbiAgZGVmIHZhbHVlXG4gICAgaWYgUHJvbWlzZSA9PT0gQHZhbHVlXG4gICAgICBAdmFsdWUudmFsdWVcbiAgICBlbHNlXG4gICAgICBAdmFsdWVcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGFjdD9cbiAgICBAYWN0aW9uLmtleT8oOnN1Y2Nlc3MpIHx8IEBhY3Rpb24ua2V5Pyg6YWx3YXlzKVxuICBlbmRcblxuICBkZWYgYWN0aW9uXG4gICAgQGFjdGlvbi5rZXlzXG4gIGVuZFxuXG4gIGRlZiBleGNlcHRpb24/XG4gICAgQGV4Y2VwdGlvblxuICBlbmRcblxuICBkZWYgcmVhbGl6ZWQ/XG4gICAgQHJlYWxpemVkICE9IGZhbHNlXG4gIGVuZFxuXG4gIGRlZiByZXNvbHZlZD9cbiAgICBAcmVhbGl6ZWQgPT0gOnJlc29sdmVcbiAgZW5kXG5cbiAgZGVmIHJlamVjdGVkP1xuICAgIEByZWFsaXplZCA9PSA6cmVqZWN0XG4gIGVuZFxuXG4gIGRlZiBeKHByb21pc2UpXG4gICAgcHJvbWlzZSA8PCBzZWxmXG4gICAgc2VsZiA+PiBwcm9taXNlXG5cbiAgICBwcm9taXNlXG4gIGVuZFxuXG4gIGRlZiA8PChwcm9taXNlKVxuICAgIEBwcmV2ID0gcHJvbWlzZVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgPj4ocHJvbWlzZSlcbiAgICBAbmV4dCA8PCBwcm9taXNlXG5cbiAgICBpZiBleGNlcHRpb24/XG4gICAgICBwcm9taXNlLnJlamVjdChAZGVsYXllZFswXSlcbiAgICBlbHNpZiByZXNvbHZlZD9cbiAgICAgIHByb21pc2UucmVzb2x2ZShAZGVsYXllZCA/IEBkZWxheWVkWzBdIDogdmFsdWUpXG4gICAgZWxzaWYgcmVqZWN0ZWQ/XG4gICAgICBpZiAhQGFjdGlvbi5rZXk/KDpmYWlsdXJlKSB8fCBQcm9taXNlID09PSAoQGRlbGF5ZWQgPyBAZGVsYXllZFswXSA6IEBlcnJvcilcbiAgICAgICAgcHJvbWlzZS5yZWplY3QoQGRlbGF5ZWQgPyBAZGVsYXllZFswXSA6IGVycm9yKVxuICAgICAgZWxzaWYgcHJvbWlzZS5hY3Rpb24uaW5jbHVkZT8oOmFsd2F5cylcbiAgICAgICAgcHJvbWlzZS5yZWplY3QoQGRlbGF5ZWQgPyBAZGVsYXllZFswXSA6IGVycm9yKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXNvbHZlKHZhbHVlID0gbmlsKVxuICAgIGlmIHJlYWxpemVkP1xuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RoZSBwcm9taXNlIGhhcyBhbHJlYWR5IGJlZW4gcmVhbGl6ZWQnXG4gICAgZW5kXG5cbiAgICBpZiBQcm9taXNlID09PSB2YWx1ZVxuICAgICAgcmV0dXJuICh2YWx1ZSA8PCBAcHJldikgXiBzZWxmXG4gICAgZW5kXG5cbiAgICBiZWdpblxuICAgICAgYmxvY2sgPSBAYWN0aW9uWzpzdWNjZXNzXSB8fCBAYWN0aW9uWzphbHdheXNdXG4gICAgICBpZiBibG9ja1xuICAgICAgICB2YWx1ZSA9IGJsb2NrLmNhbGwodmFsdWUpXG4gICAgICBlbmRcblxuICAgICAgcmVzb2x2ZSEodmFsdWUpXG4gICAgcmVzY3VlIEV4Y2VwdGlvbiA9PiBlXG4gICAgICBleGNlcHRpb24hKGUpXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXNvbHZlISh2YWx1ZSlcbiAgICBAcmVhbGl6ZWQgPSA6cmVzb2x2ZVxuICAgIEB2YWx1ZSAgICA9IHZhbHVlXG5cbiAgICBpZiBAbmV4dC5hbnk/XG4gICAgICBAbmV4dC5lYWNoIHsgfHB8IHAucmVzb2x2ZSh2YWx1ZSkgfVxuICAgIGVsc2VcbiAgICAgIEBkZWxheWVkID0gW3ZhbHVlXVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmVqZWN0KHZhbHVlID0gbmlsKVxuICAgIGlmIHJlYWxpemVkP1xuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RoZSBwcm9taXNlIGhhcyBhbHJlYWR5IGJlZW4gcmVhbGl6ZWQnXG4gICAgZW5kXG5cbiAgICBpZiBQcm9taXNlID09PSB2YWx1ZVxuICAgICAgcmV0dXJuICh2YWx1ZSA8PCBAcHJldikgXiBzZWxmXG4gICAgZW5kXG5cbiAgICBiZWdpblxuICAgICAgYmxvY2sgPSBAYWN0aW9uWzpmYWlsdXJlXSB8fCBAYWN0aW9uWzphbHdheXNdXG4gICAgICBpZiBibG9ja1xuICAgICAgICB2YWx1ZSA9IGJsb2NrLmNhbGwodmFsdWUpXG4gICAgICBlbmRcblxuICAgICAgaWYgQGFjdGlvbi5rZXk/KDphbHdheXMpXG4gICAgICAgIHJlc29sdmUhKHZhbHVlKVxuICAgICAgZWxzZVxuICAgICAgICByZWplY3QhKHZhbHVlKVxuICAgICAgZW5kXG4gICAgcmVzY3VlIEV4Y2VwdGlvbiA9PiBlXG4gICAgICBleGNlcHRpb24hKGUpXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZWplY3QhKHZhbHVlKVxuICAgIEByZWFsaXplZCA9IDpyZWplY3RcbiAgICBAZXJyb3IgICAgPSB2YWx1ZVxuXG4gICAgaWYgQG5leHQuYW55P1xuICAgICAgQG5leHQuZWFjaCB7IHxwfCBwLnJlamVjdCh2YWx1ZSkgfVxuICAgIGVsc2VcbiAgICAgIEBkZWxheWVkID0gW3ZhbHVlXVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZXhjZXB0aW9uIShlcnJvcilcbiAgICBAZXhjZXB0aW9uID0gdHJ1ZVxuXG4gICAgcmVqZWN0IShlcnJvcilcbiAgZW5kXG5cbiAgZGVmIHRoZW4oJmJsb2NrKVxuICAgIHNlbGYgXiBQcm9taXNlLm5ldyhzdWNjZXNzOiBibG9jaylcbiAgZW5kXG5cbiAgZGVmIHRoZW4hKCZibG9jaylcbiAgICB0aGVyZV9jYW5fYmVfb25seV9vbmUhXG4gICAgc2VsZi50aGVuKCZibG9jaylcbiAgZW5kXG5cbiAgYWxpYXMgZG8gdGhlblxuICBhbGlhcyBkbyEgdGhlbiFcblxuICBkZWYgZmFpbCgmYmxvY2spXG4gICAgc2VsZiBeIFByb21pc2UubmV3KGZhaWx1cmU6IGJsb2NrKVxuICBlbmRcblxuICBkZWYgZmFpbCEoJmJsb2NrKVxuICAgIHRoZXJlX2Nhbl9iZV9vbmx5X29uZSFcbiAgICBmYWlsKCZibG9jaylcbiAgZW5kXG5cbiAgYWxpYXMgcmVzY3VlIGZhaWxcbiAgYWxpYXMgY2F0Y2ggZmFpbFxuICBhbGlhcyByZXNjdWUhIGZhaWwhXG4gIGFsaWFzIGNhdGNoISBmYWlsIVxuXG4gIGRlZiBhbHdheXMoJmJsb2NrKVxuICAgIHNlbGYgXiBQcm9taXNlLm5ldyhhbHdheXM6IGJsb2NrKVxuICBlbmRcblxuICBkZWYgYWx3YXlzISgmYmxvY2spXG4gICAgdGhlcmVfY2FuX2JlX29ubHlfb25lIVxuICAgIGFsd2F5cygmYmxvY2spXG4gIGVuZFxuXG4gIGFsaWFzIGZpbmFsbHkgYWx3YXlzXG4gIGFsaWFzIGVuc3VyZSBhbHdheXNcbiAgYWxpYXMgZmluYWxseSEgYWx3YXlzIVxuICBhbGlhcyBlbnN1cmUhIGFsd2F5cyFcblxuICBkZWYgdHJhY2UoZGVwdGggPSBuaWwsICZibG9jaylcbiAgICBzZWxmIF4gVHJhY2UubmV3KGRlcHRoLCBibG9jaylcbiAgZW5kXG5cbiAgZGVmIHRyYWNlISgqYXJncywgJmJsb2NrKVxuICAgIHRoZXJlX2Nhbl9iZV9vbmx5X29uZSFcbiAgICB0cmFjZSgqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgdGhlcmVfY2FuX2JlX29ubHlfb25lIVxuICAgIGlmIEBuZXh0LmFueT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdhIHByb21pc2UgaGFzIGFscmVhZHkgYmVlbiBjaGFpbmVkJ1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIHJlc3VsdCA9IFwiIzwje3NlbGYuY2xhc3N9KCN7b2JqZWN0X2lkfSlcIlxuXG4gICAgaWYgQG5leHQuYW55P1xuICAgICAgcmVzdWx0ICs9IFwiID4+ICN7QG5leHQuaW5zcGVjdH1cIlxuICAgIGVuZFxuXG4gICAgcmVzdWx0ICs9IGlmIHJlYWxpemVkP1xuICAgICAgICAgICAgICAgIFwiOiAjeyhAdmFsdWUgfHwgQGVycm9yKS5pbnNwZWN0fT5cIlxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgJz4nXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGNsYXNzIFRyYWNlIDwgc2VsZlxuICAgIGRlZiBzZWxmLml0KHByb21pc2UpXG4gICAgICBjdXJyZW50ID0gW11cblxuICAgICAgaWYgcHJvbWlzZS5hY3Q/IHx8IHByb21pc2UucHJldi5uaWw/XG4gICAgICAgIGN1cnJlbnQucHVzaChwcm9taXNlLnZhbHVlKVxuICAgICAgZW5kXG5cbiAgICAgIHByZXYgPSBwcm9taXNlLnByZXZcbiAgICAgIGlmIHByZXZcbiAgICAgICAgY3VycmVudC5jb25jYXQoaXQocHJldikpXG4gICAgICBlbHNlXG4gICAgICAgIGN1cnJlbnRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGluaXRpYWxpemUoZGVwdGgsIGJsb2NrKVxuICAgICAgQGRlcHRoID0gZGVwdGhcblxuICAgICAgc3VwZXIgc3VjY2VzczogcHJvYyB7XG4gICAgICAgIHRyYWNlID0gVHJhY2UuaXQoc2VsZikucmV2ZXJzZVxuICAgICAgICB0cmFjZS5wb3BcblxuICAgICAgICBpZiBkZXB0aCAmJiBkZXB0aCA8PSB0cmFjZS5sZW5ndGhcbiAgICAgICAgICB0cmFjZS5zaGlmdCh0cmFjZS5sZW5ndGggLSBkZXB0aClcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYmxvY2suY2FsbCgqdHJhY2UpXG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGNsYXNzIFdoZW4gPCBzZWxmXG4gICAgZGVmIGluaXRpYWxpemUocHJvbWlzZXMgPSBbXSlcbiAgICAgIHN1cGVyKClcblxuICAgICAgQHdhaXQgPSBbXVxuXG4gICAgICBwcm9taXNlcy5lYWNoIGRvIHxwcm9taXNlfFxuICAgICAgICB3YWl0IHByb21pc2VcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGVhY2goJmJsb2NrKVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgICAgc2VsZi50aGVuIGRvIHx2YWx1ZXN8XG4gICAgICAgIHZhbHVlcy5lYWNoKCZibG9jaylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGNvbGxlY3QoJmJsb2NrKVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgICAgc2VsZi50aGVuIGRvIHx2YWx1ZXN8XG4gICAgICAgIFdoZW4ubmV3KHZhbHVlcy5tYXAoJmJsb2NrKSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGluamVjdCgqYXJncywgJmJsb2NrKVxuICAgICAgc2VsZi50aGVuIGRvIHx2YWx1ZXN8XG4gICAgICAgIHZhbHVlcy5yZWR1Y2UoKmFyZ3MsICZibG9jaylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYWxpYXMgbWFwIGNvbGxlY3RcblxuICAgIGFsaWFzIHJlZHVjZSBpbmplY3RcblxuICAgIGRlZiB3YWl0KHByb21pc2UpXG4gICAgICB1bmxlc3MgUHJvbWlzZSA9PT0gcHJvbWlzZVxuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS52YWx1ZShwcm9taXNlKVxuICAgICAgZW5kXG5cbiAgICAgIGlmIHByb21pc2UuYWN0P1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuXG4gICAgICBlbmRcblxuICAgICAgQHdhaXQgPDwgcHJvbWlzZVxuXG4gICAgICBwcm9taXNlLmFsd2F5cyBkb1xuICAgICAgICB0cnkgaWYgQG5leHQuYW55P1xuICAgICAgZW5kXG5cbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGFsaWFzIGFuZCB3YWl0XG5cbiAgICBkZWYgPj4oKilcbiAgICAgIHN1cGVyLnRhcCBkb1xuICAgICAgICB0cnlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIHRyeVxuICAgICAgaWYgQHdhaXQuYWxsPygmOnJlYWxpemVkPylcbiAgICAgICAgcHJvbWlzZSA9IEB3YWl0LmZpbmQoJjpyZWplY3RlZD8pXG4gICAgICAgIGlmIHByb21pc2VcbiAgICAgICAgICByZWplY3QocHJvbWlzZS5lcnJvcilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJlc29sdmUoQHdhaXQubWFwKCY6dmFsdWUpKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwidmFsdWUiLCJzZWxmIiwibmV3IiwicmVzb2x2ZSIsImVycm9yIiwicmVqZWN0Iiwid2hlbiIsInByb21pc2VzIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQGFjdGlvbiIsImFjdGlvbiIsIkByZWFsaXplZCIsIkBleGNlcHRpb24iLCJAdmFsdWUiLCJAZXJyb3IiLCJAZGVsYXllZCIsIkBwcmV2IiwiQG5leHQiLCI9PT0iLCJhY3Q/IiwiJHJldF9vcl8xIiwia2V5PyIsImtleXMiLCJleGNlcHRpb24/IiwicmVhbGl6ZWQ/IiwiIT0iLCJyZXNvbHZlZD8iLCI9PSIsInJlamVjdGVkPyIsIl4iLCJwcm9taXNlIiwiPDwiLCI+PiIsIltdIiwiMCIsIiRyZXRfb3JfMiIsIiEiLCJpbmNsdWRlPyIsInJhaXNlIiwiYmxvY2siLCIkcmV0X29yXzMiLCJjYWxsIiwicmVzb2x2ZSEiLCJlIiwiZXhjZXB0aW9uISIsImFueT8iLCJlYWNoIiwicCIsIiRyZXRfb3JfNCIsInJlamVjdCEiLCJ0aGVuIiwidGhlbiEiLCJ0aGVyZV9jYW5fYmVfb25seV9vbmUhIiwiZmFpbCIsImZhaWwhIiwiYWx3YXlzIiwiYWx3YXlzISIsInRyYWNlIiwiZGVwdGgiLCJ0cmFjZSEiLCJhcmdzIiwiaW5zcGVjdCIsInJlc3VsdCIsIm9iamVjdF9pZCIsIisiLCIkcmV0X29yXzUiLCJpdCIsImN1cnJlbnQiLCIkcmV0X29yXzYiLCJwcmV2IiwibmlsPyIsInB1c2giLCJjb25jYXQiLCJAZGVwdGgiLCJwcm9jIiwicmV2ZXJzZSIsInBvcCIsIiRyZXRfb3JfNyIsIjw9IiwibGVuZ3RoIiwic2hpZnQiLCItIiwiQHdhaXQiLCJ3YWl0IiwidmFsdWVzIiwiY29sbGVjdCIsIm1hcCIsImluamVjdCIsInJlZHVjZSIsInRyeSIsInRhcCIsImFsbD8iLCJmaW5kIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztFQW1HQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsSUFBQUMsVUFBSUMsSUFBSkQsWUFBQUEsbUJBQUFBLGlCQUFlLEtBQWZBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLFdBQUFFLEtBQUFBLENBQUFBLENBQUFDLFNBQUFBLENBQVlILEtBQVpHO0FBREZILElBQUFBLENBQUFBLDhC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O0FBQUFBLFFBQUFBO0FBQUFBLFFBQUFBO0FBQUFBLFFBQUFBO0FBQUFBO0FBN2FKO0FBQUEsUUFBQSw0REFBQTtBQUFBLFFBQUE7QUFBQSxRQThhTSxPQUFBMEQsTUFBQSxXQUFBLEVBQUEsb0VBQUEsTUFBQSxRQUFBLE9BQUEsQ0FBQUEsT0FBQUEsRUFBQUEsRUFBQUEsRUE5YU4saUJBQUEsRUFBQTs7QUFBQSxRQSthUSxXQUFBRCxLQUFBQSxDQUFBQSxDQS9hUixtQkFBQSxrQkFBQSxNQThhTUMsQ0E5YU47QUE2YUkxRCxNQUFBQSxDQUFBQSw4QkFBQUEsQ0F4REE7QUFBQSxNQThEQSxPQUFBeUQsQ0FBQUEsdUJBQUFBLGVBQUFBLFNBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLElBQUEsUUFBR0UsTUFBQVQsU0FBQVMsUUFBQUEsRUFBQUEsRUFBQUEsRUFBWSxzQkFBWkEsQ0FBSCxDQUFBO0FBQUE7QUFDRSxVQUFBN0QsVUFBVThELE1BQUFWLFNBQUFVLFFBQUFBLEVBQUFBLEVBQUFBLEVBQVksc0JBQVpBLENBQVY7QUFBQSxVQUNBLElBQUEsUUFBRzlELE9BQUgsQ0FBQTtBQUFBLFlBQ0UsV0FBQTFCLFFBQUFBLENBQU8wQixPQUFBM0IsT0FBQUEsQ0FBQUEsQ0FBUEM7QUFERixVQUFBO0FBQUEsWUFHRSxXQUFBRixTQUFBQSxDQUFRb0YsTUFBQUosU0FBQUksT0FBQUEsRUFBQUEsRUFBQUEsRUFBVyxrQkFBWEEsQ0FBUnBGO0FBSEYsVUFBQSxDQURBO0FBREYsUUFBQTtBQUFBO0FBQUEsUUFBQTtBQURGdUYsTUFBQUEsQ0FBQUEsMEJBQUFBLENBQUFBLGVBOURBO0FBREYzRixJQUFBQSxHQUFBQSxXQUFBQSxFQUFhRSxJQUFiRixXQS9RQTtBQURGQSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMyMjM4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9zZXQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBQb3J0aW9ucyBDb3B5cmlnaHQgKGMpIDIwMDItMjAxMyBBa2lub3JpIE1VU0hBIDxrbnVAaURhZW1vbnMub3JnPlxuY2xhc3MgU2V0XG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gIGRlZiBzZWxmLltdKCphcnkpXG4gICAgbmV3KGFyeSlcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoZW51bSA9IG5pbCwgJmJsb2NrKVxuICAgIEBoYXNoID0ge31cblxuICAgIHJldHVybiBpZiBlbnVtLm5pbD9cbiAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndmFsdWUgbXVzdCBiZSBlbnVtZXJhYmxlJyB1bmxlc3MgRW51bWVyYWJsZSA9PT0gZW51bVxuXG4gICAgaWYgYmxvY2tcbiAgICAgIGVudW0uZWFjaCB7IHxpdGVtfCBhZGQgeWllbGQoaXRlbSkgfVxuICAgIGVsc2VcbiAgICAgIG1lcmdlKGVudW0pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICByZXN1bHQgPSBzZWxmLmNsYXNzLm5ld1xuICAgIHJlc3VsdC5tZXJnZShzZWxmKVxuICBlbmRcblxuICBkZWYgLShlbnVtKVxuICAgIHVubGVzcyBlbnVtLnJlc3BvbmRfdG8/IDplYWNoXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndmFsdWUgbXVzdCBiZSBlbnVtZXJhYmxlJ1xuICAgIGVuZFxuXG4gICAgZHVwLnN1YnRyYWN0KGVudW0pXG4gIGVuZFxuICBhbGlhcyBkaWZmZXJlbmNlIC1cblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzxTZXQ6IHsje3RvX2Euam9pbignLCcpfX0+XCJcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGlmIGVxdWFsPyhvdGhlcilcbiAgICAgIHRydWVcbiAgICBlbHNpZiBvdGhlci5pbnN0YW5jZV9vZj8oc2VsZi5jbGFzcylcbiAgICAgIEBoYXNoID09IG90aGVyLmluc3RhbmNlX3ZhcmlhYmxlX2dldCg6QGhhc2gpXG4gICAgZWxzaWYgb3RoZXIuaXNfYT8oU2V0KSAmJiBzaXplID09IG90aGVyLnNpemVcbiAgICAgIG90aGVyLmFsbD8geyB8b3wgQGhhc2guaW5jbHVkZT8obykgfVxuICAgIGVsc2VcbiAgICAgIGZhbHNlXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhZGQobylcbiAgICBAaGFzaFtvXSA9IHRydWVcbiAgICBzZWxmXG4gIGVuZFxuICBhbGlhcyA8PCBhZGRcblxuICBkZWYgY2xhc3NpZnkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y2xhc3NpZnkpIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHJlc3VsdCA9IEhhc2gubmV3IHsgfGgsIGt8IGhba10gPSBzZWxmLmNsYXNzLm5ldyB9XG5cbiAgICBlYWNoIHsgfGl0ZW18IHJlc3VsdFt5aWVsZChpdGVtKV0uYWRkIGl0ZW0gfVxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb2xsZWN0ISkgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgIHJlc3VsdCA9IHNlbGYuY2xhc3MubmV3XG4gICAgZWFjaCB7IHxpdGVtfCByZXN1bHQgPDwgeWllbGQoaXRlbSkgfVxuICAgIHJlcGxhY2UgcmVzdWx0XG4gIGVuZFxuICBhbGlhcyBtYXAhIGNvbGxlY3QhXG5cbiAgZGVmIGRlbGV0ZShvKVxuICAgIEBoYXNoLmRlbGV0ZShvKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZT8obylcbiAgICBpZiBpbmNsdWRlPyhvKVxuICAgICAgZGVsZXRlKG8pXG4gICAgICBzZWxmXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfaWZcbiAgICByZXR1cm4gZW51bV9mb3IoOmRlbGV0ZV9pZikgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICMgQGhhc2guZGVsZXRlX2lmIHNob3VsZCBiZSBmYXN0ZXIsIGJ1dCB1c2luZyBpdCBicmVha3MgdGhlIG9yZGVyXG4gICAgIyBvZiBlbnVtZXJhdGlvbiBpbiBzdWJjbGFzc2VzLlxuICAgIHNlbGVjdCB7IHxvfCB5aWVsZCBvIH0uZWFjaCB7IHxvfCBAaGFzaC5kZWxldGUobykgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGtlZXBfaWZcbiAgICByZXR1cm4gZW51bV9mb3IoOmtlZXBfaWYpIHVubGVzcyBibG9ja19naXZlbj9cbiAgICByZWplY3QgeyB8b3wgeWllbGQgbyB9LmVhY2ggeyB8b3wgQGhhc2guZGVsZXRlKG8pIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZWplY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCEpIHVubGVzcyBibG9ja19naXZlbj9cbiAgICBiZWZvcmUgPSBzaXplXG4gICAgZGVsZXRlX2lmKCZibG9jaylcbiAgICBzaXplID09IGJlZm9yZSA/IG5pbCA6IHNlbGZcbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0ISkgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgIGJlZm9yZSA9IHNpemVcbiAgICBrZWVwX2lmKCZibG9jaylcbiAgICBzaXplID09IGJlZm9yZSA/IG5pbCA6IHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgZmlsdGVyISBzZWxlY3QhXG5cbiAgZGVmIGFkZD8obylcbiAgICBpZiBpbmNsdWRlPyhvKVxuICAgICAgbmlsXG4gICAgZWxzZVxuICAgICAgYWRkKG8pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHVubGVzcyBibG9ja19naXZlbj9cbiAgICBAaGFzaC5lYWNoX2tleSgmYmxvY2spXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgQGhhc2guZW1wdHk/XG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIEBoYXNoLmVxbD8ob3RoZXIuaW5zdGFuY2VfZXZhbCB7IEBoYXNoIH0pXG4gIGVuZFxuXG4gIGRlZiBjbGVhclxuICAgIEBoYXNoLmNsZWFyXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8obylcbiAgICBAaGFzaC5pbmNsdWRlPyhvKVxuICBlbmRcbiAgYWxpYXMgbWVtYmVyPyBpbmNsdWRlP1xuXG4gIGRlZiBtZXJnZShlbnVtKVxuICAgIGVudW0uZWFjaCB7IHxpdGVtfCBhZGQgaXRlbSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVwbGFjZShlbnVtKVxuICAgIGNsZWFyXG4gICAgbWVyZ2UoZW51bSlcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHNpemVcbiAgICBAaGFzaC5zaXplXG4gIGVuZFxuICBhbGlhcyBsZW5ndGggc2l6ZVxuXG4gIGRlZiBzdWJ0cmFjdChlbnVtKVxuICAgIGVudW0uZWFjaCB7IHxpdGVtfCBkZWxldGUgaXRlbSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgfChlbnVtKVxuICAgIHVubGVzcyBlbnVtLnJlc3BvbmRfdG8/IDplYWNoXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndmFsdWUgbXVzdCBiZSBlbnVtZXJhYmxlJ1xuICAgIGVuZFxuICAgIGR1cC5tZXJnZShlbnVtKVxuICBlbmRcblxuICBkZWYgc3VwZXJzZXQ/KHNldClcbiAgICBzZXQuaXNfYT8oU2V0KSB8fCByYWlzZShBcmd1bWVudEVycm9yLCAndmFsdWUgbXVzdCBiZSBhIHNldCcpXG4gICAgcmV0dXJuIGZhbHNlIGlmIHNpemUgPCBzZXQuc2l6ZVxuICAgIHNldC5hbGw/IHsgfG98IGluY2x1ZGU/KG8pIH1cbiAgZW5kXG5cbiAgYWxpYXMgPj0gc3VwZXJzZXQ/XG5cbiAgZGVmIHByb3Blcl9zdXBlcnNldD8oc2V0KVxuICAgIHNldC5pc19hPyhTZXQpIHx8IHJhaXNlKEFyZ3VtZW50RXJyb3IsICd2YWx1ZSBtdXN0IGJlIGEgc2V0JylcbiAgICByZXR1cm4gZmFsc2UgaWYgc2l6ZSA8PSBzZXQuc2l6ZVxuICAgIHNldC5hbGw/IHsgfG98IGluY2x1ZGU/KG8pIH1cbiAgZW5kXG5cbiAgYWxpYXMgPiBwcm9wZXJfc3VwZXJzZXQ/XG5cbiAgZGVmIHN1YnNldD8oc2V0KVxuICAgIHNldC5pc19hPyhTZXQpIHx8IHJhaXNlKEFyZ3VtZW50RXJyb3IsICd2YWx1ZSBtdXN0IGJlIGEgc2V0JylcbiAgICByZXR1cm4gZmFsc2UgaWYgc2V0LnNpemUgPCBzaXplXG4gICAgYWxsPyB7IHxvfCBzZXQuaW5jbHVkZT8obykgfVxuICBlbmRcblxuICBhbGlhcyA8PSBzdWJzZXQ/XG5cbiAgZGVmIHByb3Blcl9zdWJzZXQ/KHNldClcbiAgICBzZXQuaXNfYT8oU2V0KSB8fCByYWlzZShBcmd1bWVudEVycm9yLCAndmFsdWUgbXVzdCBiZSBhIHNldCcpXG4gICAgcmV0dXJuIGZhbHNlIGlmIHNldC5zaXplIDw9IHNpemVcbiAgICBhbGw/IHsgfG98IHNldC5pbmNsdWRlPyhvKSB9XG4gIGVuZFxuXG4gIGFsaWFzIDwgcHJvcGVyX3N1YnNldD9cblxuICBkZWYgaW50ZXJzZWN0PyhzZXQpXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3ZhbHVlIG11c3QgYmUgYSBzZXQnIHVubGVzcyBzZXQuaXNfYT8oU2V0KVxuXG4gICAgaWYgc2l6ZSA8IHNldC5zaXplXG4gICAgICBhbnk/IHsgfG98IHNldC5pbmNsdWRlPyhvKSB9XG4gICAgZWxzZVxuICAgICAgc2V0LmFueT8geyB8b3wgaW5jbHVkZT8obykgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZGlzam9pbnQ/KHNldClcbiAgICAhaW50ZXJzZWN0PyhzZXQpXG4gIGVuZFxuXG4gIGFsaWFzICsgfFxuICBhbGlhcyB1bmlvbiB8XG5cbiAgZGVmIHRvX2FcbiAgICBAaGFzaC5rZXlzXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBFbnVtZXJhYmxlXG4gIGRlZiB0b19zZXQoa2xhc3MgPSBTZXQsICphcmdzLCAmYmxvY2spXG4gICAga2xhc3MubmV3KHNlbGYsICphcmdzLCAmYmxvY2spXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJpbmNsdWRlIiwiW10iLCJzZWxmIiwibmV3IiwiYXJ5IiwiaW5pdGlhbGl6ZSIsIkBoYXNoIiwiZW51bSQiLCJuaWw/IiwiPT09IiwicmFpc2UiLCJibG9jayIsImVhY2giLCJhZGQiLCJpdGVtIiwibWVyZ2UiLCJkdXAiLCJyZXN1bHQiLCItIiwicmVzcG9uZF90bz8iLCJzdWJ0cmFjdCIsImluc3BlY3QiLCJ0b19hIiwiam9pbiIsIj09IiwiZXF1YWw/Iiwib3RoZXIiLCJpbnN0YW5jZV9vZj8iLCJpbnN0YW5jZV92YXJpYWJsZV9nZXQiLCIkcmV0X29yXzEiLCJpc19hPyIsInNpemUiLCJhbGw/IiwiaW5jbHVkZT8iLCJvIiwiJHdyaXRlciIsIltdPSIsIjEiLCJjbGFzc2lmeSIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiayIsImgiLCJjb2xsZWN0ISIsIjw8IiwicmVwbGFjZSIsImRlbGV0ZSIsImRlbGV0ZT8iLCJkZWxldGVfaWYiLCJzZWxlY3QiLCJrZWVwX2lmIiwicmVqZWN0IiwicmVqZWN0ISIsImJlZm9yZSIsInNlbGVjdCEiLCJhZGQ/IiwiZWFjaF9rZXkiLCJlbXB0eT8iLCJlcWw/IiwiaW5zdGFuY2VfZXZhbCIsImNsZWFyIiwifCIsInN1cGVyc2V0PyIsIiRyZXRfb3JfMiIsInNldCIsIjwiLCJwcm9wZXJfc3VwZXJzZXQ/IiwiJHJldF9vcl8zIiwiPD0iLCJzdWJzZXQ/IiwiJHJldF9vcl80IiwicHJvcGVyX3N1YnNldD8iLCIkcmV0X29yXzUiLCJpbnRlcnNlY3Q/IiwiYW55PyIsImRpc2pvaW50PyIsIiEiLCJrZXlzIiwibW9kdWxlIiwidG9fc2V0Iiwia2xhc3MiLCJhcmdzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFDQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsUUFBQUMsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FBQTtBQUFBLElBRUFDLFVBQUlDLElBQUpELFNBQUFBLFlBQUFBLFNBTEYsRUFL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QTtBQUFBLE1BQUE7QUFBQSxNQUFBLFVBQVEsbUJBQVI7QUFBQSxNQUFBLENBMU9iO0FBQUE7QUEwTzBCLE1BQUEsa0JBMU8xQjtBQUFBLE1BMk9JLE9BQUE1RSxNQUFBNkUsS0FBQTdFLE9BQUFBLEdBQVVELGFBQU0sVUFBQytFLElBQUQsRUFBaEI5RSxFQUF3QlEsZ0JBQXhCUixDQTNPSjtBQTBPRTRFLElBQUFBLENBQUFBLG9DQUFBQSxDQUFBQTtBQURGRCxFQUFBQSxHQUFBQSxXQUFBQSxXQXZPQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMyODE2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi90aW1lLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFRpbWVcbiAgZGVmIHNlbGYucGFyc2Uoc3RyKVxuICAgIGBuZXcgRGF0ZShEYXRlLnBhcnNlKHN0cikpYFxuICBlbmRcblxuICBkZWYgaXNvODYwMVxuICAgIHN0cmZ0aW1lKCclRlQlVCV6JylcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsInBhcnNlIiwic2VsZiIsImlzbzg2MDEiLCJzdHJmdGltZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQUMsVUFBSUMsSUFBSkQsWUFBQUEsZ0JBQUFBLGlCQUFlLEdBQWZBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMseUJBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsMkJBQUFBLENBQUE7QUFBQSxJQUlBLE9BQUFFLENBQUFBLDJCQUFBQSxrQkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLFdBQUFDLFVBQUFBLENBQVMsU0FBVEE7QUFERkQsSUFBQUEsQ0FBQUEsNkJBQUFBLENBQUFBLG1CQUpBO0FBREZILEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MzI4NDAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJkeG9wYWwvcGF0Y2hlcy9yZXF1aXJlX2R4b3BhbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjXG4jIFBhdGNoIHRvIGlnbm9yZSBgcmVxdWlyZSBcImR4b3BhbFwiYFxuI1xuXG4jIFRPRE86IHdoeSB0aGlzIGRvZXMgbm90IHdvcms/XG4jbW9kdWxlIERYT3BhbFxuIyAgbW9kdWxlIFBhdGNoUmVxdWlyZVxuIyAgICBkZWYgcmVxdWlyZSgqYXJncylcbiMgICAgICBpZiBhcmdzID09IFsnZHhvcGFsJ11cbiMgICAgICAgICMgRG8gbm90aGluZ1xuIyAgICAgIGVsc2VcbiMgICAgICAgIHN1cGVyXG4jICAgICAgZW5kXG4jICAgIGVuZFxuIyAgZW5kXG4jXG4jICBLZXJuZWwucHJlcGVuZChQYXRjaFJlcXVpcmUpXG4jZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgYWxpYXMgZHhvcGFsX29yaWdfcmVxdWlyZSByZXF1aXJlXG5lbmRcblxuZGVmIHJlcXVpcmUoKmFyZ3MpXG4gIGlmIGFyZ3MgPT0gWydkeG9wYWwnXVxuICAgICMgRG8gbm90aGluZywgYmVjYXVzZSBEWE9wYWwgaXMgYWxyZWFkeSBsb2FkZWQgYW5kIHlvdSBkb24ndCBuZWVkIHRvIGZpbmQgaXRcbiAgZWxzZVxuICAgIGR4b3BhbF9vcmlnX3JlcXVpcmUoKmFyZ3MpXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwicmVxdWlyZSIsImFyZ3MiLCI9PSIsImR4b3BhbF9vcmlnX3JlcXVpcmUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQW1CQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsT0FBQSxpQkFBTSxxQkFBTixFQUEwQixTQUExQjtBQURGQSxFQUFBQSxHQUFBQSxXQUFBQSxXQUFBO0FBQUEsRUFJQSxPQUFBQyxDQUFBQSwyQkFBQUEsYUFBQUEsbUJBeEJBLEVBd0JBQTtBQUFBQSxJQUFBQTs7QUFBQUE7QUF4QkE7QUFBQSxJQUFBLDREQUFBO0FBQUE7QUF3QlksSUFBQSxrQkF4Qlo7QUFBQSxJQXlCRSxJQUFHQyxJQUFBQyxPQUFBQSxDQUFRLENBQUMsUUFBRCxDQUFSQSxDQUFIO0FBQUE7QUFBQSxJQUFBO0FBQUEsTUFHRSxPQUFBQyxVQUFBQSx1QkFBQUEsRUFBb0IsVUFBQ0YsSUFBRCxDQUFwQkU7QUFIRixJQUFBLENBekJGO0FBd0JBSCxFQUFBQSxDQUFBQSx5QkFBQUEsQ0FBQUEsbUJBSkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMjg2OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vZHhvcGFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ29wYWwnXG5yZXF1aXJlICdjb25zb2xlJzsgZGVmIGNvbnNvbGU7ICRjb25zb2xlOyBlbmRcblxucmVxdWlyZSAnZHhvcGFsL2NvbnN0YW50cy9jb2xvcnMnXG5yZXF1aXJlICdkeG9wYWwvZm9udCdcbnJlcXVpcmUgJ2R4b3BhbC9pbnB1dCdcbnJlcXVpcmUgJ2R4b3BhbC9pbnB1dC9rZXlfY29kZXMnXG5yZXF1aXJlICdkeG9wYWwvaW1hZ2UnXG5yZXF1aXJlICdkeG9wYWwvc291bmQnXG5yZXF1aXJlICdkeG9wYWwvc291bmRfZWZmZWN0J1xucmVxdWlyZSAnZHhvcGFsL3Nwcml0ZSdcbnJlcXVpcmUgJ2R4b3BhbC93aW5kb3cnXG5yZXF1aXJlICdkeG9wYWwvdmVyc2lvbidcbiMgRW5hYmxlIHJ1bnRpbWUgY29tcGlsYXRpb24gb2YgT3BhbCBjb2RlIChzbyB0aGF0IHlvdSBjYW4gbWFrZSBnYW1lc1xuIyB3aXRob3V0IGV2ZW4gaW5zdGFsbCBSdWJ5KVxuIyByZXF1aXJlICdvcGFsLXBhcnNlcidcblxuIyBUaGVzZSBvcGFsIHN0ZGxpYnMgd2lsbCBiZSBlbWJlZGRlZCBpbiBkeG9wYWwuanMuXG5yZXF1aXJlICdzaW5nbGV0b24nXG5yZXF1aXJlICdkZWxlZ2F0ZSdcbnJlcXVpcmUgJ2ZvcndhcmRhYmxlJ1xucmVxdWlyZSAncHAnXG5yZXF1aXJlICdwcm9taXNlJ1xucmVxdWlyZSAnc2V0J1xucmVxdWlyZSAndGltZSdcblxuIyBQYXRjaGVzXG4jIHJlcXVpcmUgJ2R4b3BhbC9wYXRjaGVzL3JlcXVpcmVfcmVtb3RlJ1xucmVxdWlyZSAnZHhvcGFsL3BhdGNoZXMvcmVxdWlyZV9keG9wYWwnXG5cbm1vZHVsZSBEWE9wYWxcbiAgaW5jbHVkZSBEWE9wYWw6OkNvbnN0YW50czo6Q29sb3JzXG4gIGluY2x1ZGUgRFhPcGFsOjpJbnB1dDo6S2V5Q29kZXNcbiAgaW5jbHVkZSBEWE9wYWw6OklucHV0OjpNb3VzZUNvZGVzXG4gIGluY2x1ZGUgRFhPcGFsOjpTb3VuZEVmZmVjdDo6V2F2ZVR5cGVzXG5cbiAgIyBDYWxsIGJsb2NrIGFuZCBkdW1wIGJhY2t0cmFjZSBpZiBhbiBleGNlcHRpb24gaXMgcmFpc2VkLlxuICAjIE5vdGhpbmcgaXMgc2hvd24gaWYgYSB0YWcgd2l0aCBgaWQ9J2R4b3BhbC1lcnJvcnMnYCBkb2VzIG5vdCBleGlzdFxuICBkZWYgc2VsZi5kdW1wX2Vycm9yKCZibG9jaylcbiAgICBibG9jay5jYWxsXG4gIHJlc2N1ZSBFeGNlcHRpb24gPT4gZXhcbiAgICBkaXYgPSBgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2R4b3BhbC1lcnJvcnMnKWBcbiAgICBpZiBgZGl2ICYmICFleC5EWE9wYWxQcmludGVkYFxuICAgICAgJXh7XG4gICAgICAgIGRpdi50ZXh0Q29udGVudCA9IFwiRVJST1I6IFwiICsgI3tleC5jbGFzcy5uYW1lfTtcbiAgICAgICAgdmFyIHVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICAgICAgLy8gTm90ZTogZXguYmFja3RyYWNlIG1heSBiZSBhbiBBcnJheSBvciBhIFN0cmluZ1xuICAgICAgICAje0FycmF5KGV4LmJhY2t0cmFjZSl9LmZvckVhY2goZnVuY3Rpb24obGluZSl7XG4gICAgICAgICAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgICBsaS50ZXh0Q29udGVudCA9IGxpbmU7XG4gICAgICAgICAgdWwuYXBwZW5kQ2hpbGQobGkpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKHVsKTtcbiAgICAgICAgZXguRFhPcGFsUHJpbnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgZW5kXG4gICAgcmFpc2UgZXhcbiAgZW5kXG5cbiAgIyBMaWtlIGBLZXJuZWwucGAsIGJ1dCBwcmludHMgb25seSBsaW1pdGVkIHRpbWVzIGZvciBlYWNoIGBrZXlgXG4gICMgVGhpcyBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZyB5b3VyIGdhbWUgd2l0aG91dCBmbG9vZGluZyB0aGVcbiAgIyBkZXZlbG9wZXIgY29uc29sZS5cbiAgI1xuICAjIEV4YW1wbGU6XG4gICMgICBwXyBwbGF5ZXJfeDogQHBsYXllci54XG4gICMgICBwXyh7cGxheWVyX3g6IEBwbGF5ZXIueH0sIDIwKVxuICBQX0NUID0gSGFzaC5uZXd7fGgsIGt8IGhba10gPSAwfVxuICBkZWYgcF8oaGFzaCwgbj0xMClcbiAgICBrZXkgPSBoYXNoLmtleXMuc29ydC5qb2luXG4gICAgcmV0dXJuIGlmIFBfQ1Rba2V5XSA+PSBuXG4gICAgYGNvbnNvbGUubG9nKCN7aGFzaC5pbnNwZWN0fSlgXG4gICAgUF9DVFtrZXldICs9IDFcbiAgZW5kXG5lbmRcblxuJXh7XG4gIC8vIExpa2UgYGNvbnNvbGUubG9nYCwgYnV0IHByaW50cyBvbmx5IGxpbWl0ZWQgdGltZXMuXG4gIC8vIEV4YW1wbGU6XG4gIC8vICAgT3BhbC5EWE9wYWwucF8oXCJwbGF5ZXJcIiwgcGxheWVyKVxuICAoZnVuY3Rpb24oKXtcbiAgICB2YXIgUF9DVCA9IHt9O1xuICAgIE9wYWwuRFhPcGFsLnBfID0gZnVuY3Rpb24oa2V5LCBvYmosIG4pIHtcbiAgICAgIG4gPSAobiB8fCAxMCk7XG4gICAgICBQX0NUW2tleV0gPSAoUF9DVFtrZXldIHx8IDApO1xuICAgICAgaWYgKFBfQ1Rba2V5XSA8IG4pIHtcbiAgICAgICAgY29uc29sZS5sb2coa2V5LCBvYmopO1xuICAgICAgICBQX0NUW2tleV0gKz0gMTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xufVxuXG4jIGByZXF1aXJlICdkeG9wYWwnYCB3aWxsIGF1dG9tYXRpY2FsbHkgaW1wb3J0IG5hbWVzIGxpa2UgYFdpbmRvd2AgdG8gdGhlXG4jIHRvcGxldmVsIChhcyBgcmVxdWlyZSAnZHhydWJ5J2AgZG9lcylcbmluY2x1ZGUgRFhPcGFsXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNvbnNvbGUiLCIkY29uc29sZSIsIm1vZHVsZSIsImluY2x1ZGUiLCJkdW1wX2Vycm9yIiwic2VsZiIsImJsb2NrIiwiY2FsbCIsImV4IiwiZGl2IiwiY2xhc3MiLCJuYW1lIiwiQXJyYXkiLCJiYWNrdHJhY2UiLCJyYWlzZSIsIm5ldyIsIiR3cml0ZXIiLCJrIiwiMCIsIltdPSIsImgiLCItIiwiMSIsInBfIiwiMTAiLCJrZXkiLCJoYXNoIiwia2V5cyIsInNvcnQiLCJqb2luIiwiPj0iLCJbXSIsIm4iLCJpbnNwZWN0IiwiKyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxNQUFSQSxDQUFBO0FBQUEsTUFDQUEsU0FBQUEsQ0FBUSxTQUFSQSxDQURBO0FBQUE7QUFDbUJDLEVBQUFBLDJCQUFBQSxhQUFBQSxtQkFBQUE7QUFBQUEsSUFBQUE7QUFBQUE7O0FBQUFBLElBQWEsT0FBQUM7QUFBYkQsRUFBQUEsQ0FBQUEsd0JBQUFBLENBRG5CO0FBQUEsTUFHQUQsU0FBQUEsQ0FBUSx5QkFBUkEsQ0FIQTtBQUFBLE1BSUFBLFNBQUFBLENBQVEsYUFBUkEsQ0FKQTtBQUFBLE1BS0FBLFNBQUFBLENBQVEsY0FBUkEsQ0FMQTtBQUFBLE1BTUFBLFNBQUFBLENBQVEsd0JBQVJBLENBTkE7QUFBQSxNQU9BQSxTQUFBQSxDQUFRLGNBQVJBLENBUEE7QUFB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LE1BcUVJQyxNQUFNQyxJQUFBQyxNQUFBQSxDQUFBQSxDQUFBQyxNQUFBQSxDQUFBQSxDQUFBQyxNQUFBQSxDQUFBQSxDQXJFVjtBQUFBLE1Bc0VJLElBQUEsUUFBVUMsT0FBQSxvQkFBQUMsT0FBQUEsQ0FBS04sR0FBTE0sQ0FBQUQsRUFBYUUsQ0FBYkYsQ0FBVixDQUFBO0FBQUEsUUFBQSxVQUFBLENBdEVKO0FBQUEsTUF1RUssWUFBY0osSUFBQU8sU0FBQUEsQ0FBQUEsQ0FBYSxDQXZFaEM7QUFBQTtBQUFBLE1BQUFqQixVQUFBLENBd0VTUyxHQXhFVCxFQUFBUyxTQXdFSSxvQkFBQUgsT0FBQUEsQ0FBS04sR0FBTE0sQ0F4RUpHLEVBd0VpQlosQ0F4RWpCWSxDQUFBLENBQUE7QUFBQSxNQXdFSWYsTUFBQSxvQkFBQUEsT0FBQUEsRUF4RUosVUFBQUgsT0FBQSxDQXdFSUcsQ0F4RUo7QUFBQSxNQUFBLE9BQUFILE9BQUEsQ0FBQUssVUFBQUwsT0FBQSxDQUFBLFFBQUEsQ0FBQUssRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBQUE7QUFvRUVFLElBQUFBLENBQUFBLDJCQUFBQSxDQUFBQSxjQXBDQTtBQURGckIsRUFBQUEsR0FBQUEsV0FBQUEsV0E5QkE7QUFBQTtBQTRFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekZBO0FBQUEsRUE4RkEsV0FBQUMsU0FBQUEsQ0FBUSxzQkFBUkEsQ0E5RkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMzAwNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImR4b3BhbF9leHQvc291bmQyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgZm9ya2VkIGZyb20gRFhPcGFsIHYxLjUuMlxuIyBodHRwczovL2dpdGh1Yi5jb20veWhhcmEvZHhvcGFsL3RyZWUvdjEuNS4yXG5cbnJlcXVpcmUgJ2R4b3BhbC9yZW1vdGVfcmVzb3VyY2UnXG5cbm1vZHVsZSBEWE9wYWxcbiAgY2xhc3MgU291bmQyIDwgUmVtb3RlUmVzb3VyY2VcbiAgICBSZW1vdGVSZXNvdXJjZS5hZGRfY2xhc3MoU291bmQyKVxuXG4gICAgIyAwLi4yNTVcbiAgICBAQG1hc3Rlcl92b2x1bWUgPSAyMzBcblxuICAgICMgUmV0dXJuIEF1ZGlvQ29udGV4dFxuICAgIGRlZiBzZWxmLmF1ZGlvX2NvbnRleHRcbiAgICAgIEBAYXVkaW9fY29udGV4dCB8fD0gJXh7XG4gICAgICAgIG5ldyAod2luZG93LkF1ZGlvQ29udGV4dHx8d2luZG93LndlYmtpdEF1ZGlvQ29udGV4dClcbiAgICAgIH1cbiAgICBlbmRcblxuICAgICMgTG9hZCByZW1vdGUgc291bmQgKGNhbGxlZCB2aWEgV2luZG93LmxvYWRfcmVzb3VyY2VzKVxuICAgIGRlZiBzZWxmLl9sb2FkKHBhdGhfb3JfdXJsKVxuICAgICAgc25kID0gbmV3KHBhdGhfb3JfdXJsKVxuICAgICAgc25kX3Byb21pc2UgPSAleHtcbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsICN7cGF0aF9vcl91cmx9LCB0cnVlKTtcbiAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhdWRpb0RhdGEgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSAje1NvdW5kMi5hdWRpb19jb250ZXh0fTtcbiAgICAgICAgICAgIGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKGF1ZGlvRGF0YSwgZnVuY3Rpb24oZGVjb2RlZCkge1xuICAgICAgICAgICAgICBzbmRbJyRkZWNvZGVkPSddKGRlY29kZWQpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbmQsIHNuZF9wcm9taXNlXG4gICAgZW5kXG5cbiAgICBkZWYgaW5pdGlhbGl6ZShwYXRoX29yX3VybClcbiAgICAgIEBwYXRoX29yX3VybCA9IHBhdGhfb3JfdXJsICAjIFVzZWQgaW4gZXJyb3IgbWVzc2FnZVxuICAgICAgQHZvbHVtZSA9IDIzMFxuICAgIGVuZFxuICAgIGF0dHJfYWNjZXNzb3IgOmRlY29kZWRcblxuICAgIGRlZiBzZXRfdm9sdW1lKHZvbHVtZSwgdGltZT0wKVxuICAgICAgIyBUT0RPIFN1cHBvcnQgdGltZVxuICAgICAgQHZvbHVtZSA9IHZvbHVtZVxuICAgIGVuZFxuXG4gICAgZGVmIHNlbGYubWFzdGVyX3ZvbHVtZT0odm9sdW1lKVxuICAgICAgQEBtYXN0ZXJfdm9sdW1lID0gdm9sdW1lXG4gICAgZW5kXG5cbiAgICAjIGRlZiBnYWluX3ZhbHVlXG4gICAgIyAgIChAdm9sdW1lLnRvX2YgLyAyNTUuMCkgKiogMTBcbiAgICAjIGVuZFxuXG4gICAgZGVmIGdhaW5fdmFsdWVcbiAgICAgIHZfcmF0aW8gPSBAdm9sdW1lIC8gMjU1LjBcbiAgICAgIG12X3JhdGlvID0gQEBtYXN0ZXJfdm9sdW1lIC8gMjU1LjBcbiAgICAgICh2X3JhdGlvICogbXZfcmF0aW8pICoqIDEwXG4gICAgZW5kXG5cbiAgICAjIFBsYXkgdGhpcyBzb3VuZCBvbmNlXG4gICAgZGVmIHBsYXlcbiAgICAgIHJhaXNlIFwiU291bmQyICN7cGF0aF9vcl91cmx9IGlzIG5vdCBsb2FkZWQgeWV0XCIgdW5sZXNzIEBkZWNvZGVkXG4gICAgICBzb3VyY2UgPSBuaWxcbiAgICAgICV4e1xuICAgICAgICB2YXIgY29udGV4dCA9ICN7U291bmQyLmF1ZGlvX2NvbnRleHR9O1xuICAgICAgICBzb3VyY2UgPSBjb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgICBzb3VyY2UuYnVmZmVyID0gI3tAZGVjb2RlZH07XG5cbiAgICAgICAgLy8gc291cmNlLmNvbm5lY3QoY29udGV4dC5kZXN0aW5hdGlvbik7XG5cbiAgICAgICAgdmFyIGdhaW4gPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgZ2Fpbi5nYWluLnZhbHVlID0gI3tnYWluX3ZhbHVlfTtcbiAgICAgICAgc291cmNlLmNvbm5lY3QoZ2Fpbik7XG4gICAgICAgIGdhaW4uY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKTtcblxuICAgICAgICBzb3VyY2Uuc3RhcnQoMCk7IFxuICAgICAgfVxuICAgICAgQHNvdXJjZSA9IHNvdXJjZVxuICAgIGVuZFxuXG4gICAgIyBTdG9wIHBsYXlpbmcgdGhpcyBzb3VuZCAoaWYgcGxheWluZylcbiAgICBkZWYgc3RvcFxuICAgICAgcmV0dXJuIHVubGVzcyBAZGVjb2RlZCBcbiAgICAgIHJldHVybiB1bmxlc3MgQHNvdXJjZVxuICAgICAgQHNvdXJjZS5KUy5zdG9wKClcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwibW9kdWxlIiwiY2xhc3MiLCJhZGRfY2xhc3MiLCJAQG1hc3Rlcl92b2x1bWUiLCIyMzAiLCJhdWRpb19jb250ZXh0Iiwic2VsZiIsIkBAYXVkaW9fY29udGV4dCIsIiRyZXRfb3JfMSIsIl9sb2FkIiwic25kIiwibmV3IiwicGF0aF9vcl91cmwiLCJzbmRfcHJvbWlzZSIsImluaXRpYWxpemUiLCJAcGF0aF9vcl91cmwiLCJAdm9sdW1lIiwiYXR0cl9hY2Nlc3NvciIsInNldF92b2x1bWUiLCIwIiwidm9sdW1lIiwibWFzdGVyX3ZvbHVtZT0iLCJnYWluX3ZhbHVlIiwidl9yYXRpbyIsIi8iLCJtdl9yYXRpbyIsIioiLCIqKiIsIjEwIiwicGxheSIsIkBkZWNvZGVkIiwicmFpc2UiLCJzb3VyY2UiLCJAc291cmNlIiwic3RvcCJdLCJt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VixDQUFBLEdBQUEsb0JBQU5tQjtBQUFBLFFBQUEsQ0FBQTtBQUFBLFFBQ0FDLFNBQVMsR0FEVDtBQUFBO0FBR04sc0JBQXdCLHNCQUFBM0IsZUFBQUEsQ0FBQUEsQ0FBcUI7QUFDN0M7QUFDQSx3QkFBMEJ5QixZQUFTOztBQUVuQzs7QUFFQTtBQUNBLDhCQUE0QlIsWUFBQUEsQ0FBQUEsQ0FBVztBQUN2QztBQUNBOztBQUVBO0FBQ0EsTUFmTTtBQUFBLFFBZ0JBLE9BQUFXLENBQUFBLGNBQVVELE1BQVZDLENBaEJBO0FBREZKLE1BQUFBLENBQUFBLDRCQUFBQSxDQTVEQTtBQUFBLE1BaUZBLE9BQUFLLENBQUFBLHdCQUFBQSxpQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUEsSUFBQSxRQUFjSixZQUFkLENBQUE7QUFBQSxRQUFBO0FBQUEsVUFBQTtBQUFBLFFBQUEsQ0FBQTtBQUFBLFFBQ0EsSUFBQSxRQUFjRyxXQUFkLENBQUE7QUFBQSxRQUFBO0FBQUEsVUFBQTtBQUFBLFFBQUEsQ0FEQTtBQUFBLFFBRUEsT0FBQUEsV0FBQSxLQUFBLENBQUEsQ0FGQTtBQURGQyxNQUFBQSxDQUFBQSw0QkFBQUEsQ0FBQUEsZ0JBakZBO0FBREZqQyxJQUFBQSxHQUFBQSxXQUFBQSxFQUFlLDhCQUFmQTtBQURGRCxFQUFBQSxHQUFBQSxXQUFBQSxXQUZBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MzMxNDYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJkeG9wYWxfZXh0L3NvdW5kX2VmZmVjdDIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmb3JrZWQgZnJvbSBEWE9wYWwgdjEuNS4yXG4jIGh0dHBzOi8vZ2l0aHViLmNvbS95aGFyYS9keG9wYWwvdHJlZS92MS41LjJcblxuIyBTb3VuZDIg44KS57aZ5om/44GX44Gm44GE44KL5Lul5aSW44Gv44Kq44Oq44K444OK44Or44Go5ZCM44GYXG5cbm1vZHVsZSBEWE9wYWxcbiAgIyBVc2VyLWdlbmVyYXRlZCBzb3VuZFxuICAjXG4gICMgRXhhbXBsZTpcbiAgIyAgIHYgPSA4MFxuICAjICAgU291bmRFZmZlY3QyLnJlZ2lzdGVyKDpzb3VuZDEsIDQwMDAsIFdBVkVfUkVDVCwgNTAwMCkgZG9cbiAgIyAgICAgdiA9IHYgLSAwLjAzXG4gICMgICAgIFtyYW5kKDMwMCksIHZdXG4gICMgICBlbmRcbiAgI1xuICAjIFRoaXMgd2lsbCBnZW5lcmF0ZSBhIHNvdW5kIHdpdGggV2ViQXVkaW8uXG4gIGNsYXNzIFNvdW5kRWZmZWN0MiA8IFNvdW5kMlxuICAgIFJlbW90ZVJlc291cmNlLmFkZF9jbGFzcyhTb3VuZEVmZmVjdDIpXG5cbiAgICBtb2R1bGUgV2F2ZVR5cGVzXG4gICAgICBXQVZFX1NJTiA9IDpzaW5lXG4gICAgICBXQVZFX1NBVyA9IDpzYXd0b290aFxuICAgICAgV0FWRV9UUkkgPSA6dHJpYW5nbGVcbiAgICAgIFdBVkVfUkVDVCA9IDpzcXVhcmVcbiAgICBlbmRcblxuICAgICMgdGltZSA6IFRvdGFsIG51bWJlciBvZiB0aWNrc1xuICAgICMgICBXaGVuIHJlc29sdXRpb249MTAwMChkZWZhdWx0KSwgYHRpbWVgIGlzIGVxdWl2YWxlbnQgdG8gdGhlIFxuICAgICMgICB0b3RhbCBsZW5ndGggb2YgdGhlIHNvdW5kIGluIG1pbGxpc2Vjb25kcy5cbiAgICAjIHdhdmVfdHlwZSA6IFR5cGUgb2Ygd2F2ZSBmb3JtXG4gICAgIyByZXNvbHV0aW9uIDogTnVtYmVyIG9mIHRpY2tzIHBlciBzZWNvbmRcbiAgICAjIGJsb2NrIDogU2hvdWxkIHJldHVybiBbZnJlcSgwfjQ0MTAwKSwgdm9sdW1lKDB+MjU1KV1cbiAgICBkZWYgc2VsZi5fbG9hZCh0aW1lLCB3YXZlX3R5cGU9V0FWRV9SRUNULCByZXNvbHV0aW9uPTEwMDAsICZibG9jaylcbiAgICAgIHNuZCA9IG5ldyhcIihzb3VuZGVmZmVjdClcIilcbiAgICAgIHNuZF9wcm9taXNlID0gJXh7XG4gICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgICAgdmFyIG5fY2hhbm5lbHMgPSAxO1xuICAgICAgICAgIHZhciBjb250ZXh0ID0gI3tTb3VuZDIuYXVkaW9fY29udGV4dH07XG4gICAgICAgICAgdmFyIG5fdGlja3MgPSAje3RpbWV9O1xuICAgICAgICAgIHZhciB0b3RhbFNlY29uZHMgPSAje3RpbWUgLyByZXNvbHV0aW9ufTtcbiAgICAgICAgICB2YXIgdmFsdWVzUGVyU2Vjb25kID0gY29udGV4dC5zYW1wbGVSYXRlO1xuICAgICAgICAgIHZhciBuX3ZhbHVlcyA9IHRvdGFsU2Vjb25kcyAqIHZhbHVlc1BlclNlY29uZDtcbiAgICAgICAgICB2YXIgbXlBcnJheUJ1ZmZlciA9IGNvbnRleHQuY3JlYXRlQnVmZmVyKG5fY2hhbm5lbHMsIG5fdmFsdWVzLCB2YWx1ZXNQZXJTZWNvbmQpO1xuICAgICAgICAgIHZhciB2YWx1ZXMgPSBteUFycmF5QnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5fdGlja3M7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJldCA9ICN7YmxvY2suY2FsbH07XG4gICAgICAgICAgICB2YXIgZnJlcSA9IHJldFswXSwgdm9sdW1lID0gcmV0WzFdO1xuICAgICAgICAgICAgaWYgKGZyZXEgPCAwKSBmcmVxID0gMDtcbiAgICAgICAgICAgIGlmIChmcmVxID4gNDQxMDApIGZyZXEgPSA0NDEwMDtcbiAgICAgICAgICAgIGlmICh2b2x1bWUgPCAwKSB2b2x1bWUgPSAwO1xuICAgICAgICAgICAgaWYgKHZvbHVtZSA+IDI1NSkgdm9sdW1lID0gMjU1O1xuICAgICAgICAgICAgdmFyIHZvbCA9IHZvbHVtZSAvIDI1NTsgICAvLyAwLjB+MS4wXG5cbiAgICAgICAgICAgIHZhciBwZXJpb2QgPSB2YWx1ZXNQZXJTZWNvbmQgKiAxIC8gZnJlcTtcbiAgICAgICAgICAgIGZvciAoOyBuIDwgKChpKzEpIC8gbl90aWNrcyAqIG5fdmFsdWVzKTsgbisrKSB7XG4gICAgICAgICAgICAgIHZhciBwaGFzZSA9IChuICUgcGVyaW9kKSAvIHBlcmlvZDsgLy8gMC4wfjEuMFxuICAgICAgICAgICAgICB2YXIgdmFsdWU7IC8vIC0xLjB+MS4wXG4gICAgICAgICAgICAgIHN3aXRjaCgje3dhdmVfdHlwZX0pIHtcbiAgICAgICAgICAgICAgY2FzZSBcInNpbmVcIjpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguc2luKDIgKiBNYXRoLlBJICogcGhhc2UpICogMiAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzYXd0b290aFwiOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGhhc2UgKiAyIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInRyaWFuZ2xlXCI6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwaGFzZSA8IDAuMjUgPyAgMCtwaGFzZSo0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBoYXNlIDwgMC41ICA/ICAxLShwaGFzZS0wLjI1KSo0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBoYXNlIDwgMC43NSA/ICAwLShwaGFzZS0wLjUpKjQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTErKHBoYXNlLTAuNzUpKjQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzcXVhcmVcIjpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IChwaGFzZSA8IDAuNSA/IDEgOiAtMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgI3tyYWlzZSBcInVua25vd24gd2F2ZV90eXBlOiBcIiArIHdhdmVfdHlwZS5pbnNwZWN0fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YWx1ZXNbbl0gPSB2YWx1ZSAqIHZvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc25kWyckZGVjb2RlZD0nXShteUFycmF5QnVmZmVyKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNuZCwgc25kX3Byb21pc2VcbiAgICBlbmRcblxuICAgIGRlZiBhZGQod2F2ZV90eXBlPVdBVkVfUkVDVCwgcmVzb2x1dGlvbj0xMDAwKVxuICAgICAgVE9ET1xuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiYWRkX2NsYXNzIiwiX2xvYWQiLCJzZWxmIiwiMTAwMCIsInNuZCIsIm5ldyIsInNuZF9wcm9taXNlIiwiYXVkaW9fY29udGV4dCIsInRpbWUiLCIvIiwicmVzb2x1dGlvbiIsImJsb2NrIiwiY2FsbCIsIndhdmVfdHlwZSIsInJhaXNlIiwiKyIsImluc3BlY3QiLCJhZGQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0VBS0EsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQVdFLE9BQUFDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBLDhCQUFBQyxXQUFBQSxDQUF5Qiw0QkFBekJBLENBQUE7QUFBQSxNQUVBRjtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQ0UsUUFBQSx3Q0FBVyxNQUFYLENBQUE7QUFBQSxRQUNBLHdDQUFXLFVBQVgsQ0FEQTtBQUFBLFFBRUEsd0NBQVcsVUFBWCxDQUZBO0FBQUEsUUFHQSxPQUFBLHlDQUFZLFFBQVosQ0FIQTtBQURGQSxNQUFBQSxHQUFBQSxXQUFBQSxXQUZBO0FBQUEsTUFlQUcsVUFBSUMsSUFBSkQsWUFBQUEsd0JBQUFBLGlCQUFlLElBQUQsRUFBTyxTQUFQLEVBQTRCLFVBQTFDQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFBQUE7QUFBQUE7QUFqQ0o7QUFpQytELFFBQUEsNENBakMvRDtBQUFBO0FBaUN5QixRQUFBO0FBQUEsUUFBQSxjQUFVLHlCQUFWO0FBQUEsUUFBQSxDQWpDekI7QUFBQTtBQWlDOEMsUUFBQTtBQUFBLFFBQUEsZUFBV0UsSUFBWDtBQUFBLFFBQUEsQ0FqQzlDO0FBQUEsUUFrQ01DLFVBQU1DLEtBQUFBLENBQUksZUFBSkEsQ0FsQ1o7QUFBQSxRQW1DTUM7QUFDTjtBQUNBO0FBQ0Esd0JBQTBCLHNCQUFBQyxlQUFBQSxDQUFBQSxDQUFxQjtBQUMvQyx3QkFBMEJDLElBQUs7QUFDL0IsNkJBQStCQyxXQUFBRCxJQUFBQyxFQUFPQyxVQUFQRCxDQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBd0JFLEtBQUFDLE1BQUFBLENBQUFBLENBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXVCQyxTQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQWtCQyxPQUFBQSxDQUFNQyxTQUFBLHFCQUFBQSxFQUF3QkYsU0FBQUcsU0FBQUEsQ0FBQUEsQ0FBeEJELENBQU5ELENBQWdEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFwRkE7QUFBQSxRQXFGTSxRQUFPVixLQUFLRSxZQXJGbEI7QUFpQ0lMLE1BQUFBLENBQUFBLG9DQUFBQSxDQWZBO0FBQUEsTUFzRUEsT0FBQWdCLENBQUFBLHVCQUFBQSxzQkFBQUEsZUFBUSxTQUFELEVBQXNCLFVBQTdCQTtBQUFBQSxRQUFBQTs7QUFBQUE7QUF4Rko7QUF3RlksUUFBQTtBQUFBLFFBQUEsY0FBVSx5QkFBVjtBQUFBLFFBQUEsQ0F4Rlo7QUFBQTtBQXdGaUMsUUFBQTtBQUFBLFFBQUEsZUFBV2QsSUFBWDtBQUFBLFFBQUEsQ0F4RmpDO0FBQUEsUUF5Rk0sT0FBQSxvQkF6Rk47QUF3RkljLE1BQUFBLENBQUFBLGtDQUFBQSxDQUFBQSxlQXRFQTtBQURGbEIsSUFBQUEsR0FBQUEsV0FBQUEsRUFBcUIsc0JBQXJCQTtBQVhGRCxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzMjY2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9iYWxsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEJhbGwgPCBTcHJpdGVcbiAgQ09MT1JTID0gW1xuICAgIFsyNDYsIDI1NSwgMTUzXSxcbiAgICBbMTU5LCAyNTUsIDIzOV0sXG4gICAgWzIxNywgMTY0LCAyNTRdLFxuICAgIFsyNTQsIDE5OCwgMTcwXSxcbiAgICBbMTc1LCAyNTMsIDE4Ml0sXG4gICAgWzE4MCwgMTkzLCAyNTNdLFxuICAgIFsyNTMsIDE4NiwgMjE0XSxcbiAgICBbMjMyLCAyNTMsIDE5MV0sXG4gICAgWzE5NiwgMjQ4LCAyNTNdLFxuICAgIFsyNTUsIDEyNywgMTI3XSxcbiAgXVxuXG4gIGF0dHJfcmVhZGVyIDpsdiAjIGxldmVsXG5cbiAgZGVmIGluaXRpYWxpemUoeCwgeSwgaW1nLCBsdiwgb2JzZXJ2ZXJzKVxuICAgIHN1cGVyKHgsIHksIGltZylcbiAgICBAbHYgPSBsdlxuICAgIEBvYnNlcnZlcnMgPSBvYnNlcnZlcnNcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY3JlYXRlKHgsIHksIHJhZGl1cywgbHYsIGFuZ2xlLCBvYnNlcnZlcnMpXG4gICAgdyA9IHJhZGl1cyAqIDJcblxuICAgIGltZyA9IGNyZWF0ZV9pbWFnZShsdiwgdylcblxuICAgIGJhbGwgPSBCYWxsLm5ldyh4LCB5LCBpbWcsIGx2LCBvYnNlcnZlcnMpXG4gICAgYmFsbC5hbmdsZSA9IGFuZ2xlXG4gICAgYmFsbC5waHlzaWNhbF9ib2R5ID0gWzpyZWN0YW5nbGUsIHcsIHcsIGB7cmVzdGl0dXRpb246IDAuOX1gXVxuICAgIGJhbGxcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY3JlYXRlX2ltYWdlKGx2LCB3LCBvcGFjaXR5ID0gMjU1KVxuICAgIGNvbG9yID0gbHZfdG9fY29sb3IobHYsIG9wYWNpdHkpXG4gICAgaW1nID0gSW1hZ2UubmV3KHcsIHcsIGNvbG9yKVxuICAgIGltZy5ib3goMCwgMCwgdyAtIDEsIHcgLSAxLCBbb3BhY2l0eSwgMCwgMCwgMF0pXG4gICAgaW1nLmRyYXdfZm9udCgyLCAyLCBcIiN7bHZ9XCIsIEZPTlRfQkFMTCwgW29wYWNpdHksIDAsIDAsIDBdKVxuICAgIGltZ1xuICBlbmRcblxuICBkZWYgc2VsZi5sdl90b19jb2xvcihsdiwgb3BhY2l0eSA9IDI1NSlcbiAgICByZ2IgPSBDT0xPUlNbbHYgLSAxXSB8fCBbMjU1LCAyNTUsIDBdXG4gICAgW29wYWNpdHksICpyZ2JdXG4gIGVuZFxuXG4gIGRlZiBoaXQob2ZmZW5jZSlcbiAgICAjIHB1dHMgXCJoaXQgI3tzZWxmfSA8PSAje29mZmVuY2V9XCJcbiAgICBpZiBAbHYgPT0gb2ZmZW5jZS5sdlxuICAgICAgaWYgQGx2IDw9IChHYW1lOjpMVl9NQVggLSAxKVxuICAgICAgICBAb2JzZXJ2ZXJzLmVhY2ggeyB8b2JzZXJ2ZXJ8XG4gICAgICAgICAgb2JzZXJ2ZXIub25faGl0KHNlbGYsIG9mZmVuY2UpXG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiMjQ2IiwiMjU1IiwiMTUzIiwiMTU5IiwiMjM5IiwiMjE3IiwiMTY0IiwiMjU0IiwiMTk4IiwiMTcwIiwiMTc1IiwiMjUzIiwiMTgyIiwiMTgwIiwiMTkzIiwiMTg2IiwiMjE0IiwiMjMyIiwiMTkxIiwiMTk2IiwiMjQ4IiwiMTI3IiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwieCIsInkiLCJpbWciLCJAbHYiLCJsdiIsIkBvYnNlcnZlcnMiLCJvYnNlcnZlcnMiLCJjcmVhdGUiLCJzZWxmIiwidyIsIioiLCJyYWRpdXMiLCIyIiwiY3JlYXRlX2ltYWdlIiwiYmFsbCIsIm5ldyIsIiR3cml0ZXIiLCJhbmdsZSIsImFuZ2xlPSIsIi0iLCIxIiwicGh5c2ljYWxfYm9keT0iLCJjb2xvciIsImx2X3RvX2NvbG9yIiwib3BhY2l0eSIsImJveCIsIjAiLCJkcmF3X2ZvbnQiLCJyZ2IiLCIkcmV0X29yXzEiLCJbXSIsImhpdCIsIj09Iiwib2ZmZW5jZSIsIjw9IiwiZWFjaCIsIm9ic2VydmVyIiwib25faGl0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxJQUFBLHNDQUFTLENBQ1AsQ0FBQ0MsR0FBRCxFQUFNQyxHQUFOLEVBQVdDLEdBQVgsQ0FETyxFQUVQLENBQUNDLEdBQUQsRUFBTUYsR0FBTixFQUFXRyxHQUFYLENBRk8sRUFHUCxDQUFDQyxHQUFELEVBQU1DLEdBQU4sRUFBV0MsR0FBWCxDQUhPLEVBSVAsQ0FBQ0EsR0FBRCxFQUFNQyxHQUFOLEVBQVdDLEdBQVgsQ0FKTyxFQUtQLENBQUNDLEdBQUQsRUFBTUMsR0FBTixFQUFXQyxHQUFYLENBTE8sRUFNUCxDQUFDQyxHQUFELEVBQU1DLEdBQU4sRUFBV0gsR0FBWCxDQU5PLEVBT1AsQ0FBQ0EsR0FBRCxFQUFNSSxHQUFOLEVBQVdDLEdBQVgsQ0FQTyxFQVFQLENBQUNDLEdBQUQsRUFBTU4sR0FBTixFQUFXTyxHQUFYLENBUk8sRUFTUCxDQUFDQyxHQUFELEVBQU1DLEdBQU4sRUFBV1QsR0FBWCxDQVRPLEVBVVAsQ0FBQ1YsR0FBRCxFQUFNb0IsR0FBTixFQUFXQSxHQUFYLENBVk8sQ0FBVCxDQUFBO0FBQUEsUUFhQUMsYUFBQUEsQ0FBWSxJQUFaQSxDQWJBO0FBQUE7QUFlQUMsSUFBQUEsOEJBQUFBLHFCQUFBQSxzQkFBZSxDQUFELEVBQUksQ0FBSixFQUFPLEdBQVAsRUFBWSxFQUFaLEVBQWdCLFNBQTlCQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFD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QUFBQSxRQUFrQixPQUFBLENBQUNwRCxHQUFELEVBQU1BLEdBQU4sRUFBV2lELENBQVg7QUFBbEIsTUFBQSxDQUFBLGtCQTNDVjtBQUFBLE1BNENJLE9BQUEsQ0FBQ0YsT0FBRCxDQUFBLFFBQVUsVUFBQ0ksR0FBRCxDQUFWLENBNUNKO0FBMENFTCxJQUFBQSxDQUFBQSxrQ0FBQUEsQ0F4Q0E7QUFBQSxJQTZDQSxPQUFBUSxDQUFBQSx1QkFBQUEsY0FBQUEsZUFBUSxPQUFSQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFFRSxJQUFHNUIsT0FBQTZCLE9BQUFBLENBQU9DLE9BQUE3QixJQUFBQSxDQUFBQSxDQUFQNEIsQ0FBSDtBQUFBLFFBQ0UsSUFBQSxRQUFHRSxPQUFBL0IsT0FBQStCLEVBQVFmLFVBQUEsSUFBQSxvQkFBQSxXQUFBQSxFQUFlQyxDQUFmRCxDQUFSZSxDQUFILENBQUE7QUFBQSxVQUNFLE9BQUFDLE1BQUE5QixjQUFBOEIsUUFBQUEsRUFBQUEsRUFBQUEsRUFuRFIsZ0JBbUQyQixRQW5EM0IsRUFBQTs7QUFBQTtBQUFBO0FBbUQyQixZQUFBO0FBQUEsWUFBQTtBQUFBLFlBQUEsQ0FuRDNCO0FBQUEsWUFvRFUsT0FBQUMsUUFBQUMsUUFBQUEsQ0FBZ0I3QixNQUFNeUIsT0FBdEJJLENBcERWLENBQUEsa0JBQUEsaUJBQUEsS0FtRFFGO0FBREYsUUFBQTtBQUFBO0FBQUEsUUFBQTtBQURGLE1BQUE7QUFBQTtBQUFBLE1BQUE7QUFGRkosSUFBQUEsQ0FBQUEseUJBQUFBLENBQUFBLGVBN0NBO0FBREZ4RCxFQUFBQSxHQUFBQSxXQUFBQSxFQUFhLHNCQUFiQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzMzY4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9nYW1lLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEdhbWVcbiAgQkFTS0VUX1hfTUlOID0gMTUwXG4gIEJBU0tFVF9YX01BWCA9IDY0MCAtIDE1MCAtIDQwXG4gIEJBU0tFVF9XID0gQkFTS0VUX1hfTUFYIC0gQkFTS0VUX1hfTUlOXG5cbiAgQkFTS0VUX1lfTUlOID0gMTAwXG4gIEJBU0tFVF9ZX01BWCA9IDQ0MFxuICBCQVNLRVRfSCA9IEJBU0tFVF9ZX01BWCAtIEJBU0tFVF9ZX01JTlxuXG4gIExWX01BWCA9IDEwXG5cbiAgTUFQX0xWX1NDT1JFID0ge1xuICAgIDEgID0+IDEsXG4gICAgMiAgPT4gMixcbiAgICAzICA9PiA1LFxuICAgIDQgID0+IDEwLFxuICAgIDUgID0+IDE1LFxuICAgIDYgID0+IDIwLFxuICAgIDcgID0+IDUwLFxuICAgIDggID0+IDEwMCxcbiAgICA5ICA9PiAyMDAsXG4gICAgMTAgPT4gNTAwLFxuICB9XG5cbiAgZGVmIGluaXRpYWxpemVcbiAgICBAYmFza2V0X2Zsb29yID0gbmlsXG4gICAgQGJhc2tldF93YWxsX2wgPSBuaWxcbiAgICBAYmFza2V0X3dhbGxfciA9IG5pbFxuXG4gICAgQGJhbGxzID0gW11cbiAgICBAY29sbGlzaW9uX2xpc3QgPSBbXVxuICAgIHVwZGF0ZV9uZXh0X2x2KClcblxuICAgIEBzY2VuZSA9IDptYWluXG5cbiAgICBAbmV4dF9sdiA9IDFcbiAgICBAbmV4dF9uZXh0X2x2ID0gMVxuICAgIEBuZXh0X2FuZ2xlID0gcmFuZCgpICogOTBcblxuICAgIEB0X2dhbWVvdmVyX3N0YXJ0ZWRfYXQgPSBUaW1lLm5vd1xuXG4gICAgQGF1dG9fZHJvcCA9IGZhbHNlXG5cbiAgICByZXNldCgpXG4gIGVuZFxuXG4gIGRlZiByZXNldFxuICAgIEBiYWxscy5lYWNoeyB8YmFsbHwgYmFsbC52YW5pc2ggfVxuICAgIGNsZWFuX2JhbGxzKEBiYWxscylcbiAgICBAc2NvcmUgPSAwXG4gICAgQHRfbmV4dF9hdXRvX2Ryb3AgPSBUaW1lLm5vdyArIDFcbiAgZW5kXG5cbiAgZGVmIGluaXRfYmFza2V0XG4gICAgQGJhc2tldF9mbG9vciA9IG1ha2Vfd2FsbChcbiAgICAgIEJBU0tFVF9YX01JTiwgQkFTS0VUX1lfTUFYLFxuICAgICAgMzAwLCA0MFxuICAgIClcbiAgICBAYmFza2V0X3dhbGxfbCA9IG1ha2Vfd2FsbChcbiAgICAgIEJBU0tFVF9YX01JTiAtIDQwLCAxMDAsXG4gICAgICA0MCwgQkFTS0VUX1lfTUFYICsgNDBcbiAgICApXG4gICAgQGJhc2tldF93YWxsX3IgPSBtYWtlX3dhbGwoXG4gICAgICBCQVNLRVRfWF9NQVgsIDEwMCxcbiAgICAgIDQwLCBCQVNLRVRfWV9NQVggKyA0MFxuICAgIClcbiAgZW5kXG5cbiAgZGVmIHNldF9hdXRvX2Ryb3AoYXV0bylcbiAgICBAdF9uZXh0X2F1dG9fZHJvcCA9IFRpbWUubm93ICsgMVxuICAgIEBhdXRvX2Ryb3AgPSBhdXRvXG4gICAgU291bmRFZmZlY3QyWzpzMV0ucGxheVxuICBlbmRcblxuICBkZWYgY2xlYW5fYmFsbHMoYmFsbHMpXG4gICAgYmFsbHNcbiAgICAgIC5zZWxlY3R7IHxiYWxsfCBiYWxsLnZhbmlzaGVkPyB9XG4gICAgICAuZWFjaHsgfGJhbGx8IGJhbGwucmVtb3ZlX21hdHRlcl9ib2R5KCkgfVxuICAgIFNwcml0ZS5jbGVhbihiYWxscylcbiAgZW5kXG5cbiAgZGVmIGRyYXdfZ2FtZW92ZXJcbiAgICB4ID0gMTMwXG4gICAgeSA9IDE2MFxuXG4gICAgV2luZG93LmRyYXdfYm94X2ZpbGwoMCwwLFdJTl9XLCBXSU5fSCwgWzgwLCAwLCAwLCAwXSlcblxuICAgIFdpbmRvdy5kcmF3X2ZvbnQoeCwgeSwgXCJHQU1FIE9WRVJcIiwgRk9OVF9HQU1FT1ZFUiwgeyBjb2xvcjogQ19XSElURSB9KVxuICAgIHkgKz0gODBcblxuICAgIFdpbmRvdy5kcmF3X2ZvbnQoeCwgeSwgXCJTQ09SRTogI3tAc2NvcmV9XCIsIEZPTlRfR0FNRU9WRVIsIHsgY29sb3I6IENfV0hJVEUgfSlcbiAgICB5ICs9IDEwMFxuXG4gICAgaWYgQHRfZ2FtZW92ZXJfc3RhcnRlZF9hdCArIDIgPCBUaW1lLm5vd1xuICAgICAgV2luZG93LmRyYXdfZm9udCh4LCB5LCBcImNsaWNrIHRvIHN0YXJ0XCIsIEZPTlRfREVGQVVMVCwgeyBjb2xvcjogQ19XSElURSB9KVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZHJhd19uZXh0X2N1cnNvcihkeClcbiAgICBuZXh0X3JhZCA9IEdhbWUudG9fcmFkaXVzKEBuZXh0X2x2KVxuICAgIGNpcmNsZV9yYWQgPSBNYXRoLnNxcnQoKG5leHRfcmFkICoqIDIpICogMilcblxuICAgIG5leHRfY29sb3IgPSBCYWxsLmx2X3RvX2NvbG9yKEBuZXh0X2x2LCAxMDApXG4gICAgbmV4dF9pbWcgPSBCYWxsLmNyZWF0ZV9pbWFnZShAbmV4dF9sdiwgbmV4dF9yYWQgKiAyLCAxMDApXG4gICAgV2luZG93LmRyYXdfcm90KFxuICAgICAgZHggLSBuZXh0X3JhZCwgNDAsXG4gICAgICBuZXh0X2ltZyxcbiAgICAgIEBuZXh0X2FuZ2xlLFxuICAgICAgbmV4dF9yYWQsIG5leHRfcmFkICMgY2VudGVyIHgsIHlcbiAgICApXG5cbiAgICB3aWR0aCA9IGNpcmNsZV9yYWQgKiBNYXRoLmNvcygoOTAgLSAoQG5leHRfYW5nbGUgKyA0NSkpICogKE1hdGg6OlBJIC8gMTgwLjApKVxuXG4gICAgW2R4IC0gd2lkdGgsIGR4ICsgd2lkdGhdLmVhY2h7IHx4fFxuICAgICAgV2luZG93LmRyYXdfbGluZShcbiAgICAgICAgeCwgMCxcbiAgICAgICAgeCwgV0lOX0gsXG4gICAgICAgIFsxMDAsIDAsIDAsIDBdXG4gICAgICApXG4gICAgfVxuICBlbmRcblxuICBkZWYgZHJhd19kZWJ1Z19pbmZvKHlfbWF4KVxuICAgICAgW1xuICAgICAgICBcIkBiYWxscy5zaXplICN7QGJhbGxzLnNpemV9XCIsXG4gICAgICAgIFwiQGNvbGxpc2lvbl9saXN0LnNpemUgI3tAY29sbGlzaW9uX2xpc3Quc2l6ZX1cIixcbiAgICAgICAgXCJAbmV4dF9sdiAje0BuZXh0X2x2fVwiLFxuICAgICAgICBcIkBuZXh0X25leHRfbHYgI3tAbmV4dF9uZXh0X2x2fVwiLFxuICAgICAgICBmb3JtYXQoXCJ5IG1heCAlLjJmXCIsIHlfbWF4KSxcbiAgICAgICAgXCJAc2NlbmUgI3tAc2NlbmV9XCIsXG4gICAgICBdLmVhY2hfd2l0aF9pbmRleHsgfGxpbmUsIGl8XG4gICAgICAgIFdpbmRvdy5kcmF3X2ZvbnQoXG4gICAgICAgICAgMiwgaSAqIDIwICsgNDAsXG4gICAgICAgICAgbGluZSxcbiAgICAgICAgICBGT05UX0RFQlVHX0lORk8sIHsgY29sb3I6IFsxMjAsIDAsIDAsIDBdIH1cbiAgICAgICAgKVxuICAgICAgfVxuICBlbmRcblxuICBkZWYgZHJhd19iYXNrZXRcbiAgICBAYmFza2V0X2Zsb29yLmRyYXdcbiAgICBAYmFza2V0X3dhbGxfbC5kcmF3XG4gICAgQGJhc2tldF93YWxsX3IuZHJhd1xuICBlbmRcblxuICBkZWYgZHJhd19zY29yZVxuICAgIFdpbmRvdy5kcmF3X2ZvbnQoXG4gICAgICA0LCAyLFxuICAgICAgXCJzY29yZTogI3tAc2NvcmV9XCIsXG4gICAgICBGT05UX0RFRkFVTFQsIHsgY29sb3I6IFsyMDAsIDAsIDAsIDBdIH1cbiAgICApXG4gIGVuZFxuXG4gIGRlZiBkcmF3X25leHRfbmV4dFxuICAgIGJhc2VfeCA9IDU0MFxuXG4gICAgV2luZG93LmRyYXdfZm9udChiYXNlX3ggLSA2MCwgMiwgXCJuZXh0OlwiLCBGT05UX0RFRkFVTFQsIHsgY29sb3I6IFsyMDAsIDAsIDAsIDBdIH0pXG4gICAgbmV4dF9uZXh0X3JhZCA9IEdhbWUudG9fcmFkaXVzKEBuZXh0X25leHRfbHYpXG4gICAgbmV4dF9uZXh0X3BlcmkgPSBuZXh0X25leHRfcmFkICogMlxuICAgIG5leHRfbmV4dF9pbWcgPSBCYWxsLmNyZWF0ZV9pbWFnZShAbmV4dF9uZXh0X2x2LCBuZXh0X25leHRfcGVyaSwgMjAwKVxuICAgIFdpbmRvdy5kcmF3KGJhc2VfeCwgNCwgbmV4dF9uZXh0X2ltZylcbiAgZW5kXG5cbiAgZGVmIGRyb3BfYmFsbChkeClcbiAgICBsdiA9IEBuZXh0X2x2XG4gICAgQGJhbGxzIDw8IEJhbGwuY3JlYXRlKGR4IC0gbmV4dF9yYWRpdXMsIDQwLCBuZXh0X3JhZGl1cywgQG5leHRfbHYsIEBuZXh0X2FuZ2xlLCBbc2VsZl0pXG4gICAgQG5leHRfYW5nbGUgPSByYW5kKCkgKiA5MFxuICAgIHVwZGF0ZV9uZXh0X2x2KClcbiAgICBTb3VuZEVmZmVjdDJbXCJsdiN7bHZ9XCJdLnBsYXlcbiAgZW5kXG5cbiAgZGVmIG9uX2hpdChiMSwgYjIpXG4gICAgQGNvbGxpc2lvbl9saXN0IDw8IFtiMSwgYjJdXG4gIGVuZFxuXG4gIGRlZiB0aWNrXG4gICAgbXggPSBJbnB1dC5tb3VzZV94XG4gICAgbXkgPSBJbnB1dC5tb3VzZV95XG4gICAgZHggPSB0b19kcm9wX3gobXgpXG5cbiAgICBpZiBJbnB1dC5tb3VzZV9wdXNoPyhNX0xCVVRUT04pXG4gICAgICBpZiAwIDw9IG15ICYmIG15IDwgV0lOX0hcbiAgICAgICAgY2FzZSBAc2NlbmVcbiAgICAgICAgd2hlbiA6bWFpblxuICAgICAgICAgICAgZHJvcF9iYWxsKGR4KVxuICAgICAgICB3aGVuIDpnYW1lb3ZlclxuICAgICAgICAgIGlmIEB0X2dhbWVvdmVyX3N0YXJ0ZWRfYXQgKyAyIDwgVGltZS5ub3dcbiAgICAgICAgICAgIFNvdW5kRWZmZWN0Mls6czFdLnBsYXlcbiAgICAgICAgICAgIHJlc2V0KClcbiAgICAgICAgICAgIEBzY2VuZSA9IDptYWluXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBpZiBAc2NlbmUgPT0gOm1haW5cbiAgICAgIGlmIEBhdXRvX2Ryb3BcbiAgICAgICAgaWYgQHRfbmV4dF9hdXRvX2Ryb3AgPCBUaW1lLm5vd1xuICAgICAgICAgIGRyb3BfYmFsbChkeClcbiAgICAgICAgICBAdF9uZXh0X2F1dG9fZHJvcCA9IFRpbWUubm93ICsgcmFuZCg1KSArIDAuNVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgIyDooZ3nqoHliKTlrppcblxuICAgIEBjb2xsaXNpb25fbGlzdCA9IFtdXG4gICAgQGJhbGxzLmVhY2h7IHxiYWxsX3NlbGZ8XG4gICAgICAjIOihneeqgeOBl+OBn+WgtOWQiCBAY29sbGlzaW9uX2xpc3Qg44Gr6L+95Yqg44GV44KM44KLXG4gICAgICBTcHJpdGUuY2hlY2soW2JhbGxfc2VsZl0sIEBiYWxscyAtIFtiYWxsX3NlbGZdKVxuICAgIH1cblxuICAgIG5ld19iYWxscyA9IFtdICMg6KGd56qB44Gr44KI44Gj44Gm5paw44Gf44Gr55Sf5oiQ44GV44KM44KL44KC44GuXG4gICAgQGNvbGxpc2lvbl9saXN0LmVhY2h7IHxiMSwgYjJ8XG4gICAgICBpZiAoIWIxLnZhbmlzaGVkPykgJiYgKCFiMi52YW5pc2hlZD8pXG4gICAgICAgIGIxLnZhbmlzaFxuICAgICAgICBiMi52YW5pc2hcbiAgICAgICAgbWlkeCA9IChiMS54ICsgYjIueCkgLyAyLjBcbiAgICAgICAgbWlkeSA9IChiMS55ICsgYjIueSkgLyAyLjBcbiAgICAgICAgbmV3X2x2ID0gYjEubHYgKyAxXG4gICAgICAgIG5ld19iYWxscyA8PCBbbmV3X2x2LCBtaWR4LCBtaWR5XVxuICAgICAgICBAc2NvcmUgKz0gTUFQX0xWX1NDT1JFW25ld19sdl1cbiAgICAgIGVuZFxuICAgIH1cblxuICAgIGx2cyA9IG5ld19iYWxscy5tYXB7IHxsdiwgXywgX3wgbHYgfS51bmlxXG4gICAgbHZzLmVhY2h7IHxsdnxcbiAgICAgIFNvdW5kRWZmZWN0MltcImx2I3tsdn1cIl0ucGxheVxuICAgIH1cblxuICAgIGNsZWFuX2JhbGxzKEBiYWxscylcblxuICAgIEBiYWxscyArPSBuZXdfYmFsbHMubWFweyB8bHYsIHgsIHl8XG4gICAgICByYWQgPSBHYW1lLnRvX3JhZGl1cyhsdilcbiAgICAgIGFuZ2xlID0gcmFuZCgpICogOTBcbiAgICAgIEJhbGwuY3JlYXRlKHgsIHksIHJhZCwgbHYsIGFuZ2xlLCBbc2VsZl0pXG4gICAgfVxuXG4gICAgIyBkcmF3XG5cbiAgICBkcmF3X2Jhc2tldCgpXG4gICAgZHJhd19zY29yZSgpXG4gICAgZHJhd19uZXh0X25leHQoKVxuICAgICMgZHJhd19kZWJ1Z19pbmZvKHlfbWF4KVxuXG4gICAgQGJhbGxzLmVhY2h7IHxiYWxsfCBiYWxsLmRyYXcgfVxuXG4gICAgaWYgQHNjZW5lID09IDptYWluXG4gICAgICBpZiAwIDw9IG15ICYmIG15IDwgV0lOX0hcbiAgICAgICAgZHJhd19uZXh0X2N1cnNvcihkeClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgaWYgQHNjZW5lID09IDpnYW1lb3ZlclxuICAgICAgZHJhd19nYW1lb3ZlcigpXG4gICAgZW5kXG5cbiAgICAjIOOCsuODvOODoOOCquODvOODkOODvOWIpOWumlxuXG4gICAgeV9tYXggPSBAYmFsbHMubWFweyB8YmFsbHwgYmFsbC55IH0ubWF4IHx8IDBcblxuICAgIGlmIHlfbWF4ID4gV0lOX0ggKyAxMDBcbiAgICAgIEBiYWxsc1xuICAgICAgICAuc2VsZWN0eyB8YmFsbHwgYmFsbC55ID4gV0lOX0ggKyAxMDAgfVxuICAgICAgICAuZWFjaHsgfGJhbGx8IGJhbGwudmFuaXNoIH1cbiAgICAgIGNsZWFuX2JhbGxzKEBiYWxscylcblxuICAgICAgU291bmRFZmZlY3QyWzpoaXQzX2xvbmddLnBsYXlcblxuICAgICAgaWYgQHNjZW5lID09IDptYWluXG4gICAgICAgIEB0X2dhbWVvdmVyX3N0YXJ0ZWRfYXQgPSBUaW1lLm5vd1xuICAgICAgICBAc2NlbmUgPSA6Z2FtZW92ZXJcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBORVhUX0xWUyA9IFtcbiAgICAoMS4uMykudG9fYSxcbiAgICAoMS4uMykudG9fYSxcbiAgICA0ICMg5bCR44GX5L2O44GE56K6546H44Gr44GZ44KLXG4gIF0uZmxhdHRlblxuXG4gIGRlZiB1cGRhdGVfbmV4dF9sdlxuICAgIEBuZXh0X2x2ID0gQG5leHRfbmV4dF9sdlxuICAgIEBuZXh0X25leHRfbHYgPSBORVhUX0xWUy5zYW1wbGVcbiAgZW5kXG5cbiAgZGVmIG5leHRfcmFkaXVzXG4gICAgR2FtZS50b19yYWRpdXMoQG5leHRfbHYpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRvX3JhZGl1cyhsdilcbiAgICBsdiAqIDcuNSArIDRcbiAgZW5kXG5cbiAgZGVmIHRvX2Ryb3BfeCh4KVxuICAgIGlmIHggPCBCQVNLRVRfWF9NSU4gKyAyXG4gICAgICBCQVNLRVRfWF9NSU4gKyAyXG4gICAgZWxzaWYgeCA+IEJBU0tFVF9YX01BWCAtIDJcbiAgICAgIEJBU0tFVF9YX01BWCAtIDJcbiAgICBlbHNlXG4gICAgICB4XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBtYWtlX3dhbGwoeCwgeSwgdywgaClcbiAgICB3YWxsID0gU3ByaXRlLm5ldyhcbiAgICAgICAgeCwgeSxcbiAgICAgICAgSW1hZ2UubmV3KHcsIGgsIFsyMDAsIDIwMCwgMjAwXSlcbiAgICAgIClcbiAgICB3YWxsLnBoeXNpY2FsX2JvZHkgPSBbOnJlY3RhbmdsZSwgdywgaCwgYHtpc1N0YXRpYzogdHJ1ZX1gXVxuICAgIHdhbGxcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsIjE1MCIsIi0iLCI2NDAiLCI0MCIsIjEwMCIsIjQ0MCIsIjEwIiwiMSIsIjIiLCIzIiwiNSIsIjQiLCIxNSIsIjYiLCIyMCIsIjciLCI1MCIsIjgiLCI5IiwiMjAwIiwiNTAwIiwiaW5pdGlhbGl6ZSIsIkBiYXNrZXRfZmxvb3IiLCJAYmFza2V0X3dhbGxfbCIsIkBiYXNrZXRfd2FsbF9yIiwiQGJhbGxzIiwiQGNvbGxpc2lvbl9saXN0IiwidXBkYXRlX25leHRfbHYiLCJAc2NlbmUiLCJAbmV4dF9sdiIsIkBuZXh0X25leHRfbHYiLCJAbmV4dF9hbmdsZSIsIioiLCJyYW5kIiwiOTAiLCJAdF9nYW1lb3Zlcl9zdGFydGVkX2F0Iiwibm93IiwiQGF1dG9fZHJvcCIsInJlc2V0IiwiZWFjaCIsImJhbGwiLCJ2YW5pc2giLCJjbGVhbl9iYWxscyIsIkBzY29yZSIsIjAiLCJAdF9uZXh0X2F1dG9fZHJvcCIsIisiLCJpbml0X2Jhc2tldCIsIm1ha2Vfd2FsbCIsIjMwMCIsInNldF9hdXRvX2Ryb3AiLCJhdXRvIiwiW10iLCJwbGF5Iiwic2VsZWN0IiwiYmFsbHMiLCJ2YW5pc2hlZD8iLCJyZW1vdmVfbWF0dGVyX2JvZHkiLCJjbGVhbiIsImRyYXdfZ2FtZW92ZXIiLCJ4IiwiMTMwIiwieSIsIjE2MCIsImRyYXdfYm94X2ZpbGwiLCI4MCIsImRyYXdfZm9udCIsIjwiLCJkcmF3X25leHRfY3Vyc29yIiwibmV4dF9yYWQiLCJ0b19yYWRpdXMiLCJjaXJjbGVfcmFkIiwic3FydCIsIioqIiwibmV4dF9jb2xvciIsImx2X3RvX2NvbG9yIiwibmV4dF9pbWciLCJjcmVhdGVfaW1hZ2UiLCJkcmF3X3JvdCIsImR4Iiwid2lkdGgiLCJjb3MiLCI0NSIsIi8iLCJkcmF3X2xpbmUiLCJkcmF3X2RlYnVnX2luZm8iLCJlYWNoX3dpdGhfaW5kZXgiLCJzaXplIiwiZm9ybWF0IiwieV9tYXgiLCJpIiwibGluZSIsIjEyMCIsImRyYXdfYmFza2V0IiwiZHJhdyIsImRyYXdfc2NvcmUiLCJkcmF3X25leHRfbmV4dCIsImJhc2VfeCIsIjU0MCIsIjYwIiwibmV4dF9uZXh0X3JhZCIsIm5leHRfbmV4dF9wZXJpIiwibmV4dF9uZXh0X2ltZyIsImRyb3BfYmFsbCIsImx2IiwiPDwiLCJjcmVhdGUiLCJuZXh0X3JhZGl1cyIsInNlbGYiLCJvbl9oaXQiLCJiMSIsImIyIiwidGljayIsIm14IiwibW91c2VfeCIsIm15IiwibW91c2VfeSIsInRvX2Ryb3BfeCIsIm1vdXNlX3B1c2g/IiwiJHJldF9vcl8xIiwiPD0iLCI9PSIsImNoZWNrIiwiYmFsbF9zZWxmIiwibmV3X2JhbGxzIiwiJHJldF9vcl8yIiwiISIsIm1pZHgiLCJtaWR5IiwibmV3X2x2IiwibHZzIiwibWFwIiwidW5pcSIsInJhZCIsImFuZ2xlIiwiJHJldF9vcl8zIiwiJHJldF9vcl80IiwibWF4IiwiPiIsInRvX2EiLCJmbGF0dGVuIiwic2FtcGxlIiwid2FsbCIsIm5ldyIsInci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VHlCLENBQUMsV0FBRCxFQUFhRixDQUFiLEVBQWdCQyxDQUFoQixFQUFvQixnQkFBcEIsQ0F2VHpCLENBQUE7QUFBQSxNQXVUSUUsTUFBQUwsSUFBQUssa0JBQUFBLEVBdlRKLFVBQUFELE9BQUEsQ0F1VElDLENBdlRKO0FBQUEsTUFBQUQsT0FBQSxDQUFBakosVUFBQWlKLE9BQUEsQ0FBQSxRQUFBLENBQUFqSixFQUFBTSxDQUFBTixDQUFBLENBQUEsQ0FtVEk7QUFBQSxNQUtBLE9BQUE2SSxJQUxBO0FBREY5RixJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FBQUEscUJBaFRBO0FBREZqRCxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzODAyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9tYWluLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgXCJkeG9wYWxcIlxucmVxdWlyZV9yZWxhdGl2ZSBcImR4b3BhbF9leHQvc291bmQyXCJcbnJlcXVpcmVfcmVsYXRpdmUgXCJkeG9wYWxfZXh0L3NvdW5kX2VmZmVjdDJcIlxuaW5jbHVkZSBEWE9wYWxcblxucmVxdWlyZV9yZWxhdGl2ZSBcImJhbGxcIlxucmVxdWlyZV9yZWxhdGl2ZSBcImdhbWVcIlxuXG5XSU5fVyA9IDY0MFxuV0lOX0ggPSA0ODBcblxuRk9OVF9ERUZBVUxUICAgID0gRm9udC5uZXcoMjAsIFwibW9ub3NwYWNlXCIpXG5GT05UX0JBTEwgICAgICAgPSBGb250Lm5ldygxNiwgXCJtb25vc3BhY2VcIilcbkZPTlRfR0FNRU9WRVIgICA9IEZvbnQubmV3KDgwLCBcIm1vbm9zcGFjZVwiKVxuRk9OVF9ERUJVR19JTkZPID0gRm9udC5uZXcoMTIsIFwibW9ub3NwYWNlXCIpXG5cbmRlZiBwcmVfdGlja1xuICBpZiAoXG4gICAgICAoSW5wdXQua2V5X2Rvd24/KEtfTENPTlRST0wpICYmIElucHV0LmtleV9wdXNoPyhLX1IpKSB8fFxuICAgICAgKElucHV0LmtleV9kb3duPyhLX1JDT05UUk9MKSAmJiBJbnB1dC5rZXlfcHVzaD8oS19SKSkgfHxcbiAgICAgIElucHV0LmtleV9wdXNoPyhLX0Y1KVxuICAgIClcbiAgICBgbG9jYXRpb24ucmVsb2FkKClgXG4gIGVuZFxuZW5kXG5cbiMgdm9sOiAwLi4yNTVcbmRlZiBzZXRfbWFzdGVyX3ZvbHVtZSh2b2wsIHBsYXkgPSBmYWxzZSlcbiAgU291bmQyLm1hc3Rlcl92b2x1bWUgPSB2b2xcblxuICBpZiBwbGF5XG4gICAgU291bmRFZmZlY3QyW1wibHYxXCJdLnBsYXlcbiAgZW5kXG5lbmRcblxuIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuIyBzb3VuZFxuXG5Tb3VuZEVmZmVjdDIucmVnaXN0ZXIoOnMxLCA1MCwgV0FWRV9UUkksIDEwMDApIGRvXG4gIFsxMDAwLCAxMjBdXG5lbmRcblxuU291bmRFZmZlY3QyLnJlZ2lzdGVyKDpoaXQzX2xvbmcsIDMwMCwgV0FWRV9TQVcsIDEwMDApIGRvXG4gIFs1MCwgMTAwXVxuZW5kXG5cbk5PVEVfTk9TID0gW1xuICAwLCAgIyBjNFxuICA3LCAgIyBnNFxuICAxMSwgIyBiNFxuICAyLCAgIyBkNFxuICA1LCAgIyBmNFxuXG4gIDEyLCAjIGM1XG4gIDE5LCAjIGc1XG4gIDIzLCAjIGI1XG4gIDE0LCAjIGQ1XG4gIDE3LCAjIGY1XG5dXG5cbmRlZiBjcmVhdGVfc291bmRfYmFsbF9uZXcobHYpXG4gIGR1cmF0aW9uX21zZWMgPSA1MDBcbiAgbm90ZV9pID0gbHYgLSA5XG4gIG5vdGVfbm8gPSBOT1RFX05PU1tub3RlX2ldXG4gIGJhc2VfZnJlcSA9ICg0NDAgKiAoMiAqKiAobm90ZV9ubyAvIDEyLjApKSkudG9fZlxuICBtc2VjID0gMFxuXG4gIFNvdW5kRWZmZWN0Mi5yZWdpc3RlcihcImx2I3tsdn1cIiwgZHVyYXRpb25fbXNlYywgV0FWRV9UUkkpIHtcbiAgICB2b2wgPVxuICAgICAgaWYgbXNlYyA8IDEwMFxuICAgICAgICAyMFxuICAgICAgZWxzaWYgbXNlYyA8IDIwMFxuICAgICAgICAxXG4gICAgICBlbHNpZiBtc2VjIDwgMzAwXG4gICAgICAgIDVcbiAgICAgIGVsc2lmIG1zZWMgPCA0MDBcbiAgICAgICAgMVxuICAgICAgZWxzZVxuICAgICAgICAyXG4gICAgICBlbmRcbiAgICB2b2wgPSB2b2wgKiAoMjU1LjAgLyAyMClcblxuICAgIGZyZXEgPVxuICAgICAgaWYgbXNlYyA8IDIwXG4gICAgICAgIGJhc2VfZnJlcSAvIDJcbiAgICAgIGVsc2VcbiAgICAgICAgYmFzZV9mcmVxXG4gICAgICBlbmRcblxuICAgIG1zZWMgKz0gMVxuXG4gICAgW2ZyZXEsIHZvbF1cbiAgfVxuZW5kXG5cbigxLi5HYW1lOjpMVl9NQVgpLmVhY2h7IHxsdnxcbiAgY3JlYXRlX3NvdW5kX2JhbGxfbmV3KGx2KVxufVxuXG4jIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbldpbmRvdy53aWR0aCAgPSBXSU5fV1xuV2luZG93LmhlaWdodCA9IFdJTl9IXG5XaW5kb3cuZnBzID0gNjBcbldpbmRvdy5iZ2NvbG9yID0gWzI1MCwgMjUwLCAyNTBdXG5cbnNldF9tYXN0ZXJfdm9sdW1lKDIzMClcblxuJGdhbWUgPSBHYW1lLm5ld1xuJGdhbWUuaW5pdF9iYXNrZXQoKVxuXG5XaW5kb3cubG9hZF9yZXNvdXJjZXMgZG9cbiAgcHV0cyBcImxvYWRfcmVzb3VyY2VzIC4uLiBkb25lXCJcblxuICBXaW5kb3cubG9vcCBkb1xuICAgIHByZV90aWNrXG4gICAgJGdhbWUudGlja1xuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJyZXF1aXJlX3JlbGF0aXZlIiwiaW5jbHVkZSIsIjY0MCIsIjQ4MCIsIm5ldyIsIjIwIiwiMTYiLCI4MCIsIjEyIiwicHJlX3RpY2siLCIkcmV0X29yXzEiLCIkcmV0X29yXzIiLCIkcmV0X29yXzMiLCJrZXlfZG93bj8iLCJrZXlfcHVzaD8iLCIkcmV0X29yXzQiLCJzZXRfbWFzdGVyX3ZvbHVtZSIsIiR3cml0ZXIiLCJ2b2wiLCJtYXN0ZXJfdm9sdW1lPSIsIi0iLCIxIiwicGxheSIsIltdIiwicmVnaXN0ZXIiLCI1MCIsIjEwMDAiLCIxMjAiLCIzMDAiLCIxMDAiLCIwIiwiNyIsIjExIiwiMiIsIjUiLCIxOSIsIjIzIiwiMTQiLCIxNyIsImNyZWF0ZV9zb3VuZF9iYWxsX25ldyIsImR1cmF0aW9uX21zZWMiLCI1MDAiLCJub3RlX2kiLCJsdiIsIjkiLCJub3RlX25vIiwiYmFzZV9mcmVxIiwiKiIsIjQ0MCIsIioqIiwiLyIsInRvX2YiLCJtc2VjIiwiPCIsIjIwMCIsIjQwMCIsImZyZXEiLCIrIiwiZWFjaCIsIndpZHRoPSIsImhlaWdodD0iLCI2MCIsImZwcz0iLCIyNTAiLCJiZ2NvbG9yPSIsIjIzMCIsIiRnYW1lIiwiaW5pdF9iYXNrZXQiLCJsb2FkX3Jlc291cmNlcyIsInB1dHMiLCJsb29wIiwidGljayJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsUUFBUkEsQ0FBQTtBQUFBLEVBQ0FDLG9DQUFpQixtQkFBakJBLENBREE7QUFBQSxFQUVBQSxvQ0FBaUIsMEJBQWpCQSxDQUZBO0FBQUEsTUFHQUMsU0FBQUEsQ0FBUSxzQkFBUkEsQ0FIQTtBQUFBLEVBS0FELG9DQUFpQixNQUFqQkEsQ0FMQTtBQUFBLEVBTUFBLG9DQUFpQixNQUFqQkEsQ0FOQTtBQUFBLEVBUUEscUNBQVFFLEdBQVIsQ0FSQTtBQUFBLEVBU0EscUNBQVFDLEdBQVIsQ0FUQTtBQUFBLEVBV0EsNENBQWtCLG9CQUFBQyxLQUFBQSxDQUFTQyxJQUFJLFdBQWJELENBQWxCLENBWEE7QUFBQSxFQVlBLHlDQUFrQixvQkFBQUEsS0FBQUEsQ0FBU0UsSUFBSSxXQUFiRixDQUFsQixDQVpBO0FBQUEsRUFhQSw2Q0FBa0Isb0JBQUFBLEtBQUFBLENBQVNHLElBQUksV0FBYkgsQ0FBbEIsQ0FiQTtBQUFBLEVBY0EsK0NBQWtCLG9CQUFBQSxLQUFBQSxDQUFTSSxJ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
